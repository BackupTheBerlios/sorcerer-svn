#!/bin/bash
############################################################
# Copyright 2001 through 2010 by Kyle Sallee,              #
# all rights reserved                                      #
# and may not be reditribute in modified form without      # 
# prior writen permission of Kyle Sallee                   #
# It may only be used for installing Sorcerer              #
############################################################
# sorcerer.install menu driven process of for installing   #
# installing the Sorcerer Install/Rescue ISO               #
############################################################

sane_pass(){
 if   [ -z "$1" ]
 then msgbox "Please type something before pressing enter."; return 1
 fi
 local PASS="$1"
 shift 1
 while [ -n "$1" ]; do
  if   [    "$1" == "$PASS" ]
  then msgbox "Password must not match previously entered password."
       return 1
  else shift  1
  fi
 done
}

ask_pass(){
 local ASK="$1"; shift 1
 while REPLY="$( inputbox "$ASK" )"
       ! sane_pass "$REPLY" "$USER_PASS" "$ROOT_PASS"
 do :;
 done
}

run_auto(){

 local BOOTLOADER BL_CONF GL MBR MIRD SILENCE
 local BOOT_PASS ROOT_PASS USER_PASS USER_NAME

  part_keys(){ echo -e "\nd\n4\nd\n3\nd\n2\nd\n1\nn\np\n1\n\n+4G\nt\n82\nn\np\n2\n\n\na\n2\nw"; }
# part_keys(){ echo -e "\nd\n4\nd\n3\nd\n2\nd\n1\nn\np\n1\n\n\na\n1\nw"; }

 if   [ -b /dev/sdb ] || [ -b /dev/sdc ] || [ -b /dev/sdd ]
 then DISK=$( get_disk )
 else DISK=/dev/sda
 fi

 while [ -z "$USER_NAME" ]; do
  USER_NAME="$( inputbox "Please type the primary user name." )"
  if   echo "$USER_NAME" | tr -d 'A-Za-z' | grep -q '.'
  then msgbox "One word with characters from A-Z and a-z, please."; USER_NAME=
  fi
 done

 ask_pass "Please type the user password."; USER_PASS="$REPLY"
 ask_pass "Please type the root password."; ROOT_PASS="$REPLY"
 ask_pass "Please type the boot password."
 BOOT_PASS="$( md5crypt <<< "$REPLY" )"

 if   ! confirm "All partitions on $DISK will be lost?" --defaultno
 then return
 fi

 SILENCE=golden
 MBR=true

 part_keys |
 fdisk     $DISK &>/dev/null
 ms-sys -s $DISK

 filesystem_table_load

 empty_entry 0
     PDEVICE[0]=
 PFILESYSTEM[0]=

 PFILESYSTEM[1]=swap
      PMOUNT[1]=none

      PMOUNT[2]=/
 PFILESYSTEM[2]=ext4

 get_filesystem_assumptions 1
 get_filesystem_assumptions 2

 make_fstab > /tmp/fstab
 mkswap		${PFEATURE[1]}	${PDEVICE[1]}
 mkfs.ext4	${PFEATURE[2]}	${PDEVICE[2]}

 filesystem_mount
 transfer_arch

 make_bootloader_conf
 GL=$TARGET/etc/sorcery/log/config/glibc-locales
 mkdir -p $GL
 echo 'LOCALES=""' > $GL/sorcery

 echo    "$USER_NAME"             | chroot $TARGET /usr/sbin/adduser
 echo -e "$USER_PASS\n$USER_PASS" | chroot $TARGET /usr/bin/passwd "$USER_NAME"
 echo -e "$ROOT_PASS\n$ROOT_PASS" | chroot $TARGET /usr/bin/passwd root 
 chroot $TARGET /usr/sbin/usermod -G audio,cdrom,lp,video -a "$USER_NAME"
 sed -i "s|sorcerer|$BOOT_PASS|" /etc/extlinux/head

 sed   -i 's/id:3:/id:5:/' $TARGET/etc/inittab

 chroot_silent

 mkdir -pvm 755            $TARGET/var/log/sorcery/resume
 touch -t 200101010000     $TARGET/var/log/sorcery/resume/grimoire-sentient
 touch -t 200101010000     $TARGET/var/log/sorcery/resume/sorcerer-sentient
 sync

 grep /media/root /proc/mounts |
 cut -d ' ' -f2 |
 sort -r |
 xargs -r --max-lines=1024 umount

 MIRD=$( grep /media/IR /proc/mounts | cut -d ' ' -f1 )
 umount $MIR
 eject  $MIRD
 sleep 5
 reboot -d -f -i
}


inputbox(){ $DIALOG --no-collapse --nocancel --inputbox "$1" 0 0 "$2"; }

chroot_run(){
 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon  -a
 chroot $TARGET "$@"
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
 pause
}


chroot_silent(){
 wait_finish(){
  while pgrep cast | grep -q .
  do    sleep 5
  done
 }

 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon -a
 chroot $TARGET /usr/sbin/augur queue dispel/sorcerer-installer
 chroot $TARGET /usr/sbin/augur queue cast/glibc-locales
 chroot $TARGET /usr/sbin/augur queue cast/suspend-utils
 chroot $TARGET /usr/sbin/dispel
 chroot $TARGET /usr/sbin/cast
 chroot $TARGET /usr/sbin/augur scry glibc-locales
 wait_finish
 chroot $TARGET /etc/init.d/depmod
 chroot $TARGET /etc/init.d/rc.d
 chroot $TARGET /etc/init.d/services
 chroot $TARGET /etc/init.d/extlinux
 chroot $TARGET /etc/init.d/initramfs
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
}

chroot_build(){
 scry_finish(){
  while pgrep cast | grep -q .
  do    chroot $TARGET augur scry
  done
 }

 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon -a
 chroot $TARGET dispel sorcerer-installer
 chroot $TARGET cast "$@"
 scry_finish
 chroot $TARGET /etc/init.d/depmod
 chroot $TARGET /etc/init.d/rc.d
 chroot $TARGET /etc/init.d/services
 chroot $TARGET /etc/init.d/extlinux
 chroot $TARGET /etc/init.d/initramfs
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
 pause
}

msgbox(){  [ -n "$SILENCE" ] || $DIALOG --no-collapse --msgbox "$1" 0 0; }
confirm(){ [ -n "$SILENCE" ] || $DIALOG $2 --yesno "$1" 8 50; }

offer_man(){
 local   VIEW=$"View manual page"
 local SCROLL=$"Page Up and Page down scrolls."
 local   QUIT=$"Press q when done viewing."

 if   [ -f /usr/bin/man ] &&
      confirm "$VIEW $1" --defaultno
 then msgbox  "$SCROLL$LF$QUIT"; man $1
 fi
}

goodbye(){
 if   mounted
 then filesystem_unmount
 fi

 if   confirm "Reboot now?" --defaultno
 then shutdown -r now
 fi
 exit  0
}

list_disk(){
 find /dev -group disk -printf "%p	disk\n" | sed "/[0-9]/d"
 find /dev -group disk -printf "%p	RAID\n" | sed "\,/dev/md[0-9]\t,p;d"
}


list_bb()  { find /dev -type b -printf "%p	%y\n"   | sed '\,^/dev/loop,d;\,^/dev/dm-[0-9],d;\,^/dev/mapper/,d'; }
get_disk() { $DIALOG --title $"Please select disk"       --menu "" 0 0 0 $( list_disk ); }

get_bb(){
 for ((CX=0;CX<MP;CX++)); do if [[ ${PMOUNT[$CX]} == /boot ]]; then BB=$CX; return; fi; done
 for ((CX=0;CX<MP;CX++)); do if [[ ${PMOUNT[$CX]} == /     ]]; then BB=$CX; return; fi; done
}

get_def_prmount(){
 if   [ -n               "${PMOUNT[$1]}" ]
 then PRMOUNT[$1]="$TARGET${PMOUNT[$1]}"
 fi
}

get_def_size(){ PSIZE[$1]=$( sfdisk -s ${PDEVICE[$1]} ); }

get_filesystem_assumptions(){
 get_puuid       $1
 get_mkfs        $1
 get_def_options $1
 get_def_order   $1
 get_def_dump    $1; [ -n "${PMOUNT[$1]}" ] ||
 get_def_mount   $1
 get_def_feature $1
 get_def_prmount $1
 get_def_size    $1
}


boot_dev_check(){
 if ! [ "${PMOUNT[$1]}" == /boot ]; then return; fi

 if   [ "${PDEVICE[$1]:0:12}" == /dev/mapper/ ]; then
       PMOUNT[$1]=
  PFILESYSTEM[$1]=
  $DIALOG --msgbox $"/boot must not be a mapped device" 8 50
 elif ! [ "${PFILESYSTEM[$1]}" == ext2 ]; then
  PFILESYSTEM[$1]=ext2
  get_filesystem_assumptions $1
  $DIALOG --msgbox $"/boot must be ext2" 8 50
 fi

 if (( 2000000 > ${PSIZE[$1]} )); then
  $DIALOG --msgbox $"/boot must be at least 2G in size." 8 50
  empty_entry $1
 fi
}


get_filesystem(){

 local BTRFS EXT2 EXT3 EXT4 OCFS2 JFS XFS REISER SWAP

  BTRFS=$"B Tree Reversible           file system experimental"
   EXT2=$"Second Extended             file system"
   EXT3=$"Second Extended  journaling file system"
   EXT4=$"Second Extended  journaling file system with 64 bit scalability"
  OCFS2=$"Oracle Clustering           file system"
    JFS=$"JFS              journaling file system"
    XFS=$"XFS              journaling file system"
 REISER=$"Reiserfs         journaling file system"
   SWAP=$"Swap"

 local BOOT HELP TITLE FS

  BOOT=$"Reiserfs OCFS2 XFS and BTRFS can be selected for / after /boot is defined."
  HELP=$"Please select a file system"
 TITLE=$"File System Selection Menu"

 case "${PMOUNT[$1]}" in
  /boot) PFILESYSTEM[$1]=ext2; get_filesystem_assumptions $1; return ;;
   none) PFILESYSTEM[$1]=swap; get_filesystem_assumptions $1; return ;;
      *) FS=ext4 ;;
 esac

# ocfs2-tools version 1.6.3 installs buggy init-scripts
# therefore ocfs2 configuration must be done manually by SA
# assuming that it is possilbe to do.

 if ! [ / == "${PMOUNT[$1]}" ] || boot_device | grep -q .
 then
  FS="$(
   $DIALOG --title "$TITLE" --default-item "$FS" --menu "$HELP" 0 0 0 \
    ext4 "$EXT4" ext3 "$EXT3" ext2 "$EXT2" jfs "$JFS" swap "$SWAP" \
    reiserfs "$REISER" xfs "$XFS" btrfs "$BTRFS" )"
 else
  msgbox "$BOOT"
  FS="$(
   $DIALOG --title "$TITLE" --default-item "$FS" --menu "$HELP" 0 0 0 \
    ext4 "$EXT4" ext3 "$EXT3" ext2 "$EXT2" jfs "$JFS" swap "$SWAP" )"
 fi

 PFILESYSTEM[$1]="$FS"
    PFEATURE[$1]=

 get_filesystem_assumptions $1
}


fdisc(){
 $DIALOG \
 --title $"Partitioning Menu" --no-cancel \
 --menu  $"Select a partitioning program" 0 0 0 \
 cfdisk "" fdisk "" parted ""
}


run_partition(){
 if   launch $( fdisc ) $( get_disk )
 then PARTITION=true
 fi
 filesystem_table_load
}


run_mbr(){ ms-sys -s $( get_disk ); MBR=true; }


get_def_mount(){

 local BOOTDEV ROOTDEV HOMEDEV NOTROOT
 local NOTXFS=$"xfs on / requires a /boot partition"
 local NOTBTRFS=$"btrfs on / requires a /boot partition"
 local NOOCFS2=$"ocfs2 on / requires a /boot partition"
 local FS="${PFILESYSTEM[$1]}"
 local MOUNT
 local ASK="$2"
 local CX

 for ((CX=0; CX<$MP; CX++)); do
  case  "${PMOUNT[$CX]}" in
   /boot) BOOTDEV=$CX ;;
   /)     ROOTDEV=$CX ;;
   /home) HOMEDEV=$CX ;;
  esac
 done

 case "$FS" in
     xfs) NOTROOT="$NOTXFS" ;;
   btrfs) NOTROOT="$NOTBTRFS" ;;
   ocfs2) NOTROOT="$NOOCFS2" ;;
 esac

 if   [ swap == "$FS" ];                      then MOUNT="none"
 elif [ ext2 == "$FS" ] && [ -z "$BOOTDEV" ]; then MOUNT="/boot"
 elif [ -z "$ROOTDEV" ] && [ -n "$BOOTDEV" ]; then MOUNT="/"
 elif [ -z "$ROOTDEV" ] && [ -z "$NOTROOT" ]; then MOUNT="/"
 elif [ -z "$HOMEDEV" ];                      then MOUNT="/home"
 fi

 if [ -n "$ASK" ]; then
  local                PLEASE=$"Please enter a mount point"
  MOUNT="$( inputbox "$PLEASE" "${PMOUNT[$1]:-$MOUNT}" )"

   if   [ / == "$MOUNT" ] && [ -n "$NOTROOT" ]
   then msgbox "$NOTROOT"; MOUNT=""
   fi

   PMOUNT[$1]="$MOUNT"
   boot_dev_check "$1"
 else
   PMOUNT[$1]="$MOUNT"
 fi

}


get_mount(){ get_def_mount "$1" "Ask"; }

get_device(){ PDEVICE[$1]="$( get_part "$1" )"; }

list_swaps(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ "${PFILESYSTEM[$CX]}" == swap ]
  then echo "${PLDEVICE[$CX]:-${PDEVICE[$CX]}} none swap defaults 0 0"
  fi
 done
}


get_puuid(){
 if     [ -n         "${PUUID[$1]}"     ] ||
      ! [ /dev/ == "${PDEVICE[$1]:0:5}" ]
 then return
 fi

 from_blkid(){ blkid -p -o value -s UUID "${PDEVICE[$1]}" 2>/dev/null; }
 from_btrfs(){ btrfs-show                "${PDEVICE[$1]}" |
               sed 's/.*uuid: //p;d'; }

# blkid can fetch UUID from btrfs

 PUUID[$1]="$( from_blkid $1 )"

# case "${PFILESYSTEM[$1]}" in
#  btrfs)       PUUID[$1]="$( from_btrfs $1 )" ;;
#      *)       PUUID[$1]="$( from_blkid $1 )" ;;
# esac
}


fstab_line(){
 get_puuid $1

 if   [ -n "${PLDEVICE[$1]}" ];                then echo -n "${PLDEVICE[$1]}"
 elif [ -z    "${PUUID[$1]}" ] || [ -n "$2" ]; then echo -n "${PDEVICE[$1]}"
                                               else echo -n "UUID=${PUUID[$1]}"
 fi
 echo -n "${TAB}"
 echo -n "${PMOUNT[$1]:-none} "
 echo -n "${PFILESYSTEM[$1]:-unknown} "
 echo -n "${POPTIONS[$1]:-defaults} "
 echo -n "${PDUMP[$1]:-0} "
 echo    "${PORDER[$1]:-0}"
}


make_fstab(){
 echo "# Real file systems"
 list_mounts | LC_ALL=C sort | cut -f2 |
 while read          CX
 do    fstab_line  "$CX"
 done | tr ' ' '\t'
 echo; echo
 echo "# Swap"
 list_swaps
 echo; echo
 cat /etc/fstab.empty
}


make_bootloader_conf(){

 get_bb

 # To update /dev/disk/by-uuid/
 /etc/init.d/udevtrigger start

 get_puuid $BB

 BBDEV=${PDEVICE[$BB]}

 sfdisk ${BBDEV:0:8} -A ${BBDEV:8:2}
 mbr_check
}


terror_retry(){

 rm -f /tmp/terror

#$DIALOG --msgbox $"Errors during unarchiving. Attempting unarchiving archives one at a time." 10 50
 find /media/IR/var/cache/archive/$HOSTTYPE/ -type f |
 while read; do
  if ! xz -cd "$REPLY"
  then echo "$REPLY${TAB}Error decompressing" >> /tmp/terror
  fi |
  if ! tar -C $TARGET -ixvpf - 2>&1
  then echo "$REPLY${TAB}Error while untarring" >> /tmp/terror
  fi
 done

 if ! [ -f /tmp/terror ]; then
  pause
  msgbox $"Files transferred."
 else
  $DIALOG --textbox /tmp/terror 20 70
 fi
} 


transfer_arch(){
 local NOT_MOUNT=$"Not detecting file system mounted on $TARGET"

 if   ! mounted
 then msgbox "$NOT_MOUNT"; allow || return 1
 fi

 local MIR=/media/IR

 rm -f /tmp/terror

 if   [[ -d $TARGET/var/cache ]]
 then mv    $TARGET/var/cache $TARGET/var/cache.old
 fi

 # Free some RAM incase the box is running low.
 rm -fr /lib/modules

 cd /
 rm    -vfr              $TARGET/{bin,dev,etc,lib,lib64,opt,sbin,tmp,usr,var}
 mkdir -vpm 755          $TARGET/{dev,etc,home,media/{cdrom,floppy,root},proc,sys,tmp,var/cache/archive}
 mkdir -vpm 700          $TARGET/etc/sorcery/log/{config,opt.{on,off},provide}
 chmod -v  1777          $TARGET/{,var/}tmp
 cp    -va dev etc init  $TARGET
 rm    -f                $TARGET/etc/init.d/log.d/*
 cp    -va     etc/skel  $TARGET/root
 mkdir -vpm 700          $TARGET/root/.sorcery
 chmod -v   700          $TARGET/root
 cp    -va $MIR/boot     $TARGET
 cp    -av $MIR/var/cache/sources \
                         $TARGET/var/cache/
 rm    -fr               $TARGET/boot/isolinux
 cp    -va $MIR/var/cache/archive \
                         $TARGET/var/cache/
 mkdir -vpm 755          $TARGET/lib/udev
 cp    -va /lib/udev/dev $TARGET/lib/udev/

 local ED="Error while decompressing archives"
 local ET="Error while untarring archives"

 find $TARGET/var/cache/archive/$HOSTTYPE/ -type f |
 xargs --max-lines=1024 cat |
 if ! xz -cd;                  then echo "$ED" >> /tmp/terror; fi |
 if ! tar -C $TARGET -ixvpf -; then echo "$ET" >> /tmp/terror; fi

 if ! [ -f /tmp/terror ]; then
  pause
  msgbox $"Files transferred."
 else terror_retry
 fi

 cp /tmp/fstab $TARGET/etc/fstab
 echo "--speed-time  120" >  $TARGET/root/.curlrc.sorcery
 echo "--speed-limit 256" >> $TARGET/root/.curlrc.sorcery
}


select_extra_spells(){
 HELP="Additional software may be useful or required for networking.
Please select software that will also be compiled and installed."

 show_extra(){
  ( find $TARGET/var/cache/sources -maxdepth 1 -mindepth 1 -type d -printf "%P\n"
    echo "$REQUIRED_SPELLS"
    echo "$REQUIRED_SPELLS"
  ) | LC_ALL=C sort | uniq -u | grep -vx "" |
  while read; do
   echo "$REPLY"
   echo "Optional"
   echo "off"
  done
 }


 $DIALOG \
  --title "Additional Software Selection" \
  --nocancel --ok-label "Commit" --separate-output \
  --checklist "$HELP" 0 0 0 $( show_extra )
}


editor_menu(){
 local      TITLE="Text Editor Selection Menu"
 local  NANO_HELP="nano is a very easy to use text editor."
 local ELVIS_HELP="elvis is a clone vi/en editor."
 local  ZILE_HELP="zile is a small, fast and powerful emacs clone."

 EDITOR=$(
  $DIALOG \
  --title $"Text Editor Selection Menu" --item-help --default-item nano \
  --menu  $"Please select a text editor" 0 0 0 \
  nano "" "$NANO_HELP" elvis "" "$ELVIS_HELP" zile "" "$ZILE_HELP" )
 export EDTIOR
}


edit(){
 [ -n "$EDITOR" ] || editor_menu
 $EDITOR "$1"
}


edit_fstab(){
 if   [ -f $TARGET/etc/fstab ]
 then edit $TARGET/etc/fstab
 else $DIALOG --msgbox $"Transfer first." 8 50
 fi
}

get_def_options(){
 local REPLY

 case ${PFILESYSTEM[$1]} in
      ext4) REPLY="defaults,noatime,commit=3600" ;;
      ext3) REPLY="defaults,noatime,commit=3600" ;;
      ext2) REPLY="defaults,noatime"             ;;
     ocfs2) REPLY="defaults,noatime"             ;;
     btrfs) REPLY="defaults"                     ;;
      swap) REPLY="defaults"                     ;;
       xfs) REPLY="defaults,noatime"             ;;
  reiserfs) REPLY="defaults,notail,noatime"      ;;
       jfs) REPLY="defaults,noatime"             ;;
         *) REPLY="defaults"                     ;;
 esac

 case ${PMOUNT[$1]} in
  /tmp) if [ "${PFILESYSTEM[$1]}" == ext3 ] ||
           [ "${PFILESYSTEM[$1]}" == ext4 ]
        then REPLY="defaults,noatime,commit=864000"
        fi ;;
 esac

 POPTIONS[$1]="$REPLY"
}


get_options(){
 offer_man mount

 if   [ -z "${POPTIONS[$1]}" ]
 then get_def_options "$1"
 fi

 local HELP=$"Please enter mount options"
 local CURRENT=$"Current Options: "
       CURRENT+="${POPTIONS[$1]}$LF"

 POPTIONS[$1]="$( inputbox "${CURRENT}${HELP}" "${POPTIONS[$1]}" )"
}


get_size(){
 PSIZE[$1]="$( inputbox "Please enter size in megabytes" "${PSIZE[$1]:-256}" )"
}

get_password(){
 local FIRST_DEV=$"Please first set device."
 local FIRST_FIL=$"Please first set file system type."
 local FIRST_MNT=$"Please first set mount point."
 local MUST_BOOT=$"/boot must exists."
 local  NOT_BOOT=$"/boot must not be encrypted."
 local  PASSWORD=$"Please enter a password for key 0."
 local      SWAP=$"Encrypted swap?"

 local KEY

 if   [ -z      "${PDEVICE[$1]}" ]; then msgbox "$FIRST_DEV"; return 1; fi
 if   [ -z  "${PFILESYSTEM[$1]}" ]; then msgbox "$FIRST_FIL"; return 1; fi
 if   [ -z       "${PMOUNT[$1]}" ]; then msgbox "$FIRST_MNT"; return 1; fi
 if   [ /boot == "${PMOUNT[$1]}" ]; then msgbox "$NOT_BOOT";  return 1; fi
 if ! boot_device | grep -q .     ; then msgbox "$MUST_BOOT"; return 1; fi

 if   [     "${PFILESYSTEM[$1]}" == swap ]
 then confirm "$SWAP" --defaultno &&
      KEY=$RANDOM$RANDOM$RANDOM
 else KEY="$( inputbox "$PASSWORD" )"
 fi

 PPASSWORD[$1]="$KEY"

 # The key for swaps change on each boot.

 local DML=/dev/mapper/luks-

 if    [ -z "$KEY" ]; then
  if   [ -n                 "${PLDEVICE[$1]}" ]
  then cryptsetup luksClose "${PLDEVICE[$1]##*/}"
  fi
  PLDEVICE[$1]=""
 else
  PLDEVICE[$1]="$DML${PDEVICE[$1]##*/}"

  echo          cryptsetup -c aes-xts-plain -s 512 luksFormat ${PDEVICE[$1]} 1>&2
  echo "$KEY" | cryptsetup -c aes-xts-plain -s 512 luksFormat ${PDEVICE[$1]}
  echo          cryptsetup luksOpen ${PDEVICE[$1]} ${PLDEVICE[$1]##*/} 1>&2
  echo "$KEY" | cryptsetup luksOpen ${PDEVICE[$1]} ${PLDEVICE[$1]##*/}
  pause
 fi
}


get_def_feature(){
 if [ -z  "${PFEATURE[$1]}" ]; then
  case "${PFILESYSTEM[$1]}" in
    ext4)    PFEATURE[$1]="-O	dir_index,extent,filetype,sparse_super" ;;
    ext*)    PFEATURE[$1]="-O	dir_index,filetype,sparse_super" ;;
   ocfs2)    PFEATURE[$1]="--fs-feature-level=max-features" ;;
  esac
 fi
}


get_feature(){
 local FAIL=$"First select file system"

 if   [ -z "${PFILESYSTEM[$1]}" ]
 then msgbox "$FAIL"; return 1
 fi

 offer_man "${PMKFS[$1]}"

 local FEAT

 if [ -z  "${PFEATURE[$1]}" ]; then
  case "${PFILESYSTEM[$1]}" in
   ext*) FEAT="dir_index,filetype,sparse_super" ;;
  ocfs2) FEAT="--fs-feature-level=max-features" ;;
  esac
 fi

 FEAT="$( inputbox "Please enter optional features" "$FEATURE" )"
 case "${PFILESYSTEM[$1]}" in
   ext*) PFEATURE[$1]="-O	$FEAT" ;;
  ocfs2) PFEATURE[$1]="$FEAT" ;;
 esac
}


get_check(){

 check_type(){
  echo "Skip"
  echo "Do not check device for bad blocks"

  case  "${PFILESYSTEM[$1]}"  in
   jfs)  echo RO
         echo "Check for bad blocks before creating the file system" ;;
   swap) if [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
          echo RO
          echo "Check for bad blocks before creating the swap space"
         fi ;;
   ext*) echo RO
         echo "Adequate read only checking for new drives"
         echo RW
         echo "Appropritate read write checking for older drives." ;;
  esac
 }

 local FIRST_FS=$"Please first set file system type."
 local FIRST_DEV=$"Please first set device first."
 local TITLE=$"File system Check Menu"
 local HELP=$"Please select desired checking"

 if   [ -z "${PFILESYSTEM[$1]}" ]; then msgbox "$FIRST_FS";  return 1
 elif [ -z "${PDEVICE[$1]}"     ]; then msgbox "$FIRST_DEV"; return 1
 fi

 CHECK=$(
  $DIALOG --title "$TITLE" --default-item Skip \
          --menu  "$HELP" 0 0 0 $( check_type "$1" ) )

 case $CHECK in
  RO) PCHECK[$1]="-c"		;;
  RW) PCHECK[$1]="-c	-c"	;;
   *) PCHECK[$1]=""		;;
 esac
}


get_def_order(){
 case "${PFILESYSTEM[$1]}" in
  ext2) PORDER[$1]=0 ;;
     *) PORDER[$1]=0 ;;
 esac
}


get_def_dump(){ PDUMP[$1]=0; }


show_pinfo_old(){
 echo "device"
 echo "mount fsys options d o"
 for (( CX=0; CX<MP; CX++ )); do
  if    [ -n "${PDEVICE[$CX]}" ]; then
   echo   -n  "${PMOUNT[$CX]:-none}	"
   fstab_line          "$CX" $1
  fi
 done | LC_ALL=C sort | cut -f2- | tr '\t' '\n'
}

show_pinfo(){
 (
  echo "device mount fsys options d o"
  for (( CX=0; CX<MP; CX++ )); do
   if    [ -n "${PDEVICE[$CX]}" ]; then
    echo   -n  "${PMOUNT[$CX]:-none} "
    fstab_line          "$CX" $1
   fi
  done | tr '\t' ' ' | LC_ALL=C sort | cut -d ' ' -f2-
 ) | column -s ' ' -t | sed -r "s: +:\n:"
}


get_pcx(){
 if   [ -z "$1"           ]; then false
 elif [    "$1" == device ]; then
  for (( CX=0; CX<MP; CX++ )); do
   if   [ -z "${PDEVICE[$CX]}" ]
   then echo           "$CX"; break
   fi
  done
 else
  for (( CX=0; CX<MP; CX++ )); do
   if   [ "$1" == "${PLDEVICE[$CX]}" ] ||
        [ "$1" ==  "${PDEVICE[$CX]}" ]
   then echo                 "$CX"; break
   fi
  done
 fi
}


show_pinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if  [ -n        "${PMOUNT[$CX]}"     ]; then
   if [ /dev/ == "${PDEVICE[$CX]:0:5}" ]; then
    fstab_line "$CX" "dev"
    echo off
   fi
  fi
 done | tr '\t' '\n'
}


show_sinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ -n             "${PSIZE[$CX]}"     ] &&
       [ swap  == "${PFILESYSTEM[$CX]}"     ] &&
     ! [ /dev/ ==     "${PDEVICE[$CX]:0:5}" ]; then
   fstab_line "$CX" "dev"
   echo off
  fi
 done | tr '\t' '\n'
}


root_device(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ / == "${PMOUNT[$CX]}" ]
  then echo  "${PDEVICE[$CX]}"; break
  fi
 done
}

boot_device(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ /boot == "${PMOUNT[$CX]}" ]
  then echo      "${PDEVICE[$CX]}"; break
  fi
 done
}


empty_entry(){
#    PDEVICE[$1]=
#      PUUID[$1]=
      PMOUNT[$1]=
     PRMOUNT[$1]=
#PFILESYSTEM[$1]=
       PMKFS[$1]=
    POPTIONS[$1]=
       PDUMP[$1]=
      PORDER[$1]=
    PFEATURE[$1]=
      PCHECK[$1]=
   PPASSWORD[$1]=

 if [ /swap/0 ==     "${PDEVICE[$1]}" ] &&
    [  swap   == "${PFILESYSTEM[$1]}" ]; then
      PDEVICE[$1]=
  PFILESYSTEM[$1]=
 fi
}


filesystem_table(){

 pselect(){
  $DIALOG --ok-label Select --cancel-label Done \
   --title $"File System Table Menu" \
   --menu  $"File systems with mount point of none are ignored unless swap." 0 75 12 $( show_pinfo dev )
 }

 pempty(){
  if   confirm $"Remove this entry?" --defaultno
  then empty_entry "$1"
  fi
  if   confirm $"Remove device from file system table?" --defaultno; then
       PDEVICE[$1]=
   PFILESYSTEM[$1]=
  fi
 }


 check_pentry(){
  if [ -z "${PDEVICE[$1]}"     ] ||
     [ -z "${PFILESYSTEM[$1]}" ] ||
     [ -z "${PMOUNT[$1]}"      ] ||
     [ -z "${POPTIONS[$1]}"    ] ||
     [ -z "${PDUMP[$1]}"       ] ||
     [ -z "${PORDER[$1]}"      ]; then
   $DIALOG --msgbox $"Essential fields are missing. Emptying entry." 8 50
   empty_entry "$1"
   false
  fi
 }


 modify_pentry(){

  if   [ -z "$1" ]; then return 1; fi

  local COMMAND TITLE EHELP HELP

  TITLE=$"File system entry menu"
   HELP=$"Please visit every menu item except the Empty All Fields"

  while
   if [ "$SKILL" == expert ] && [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
    COMMAND=$(
     $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
      --title "$TITLE" \
      --menu  "$HELP" 20 60 15 \
      Device         "${PDEVICE[$1]}" \
      Mount           "${PMOUNT[$1]}" \
      Filesystem "${PFILESYSTEM[$1]}" \
      Options       "${POPTIONS[$1]}" \
      Feature       "${PFEATURE[$1]}" \
      Check           "${PCHECK[$1]}" \
      Encryption   "${PPASSWORD[$1]:+yes}" \
      Empty      "All fields removing entry" )
   elif [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
    COMMAND=$(
     $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
      --title "$TITLE" \
      --menu  "$HELP" 20 60 15 \
      Mount           "${PMOUNT[$1]}" \
      Filesystem "${PFILESYSTEM[$1]}" \
      Options       "${POPTIONS[$1]}" \
      Check           "${PCHECK[$1]}" \
      Empty      "All fields removing entry" )
   else
    # swap file
    COMMAND=$(
     $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
      --title "$TITLE" \
      --menu  "$HELP" 20 60 15 \
      Size    "${PSIZE[$1]}" \
      Empty   "All fields removing entry" )
   fi
  do
   case $COMMAND in
    Empty)	pempty		"$1"	;;
    Device)	get_device	"$1"	;;
    Filesystem)	get_filesystem	"$1"	;;
    Mount)	get_mount	"$1"	;;
    Options)	get_options	"$1"	;;
    Size)	get_size	"$1"	;;
    Feature)	get_feature	"$1"	;;
    Check)	get_check	"$1"	;;
    Encryption)	get_password	"$1"	;;
   esac
  done

  if   check_pentry "$1"
  then PRMOUNT[$1]="$TARGET${PMOUNT[$1]}"
  fi
 }


 check_root_defined(){
  if   ! root_device | grep -q .
  then msgbox $"/ Root file system required!"; return 1
  fi
 }

 check_double_device(){
  local CX
  local DDD=$"Double defined device"
  local FIX=$"Please select incorrect fstab line from menu and delete entry."
  local DUP="$(
   for (( CX=0; CX<MP; CX++ )); do
    if   [ -n "${PDEVICE[$CX]}" ]
    then echo "${PDEVICE[$CX]}"
    fi
   done | LC_ALL=C sort | uniq -d
  )"

  if   [ -n "$DUP" ]
  then msgbox "${DDD}: ${DUP//$LF/ }${LF}${FIX}"; return 1
  fi
 }


 local HELP="The following menu is for specifying file systems
to mount prior to transfering sorcerer.
The information prompted for corresponds
to the fields on a line in /etc/fstab"

 $DIALOG --msgbox "$HELP" 18 65
 offer_man fstab

 while modify_pentry $( get_pcx $( pselect ) ); do : ; done

 if   check_root_defined &&
      check_double_device
 then make_fstab > /tmp/fstab
 else return 1
 fi
}


select_filesystems_to_initialize(){

 local TITLE=$"File System Initialization Selection Menu"
 local HELP=$"Select file systems to initialize.
All data on selected device will be lost.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title "$TITLE" --checklist "$HELP" 18 74 8 $( show_pinfo_init )
}


select_swapfile_to_initialize(){

 local TITLE=$"Swapfile Initialization Selection Menu"
 local HELP=$"If swapfiles have not been created and initialized
then now is the time to do so.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title "$TITLE" --checklist "$HELP" 18 74 8 $( show_sinfo_init )
}


installed_fs(){

 check_jfs(){ dd if=$1 bs=64k count=1 2>/dev/null | grep -q JFS1 && echo jfs; }

 case $( file -ks $1 ) in
  *swap\ file*)		echo  swap	;;
  *ext4\ filesystem*)	echo  ext4	;;
  *ext3\ filesystem*)	echo  ext3	;;
  *ext2\ filesystem*)	echo  ext2	;;
  *ocfs2*)		echo  ocfs2	;;
  *BTRFS\ Filesystem*)  echo  btrfs     ;;
  *SGI\ XFS*)		echo  xfs	;;
  *ReiserFS*)		echo  reiserfs	;;    
  *FAT*)		echo  fat	;;
  *stdin:\ data*)  	check_jfs "$1"	;;
 esac
}

pipe(){ cat -; "$@"; }
uniqs(){  LC_ALL=C sort | uniq -u; }
dups(){   LC_ALL=C sort | uniq -d; }

lv(){       lvs --noheadings -o lv_name       $1 | tr -d ' '; }
pv_in_vg(){ vgs --noheadings -o pv_name       $1 | tr -d ' '; }
pv(){       pvs --noheadings -o pv_name          | tr -d ' '; }
vg(){       vgs --noheadings -o vg_name          | tr -d ' '; }
vg_free(){  vgs --noheadings -o vg_free_count $1 | tr -d ' '; }
vg_lv(){    vgs --noheadings -o vg_name,lv_name  |
            sed 's:^ *::;s: :/:'                 | tr -d ' '; }
            

apvs(){ pv_in_vg | sed p | pipe pv | uniqs; }

ppv(){
 pv | sed p | pipe \
 find /dev -type b |
 sed '\,^/dev/loop,d
      \,^/dev/dm-[0-9],d
      \,^/dev/mapper/,d
      \,^/dev/fd[0-9],d
      \,^/dev/sr[0-9],d
      \,[0-9],p;d' |
 uniqs
}


filesystem_table_load(){
 local CX PART MEM

     PDEVICE[0]=/swap/0
 PFILESYSTEM[0]=swap
    POPTIONS[0]=defaults
       PDUMP[0]=0
      PORDER[0]=0
      PMOUNT[0]=none
       PSIZE[0]=256

 (( CX = 1 ))

 for PART in $( list_part ); do

      PDEVICE[$CX]="$PART"
  PFILESYSTEM[$CX]="$( installed_fs $PART )"
  get_filesystem_assumptions $CX
  (( CX++ ))
 done

 for (( ; CX<MP; CX++ )); do PDEVICE[$CX]=; empty_entry "$CX"; done
}


get_mkfs(){
 case ${PFILESYSTEM[$1]} in
      ext4) PMKFS[$1]="mkfs.ext4"	;;
      ext3) PMKFS[$1]="mkfs.ext3"	;;
      ext2) PMKFS[$1]="mkfs.ext2"	;;
     ocfs2) PMKFS[$1]="mkfs.ocfs2"      ;;
     btrfs) PMKFS[$1]="mkfs.btrfs"	;;
      swap) PMKFS[$1]="mkswap"		;;
  reiserfs) PMKFS[$1]="mkreiserfs"	;;
       xfs) PMKFS[$1]="mkfs.xfs"	;;
       jfs) PMKFS[$1]="jfs_mkfs"	;;
 esac
}


get_mk_command(){
 file_or_part(){
  case ${PDEVICE[$1]:0:5} in
   /dev/) echo "mkswap	${PCHECK[$1]}	$DEV" ;;
       *) echo "fallocate	-l${PSIZE[$1]}m	$TARGET$DEV&&${LF}mkswap	$TARGET$DEV	&&${LF}chmod	0	$TARGET$DEV" ;;
  esac
 }

 local DEV="${PLDEVICE[$1]}"
 DEV="${DEV:-${PDEVICE[$1]}}"

 case ${PFILESYSTEM[$1]} in
      ext4) echo "mkfs.ext4	${PCHECK[$1]}	${PFEATURE[$1]}	$DEV" ;;
      ext3) echo "mkfs.ext3	${PCHECK[$1]}	${PFEATURE[$1]}	$DEV" ;;
      ext2) echo "mkfs.ext2	${PCHECK[$1]}	${PFEATURE[$1]}	$DEV" ;;
     ocfs2) echo "mkfs.ocfs2	-F		${PFEATURE[$1]}	$DEV" ;;
     btrfs) echo "mkfs.btrfs	$DEV" ;;
  reiserfs) echo "mkreiserfs	-f	$DEV" ;;
       xfs) echo "mkfs.xfs	-f	$DEV" ;;
       jfs) echo "jfs_mkfs	-q	${PCHECK[$1]}	$DEV" ;;
      swap) file_or_part "$1" ;;
 esac
}

log_eval(){
 rm -fr /tmp/{err,out}
 echo > /tmp/err

 if eval "$1"; then rm -f /tmp/err; fi 2>&1 | tee /tmp/out
 if [ -f /tmp/err ]
 then cat /tmp/out >> /tmp/initialize_problem.txt; false
 else cat /tmp/out >> /tmp/initialize_success.txt
 fi
}

initialize(){

 local SURE SUCCESS FAILURE COMMAND

 SURE=$"Please confirm that all data on ${PLDEVICE[$1]:-${PDEVICE[$1]}} will be lost?"
 SUCCESS=$"${PFILESYSTEM[$1]} successfully created on ${PLDEVICE[$1]:-${PDEVICE[$1]}}"
 FAILURE=$"No success at creating ${PFILESYSTEM[$1]} on ${PLDEVICE[$1]:-${PDEVICE[$1]}}"

 if confirm "$SURE" --defaultno; then
                  COMMAND="$( get_mk_command "$1" )"
  if   confirm  "$COMMAND" --defaultno &&
       log_eval "$COMMAND"
  then pause; msgbox "$SUCCESS"
  else pause; msgbox "$FAILURE"; return 1
  fi
  PUUID[$1]=""; get_puuid $1
  make_fstab > /tmp/fstab
 fi
}


filesystem_initialize(){
 local PART

 [ -n "${PDEVICE[1]}" ] &&
 for PART in $( select_filesystems_to_initialize )
 do  initialize $( get_pcx "$PART" )
 done
}


swapfile_initialize(){
 local SWAP

 mkdir -pvm 700 $TARGET/swap
 if [ -n "$SILENCE" ]; then initialize 0; else
  [ -n "${PDEVICE[1]}" ] &&
  for SWAP in $( select_swapfile_to_initialize )
  do  initialize $( get_pcx "$SWAP" )
  done
 fi
}


list_mounts(){
 for (( CX=0; CX<MP; CX++ )); do
  if     [ -n       "${PMOUNT[$CX]}" ] &&
       ! [ none ==  "${PMOUNT[$CX]}" ]
  then echo         "${PMOUNT[$CX]}	$CX"
  fi
 done
}


filesystem_mount(){

 local ALREADY NOT_NOW SUCCESS FAILED

 SUCCESS=$"successfully mounted"
  FAILED=$"failed mounting"

 list_mounts | LC_ALL=C sort | cut -f2 |
 while read CX; do
  if mkdir -p     ${PRMOUNT[$CX]} &&
     mount -t ${PFILESYSTEM[$CX]} \
           -o  ${POPTIONS[$CX]} \
               ${PLDEVICE[$CX]:-${PDEVICE[$CX]}} \
               ${PRMOUNT[$CX]}
  then        msgbox "${PRMOUNT[$CX]} $SUCCESS"
  else pause; msgbox "${RPMOUNT[$CX]} $FAILED"
  fi
  if   [ -d       $TARGET/tmp ]
  then chmod 1777 $TARGET/tmp
  fi
 done
 swapfile_initialize
}

trans(){ [[ -f $TARGET/etc/fstab ]]; }

mbr_check(){
 if [[ -n $MBR ]]; then return; fi
 if [[ -n $BB  ]] && echo "$BB" | grep -q '[a-z]$'; then return; fi
 if confirm "Install a bootable MBR?"; then run_mbr; fi
}


filesystem_unmount(){

 local ALREADY NOT_NOW SURE SUCCESS FAILED

 SUCCESS=$"successfully unmounted"
  FAILED=$"failed unmounting"

  SURE=$"Partitions must be mounted to transfer 
Sorcerer and continue installation.
Really unmount the currently mounted partitions?"

 if trans || confirm "$SURE" --defaultno; then
  list_mounts | LC_ALL=C sort -r | cut -f2 |
  while read CX; do
   if   umount ${PRMOUNT[$CX]}
   then          $DIALOG --msgbox "${PRMOUNT[$CX]} $SUCCESS" 8 50
   else sleep 5; $DIALOG --msgbox "${PRMOUNT[$CX]} $FAILED"  8 50
   fi
  done
 fi
}


confirm_unmount(){
 local NOT_YET="
Until the install image is transfered,
initramfs images created,
and extlinux is installed to a boot block
the file systems should remain mounted.

However to modify the file system table, create,
initialize and/or mount more file systems
then the currently mounted file systems must be unmounted first."

 $DIALOG --msgbox "$NOT_YET" 20 70
 if   confirm "Really Unmount file systems?" --defaultno
 then filesystem_unmount
 fi
}


mapped(){
 find /dev/mapper -type b |
 sed 's:/dev/mapper/luks-:/dev/:
      s:/dev/mapper/:/dev/:'
}


list_part(){
 ( mapped | pipe pv_in_vg 2>/dev/null | sed p
   find /dev -type b |
   sed '\, ,d
        \,^/dev/loop,d
        \,^/dev/dm-[0-9],d
        \,^/dev/mapper/,p
        \,^/dev/mapper/,d
        \,^/dev/fd[0-9],d
        \,^/dev/sr[0-9],d
        \,[0-9],p;d'
 ) | uniqs
}

get_part(){
 $DIALOG \
  --title $"Block Device Selection Menu" \
  --menu  $"Please select a block device" \
  0 0 0   $( list_part | sed ' s:$:\tblock:' )
}

get_pass(){
 local PASS1 PASS2
 PASS1="$( $DIALOG --passwordbox $"Please    enter password" --no-cancel 0 0 )"
 PASS2="$( $DIALOG --passwordbox $"Please re-enter password" --no-cancel 0 0 )"
 if   [    "$PASS1" == "$PASS2" ]
 then echo "$PASS1";
 else $DIALOG --msgbox "passwords did not match" 0 0; false
 fi
}

boot_partition_warning(){

 $DIALOG --msgbox \
'A dedicated /boot partition with ext2 file system
of size 2G is required when
any of these conditions are true:

1. On old 80586 with broken BIOS
2. When / is a LVM2 logical volume
3. When / is a LUKS encrypted volume
5. When / is a software RAID.
6. When / is a XFS, BTRFS, ocfs2 or Reiserfs file system' 20 75
}


launch(){
 if confirm "Execute $*" --defaultno
 then eval "$@"; pause
 else            pause; return 1
 fi
}

name_vg(){ inputbox $"Name for Volume Group?${LF}No / in name"; }
name_lv(){ inputbox $"Name for Logical Volume?${LF}No / in name"; }

set_pv(){
 local HELP=$"Select block device"
 $DIALOG --no-cancel --ok-label Select --menu "$HELP" 0 60 8 \
         $( ppv | sed 's:$:	Block Device:' )
}

get_pv(){
 local HELP=$"Select physical volumes for volume group"
 $DIALOG --nocancel --separate-output --checklist "$HELP" 20 70 10 \
         $( apvs | sed 's:$:	Physical Volume	off:' ) | tr '\n' '\t'
 echo
}


get_vg(){
 local HELP=$"Select volume group"
 $DIALOG --no-cancel --ok-label Select --menu "$HELP" 0 60 8 \
         $( vg | sed 's:$:	Volume Group:' )
}


get_lv(){
 local HELP=$"Select logical volume"
 $DIALOG --no-cancel --ok-label Select --menu "$HELP" 0 60 8 \
         $( lv | sed 's:$:	Logical Volume:' )
}

get_vg_lv(){
 local HELP=$"Select volume group/logical volume"
 $DIALOG --no-cancel --ok-label Select --menu "Select LV" 0 60 8 \
         $( vg_lv | sed 's:$:	Volume Group/Logical Volume:' )
}

get_lv_size(){
 local SIZE
 local HELP=$"
Enter Size where suffix can be:
 %VG   Percentage of total space in Volume Group
 %FREE Percentage of free  space in Volume Group
 M for Megabytes,
 G for Gigabytes,
 T for Terabytes,
 P for Petabytes,
 E for Exabytes"

 SIZE=$( inputbox "$HELP" )

 case $SIZE in
  *VG) echo "-l	$SIZE" ;;
  *EE) echo "-l	$SIZE" ;;
    *) echo "-L	$SIZE" ;;
 esac
}


cpv(){ launch pvcreate    $( set_pv ); }
clv(){ launch lvcreate -n $( name_lv ) $( get_vg ) $( get_lv_size ); }
cvg(){ launch vgcreate    $( name_vg ) $( get_pv ); }
rvg(){ launch vgremove -f $( get_vg ); }
rlv(){ launch lvremove -f $( get_vg_lv ); }

run_pvcreate(){ cpv; vgchange -ay; filesystem_table_load; }
run_vgcreate(){ cvg; vgchange -ay; filesystem_table_load; }
run_lvcreate(){ clv; vgchange -ay; filesystem_table_load; }
run_vgremove(){ rvg; vgchange -ay; filesystem_table_load; }
run_lvremove(){ rlv; vgchange -ay; filesystem_table_load; }


pause(){ [ -n "$SILENCE" ] || read -n 1 -t 900 -p "Press space to continue."; }

name_raid(){
 local CX
 for ((CX=0;CX<MP;CX++)); do
  if ! [ -b /dev/md$CX ]
  then echo /dev/md$CX; break
  fi
 done
}

raid_level(){
 $DIALOG --title $"RAID Level?" --item-help --no-cancel --menu "" 20 40 10 \
 linear "2 >= devices" "concatenate devices"  \
 raid0  "2 >= devices" "concatenate devices and stripe data" \
 0      "2 >= devices" "concatenate devices and stripe data" \
 stripe "2 >= devices" "concatenate devices and stripe data" \
 raid1  "2 >= devices" "mirror devices" \
 1      "2 >= devices" "mirror devices" \
 mirror "2 >= devices" "mirror devices" \
 raid4  "3 >= devices" "block-level striping with dedicated parity confined to single device" \
 4      "3 >= devices" "block-level striping with dedicated parity confined to single device" \
 raid5  "3 >= devices" "block-level striping with distributed parity" \
 5      "3 >= devices" "block-level striping with distributed parity" \
 raid6  "4 >= devices" "block-level striping with double distributed parity" \
 6      "4 >= devices" "block-level striping with double distributed parity" \
 raid10 "2 >= devices" "RAID 1 + RAID 0" \
 10     "2 >= devices" "RAID 1 + RAID 0"
}

raid_part(){
 local CX=0

 DEVS=$( $DIALOG --separate-output --nocancel \
         --title "Select Devices for RAID" --checklist "" 20 70 10 \
         $( list_disk | sed 's:$:	off:'
            list_part | sed '\,^/dev/mapper,d
                             s:$:	Partition	off:' ) )
 [ -n "$DEVS" ] || return

 for DEV in $DEVS; do
  (( CX++ ))
  case $DEV in
   hd[a-z][0-9]) sfdisk -c ${DEV:0:8} ${DEV:8:2} fd ;;
   sd[a-z][0-9]) sfdisk -c ${DEV:0:8} ${DEV:8:2} fd ;;
  esac
 done

 echo "-n $CX $DEVS"
}

compile_menu(){
 if   ! [ -f $TARGET/etc/fstab ]
 then $DIALOG --msgbox $"Transfer first." 8 50; return 1
 fi

 local EXTRA_SPELLS REQUIRED_SPELLS="\
etc
glibc-locales"

 make_bootloader_conf

 EXTRA_SPELLS=$( select_extra_spells )

 chroot_build	$REQUIRED_SPELLS	$EXTRA_SPELLS

 for ITEM in $EXTRA_SPELLS; do
  case $ITEM in
   rp-pppoe)	chroot_run /usr/sbin/adsl-setup	;;
   wvdial)	chroot_run /usr/bin/wvdialconf;	edit $TARGET/etc/wvdial.conf ;;
  esac
 done

 CVIS="Visited"
}

expert_advise(){
 local   HINT=$"Here are easy to forget yet useful facts."
 local DISKS0=$"Disks         should be partitioned."
 local DISKS1=$"Disks            can be added to MDRAIDs."
 local PARTS1=$"Partitions       can be added to MDRAIDs."
 local PARTS2=$"Partitions       can be converted into physical volumes."
 local  RAID0=$"MDRAID           can be converted into physical volume."
 local  RAID1=$"MDRAID           can be partitioned."
 local PVTOVG=$"Physical volumes can be added     to   a volume group."
 local VGTOLV=$"Logical  volumes can be allocated from a volume group."
 local CRYPT1=$"Partition        can be LUKS encrypted."
 local CRYPT2=$"MDRAID           can be LUKS encrypted."
 local CRYPT3=$"Logical  volumes can be LUKS encrypted."
 local  BOOT0=$"During boot:"
 local  BOOT1=$"MDRAIDs         activate first;"
 local  BOOT2=$"Logical volumes activate after MDRAIDs;"
 local  BOOT3=$"LUKS            activate after volume groups;"
 local  BOOT4=$"file systems    check;"
 local  BOOT5=$"file systems    mount;"
 local  BOOT6=$"swaps           activate."
 local   LVM2=$"LVM2: physical volumes -> volume groups -> logical volumes"
 local   LUKS=$"LUKS, the Linux Unified Key Setup, is encryption."
 local COMBO0=$"A partial list of usable combinations are:"
 local COMBO1=$"Disk -> Part ->                                FS or Swap"
 local COMBO2=$"Disk -> Part ->                        LUKS -> FS or Swap"
 local COMBO3=$"Disk or Part -> RAID ->                        FS or Swap"
 local COMBO4=$"Disk or Part -> RAID ->                LUKS -> FS or Swap"
 local COMBO5=$"Disk or Part -> RAID -> Part ->                FS or Swap"
 local COMBO6=$"Disk or Part -> RAID -> Part ->        LUKS -> FS or Swap"
 local COMBO7=$"Disk or Part -> RAID ->         LVM ->      -> FS or Swap"
 local COMBO8=$"Disk or Part -> RAID ->         LVM -> LUKS -> FS or Swap"
 local COMBO9=$"Disk -> Part ->                 LVM ->      -> FS or Swap"
 local COMBOa=$"Disk -> Part ->                 LVM -> LUKS -> FS or Swap"

 local WARN0=$"The Primary disk must be partitioned."

 local SWAPS0=$"A swap area can be created instead of  a file system."
 local SWAPS1=$"A swap file can be created         on  a file system."
 local SWAPS2=$"A swap file is less efficient than     a swap area."
 local SWAPS3=$"A swap file can fix a temporary low memory situation."
 local MEMORY=$"Installed RAM + SWAP >= 3G"

 local   OKAY=$"Easy, yes?  Good luck."

 msgbox "${HINT}${LF}${LF}${DISKS0}${LF}${DISKS1}${LF}${PARTS1}${LF}${PARTS2}${LF}${RAID0}${LF}${RAID1}${LF}${PVTOVG}${LF}${VGTOLV}${LF}${CRYPT1}${LF}${CRYPT2}${LF}${CRYPT3}${LF}${LF}${BOOT0}${LF}${BOOT1}${LF}${BOOT2}${LF}${BOOT3}${LF}${BOOT4}${LF}${BOOT5}${LF}${BOOT6}${LF}${LF}${LVM2}${LF}${LUKS}${LF}${LF}${COMBO0}${LF}${LF}${COMBO1}${LF}${COMBO2}${LF}${COMBO3}${LF}${COMBO4}${LF}${COMBO5}${LF}${COMBO6}${LF}${COMBO7}${LF}${COMBO8}${LF}${COMBO9}${LF}${COMBOa}${LF}${LF}${WARN0}${LF}${LF}${SWAPS0}${LF}${SWAPS1}${LF}${SWAPS2}${LF}${SWAPS3}${LF}${LF}${MEMORY}${LF}${LF}${OKAY}"
}


novice_advise(){
 local HELP0=$"Installation is easy."
 local PART0=$"Select a disk to partition."
 local PART1=$"Make the first   partition ID 83 Linux      size 2G."
 local PART2=$"Make the second  partition ID 82 Linux swap size 2G."
 local PART3=$"Make the third   partition ID 83 Linux      size huge."
 local FSYS0=$"In the fstab menu define mount points and file systems."
 local FSYS1=$"Make the first  partition file system ext2 mounted as /boot"
 local FSYS2=$"Make the second partition file system swap"
 local FSYS3=$"Make the third  partition file system ext3 mounted as /"
 local INIT0=$"Leave the fstab menu."
 local INIT1=$"Initialize the file systems."
 local MOUNT=$"Mount      the file systems."
 local COPY0=$"Transfer the operating system to fixed disk."
 local CAST0=$"Compile necessary software."
 local QUIT0=$"Quit and reboot using only the fixed disk."
 local   OKAY=$"Easy, yes?  Good luck."

 msgbox "${HELP0}${LF}${LF}${PART0}${LF}${PART1}${LF}${PART2}${LF}${PART3}${LF}${LF}${FSYS0}${LF}${LF}${FSYS1}${LF}${FSYS2}${LF}${FSYS3}${LF}${LF}${INIT0}${LF}${INIT1}${LF}${MOUNT}${LF}${COPY0}${LF}${CAST0}${LF}${QUIT0}${LF}${LF}${OKAY}"
}
 

run_skill(){
 local LVM=$"logical volume managment;"
 local RAID=$"kernel implemented redundant array of inexpensive disks;"
 local LUKS=$"linux unified key setup;"
 local ALSO=$"and enforcement of safe order bypass."
 local NOVICE=$"Novice allows for an uncomplicated installation."
 local EXPERT=$"Expert provides:"
 local AWESOME=$"Enable expert skill level?"

 msgbox "${NOVICE}${LF}${EXPERT}${LF}${LVM}${LF}${RAID}${LF}${LUKS}${LF}${ALSO}"

 if   confirm "$AWESOME" --defaultno
 then SKILL="expert"; expert_advise
 else SKILL="novice"; novice_advise
 fi
}


run_mdadm(){ launch mdadm -C -a mdp $( name_raid ) -l $( raid_level ) $( raid_part ); filesystem_table_load; }
run_mdadm_stop(){ mdadm --stop --scan; filesystem_table_load; }

run_lsmod(){ ( lsmod; echo "Press q to return" ) | less; }

loaded(){
 echo "Module"; echo "Used by"
 lsmod | tr -s ' ' | cut -d ' ' -f1,3- | sed "1d;s: :\n:"
}

run_rmmod(){
 local MOD=$( $DIALOG \
  --title $"Module Unload Menu" \
  --menu  $"Select a module to unload please" 0 0 0  $( loaded ) )

 [ -n "$MOD" ] && rmmod "$MOD"
}


run_modprobe(){
 para(){ $DIALOG --nocancel --inputbox "Parameters for $1?" 0 0; }
 mods(){ find /lib/modules -type f | cut -d / -f6- | LC_ALL=C sort | sed -nr "s:(.*)/(.*):\2\t\1: ; s:\.ko\t:\t:p"; }
 msel(){ $DIALOG --title $"Module Load Menu" --menu  $"Select a module to load please" 0 0 0 $( mods ); }

 local PARAM MODULE
 if          MODULE="$( msel )" &&
      [ -n "$MODULE" ] &&
      PARAM="$( para "$MODULE" )"
 then
  modprobe $MODULE $PARAMETERS
  pause
 fi
}

allow(){
 local SOON=$"Earlier menus are required."
 local YEAH=$"Disregard and proceed at the risk of grand failure?"

 if   [ expert = "$SKILL" ]
 then msgbox "$SOON"; confirm "$YEAH" --defaultno
 else return 1
 fi
}

mounted(){ grep -q "$TARGET" /proc/mounts; }

installed(){ [ -f "$TARGET/usr/sbin/cast" ]; }

compiled(){ [ -d "$TARGET/var/log/sorcery/event" ]; }

fstabed(){ [ -f /tmp/fstab ]; }

initialized(){ [ -f /tmp/initialize_success.txt ]; }


run_reload_fstab(){
 if ! mounted
 then filesystem_table_load
 fi
}


run_modify_fstab(){ filesystem_table; }

run_init_filesys(){
 if   fstabed || allow
 then filesystem_initialize
 fi
}

run_install(){    if mounted   || allow; then transfer_arch 2>&1 | tee /tmp/transfer.txt; fi; }
run_edit_fstab(){ if installed || allow; then edit_fstab;   fi; }
run_compile(){    if installed || allow; then compile_menu; fi; }

run_mount(){  if ! mounted; then filesystem_mount; fi; }
run_umount(){ if   mounted; then filesystem_unmount; fi; }

        run_done(){ goodbye; }
       rdy_lsmod(){ echo optional; }
    rdy_modprobe(){ echo optional; }
       rdy_rmmod(){ echo optional; }
    rdy_pvcreate(){ echo optional; }
    rdy_vgcreate(){ echo optional; }
    rdy_lvcreate(){ echo optional; }
    rdy_vgremove(){ echo optional; }
    rdy_lvremove(){ echo optional; }
       rdy_mdadm(){ echo optional; }
  rdy_mdadm_stop(){ echo optional; }
        rdy_auto(){ echo optional; }

rdy_mbr(){
 if   [ "$MBR" ]
 then echo complete
 else echo optional
 fi
}

rdy_partition(){
 if   [ "$PARTITION" ]
 then echo complete
 else echo optional
 fi
}


rdy_reload_fstab(){ 
 if mounted
 then echo 'optional before mount'
 else echo 'optional'
 fi
}


rdy_modify_fstab(){ 
 if   fstabed
 then echo complete
 else echo required
 fi
}

rdy_init_filesys(){
 if   initialized; then echo 'complete'
 elif fstabed;     then echo 'prudent' 
                   else echo 'prudent later'
 fi
}

rdy_mount(){
 if   mounted; then echo 'complete'
 elif fstabed; then echo 'required'
               else echo 'required later'
 fi
}

rdy_install(){
 if   installed; then echo 'complete'
 elif mounted;   then echo 'required'
                 else echo 'required later'
 fi
}

rdy_edit_fstab(){
 if   mounted
 then echo 'optional'
 else echo 'optional later'
 fi
}

rdy_compile(){
 if   compiled; then echo 'complete'
 elif mounted;  then echo 'required'
                else echo 'required later'
 fi
}

rdy_umount(){
 if   mounted
 then echo 'optional'
 else echo 'optional later'
 fi
}

rdy_done(){
 if   compiled
 then echo 'required'
 else echo 'required later'
 fi
}


main_menu_novice(){
 local HELP="Sorcerer comes with no warranty.
Navigate this menu with the up an down arrow keys.
Press the Enter key to make a selection."

 $DIALOG --item-help --nocancel --default-item "$MAIN" --menu "$HELP" 0 60 10 \
  auto         "$( rdy_auto         )" "automatically install Sorcerer sentient" \
  skill        "$SKILL"                "select novice or expert menus" \
  mbr          "$( rdy_mbr          )" "write bootable master boot record" \
  partition    "$( rdy_partition    )" "create partition on a block device" \
  modify_fstab "$( rdy_modify_fstab )" "modify     file system table" \
  init_filesys "$( rdy_init_filesys )" "initialize file systems" \
  mount        "$( rdy_mount        )" "mount file systems" \
  install      "$( rdy_install      )" "install software" \
  compile      "$( rdy_compile      )" "configure, compile and install some software" \
  umount       "$( rdy_umount       )" "unmount file systems" \
  exit         "$( rdy_done         )" "exit installer"
}

main_menu_expert(){
 local HELP="Sorcerer comes with no warranty.
Navigate this menu with the up an down arrow keys.
Press the Enter key to make a selection."

 $DIALOG --item-help --nocancel --default-item "$MAIN" --menu "$HELP" 0 60 10 \
  skill        "$SKILL"                "Select novice or expert menus" \
  lsmod        "$( rdy_lsmod        )" "list loaded modules" \
  modprobe     "$( rdy_modprobe     )" "load module" \
  rmmod        "$( rdy_rmmod        )" "remove loaded module" \
  mbr          "$( rdy_mbr          )" "write bootable master boot record" \
  partition    "$( rdy_partition    )" "create partition on a block device" \
  mdadm        "$( rdy_mdadm        )" "create and activate software RAID" \
  mdadm_stop   "$( rdy_mdadm_stop   )" "stop software RAID" \
  pvcreate     "$( rdy_pvcreate     )" "create physical volume" \
  vgcreate     "$( rdy_vgcreate     )" "create volume group" \
  lvcreate     "$( rdy_lvcreate     )" "create logical volume" \
  vgremove     "$( rdy_vgremove     )" "remove volume group" \
  lvremove     "$( rdy_lvremove     )" "remove logical volume" \
  reload_fstab "$( rdy_reload_fstab )" "reload incomplete file system table" \
  modify_fstab "$( rdy_modify_fstab )" "modify file system table" \
  init_filesys "$( rdy_init_filesys )" "initialize file systems" \
  mount        "$( rdy_mount        )" "mount file systems" \
  install      "$( rdy_install      )" "install software" \
  edit_fstab   "$( rdy_edit_fstab   )" "edit /etc/fstab on new root file system" \
  compile      "$( rdy_compile      )" "configure, compile and install some software" \
  umount       "$( rdy_umount       )" "unmount file systems" \
  exit         "$( rdy_done         )" "exit installer"
}

main_menu(){
 local MAIN

 filesystem_table_load
 [ -n "$SKILL" ] || SKILL=novice

 while MAIN=$( main_menu_$SKILL ); do
  case $MAIN in
   auto)		run_auto ;;
   skill)		run_skill ;;
   lsmod)		run_lsmod ;;
   modprobe)		run_modprobe ;;
   rmmod)		run_rmmod ;;
   mbr)			run_mbr ;;
   partition)		run_partition ;;
   pvcreate)            run_pvcreate ;;
   vgcreate)		run_vgcreate ;;
   lvcreate)		run_lvcreate ;;
   vgremove)		run_vgremove ;;
   lvremove)		run_lvremove ;;
   mdadm)		run_mdadm ;;
   mdadm_stop)		run_mdadm_stop ;;
   reload_fstab)	run_reload_fstab ;;
   modify_fstab)	run_modify_fstab ;;
   init_filesys)	run_init_filesys ;;
   mount)		run_mount ;;
   install)		run_install ;;
   edit_fstab)		run_edit_fstab ;;
   compile)		run_compile ;;
   umount)		run_umount ;;
   exit)		goodbye	;;
  esac
 done
}


# Max Partitions
MP=64
TARGET="/media/root"

# Total kilobytes
RAM=$( sed -r "s/MemTotal: *(.*) kB/\1/p;d" /proc/meminfo )

TAB="	"
LF="
"

export IFS="	$LF"
export DIALOG="dialog	--backtitle	Sorcerer Installer	--stdout"

trap : INT QUIT

if   ! [ -d /media/IR/boot/isolinux ]
then $DIALOG --msgbox "\
The Sorcerer Install/Rescue image is
normally automatically mounted during boot
by the execution of /etc/init.d/find_ir start
Not having it mounted is unexpected.
Menu driven installation will not be possible.
I apologize for the inconvenience.
Please email a detailed report of the problem,
cause and solution please to kyle.sallee@gmail.com" 15 60
exit 1
fi

if ! [ -f /usr/bin/tr ]
then $DIALOG --msgbox "\
Important archives such as coreutils
were not unarchived from the Install/Rescue image.
Archive are normally automatically unarchived during boot 
by the execution of /etc/init.d/archives start
Consequently, menu driven installation is not possible.
I apologize for the inconvenience.
Please email a detailed report of the problem,
cause and solution please to kyle.sallee@gmail.com" 15 70
exit 1
fi

run_skill
main_menu

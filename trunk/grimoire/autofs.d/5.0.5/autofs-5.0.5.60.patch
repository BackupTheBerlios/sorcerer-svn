diff -r -U2 autofs-5.0.5/CHANGELOG autofs-5.0.5/CHANGELOG
--- autofs-5.0.5/CHANGELOG	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/CHANGELOG	2010-12-07 10:54:27.579737591 -0700
@@ -1,2 +1,60 @@
+??/??/20?? autofs-5.0.6
+-----------------------
+- fix included map read fail handling.
+- refactor ldap sasl bind handling.
+- add mount wait timeout parameter.
+- special case cifs escapes.
+- fix compile fail with when LDAP is excluded.
+- more code analysis corrections (and fix a typo in an init script).
+- fix backwards #ifndef INET6.
+- fix stale initialization for file map instance.
+- add "preen" fsck for ext4 mounts.
+- don't use master_lex_destroy() to clear parse buffer.
+- make documentation for set-log-priority clearer.
+- fix timeout in connect_nb().
+- fix pidof init script usage.
+- check for path mount location in generic module.
+- dont fail mount on access fail.
+- fix rpc fail on large export list.
+- fix memory leak on reload.
+- update kernel patches for 2.6.18 and 2.6.19.
+- dont connect at ldap lookup module init.
+- fix random selection option.
+- fix disable timeout.
+- fix strdup() return value check (Leonardo Chiquitto).
+- fix reconnect get base dn.
+- add missing sasl mutex callbacks.
+- fix get query dn failure.
+- fix ampersand escape in auto.smb.
+- add locality as valid ldap master map attribute.
+- add locality as valid ldap master map attribute fix.
+- add simple bind authentication.
+- fix master map source server unavailable handling.
+- add autofs_ldap_auth.conf man page.
+- fix random selection for host on different network.
+- make redhat init script more lsb compliant.
+- don't hold lock for simple mounts.
+- fix remount locking.
+- fix wildcard map entry match.
+- fix parse_sun() module init.
+- dont check null cache on expire.
+- fix null cache race.
+- fix cache_init() on source re-read.
+- fix mapent becomes negative during lookup.
+- check each dc server individually.
+- fix negative cache included map lookup.
+- remove state machine timed wait.
+- remove extra read master map call.
+- fix error handing in do_mount_indirect().
+- expire thread use pending mutex.
+- remove ERR_remove_state() openssl call.
+- fix init script restart option.
+- fix init script status privilege error.
+- always read file maps mount lookup map read fix.
+- fix direct map not updating on reread.
+- add external bind method.
+- fix add simple bind auth.
+- add option to dump configured automount maps.
+
 03/09/2009 autofs-5.0.5
 -----------------------
diff -r -U2 autofs-5.0.5/Makefile.conf.in autofs-5.0.5/Makefile.conf.in
--- autofs-5.0.5/Makefile.conf.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/Makefile.conf.in	2010-12-07 10:54:27.533078863 -0700
@@ -32,4 +32,6 @@
 LIBSASL= @LIBSASL@
 SASL_FLAGS = @SASL_FLAGS@
+KRB5_LIBS=@KRB5_LIBS@
+KRB5_FLAGS=@KRB5_FLAGS@
 
 # NIS+ support: yes (1) no (0)
@@ -45,4 +47,7 @@
 EXT3FS = @HAVE_E3FSCK@
 
+# Support for calling e4fsck when mounting ext4 filesystems
+EXT4FS = @HAVE_E4FSCK@
+
 LEX = @PATH_LEX@
 YACC = @PATH_YACC@
diff -r -U2 autofs-5.0.5/aclocal.m4 autofs-5.0.5/aclocal.m4
--- autofs-5.0.5/aclocal.m4	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/aclocal.m4	2010-12-07 10:54:27.533078863 -0700
@@ -216,4 +216,23 @@
 
 dnl --------------------------------------------------------------------------
+dnl AF_CHECK_KRB5
+dnl
+dnl Check for Kerberos 5
+dnl --------------------------------------------------------------------------
+AC_DEFUN([AF_CHECK_KRB5],
+[AC_PATH_PROGS(KRB5_CONFIG, krb5-config, no)
+AC_MSG_CHECKING(for Kerberos library)
+if test "$KRB5_CONFIG" = "no"
+then
+  AC_MSG_RESULT(no)
+  HAVE_KRB5=0
+else
+  AC_MSG_RESULT(yes)
+  HAVE_KRB5=1
+  KRB5_LIBS=`$KRB5_CONFIG --libs`
+  KRB5_FLAGS=`$KRB5_CONFIG --cflags`
+fi])
+
+dnl --------------------------------------------------------------------------
 dnl AF_CHECK_LIBHESIOD
 dnl
diff -r -U2 autofs-5.0.5/configure autofs-5.0.5/configure
--- autofs-5.0.5/configure	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/configure	2010-12-07 10:54:27.536411629 -0700
@@ -641,4 +641,6 @@
 DAEMON_LDFLAGS
 DAEMON_CFLAGS
+KRB5_FLAGS
+KRB5_LIBS
 LIBSASL
 HAVE_SASL
@@ -658,4 +660,5 @@
 LIBRESOLV
 LIBNSL
+KRB5_CONFIG
 XML_CONFIG
 PATH_RPCGEN
@@ -669,4 +672,6 @@
 HAVE_MODPROBE
 MODPROBE
+HAVE_E4FSCK
+E4FSCK
 HAVE_E3FSCK
 E3FSCK
@@ -3408,4 +3413,65 @@
 fi
 
+for ac_prog in fsck.ext4 e4fsck
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_E4FSCK+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $E4FSCK in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_E4FSCK="$E4FSCK" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $searchpath
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_E4FSCK="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+E4FSCK=$ac_cv_path_E4FSCK
+if test -n "$E4FSCK"; then
+  { $as_echo "$as_me:$LINENO: result: $E4FSCK" >&5
+$as_echo "$E4FSCK" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$E4FSCK" && break
+done
+
+if test -n "$E4FSCK"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_E4FSCK 1
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PATH_E4FSCK "$E4FSCK"
+_ACEOF
+
+  HAVE_E4FSCK=1
+else
+  HAVE_E4FSCK=0
+fi
+
 for ac_prog in modprobe
 do
@@ -3724,5 +3790,5 @@
 fi
 
-# LDAP SASL auth need libxml
+# LDAP SASL auth needs libxml and Kerberos
 for ac_prog in xml2-config
 do
@@ -3802,4 +3868,64 @@
   fi
 fi
+for ac_prog in krb5-config
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_KRB5_CONFIG+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $KRB5_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_KRB5_CONFIG="$KRB5_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_KRB5_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+KRB5_CONFIG=$ac_cv_path_KRB5_CONFIG
+if test -n "$KRB5_CONFIG"; then
+  { $as_echo "$as_me:$LINENO: result: $KRB5_CONFIG" >&5
+$as_echo "$KRB5_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$KRB5_CONFIG" && break
+done
+test -n "$KRB5_CONFIG" || KRB5_CONFIG="no"
+
+{ $as_echo "$as_me:$LINENO: checking for Kerberos library" >&5
+$as_echo_n "checking for Kerberos library... " >&6; }
+if test "$KRB5_CONFIG" = "no"
+then
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  HAVE_KRB5=0
+else
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  HAVE_KRB5=1
+  KRB5_LIBS=`$KRB5_CONFIG --libs`
+  KRB5_FLAGS=`$KRB5_CONFIG --cflags`
+fi
 
 #
@@ -5175,4 +5301,6 @@
 
 
+
+
 
 
diff -r -U2 autofs-5.0.5/configure.in autofs-5.0.5/configure.in
--- autofs-5.0.5/configure.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/configure.in	2010-12-07 10:54:27.539744396 -0700
@@ -132,4 +132,5 @@
 AF_PATH_INCLUDE(E2FSCK, fsck.ext2 e2fsck, , $searchpath)
 AF_PATH_INCLUDE(E3FSCK, fsck.ext3 e3fsck, , $searchpath)
+AF_PATH_INCLUDE(E4FSCK, fsck.ext4 e4fsck, , $searchpath)
 AF_PATH_INCLUDE(MODPROBE, modprobe, , $searchpath)
 
@@ -145,6 +146,7 @@
 AF_SLOPPY_MOUNT()
 
-# LDAP SASL auth need libxml
+# LDAP SASL auth needs libxml and Kerberos
 AF_CHECK_LIBXML()
+AF_CHECK_KRB5()
 
 #
@@ -275,4 +277,6 @@
 AC_SUBST(HAVE_SASL)
 AC_SUBST(LIBSASL)
+AC_SUBST(KRB5_LIBS)
+AC_SUBST(KRB5_FLAGS)
 LDFLAGS="${AF_tmp_ldflags}"
 
diff -r -U2 autofs-5.0.5/daemon/Makefile autofs-5.0.5/daemon/Makefile
--- autofs-5.0.5/daemon/Makefile	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/Makefile	2010-12-07 10:54:27.319781821 -0700
@@ -24,8 +24,6 @@
 
 ifeq ($(LDAP), 1)
-  ifeq ($(SASL), 1)
     CFLAGS += $(XML_FLAGS)
     LIBS += $(XML_LIBS)
-  endif
 endif
 
diff -r -U2 autofs-5.0.5/daemon/automount.c autofs-5.0.5/daemon/automount.c
--- autofs-5.0.5/daemon/automount.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/automount.c	2010-12-07 10:54:27.579737591 -0700
@@ -39,8 +39,10 @@
 
 #include "automount.h"
-#ifdef LIBXML2_WORKAROUND
+#if defined(LIBXML2_WORKAROUND) || defined(TIRPC_WORKAROUND)
 #include <dlfcn.h>
+#ifdef WITH_LDAP
 #include <libxml/parser.h>
 #endif
+#endif
 
 const char *program;		/* Initialized with argv[0] */
@@ -511,5 +513,5 @@
 	 */
 	if (!is_mm_root && is_mounted(_PATH_MOUNTED, path, MNTS_REAL)) {
-		info(ap->logopt, "unmounting dir = %s", path);
+		debug(ap->logopt, "unmounting dir = %s", path);
 		if (umount_ent(ap, path)) {
 			warn(ap->logopt, "could not umount dir %s", path);
@@ -525,5 +527,4 @@
 int umount_multi(struct autofs_point *ap, const char *path, int incl)
 {
-	struct mapent_cache *nc;
 	int is_autofs_fs;
 	int left;
@@ -531,12 +532,4 @@
 	debug(ap->logopt, "path %s incl %d", path, incl);
 
-	nc = ap->entry->master->nc;
-	cache_readlock(nc);
-	if (cache_lookup_distinct(nc, path)) {
-		cache_unlock(nc);
-		return 0;
-	}
-	cache_unlock(nc);
-
 	is_autofs_fs = 0;
 	if (master_find_submount(ap, path))
@@ -1281,12 +1274,14 @@
 		fatal(status);
 
+	master_mutex_lock();
 	if (master->reading) {
 		status = pthread_mutex_unlock(&mrc.mutex);
 		if (status)
 			fatal(status);
+		master_mutex_unlock();
 		return 1;
 	}
-
 	master->reading = 1;
+	master_mutex_unlock();
 
 	status = pthread_create(&thid, &th_attr_detached, do_read_master, NULL);
@@ -1477,5 +1472,4 @@
 		master_free_mapent(ap->entry);
 	}
-	master_mutex_unlock();
 
 	if (clean) {
@@ -1496,5 +1490,7 @@
 	if (!submount)
 		pthread_kill(state_mach_thid, SIGTERM);
-	
+
+	master_mutex_unlock();
+
 	return;
 }
@@ -1669,4 +1665,5 @@
 		"	-r --random-multimount-selection\n"
 		"			use ramdom replicated server selection\n"
+		"	-m --dumpmaps	dump automounter maps and exit\n"
 		"	-n --negative-timeout n\n"
 		"			set the timeout for failed key lookups.\n"
@@ -1818,5 +1815,5 @@
 	int logpri = -1;
 	unsigned ghost, logging, daemon_check;
-	unsigned foreground, have_global_options;
+	unsigned dumpmaps, foreground, have_global_options;
 	time_t timeout;
 	time_t age = time(NULL);
@@ -1832,4 +1829,5 @@
 		{"random-multimount-selection", 0, 0, 'r'},
 		{"negative-timeout", 1, 0, 'n'},
+		{"dumpmaps", 0, 0, 'm'},
 		{"global-options", 1, 0, 'O'},
 		{"version", 0, 0, 'V'},
@@ -1862,8 +1860,9 @@
 	have_global_options = 0;
 	foreground = 0;
+	dumpmaps = 0;
 	daemon_check = 1;
 
 	opterr = 0;
-	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:l:n:CF", long_options, NULL)) != EOF) {
+	while ((opt = getopt_long(argc, argv, "+hp:t:vmdD:fVrO:l:n:CF", long_options, NULL)) != EOF) {
 		switch (opt) {
 		case 'h':
@@ -1907,4 +1906,8 @@
 			break;
 
+		case 'm':
+			dumpmaps = 1;
+			break;
+
 		case 'O':
 			if (!have_global_options) {
@@ -1993,5 +1996,6 @@
 #endif
 
-	if (!query_kproto_ver() || get_kver_major() < 5) {
+	/* Don't need the kernel module just to look at the configured maps */
+	if (!dumpmaps && (!query_kproto_ver() || get_kver_major() < 5)) {
 		fprintf(stderr,
 			"%s: test mount forbidden or "
@@ -2006,6 +2010,6 @@
 	res = setrlimit(RLIMIT_NOFILE, &rlim);
 	if (res)
-		warn(logging,
-		     "can't increase open file limit - continuing");
+		printf("%s: can't increase open file limit - continuing",
+			argv[0]);
 
 #if ENABLE_CORES
@@ -2014,10 +2018,8 @@
 	res = setrlimit(RLIMIT_CORE, &rlim);
 	if (res)
-		warn(logging,
-		     "can't increase core file limit - continuing");
+		printf("%s: can't increase core file limit - continuing",
+			argv[0]);
 #endif
 
-	become_daemon(foreground, daemon_check);
-
 	if (argc == 0)
 		master_list = master_new(NULL, timeout, ghost);
@@ -2026,12 +2028,30 @@
 
 	if (!master_list) {
-		logerr("%s: can't create master map %s",
-			program, argv[0]);
-		res = write(start_pipefd[1], pst_stat, sizeof(*pst_stat));
-		close(start_pipefd[1]);
-		release_flag_file();
+		printf("%s: can't create master map %s", program, argv[0]);
 		exit(1);
 	}
 
+	if (dumpmaps) {
+		struct mapent_cache *nc;
+
+		open_log();
+
+		master_init_scan();
+
+		nc = cache_init_null_cache(master_list);
+		if (!nc) {
+			printf("%s: failed to init null map cache for %s",
+				master_list->name, argv[0]);
+			exit(1);
+		}
+		master_list->nc = nc;
+
+		lookup_nss_read_master(master_list, 0);
+		master_show_mounts(master_list);
+		exit(0);
+	}
+
+	become_daemon(foreground, daemon_check);
+
 	if (pthread_attr_init(&th_attr)) {
 		logerr("%s: failed to init thread attribute struct!",
@@ -2111,5 +2131,5 @@
 	}
 
-#ifdef LIBXML2_WORKAROUND
+#if defined(WITH_LDAP) && defined(LIBXML2_WORKAROUND)
 	void *dh_xml2 = dlopen("libxml2.so", RTLD_NOW);
 	if (!dh_xml2)
@@ -2159,5 +2179,5 @@
 		dlclose(dh_tirpc);
 #endif
-#ifdef LIBXML2_WORKAROUND
+#if defined(WITH_LDAP) && defined( LIBXML2_WORKAROUND)
 	if (dh_xml2) {
 		xmlCleanupParser();
diff -r -U2 autofs-5.0.5/daemon/direct.c autofs-5.0.5/daemon/direct.c
--- autofs-5.0.5/daemon/direct.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/direct.c	2010-12-07 10:54:27.529746097 -0700
@@ -36,4 +36,5 @@
 #include <sched.h>
 
+#define INCLUDE_PENDING_FUNCTIONS
 #include "automount.h"
 
@@ -49,6 +50,4 @@
 pthread_once_t key_mnt_params_once = PTHREAD_ONCE_INIT;
 
-static pthread_mutex_t ea_mutex = PTHREAD_MUTEX_INITIALIZER;
-
 static void key_mnt_params_destroy(void *arg)
 {
@@ -953,15 +952,4 @@
 }
 
-static void pending_cond_destroy(void *arg)
-{
-	struct pending_args *mt;
-	int status;
-
-	mt = (struct pending_args *) arg;
-	status = pthread_cond_destroy(&mt->cond);
-	if (status)
-		fatal(status);
-}
-
 static void expire_send_fail(void *arg)
 {
@@ -973,17 +961,4 @@
 }
 
-static void free_pending_args(void *arg)
-{
-	struct pending_args *mt = arg;
-	free(mt);
-}
-
-static void expire_mutex_unlock(void *arg)
-{
-	int status = pthread_mutex_unlock(&ea_mutex);
-	if (status)
-		fatal(status);
-}
-
 static void *do_expire_direct(void *arg)
 {
@@ -996,7 +971,5 @@
 	args = (struct pending_args *) arg;
 
-	status = pthread_mutex_lock(&ea_mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(args);
 
 	memcpy(&mt, args, sizeof(struct pending_args));
@@ -1009,5 +982,5 @@
 		fatal(status);
 
-	expire_mutex_unlock(NULL);
+	pending_mutex_unlock(args);
 
 	pthread_cleanup_push(expire_send_fail, &mt);
@@ -1125,5 +1098,5 @@
 		fatal(status);
 
-	status = pthread_mutex_lock(&ea_mutex);
+	status = pthread_mutex_init(&mt->mutex, NULL);
 	if (status)
 		fatal(status);
@@ -1141,4 +1114,6 @@
 		  (unsigned long) pkt->wait_queue_token, mt->name);
 
+	pending_mutex_lock(mt);
+
 	status = pthread_create(&thid, &th_attr_detached, do_expire_direct, mt);
 	if (status) {
@@ -1148,6 +1123,7 @@
 		cache_unlock(mc);
 		master_source_unlock(ap->entry);
-		expire_mutex_unlock(NULL);
+		pending_mutex_unlock(mt);
 		pending_cond_destroy(mt);
+		pending_mutex_destroy(mt);
 		free_pending_args(mt);
 		pthread_setcancelstate(state, NULL);
@@ -1159,6 +1135,7 @@
 
 	pthread_cleanup_push(free_pending_args, mt);
+	pthread_cleanup_push(pending_mutex_destroy, mt);
 	pthread_cleanup_push(pending_cond_destroy, mt);
-	pthread_cleanup_push(expire_mutex_unlock, NULL);
+	pthread_cleanup_push(pending_mutex_unlock, mt);
 	pthread_setcancelstate(state, NULL);
 
@@ -1168,5 +1145,5 @@
 		wait.tv_sec = now.tv_sec + 2;
 		wait.tv_nsec = now.tv_usec * 1000;
-		status = pthread_cond_wait(&mt->cond, &ea_mutex);
+		status = pthread_cond_timedwait(&mt->cond, &mt->mutex, &wait);
 		if (status && status != ETIMEDOUT)
 			fatal(status);
@@ -1176,4 +1153,5 @@
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
 
 	return 0;
@@ -1189,20 +1167,4 @@
 }
 
-static void pending_mutex_destroy(void *arg)
-{
-	struct pending_args *mt = (struct pending_args *) arg;
-	int status = pthread_mutex_destroy(&mt->mutex);
-	if (status)
-		fatal(status);
-}
-
-static void mount_mutex_unlock(void *arg)
-{
-	struct pending_args *mt = (struct pending_args *) arg;
-	int status = pthread_mutex_unlock(&mt->mutex);
-	if (status)
-		fatal(status);
-}
-
 static void *do_mount_direct(void *arg)
 {
@@ -1215,7 +1177,5 @@
 	args = (struct pending_args *) arg;
 
-	status = pthread_mutex_lock(&args->mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(args);
 
 	memcpy(&mt, args, sizeof(struct pending_args));
@@ -1228,5 +1188,5 @@
 		fatal(status);
 
-	mount_mutex_unlock(args);
+	pending_mutex_unlock(args);
 
 	pthread_cleanup_push(mount_send_fail, &mt);
@@ -1246,5 +1206,5 @@
 
 	status = stat(mt.name, &st);
-	if (!S_ISDIR(st.st_mode) || st.st_dev != mt.dev) {
+	if (status != 0 || !S_ISDIR(st.st_mode) || st.st_dev != mt.dev) {
 		error(ap->logopt,
 		     "direct trigger not valid or already mounted %s",
@@ -1435,7 +1395,5 @@
 		fatal(status);
 
-	status = pthread_mutex_lock(&mt->mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(mt);
 
 	mt->ap = ap;
@@ -1459,5 +1417,5 @@
 		master_source_unlock(ap->entry);
 		master_mutex_unlock();
-		mount_mutex_unlock(mt);
+		pending_mutex_unlock(mt);
 		pending_cond_destroy(mt);
 		pending_mutex_destroy(mt);
@@ -1475,5 +1433,5 @@
 	pthread_cleanup_push(pending_mutex_destroy, mt);
 	pthread_cleanup_push(pending_cond_destroy, mt);
-	pthread_cleanup_push(mount_mutex_unlock, mt);
+	pthread_cleanup_push(pending_mutex_unlock, mt);
 	pthread_setcancelstate(state, NULL);
 
diff -r -U2 autofs-5.0.5/daemon/indirect.c autofs-5.0.5/daemon/indirect.c
--- autofs-5.0.5/daemon/indirect.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/indirect.c	2010-12-07 10:54:27.529746097 -0700
@@ -35,4 +35,5 @@
 #include <sched.h>
 
+#define INCLUDE_PENDING_FUNCTIONS
 #include "automount.h"
 
@@ -40,6 +41,4 @@
 extern pthread_attr_t th_attr_detached;
 
-static pthread_mutex_t ea_mutex = PTHREAD_MUTEX_INITIALIZER;
-
 static int unlink_mount_tree(struct autofs_point *ap, struct mnt_list *mnts)
 {
@@ -588,15 +587,4 @@
 }
 
-static void pending_cond_destroy(void *arg)
-{
-	struct pending_args *mt;
-	int status;
-
-	mt = (struct pending_args *) arg;
-	status = pthread_cond_destroy(&mt->cond);
-	if (status)
-		fatal(status);
-}
-
 static void expire_send_fail(void *arg)
 {
@@ -608,17 +596,4 @@
 }
 
-static void free_pending_args(void *arg)
-{
-	struct pending_args *mt = arg;
-	free(mt);
-}
-
-static void expire_mutex_unlock(void *arg)
-{
-	int status = pthread_mutex_unlock(&ea_mutex);
-	if (status)
-		fatal(status);
-}
-
 static void *do_expire_indirect(void *arg)
 {
@@ -630,7 +605,5 @@
 	args = (struct pending_args *) arg;
 
-	status = pthread_mutex_lock(&ea_mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(args);
 
 	memcpy(&mt, args, sizeof(struct pending_args));
@@ -643,5 +616,5 @@
 		fatal(status);
 
-	expire_mutex_unlock(NULL);
+	pending_mutex_unlock(args);
 
 	pthread_cleanup_push(expire_send_fail, &mt);
@@ -691,5 +664,5 @@
 		fatal(status);
 
-	status = pthread_mutex_lock(&ea_mutex);
+	status = pthread_mutex_init(&mt->mutex, NULL);
 	if (status)
 		fatal(status);
@@ -701,4 +674,6 @@
 	mt->wait_queue_token = pkt->wait_queue_token;
 
+	pending_mutex_lock(mt);
+
 	status = pthread_create(&thid, &th_attr_detached, do_expire_indirect, mt);
 	if (status) {
@@ -706,6 +681,7 @@
 		ops->send_fail(ap->logopt,
 			       ap->ioctlfd, pkt->wait_queue_token, -status);
-		expire_mutex_unlock(NULL);
+		pending_mutex_unlock(mt);
 		pending_cond_destroy(mt);
+		pending_mutex_destroy(mt);
 		free_pending_args(mt);
 		pthread_setcancelstate(state, NULL);
@@ -714,6 +690,7 @@
 
 	pthread_cleanup_push(free_pending_args, mt);
+	pthread_cleanup_push(pending_mutex_destroy, mt);
 	pthread_cleanup_push(pending_cond_destroy, mt);
-	pthread_cleanup_push(expire_mutex_unlock, NULL);
+	pthread_cleanup_push(pending_mutex_unlock, mt);
 	pthread_setcancelstate(state, NULL);
 
@@ -723,5 +700,5 @@
 		wait.tv_sec = now.tv_sec + 2;
 		wait.tv_nsec = now.tv_usec * 1000;
-		status = pthread_cond_timedwait(&mt->cond, &ea_mutex, &wait);
+		status = pthread_cond_timedwait(&mt->cond, &mt->mutex, &wait);
 		if (status && status != ETIMEDOUT)
 			fatal(status);
@@ -731,4 +708,5 @@
 	pthread_cleanup_pop(1);
 	pthread_cleanup_pop(1);
+	pthread_cleanup_pop(1);
 
 	return 0;
@@ -744,20 +722,4 @@
 }
 
-static void pending_mutex_destroy(void *arg)
-{
-	struct pending_args *mt = (struct pending_args *) arg;
-	int status = pthread_mutex_destroy(&mt->mutex);
-	if (status)
-		fatal(status);
-}
-
-static void mount_mutex_unlock(void *arg)
-{
-	struct pending_args *mt = (struct pending_args *) arg;
-	int status = pthread_mutex_unlock(&mt->mutex);
-	if (status)
-		fatal(status);
-}
-
 static void *do_mount_indirect(void *arg)
 {
@@ -771,7 +733,5 @@
 	args = (struct pending_args *) arg;
 
-	status = pthread_mutex_lock(&args->mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(args);
 
 	memcpy(&mt, args, sizeof(struct pending_args));
@@ -784,5 +744,5 @@
 		fatal(status);
 
-	mount_mutex_unlock(args);
+	pending_mutex_unlock(args);
 
 	pthread_cleanup_push(mount_send_fail, &mt);
@@ -793,4 +753,7 @@
 	if (!len) {
 		crit(ap->logopt, "path to be mounted is to long");
+		ops->send_fail(ap->logopt,
+			       ap->ioctlfd, mt.wait_queue_token,
+			      -ENAMETOOLONG);
 		pthread_setcancelstate(state, NULL);
 		pthread_exit(NULL);
@@ -801,4 +764,5 @@
 		error(ap->logopt,
 		      "indirect trigger not valid or already mounted %s", buf);
+		ops->send_ready(ap->logopt, ap->ioctlfd, mt.wait_queue_token);
 		pthread_setcancelstate(state, NULL);
 		pthread_exit(NULL);
@@ -876,7 +840,5 @@
 		fatal(status);
 
-	status = pthread_mutex_lock(&mt->mutex);
-	if (status)
-		fatal(status);
+	pending_mutex_lock(mt);
 
 	mt->ap = ap;
@@ -895,5 +857,5 @@
 			       ap->ioctlfd, pkt->wait_queue_token, -status);
 		master_mutex_unlock();
-		mount_mutex_unlock(mt);
+		pending_mutex_unlock(mt);
 		pending_cond_destroy(mt);
 		pending_mutex_destroy(mt);
@@ -908,5 +870,5 @@
 	pthread_cleanup_push(pending_mutex_destroy, mt);
 	pthread_cleanup_push(pending_cond_destroy, mt);
-	pthread_cleanup_push(mount_mutex_unlock, mt);
+	pthread_cleanup_push(pending_mutex_unlock, mt);
 	pthread_setcancelstate(state, NULL);
 
diff -r -U2 autofs-5.0.5/daemon/lookup.c autofs-5.0.5/daemon/lookup.c
--- autofs-5.0.5/daemon/lookup.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/lookup.c	2010-12-07 10:54:27.563073760 -0700
@@ -158,4 +158,7 @@
 		}
 
+		if (result == NSS_STATUS_UNAVAIL)
+			master->read_fail = 1;
+
 		return !result;
 	} else {
@@ -195,4 +198,7 @@
 				master->name = name;
 
+				if (result == NSS_STATUS_UNAVAIL)
+					master->read_fail = 1;
+
 				return !result;
 			}
@@ -249,4 +255,7 @@
 		}
 
+		if (result == NSS_STATUS_UNAVAIL)
+			master->read_fail = 1;
+
 		status = check_nss_result(this, result);
 		if (status >= 0) {
@@ -287,5 +296,6 @@
 	status = lookup->lookup_read_map(ap, age, lookup->context);
 
-	map->stale = 0;
+	if (status != NSS_STATUS_SUCCESS)
+		map->stale = 0;
 
 	/*
@@ -293,6 +303,11 @@
 	 * and do whatever we must to have autofs function with an
 	 * empty map entry cache.
+	 *
+	 * For indirect maps that use the browse option, when the
+	 * server is unavailable continue as best we can with
+	 * whatever we have in the cache, if anything.
 	 */
-	if (status == NSS_STATUS_UNKNOWN)
+	if (status == NSS_STATUS_UNKNOWN ||
+	   (ap->type == LKP_INDIRECT && status == NSS_STATUS_UNAVAIL))
 		return NSS_STATUS_SUCCESS;
 
@@ -399,4 +414,5 @@
 	tmap.recurse = map->recurse;
 	tmap.depth = map->depth;
+	tmap.stale = map->stale;
 	tmap.argc = 0;
 	tmap.argv = NULL;
@@ -586,5 +602,5 @@
 		me = cache_enumerate(mc, NULL);
 		while (me) {
-			if (*me->key == '*')
+			if (!strcmp(me->key, "*"))
 				goto next;
 
@@ -674,5 +690,5 @@
 
 	if (stat(map->argv[0], &st) == -1) {
-		warn(ap->logopt, "file map not found");
+		debug(ap->logopt, "file map not found");
 		return NSS_STATUS_NOTFOUND;
 	}
@@ -799,4 +815,8 @@
 	struct mapent *me;
 
+	/* Don't update negative cache for included maps */ 
+	if (source && source->depth)
+		return;
+
 	/* Have we recorded the lookup fail for negative caching? */
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
@@ -809,5 +829,5 @@
 	else {
 		/* Notify only once after fail */
-		error(ap->logopt, "key \"%s\" not found in map.", name);
+		logmsg("key \"%s\" not found in map source(s).", name);
 
 		/* Doesn't exist in any source, just add it somewhere */
@@ -1021,5 +1041,5 @@
 		key = strdup(me->key);
 		me = cache_enumerate(mc, me);
-		if (!key || *key == '*') {
+		if (!key || !strcmp(key, "*")) {
 			if (key)
 				free(key);
diff -r -U2 autofs-5.0.5/daemon/spawn.c autofs-5.0.5/daemon/spawn.c
--- autofs-5.0.5/daemon/spawn.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/spawn.c	2010-12-07 10:54:27.369773316 -0700
@@ -155,4 +155,7 @@
 	f = fork();
 	if (f == 0) {
+		char **pargv = (char **) argv;
+		int loc = 0;
+
 		reset_signals();
 		close(pipefd[0]);
@@ -161,15 +164,20 @@
 		close(pipefd[1]);
 
-		/* Bind mount - check target exists */
-		if (use_access) {
-			char **pargv = (char **) argv;
-			int argc = 0;
+		/* what to mount must always be second last */
+		while (*pargv++)
+			loc++;
+		loc -= 2;
+
+		/*
+		 * If the mount location starts with a "/" then it is
+		 * a local path. In this case it is a bind mount, a
+		 * loopback mount or a file system that uses a local
+		 * path so we need to check for dependent mounts.
+		 *
+		 * I hope host names are never allowed "/" as first char
+		 */
+		if (use_access && *(argv[loc]) == '/') {
 			pid_t pgrp = getpgrp();
 
-			/* what to mount must always be second last */
-			while (*pargv++)
-				argc++;
-			argc -= 2;
-
 			/*
 			 * Pretend to be requesting user and set non-autofs
@@ -182,7 +190,13 @@
 			setpgrp();
 
-			/* Trigger the recursive mount */
-			if (access(argv[argc], F_OK) == -1)
-				_exit(errno);
+			/*
+			 * Trigger the recursive mount.
+			 *
+			 * Ignore the access(2) return code as there may be
+			 * multiple waiters for this mount and we need to
+			 * let the  VFS handle access returns to each
+			 * individual waiter.
+			 */
+			access(argv[loc], F_OK);
 
 			seteuid(0);
@@ -306,4 +320,5 @@
 	unsigned int retries = MTAB_LOCK_RETRIES;
 	int update_mtab = 1, ret, printed = 0;
+	unsigned int wait = defaults_get_mount_wait();
 	char buf[PATH_MAX];
 
@@ -312,5 +327,5 @@
 	options = SPAWN_OPT_LOCK;
 #else
-	options = SPAWN_OPT_NONE;
+	options = SPAWN_OPT_ACCESS;
 #endif
 
@@ -344,10 +359,15 @@
 	}
 	while ((*p = va_arg(arg, char *))) {
-		if (options == SPAWN_OPT_NONE && !strcmp(*p, "-o")) {
+		if (options == SPAWN_OPT_ACCESS && !strcmp(*p, "-t")) {
 			*(++p) = va_arg(arg, char *);
 			if (!*p)
 				break;
-			if (strstr(*p, "loop"))
-				options = SPAWN_OPT_ACCESS;
+			/*
+			 * A cifs mount location begins with a "/" but
+			 * is not a local path, so don't try to resolve
+			 * it. Mmmm ... does anyone use smbfs these days?
+			 */
+			if (strstr(*p, "cifs"))
+				options = SPAWN_OPT_NONE;
 		}
 		p++;
@@ -356,5 +376,5 @@
 
 	while (retries--) {
-		ret = do_spawn(logopt, -1, options, prog, (const char **) argv);
+		ret = do_spawn(logopt, wait, options, prog, (const char **) argv);
 		if (ret & MTAB_NOTUPDATED) {
 			struct timespec tm = {3, 0};
diff -r -U2 autofs-5.0.5/daemon/state.c autofs-5.0.5/daemon/state.c
--- autofs-5.0.5/daemon/state.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/daemon/state.c	2010-12-07 10:54:27.513082266 -0700
@@ -161,5 +161,5 @@
 			 */
 			rv = ops->askumount(ap->logopt, ap->ioctlfd, &idle);
-			if (!idle && !ap->shutdown) {
+			if (!rv && !idle && !ap->shutdown) {
 				next = ST_READY;
 				if (!ap->submount)
@@ -198,9 +198,9 @@
 	}
 
+	st_set_done(ap);
+
 	if (next != ST_INVAL)
 		__st_add_task(ap, next);
 
-	st_set_done(ap);
-
 	st_mutex_unlock();
 
@@ -333,9 +333,8 @@
 
 	ap->readmap_thread = 0;
-	st_ready(ap);
 	st_set_done(ap);
-
 	if (!ap->submount)
 		alarm_add(ap, ap->exp_runfreq);
+	st_ready(ap);
 
 	st_mutex_unlock();
@@ -1061,6 +1060,4 @@
 	struct list_head *head;
 	struct list_head *p;
-	struct timespec wait;
-	struct timeval now;
 	int status, ret;
 
@@ -1073,15 +1070,9 @@
 		 */
 		head = &state_queue;
-		gettimeofday(&now, NULL);
-		wait.tv_sec = now.tv_sec + 1;
-		wait.tv_nsec = now.tv_usec * 1000;
 
 		while (list_empty(head)) {
-			status = pthread_cond_timedwait(&cond, &mutex, &wait);
-			if (status) {
-				if (status == ETIMEDOUT)
-					break;
+			status = pthread_cond_wait(&cond, &mutex);
+			if (status)
 				fatal(status);
-			}
 		}
 
@@ -1109,16 +1100,9 @@
 
 		while (1) {
-			gettimeofday(&now, NULL);
-			wait.tv_sec = now.tv_sec + 1;
-			wait.tv_nsec = now.tv_usec * 1000;
-
 			signaled = 0;
 			while (!signaled) {
-				status = pthread_cond_timedwait(&cond, &mutex, &wait);
-				if (status) {
-					if (status == ETIMEDOUT)
-						break;
+				status = pthread_cond_wait(&cond, &mutex);
+				if (status)
 					fatal(status);
-				}
 			}
 
@@ -1199,5 +1183,6 @@
 	status = pthread_create(&thid, pattrs, st_queue_handler, NULL);
 
-	pthread_attr_destroy(pattrs);
+	if (pattrs)
+		pthread_attr_destroy(pattrs);
 
 	return !status;
diff -r -U2 autofs-5.0.5/include/automount.h autofs-5.0.5/include/automount.h
--- autofs-5.0.5/include/automount.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/automount.h	2010-12-07 10:54:27.529746097 -0700
@@ -195,4 +195,5 @@
 int cache_delete_offset_list(struct mapent_cache *mc, const char *key);
 void cache_release(struct map_source *map);
+void cache_clean_null_cache(struct mapent_cache *mc);
 void cache_release_null_cache(struct master *master);
 struct mapent *cache_enumerate(struct mapent_cache *mc, struct mapent *me);
@@ -375,4 +376,45 @@
 };
 
+#ifdef INCLUDE_PENDING_FUNCTIONS
+static void pending_cond_destroy(void *arg)
+{
+	struct pending_args *mt = (struct pending_args *) arg;
+	int status;
+	status = pthread_cond_destroy(&mt->cond);
+	if (status)
+		fatal(status);
+}
+
+static void pending_mutex_destroy(void *arg)
+{
+	struct pending_args *mt = (struct pending_args *) arg;
+	int status = pthread_mutex_destroy(&mt->mutex);
+	if (status)
+		fatal(status);
+}
+
+static void free_pending_args(void *arg)
+{
+	struct pending_args *mt = (struct pending_args *) arg;
+	free(mt);
+}
+
+static void pending_mutex_lock(void *arg)
+{
+        struct pending_args *mt = (struct pending_args *) arg;
+        int status = pthread_mutex_lock(&mt->mutex);
+        if (status)
+                fatal(status);
+}
+
+static void pending_mutex_unlock(void *arg)
+{
+        struct pending_args *mt = (struct pending_args *) arg;
+        int status = pthread_mutex_unlock(&mt->mutex);
+        if (status)
+                fatal(status);
+}
+#endif
+
 struct thread_stdenv_vars {
 	uid_t uid;
diff -r -U2 autofs-5.0.5/include/config.h.in autofs-5.0.5/include/config.h.in
--- autofs-5.0.5/include/config.h.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/config.h.in	2010-12-07 10:54:27.346443953 -0700
@@ -19,4 +19,7 @@
 #undef HAVE_E3FSCK
 
+/* define if you have E4FSCK */
+#undef HAVE_E4FSCK
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
@@ -94,4 +97,7 @@
 #undef PATH_E3FSCK
 
+/* define if you have E4FSCK */
+#undef PATH_E4FSCK
+
 /* define if you have LEX */
 #undef PATH_LEX
diff -r -U2 autofs-5.0.5/include/defaults.h autofs-5.0.5/include/defaults.h
--- autofs-5.0.5/include/defaults.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/defaults.h	2010-12-07 10:54:27.313116289 -0700
@@ -25,4 +25,5 @@
 #define DEFAULT_TIMEOUT			600
 #define DEFAULT_NEGATIVE_TIMEOUT	60
+#define DEFAULT_MOUNT_WAIT		-1
 #define DEFAULT_UMOUNT_WAIT		12
 #define DEFAULT_BROWSE_MODE		1
@@ -65,4 +66,5 @@
 unsigned int defaults_get_mount_nfs_default_proto(void);
 unsigned int defaults_get_append_options(void);
+unsigned int defaults_get_mount_wait(void);
 unsigned int defaults_get_umount_wait(void);
 const char *defaults_get_auth_conf_file(void);
diff -r -U2 autofs-5.0.5/include/log.h autofs-5.0.5/include/log.h
--- autofs-5.0.5/include/log.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/log.h	2010-12-07 10:54:27.579737591 -0700
@@ -36,4 +36,5 @@
 extern void set_mnt_logging(unsigned global_logopt);
 
+extern void open_log(void);
 extern void log_to_syslog(void);
 extern void log_to_stderr(void);
diff -r -U2 autofs-5.0.5/include/lookup_ldap.h autofs-5.0.5/include/lookup_ldap.h
--- autofs-5.0.5/include/lookup_ldap.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/lookup_ldap.h	2010-12-07 10:54:27.573072059 -0700
@@ -2,4 +2,6 @@
 #define LOOKUP_LDAP_H
 
+#include <ldap.h>
+
 #ifdef WITH_SASL
 #include <openssl/ssl.h>
@@ -11,4 +13,5 @@
 #endif
 
+#include "list.h"
 #include "dclist.h"
 
@@ -77,7 +80,11 @@
 	int          kinit_successful;
 #ifdef WITH_SASL
+	/* Kerberos */
 	krb5_context krb5ctxt;
 	krb5_ccache  krb5_ccache;
 	sasl_conn_t  *sasl_conn;
+	/* SASL external */
+	char	     *extern_cert;
+	char	     *extern_key;
 #endif
 	/* keytab file name needs to be added */
@@ -98,4 +105,7 @@
 #define LDAP_AUTH_REQUIRED	0x0002
 #define LDAP_AUTH_AUTODETECT	0x0004
+#endif
+
+#define LDAP_AUTH_USESIMPLE	0x0008
 
 /* lookup_ldap.c */
@@ -104,4 +114,5 @@
 int authtype_requires_creds(const char *authtype);
 
+#ifdef WITH_SASL
 /* cyrus-sasl.c */
 int autofs_sasl_client_init(unsigned logopt);
@@ -111,4 +122,6 @@
 void autofs_sasl_dispose(struct lookup_context *ctxt);
 void autofs_sasl_done(void);
+/* cyrus-sasl-extern */
+int do_sasl_extern(LDAP *ldap, struct lookup_context *ctxt);
 #endif
 
diff -r -U2 autofs-5.0.5/include/master.h autofs-5.0.5/include/master.h
--- autofs-5.0.5/include/master.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/master.h	2010-12-07 10:54:27.579737591 -0700
@@ -57,4 +57,5 @@
 	unsigned int depth;
 	unsigned int reading;
+	unsigned int read_fail;
 	unsigned int default_ghost;
 	unsigned int default_logging;
@@ -110,4 +111,5 @@
 void master_notify_state_change(struct master *, int);
 int master_mount_mounts(struct master *, time_t, int);
+int master_show_mounts(struct master *);
 extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
diff -r -U2 autofs-5.0.5/include/replicated.h autofs-5.0.5/include/replicated.h
--- autofs-5.0.5/include/replicated.h	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/include/replicated.h	2010-12-07 10:54:27.453092472 -0700
@@ -65,5 +65,5 @@
 void seed_random(void);
 void free_host_list(struct host **);
-int parse_location(unsigned, struct host **, const char *);
+int parse_location(unsigned, struct host **, const char *, unsigned int);
 int prune_host_list(unsigned, struct host **, unsigned int, const char *, unsigned int);
 void dump_host_list(struct host *);
diff -r -U2 autofs-5.0.5/lib/alarm.c autofs-5.0.5/lib/alarm.c
--- autofs-5.0.5/lib/alarm.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/alarm.c	2010-12-07 10:54:27.406433745 -0700
@@ -68,4 +68,7 @@
 	int status;
 
+	if (!seconds)
+		return 1;
+
 	new = malloc(sizeof(struct alarm));
 	if (!new)
@@ -240,5 +243,6 @@
 	status = pthread_create(&thid, pattrs, alarm_handler, NULL);
 
-	pthread_attr_destroy(pattrs);
+	if (pattrs)
+		pthread_attr_destroy(pattrs);
 
 	return !status;
diff -r -U2 autofs-5.0.5/lib/cache.c autofs-5.0.5/lib/cache.c
--- autofs-5.0.5/lib/cache.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/cache.c	2010-12-07 10:54:27.489752902 -0700
@@ -229,4 +229,30 @@
 }
 
+void cache_clean_null_cache(struct mapent_cache *mc)
+{
+	struct mapent *me, *next;
+	int i;
+
+	for (i = 0; i < mc->size; i++) {
+		me = mc->hash[i];
+		if (me == NULL)
+			continue;
+		next = me->next;
+		free(me->key);
+		if (me->mapent)
+			free(me->mapent);
+		free(me);
+
+		while (next != NULL) {
+			me = next;
+			next = me->next;
+			free(me->key);
+			free(me);
+		}
+	}
+
+	return;
+}
+
 struct mapent_cache *cache_init_null_cache(struct master *master)
 {
@@ -235,7 +261,4 @@
 	int status;
 
-	if (master->nc)
-		cache_release_null_cache(master);
-
 	mc = malloc(sizeof(struct mapent_cache));
 	if (!mc)
@@ -265,6 +288,4 @@
 		fatal(status);
 
-	cache_writelock(mc);
-
 	for (i = 0; i < mc->size; i++) {
 		mc->hash[i] = NULL;
@@ -275,6 +296,4 @@
 	mc->map = NULL;
 
-	cache_unlock(mc);
-
 	return mc;
 }
@@ -720,5 +739,5 @@
 	while (me && me->source != ms)
 		me = cache_lookup_key_next(me);
-	if (!me || (*me->key == '*' && *key != '*')) {
+	if (!me || (!strcmp(me->key, "*") && strcmp(key, "*"))) {
 		ret = cache_add(mc, ms, key, mapent, age);
 		if (!ret) {
diff -r -U2 autofs-5.0.5/lib/defaults.c autofs-5.0.5/lib/defaults.c
--- autofs-5.0.5/lib/defaults.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/defaults.c	2010-12-07 10:54:27.409766511 -0700
@@ -48,4 +48,5 @@
 #define ENV_MOUNT_NFS_DEFAULT_PROTOCOL	"MOUNT_NFS_DEFAULT_PROTOCOL"
 #define ENV_APPEND_OPTIONS		"APPEND_OPTIONS"
+#define ENV_MOUNT_WAIT			"MOUNT_WAIT"
 #define ENV_UMOUNT_WAIT			"UMOUNT_WAIT"
 #define ENV_AUTH_CONF_FILE		"AUTH_CONF_FILE"
@@ -65,5 +66,5 @@
 
 	res = strdup(val);
-	if (!val)
+	if (!res)
 		return NULL;
 
@@ -326,4 +327,5 @@
 		    check_set_config_value(key, ENV_NAME_VALUE_ATTR, value, to_syslog) ||
 		    check_set_config_value(key, ENV_APPEND_OPTIONS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_MOUNT_WAIT, value, to_syslog) ||
 		    check_set_config_value(key, ENV_UMOUNT_WAIT, value, to_syslog) ||
 		    check_set_config_value(key, ENV_AUTH_CONF_FILE, value, to_syslog) ||
@@ -533,5 +535,4 @@
 	struct ldap_searchdn *next;
 
-	next = this;
 	while (this) {
 		next = this->next;
@@ -668,4 +669,15 @@
 }
 
+unsigned int defaults_get_mount_wait(void)
+{
+	long wait;
+
+	wait = get_env_number(ENV_MOUNT_WAIT);
+	if (wait < 0)
+		wait = DEFAULT_MOUNT_WAIT;
+
+	return (unsigned int) wait;
+}
+
 unsigned int defaults_get_umount_wait(void)
 {
diff -r -U2 autofs-5.0.5/lib/log.c autofs-5.0.5/lib/log.c
--- autofs-5.0.5/lib/log.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/log.c	2010-12-07 10:54:27.579737591 -0700
@@ -194,9 +194,6 @@
 }
 
-void log_to_syslog(void)
+void open_log(void)
 {
-	char buf[MAX_ERR_BUF];
-	int nullfd;
-
 	if (!syslog_open) {
 		syslog_open = 1;
@@ -205,4 +202,13 @@
 
 	logging_to_syslog = 1;
+	return;
+}
+
+void log_to_syslog(void)
+{
+	char buf[MAX_ERR_BUF];
+	int nullfd;
+
+	open_log();
 
 	/* Redirect all our file descriptors to /dev/null */
diff -r -U2 autofs-5.0.5/lib/master.c autofs-5.0.5/lib/master.c
--- autofs-5.0.5/lib/master.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/master.c	2010-12-07 10:54:27.586403123 -0700
@@ -31,4 +31,5 @@
 struct master *master_list = NULL;
 
+extern const char *global_options;
 extern long global_negative_timeout;
 
@@ -153,5 +154,5 @@
 	struct map_source *source;
 	char *ntype, *nformat;
-	const char **tmpargv, *name = NULL;
+	const char **tmpargv;
 
 	source = malloc(sizeof(struct map_source));
@@ -189,13 +190,15 @@
 	source->argv = tmpargv;
 
-	/* Can be NULL for "hosts" map */
-	if (argv)
-		name = argv[0];
-
 	master_source_writelock(entry);
 
-	if (!entry->maps)
+	if (!entry->maps) {
+		source->mc = cache_init(entry->ap, source);
+		if (!source->mc) {
+			master_free_map_source(source, 0);
+			master_source_unlock(entry);
+			return NULL;
+		}
 		entry->maps = source;
-	else {
+	} else {
 		struct map_source *this, *last, *next;
 
@@ -210,4 +213,11 @@
 		}
 
+		source->mc = cache_init(entry->ap, source);
+		if (!source->mc) {
+			master_free_map_source(source, 0);
+			master_source_unlock(entry);
+			return NULL;
+		}
+
 		last = NULL;
 		next = entry->maps;
@@ -481,7 +491,4 @@
 	int status, need_update = 0;
 
-	if (!(ap->flags & MOUNT_FLAG_GHOST))
-		return;
-
 	status = pthread_mutex_lock(&instance_mutex);
 	if (status)
@@ -786,4 +793,5 @@
 	master->depth = 0;
 	master->reading = 0;
+	master->read_fail = 0;
 	master->default_ghost = ghost;
 	master->default_timeout = timeout;
@@ -802,16 +810,34 @@
 	struct mapent_cache *nc;
 
-	nc = cache_init_null_cache(master);
-	if (!nc) {
-		error(logopt,
-		      "failed to init null map cache for %s", master->name);
-		return 0;
+	/*
+	 * We need to clear and re-populate the null map entry cache
+	 * before alowing anyone else to use it.
+	 */
+	if (master->nc) {
+		cache_writelock(master->nc);
+		nc = master->nc;
+		cache_clean_null_cache(nc);
+	} else {
+		nc = cache_init_null_cache(master);
+		if (!nc) {
+			error(logopt,
+			      "failed to init null map cache for %s",
+			      master->name);
+			return 0;
+		}
+		cache_writelock(nc);
+		master->nc = nc;
 	}
-	master->nc = nc;
-
 	master_init_scan();
-
 	lookup_nss_read_master(master, age);
-	master_mount_mounts(master, age, readall);
+	cache_unlock(nc);
+
+	if (!master->read_fail)
+		master_mount_mounts(master, age, readall);
+	else {
+		master->read_fail = 0;
+		if (!readall)
+			master_mount_mounts(master, age, readall);
+	}
 
 	master_mutex_lock();
@@ -880,6 +906,7 @@
 
 		/*
-		 * If our submount gets to state ST_SHUTDOWN we need to
-		 * wait until it goes away or changes to ST_READY.
+		 * If our submount gets to state ST_SHUTDOWN, ST_SHUTDOWN_PENDING or
+		 * ST_SHUTDOWN_FORCE we need to wait until it goes away or changes
+		 * to ST_READY.
 		 */
 		mounts_mutex_lock(ap);
@@ -889,5 +916,7 @@
 			struct timespec r;
 
-			if (this->state != ST_SHUTDOWN) {
+			if (this->state != ST_SHUTDOWN &&
+			    this->state != ST_SHUTDOWN_PENDING &&
+			    this->state != ST_SHUTDOWN_FORCE) {
 				ret = 0;
 				break;
@@ -1163,4 +1192,129 @@
 
 	return 1;
+}
+
+/* The nss source instances end up in reverse order. */
+static void list_source_instances(struct map_source *source, struct map_source *instance)
+{
+	if (!source || !instance) {
+		printf("none");
+		return;
+	}
+
+	if (instance->next)
+		list_source_instances(source, instance->next);
+
+	/*
+	 * For convienience we map nss instance type "files" to "file".
+	 * Check for that and report corrected instance type.
+	 */
+	if (strcmp(instance->type, "file"))
+		printf("%s ", instance->type);
+	else {
+		if (source->argv && *(source->argv[0]) != '/')
+			printf("files ");
+		else
+			printf("%s ", instance->type);
+	}
+
+	return;
+}
+
+int master_show_mounts(struct master *master)
+{
+	struct list_head *p, *head;
+
+	printf("\nautofs dump map information\n"
+		 "===========================\n\n");
+
+	printf("global options: ");
+	if (!global_options)
+		printf("none configured\n");
+	else {
+		printf("%s\n", global_options);
+		unsigned int append_options = defaults_get_append_options();
+		const char *append = append_options ? "will" : "will not";
+		printf("global options %s be appended to map entries\n", append);
+	}
+
+	if (list_empty(&master->mounts)) {
+		printf("no master map entries found\n\n");
+		return 1;
+	}
+
+	head = &master->mounts;
+	p = head->next;
+	while (p != head) {
+		struct map_source *source;
+		struct master_mapent *this;
+		struct autofs_point *ap;
+		time_t now = time(NULL);
+		int i;
+
+		this = list_entry(p, struct master_mapent, list);
+		p = p->next;
+
+		ap = this->ap;
+
+		printf("\nMount point: %s\n", ap->path);
+		printf("\nsource(s):\n");
+
+		/* Read the map content into the cache */
+		if (lookup_nss_read_map(ap, NULL, now))
+			lookup_prune_cache(ap, now);
+		else {
+			printf("  failed to read map\n\n");
+			continue;
+		}
+
+		if (!this->maps) {
+			printf("  no map sources found\n\n");
+			continue;
+		}
+
+		source = this->maps;
+		while (source) {
+			struct mapent *me;
+
+			if (source->type)
+				printf("\n  type: %s\n", source->type);
+			else {
+				printf("\n  instance type(s): ");
+				list_source_instances(source, source->instance);
+				printf("\n");
+			}
+
+			if (source->argc >= 1) {
+				i = 0;
+				if (source->argv[0] && *source->argv[0] != '-') {
+					printf("  map: %s\n", source->argv[0]);
+					i = 1;
+				}
+				if (source->argc > 1) {
+					printf("  arguments: ");
+					for (; i < source->argc; i++)
+						printf("%s ", source->argv[i]);
+					printf("\n");
+				}
+			}
+
+			printf("\n");
+
+			me = cache_lookup_first(source->mc);
+			if (!me)
+				printf("  no keys found in map\n");
+			else {
+				do {
+					printf("  %s | %s\n", me->key, me->mapent);
+				} while ((me = cache_lookup_next(source->mc, me)));
+			}
+
+			source = source->next;
+		}
+
+		printf("\n");
+	}
+
+	return 1;
 }
 
diff -r -U2 autofs-5.0.5/lib/master_parse.y autofs-5.0.5/lib/master_parse.y
--- autofs-5.0.5/lib/master_parse.y	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/master_parse.y	2010-12-07 10:54:27.496418435 -0700
@@ -742,7 +742,5 @@
 	/* Add null map entries to the null map cache */
 	if (type && !strcmp(type, "null")) {
-		cache_writelock(nc);
 		cache_update(nc, NULL, path, NULL, lineno);
-		cache_unlock(nc);
 		local_free_vars();
 		return 1;
@@ -750,11 +748,8 @@
 
 	/* Ignore all subsequent matching nulled entries */
-	cache_readlock(nc);
 	if (cache_lookup_distinct(nc, path)) {
-		cache_unlock(nc);
 		local_free_vars();
 		return 1;
 	}
-	cache_unlock(nc);
 
 	if (debug || verbose) {
@@ -812,5 +807,6 @@
 		}
 	}
-	entry->ap->flags |= MOUNT_FLAG_RANDOM_SELECT;
+	if (random_selection)
+		entry->ap->flags |= MOUNT_FLAG_RANDOM_SELECT;
 	if (negative_timeout)
 		entry->ap->negative_timeout = negative_timeout;
@@ -835,14 +831,4 @@
 	}
 
-	if (!source->mc) {
-		source->mc = cache_init(entry->ap, source);
-		if (!source->mc) {
-			error(m_logopt, "failed to init source cache");
-			if (new)
-				master_free_mapent(new);
-			local_free_vars();
-			return 0;
-		}
-	}
 	source->master_line = lineno;
 
diff -r -U2 autofs-5.0.5/lib/master_tok.l autofs-5.0.5/lib/master_tok.l
--- autofs-5.0.5/lib/master_tok.l	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/master_tok.l	2010-12-07 10:54:27.433095876 -0700
@@ -111,5 +111,6 @@
 AT_O		([oO])
 AT_C		([cC])
-DNATTRSTR	({AT_CN}|{AT_NMN}|{AT_AMN}|{AT_OU}|{AT_DC}|{AT_O}|{AT_C})
+AT_L		([lL])
+DNATTRSTR	({AT_CN}|{AT_NMN}|{AT_AMN}|{AT_OU}|{AT_DC}|{AT_O}|{AT_C}|{AT_L})
 DNNAMESTR1	([[:alnum:]_.\- ]+)
 DNNAMESTR2	([[:alnum:]_.\-]+)
@@ -210,5 +211,5 @@
 
 	{MTYPE} |
-	{MTYPE}/{DNSERVERSTR}{DNATTRSTR} |
+	{MTYPE}/{DNSERVERSTR}{DNATTRSTR}= |
 	{MTYPE}/{DNATTRSTR}= {
 		tlen = master_leng - 1;
@@ -250,5 +251,5 @@
 	}
 
-	{DNSERVERSTR}{DNATTRSTR} {
+	{DNSERVERSTR}{DNATTRSTR}= {
 		BEGIN(DNSTR);
 		yyless(0);
@@ -415,5 +416,5 @@
 void master_set_scan_buffer(const char *buffer)
 {
-	master_lex_destroy();
+	memset(buff, 0, sizeof(buff));
 	optr = buff;
 
diff -r -U2 autofs-5.0.5/lib/rpc_subs.c autofs-5.0.5/lib/rpc_subs.c
--- autofs-5.0.5/lib/rpc_subs.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/lib/rpc_subs.c	2010-12-07 10:54:27.373106083 -0700
@@ -54,4 +54,5 @@
 #define getbits(x, p, n)      ((x >> (p + 1 - n)) & ~(~0 << n))
 
+static int connect_nb(int, struct sockaddr *, socklen_t, struct timeval *);
 inline void dump_core(void);
 
@@ -98,4 +99,5 @@
 	struct sockaddr_in6 *in6_raddr;
 	CLIENT *client = NULL;
+	socklen_t slen;
 
 	switch (addr->sa_family) {
@@ -103,4 +105,9 @@
 		in4_raddr = (struct sockaddr_in *) addr;
 		in4_raddr->sin_port = htons(info->port);
+		slen = sizeof(struct sockaddr_in);
+
+		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
+			break;
+
 		client = clnttcp_create(in4_raddr,
 					info->program, info->version, fd,
@@ -115,4 +122,9 @@
 		in6_raddr = (struct sockaddr_in6 *) addr;
 		in6_raddr->sin6_port = htons(info->port);
+		slen = sizeof(struct sockaddr_in6);
+
+		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
+			break;
+
 		client = clnttcp6_create(in6_raddr,
 					 info->program, info->version, fd,
@@ -162,4 +174,11 @@
 		goto done;
 
+	if (timeout != -1) {
+		if (timeout >= (INT_MAX - 1)/1000)
+			timeout = INT_MAX - 1;
+		else
+			timeout = timeout * 1000;
+	}
+
 	pfd[0].fd = fd;
 	pfd[0].events = POLLOUT;
@@ -254,30 +273,19 @@
 	}
 
+	if (!info->client) {
+		*fd = open_sock(addr->sa_family, type, proto);
+		if (*fd < 0)
+			return NULL;
+
+		if (bind(*fd, laddr, slen) < 0)
+			return NULL;
+	}
+
 	switch (info->proto->p_proto) {
 	case IPPROTO_UDP:
-		if (!info->client) {
-			*fd = open_sock(addr->sa_family, type, proto);
-			if (*fd < 0)
-				return NULL;
-
-			if (bind(*fd, laddr, slen) < 0) {
-				close(*fd);
-				return NULL;
-			}
-		}
 		client = rpc_clntudp_create(addr, info, fd);
 		break;
 
 	case IPPROTO_TCP:
-		if (!info->client) {
-			*fd = open_sock(addr->sa_family, type, proto);
-			if (*fd < 0)
-				return NULL;
-
-			if (connect_nb(*fd, laddr, slen, &info->timeout) < 0) {
-				close(*fd);
-				return NULL;
-			}
-		}
 		client = rpc_clnttcp_create(addr, info, fd);
 		break;
@@ -321,5 +329,5 @@
 			goto done;
 
-		if (!info->client) {
+		if (!info->client && fd != RPC_ANYSOCK) {
 			close(fd);
 			fd = RPC_ANYSOCK;
@@ -346,5 +354,5 @@
 			break;
 
-		if (!info->client) {
+		if (!info->client && fd != RPC_ANYSOCK) {
 			close(fd);
 			fd = RPC_ANYSOCK;
@@ -471,5 +479,5 @@
 			break;
 
-		if (!info->client) {
+		if (!info->client && fd != RPC_ANYSOCK) {
 			close(fd);
 			fd = RPC_ANYSOCK;
diff -r -U2 autofs-5.0.5/man/auto.master.5.in autofs-5.0.5/man/auto.master.5.in
--- autofs-5.0.5/man/auto.master.5.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/man/auto.master.5.in	2010-12-07 10:54:27.449759706 -0700
@@ -175,4 +175,11 @@
 setting.
 .TP
+.B MOUNT_WAIT
+Set the default time to wait for a response from a spawned mount(8)
+before sending it a SIGTERM. Note that we still need to wait for the
+RPC layer to timeout before the sub-process exits so this isn't ideal
+but it is the best we can do. The default is to wait until mount(8)
+returns without intervention.
+.TP
 .B UMOUNT_WAIT
 Set the default time to wait for a response from a spawned umount(8)
@@ -359,4 +366,6 @@
 entry requirements is system dependent so the documentation for your
 installation will need to be consulted to get further information.
+.P
+See \fBautofs_ldap_auth.conf\fP(5) for more information.
 .SH EXAMPLE
 .sp
@@ -393,4 +402,5 @@
 .BR autofs (5),
 .BR autofs (8).
+.BR autofs_ldap_auth.conf (5)
 .SH AUTHOR
 This manual page was written by Christoph Lameter <chris@waterf.org>,
diff -r -U2 autofs-5.0.5/man/autofs.5 autofs-5.0.5/man/autofs.5
--- autofs-5.0.5/man/autofs.5	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/man/autofs.5	2010-12-07 10:54:27.449759706 -0700
@@ -230,4 +230,5 @@
 .BR autofs (8),
 .BR mount (8).
+.BR autofs_ldap_auth.conf (5)
 .SH AUTHOR
 This manual page was written by Christoph Lameter <chris@waterf.org>,
diff -r -U2 autofs-5.0.5/man/autofs.8.in autofs-5.0.5/man/autofs.8.in
--- autofs-5.0.5/man/autofs.8.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/man/autofs.8.in	2010-12-07 10:54:27.449759706 -0700
@@ -51,4 +51,5 @@
 .BR autofs (5),
 .BR auto.master (5).
+.BR autofs_ldap_auth.conf (5)
 .SH AUTHOR
 This manual page was written by Christoph Lameter <chris@waterf.org>,
Only in autofs-5.0.5/man: autofs_ldap_auth.conf.5.in
diff -r -U2 autofs-5.0.5/man/automount.8 autofs-5.0.5/man/automount.8
--- autofs-5.0.5/man/automount.8	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/man/automount.8	2010-12-07 10:54:27.583070357 -0700
@@ -58,4 +58,7 @@
 list of replicated servers.
 .TP
+.I "\-m, \-\-dumpmaps"
+Dump configured automounter maps, then exit.
+.TP
 .I "\-O, \-\-global-options"
 Allows the specification of global mount options used for all master
@@ -78,5 +81,7 @@
 or emerg won't stop the verbose logging. However, setting logging to debug
 will lead to everything (debug logging) being logged witch can then also
-be disabled, returning the daemon to verbose logging.
+be disabled, returning the daemon to verbose logging. This option can be
+specified to change the logging priority of an already running automount
+process.
 .P
 The \fIpath\fP argument corresponds to the automounted
@@ -151,4 +156,5 @@
 .BR auto.master (5),
 .BR mount (8).
+.BR autofs_ldap_auth.conf (5)
 .SH BUGS
 Don't know, I've fixed everything I know about.
diff -r -U2 autofs-5.0.5/modules/Makefile autofs-5.0.5/modules/Makefile
--- autofs-5.0.5/modules/Makefile	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/Makefile	2010-12-07 10:54:27.566406527 -0700
@@ -42,7 +42,7 @@
   MODS += lookup_ldap.so
   ifeq ($(SASL), 1)
-    SASL_OBJ = cyrus-sasl.o
-    LDAP_FLAGS += $(SASL_FLAGS) $(XML_FLAGS) -DLDAP_THREAD_SAFE
-    LIBLDAP += $(LIBSASL) $(XML_LIBS)
+    SASL_OBJ = cyrus-sasl.o cyrus-sasl-extern.o
+    LDAP_FLAGS += $(SASL_FLAGS) $(XML_FLAGS) $(KRB5_FLAGS) -DLDAP_THREAD_SAFE
+    LIBLDAP += $(LIBSASL) $(XML_LIBS) $(KRB5_LIBS)
   endif
 endif
@@ -70,8 +70,14 @@
 	ln -fs mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext3.so
  endif
-else
- ifeq ($(EXT3FS), 1)
+ ifeq ($(EXT4FS), 1)
+	ln -fs mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
+ endif
+else ifeq ($(EXT3FS), 1)
 	mv $(INSTALLROOT)$(autofslibdir)/mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext3.so
+ ifeq ($(EXT4FS), 1)
+	ln -fs mount_ext3.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
  endif
+else ifeq ($(EXT4FS), 1)
+	mv $(INSTALLROOT)$(autofslibdir)/mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
 endif
 
@@ -87,4 +93,7 @@
 	$(CC) $(CFLAGS) $(LDAP_FLAGS) -c $<
 
+cyrus-sasl-extern.o: cyrus-sasl-extern.c
+	$(CC) $(CFLAGS) $(LDAP_FLAGS) -c $<
+
 lookup_ldap.so: lookup_ldap.c dclist.o $(SASL_OBJ)
 	$(CC) $(SOLDFLAGS) $(CFLAGS) $(LDAP_FLAGS) -o lookup_ldap.so \
Only in autofs-5.0.5/modules: cyrus-sasl-extern.c
diff -r -U2 autofs-5.0.5/modules/cyrus-sasl.c autofs-5.0.5/modules/cyrus-sasl.c
--- autofs-5.0.5/modules/cyrus-sasl.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/cyrus-sasl.c	2010-12-07 10:54:27.573072059 -0700
@@ -52,5 +52,4 @@
 #include <stdlib.h>
 #include <string.h>
-#include <ldap.h>
 #include <sasl/sasl.h>
 
@@ -88,6 +87,6 @@
 };
 
-static char *sasl_auth_id, *sasl_auth_secret;
-sasl_secret_t *sasl_secret;
+static char *sasl_auth_id = NULL;
+static char *sasl_auth_secret = NULL;
 
 static int
@@ -799,5 +798,5 @@
 sasl_choose_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
-	sasl_conn_t *conn;
+	sasl_conn_t *conn = NULL;
 	int authenticated;
 	int i;
@@ -846,20 +845,4 @@
 }
 
-int
-autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
-{
-	sasl_conn_t *conn;
-
-	if (!ctxt->sasl_mech)
-		return -1;
-
-	conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
-	if (!conn)
-		return -1;
-
-	ctxt->sasl_conn = conn;
-	return 0;
-}
-
 /*
  *  Routine called when unbinding an ldap connection.
@@ -884,11 +867,42 @@
  */
 int
-autofs_sasl_init(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
+autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
-	sasl_conn_t *conn;
+	sasl_conn_t *conn = NULL;
+
+	/* If we already have a connection use it */
+	if (ctxt->sasl_conn)
+		return 0;
+
+	if (ctxt->sasl_mech && !strncmp(ctxt->sasl_mech, "EXTERNAL", 8)) {
+		int result;
+
+		debug(logopt,
+		      "Attempting sasl bind with mechanism %s",
+		      ctxt->sasl_mech);
+
+		result = do_sasl_extern(ldap, ctxt);
+		if (result)
+			debug(logopt,
+			      "Failed to authenticate with mech %s",
+			      ctxt->sasl_mech);
+		else
+			debug(logopt,
+			      "sasl bind with mechanism %s succeeded",
+			      ctxt->sasl_mech);
+
+		return result;
+	}
 
 	sasl_auth_id = ctxt->user;
 	sasl_auth_secret = ctxt->secret;
 
+	if (ctxt->auth_required & LDAP_AUTH_AUTODETECT) {
+		if (ctxt->sasl_mech) {
+			free(ctxt->sasl_mech);
+			ctxt->sasl_mech = NULL;
+		}
+	}
+
 	/*
 	 *  If LDAP_AUTH_AUTODETECT is set, it means that there was no
@@ -897,20 +911,14 @@
 	 *  auth mechanism.
 	 */
-	if (!(ctxt->auth_required & LDAP_AUTH_AUTODETECT))
+	if (ctxt->sasl_mech)
 		conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
-	else {
-		if (ctxt->sasl_mech) {
-			free(ctxt->sasl_mech);
-			ctxt->sasl_mech = NULL;
-		}
+	else
 		conn = sasl_choose_mech(logopt, ldap, ctxt);
-	}
 
-	if (conn) {
-		sasl_dispose(&conn);
-		return 0;
-	}
+	if (!conn)
+		return -1;
 
-	return -1;
+	ctxt->sasl_conn = conn;
+	return 0;
 }
 
@@ -923,5 +931,5 @@
 	int status, ret;
 
-	if (ctxt && ctxt->sasl_conn) {
+	if (ctxt->sasl_conn) {
 		sasl_dispose(&ctxt->sasl_conn);
 		ctxt->sasl_conn = NULL;
@@ -956,4 +964,55 @@
 }
 
+static void *sasl_mutex_new(void)
+{
+	pthread_mutex_t* mutex;
+
+	mutex = malloc(sizeof(pthread_mutex_t));
+	if (!mutex)
+		return 0;
+		
+	pthread_mutex_init(mutex, NULL);
+
+	return (void *) mutex;
+}
+
+static int sasl_mutex_lock(void *mutex __attribute__((unused)))
+{
+	int rc;
+
+	if (!mutex)
+		return SASL_FAIL;
+
+	rc = pthread_mutex_lock((pthread_mutex_t *) mutex);
+
+	return (rc==0 ? SASL_OK : SASL_FAIL);
+}
+
+static int sasl_mutex_unlock(void *mutex __attribute__((unused)))
+{
+	int rc;
+
+	if (!mutex)
+		return SASL_FAIL;
+
+	rc = pthread_mutex_unlock((pthread_mutex_t *) mutex);
+
+	return (rc==0 ? SASL_OK : SASL_FAIL);
+}
+
+static void sasl_mutex_dispose(void *mutex __attribute__((unused)))
+{
+	int rc;
+
+	if (!mutex)
+		return;
+
+	rc = pthread_mutex_destroy((pthread_mutex_t *) mutex);
+	if (rc == 0)
+		free(mutex);
+
+	return;
+}
+
 /*
  * Initialize the sasl callbacks, which increments the global
@@ -962,4 +1021,10 @@
 int autofs_sasl_client_init(unsigned logopt)
 {
+
+	sasl_set_mutex(sasl_mutex_new,
+		       sasl_mutex_lock,
+		       sasl_mutex_unlock,
+		       sasl_mutex_dispose);
+
 	/* Start up Cyrus SASL--only needs to be done at library load. */
 	if (sasl_client_init(callbacks) != SASL_OK) {
diff -r -U2 autofs-5.0.5/modules/lookup_file.c autofs-5.0.5/modules/lookup_file.c
--- autofs-5.0.5/modules/lookup_file.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_file.c	2010-12-07 10:54:27.499751201 -0700
@@ -439,11 +439,4 @@
 				     "failed to read included master map %s",
 				     master->name);
-				if (!master->recurse) {
-					master->name = save_name;
-					master->depth--;
-					master->recurse = 0;
-					fclose(f);
-					return NSS_STATUS_UNAVAIL;
-				}
 			}
 			master->depth--;
@@ -664,6 +657,4 @@
 				warn(ap->logopt,
 				     "failed to read included map %s", key);
-				fclose(f);
-				return NSS_STATUS_UNAVAIL;
 			}
 		} else {
@@ -881,5 +872,4 @@
 		return NSS_STATUS_NOTFOUND;
 
-	pthread_cleanup_push(cache_lock_cleanup, mc);
 	cache_writelock(mc);
 	exists = cache_lookup_distinct(mc, key);
@@ -892,5 +882,5 @@
 		}
 	}
-	pthread_cleanup_pop(1);
+	cache_unlock(mc);
 
 	if (ret == CHE_MISSING) {
@@ -906,5 +896,4 @@
 		 * following cache lookup.
 		 */
-		pthread_cleanup_push(cache_lock_cleanup, mc);
 		cache_writelock(mc);
 		we = cache_lookup_distinct(mc, "*");
@@ -914,5 +903,5 @@
 				cache_delete(mc, "*");
 		}
-		pthread_cleanup_pop(1);
+		cache_unlock(mc);
 
 		if (wild & (CHE_OK | CHE_UPDATED))
@@ -967,11 +956,20 @@
 			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
-
-		/* Negative timeout expired for non-existent entry. */
-		if (!me->mapent)
-			cache_delete(me->mc, key);
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		cache_unlock(me->mc);
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, key);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, key);
+				cache_unlock(smc);
+			}
+		}
 	}
 
@@ -1050,5 +1048,5 @@
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && (me->source == source || *me->key == '/')) {
+	if (me && me->mapent && (me->source == source || *me->key == '/')) {
 		pthread_cleanup_push(cache_lock_cleanup, mc);
 		strcpy(mapent_buf, me->mapent);
diff -r -U2 autofs-5.0.5/modules/lookup_hosts.c autofs-5.0.5/modules/lookup_hosts.c
--- autofs-5.0.5/modules/lookup_hosts.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_hosts.c	2010-12-07 10:54:27.466423539 -0700
@@ -147,17 +147,23 @@
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
 	if (me) {
-		struct mapent_cache *fmc = me->mc;
-
 		if (me->status >= time(NULL)) {
-			cache_unlock(fmc);
+			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		if (!me->mapent) {
-			cache_delete(fmc, name);
-			me = NULL;
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, name);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, name);
+				cache_unlock(smc);
+			}
 		}
-
-		cache_unlock(fmc);
 	}
 
diff -r -U2 autofs-5.0.5/modules/lookup_ldap.c autofs-5.0.5/modules/lookup_ldap.c
--- autofs-5.0.5/modules/lookup_ldap.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_ldap.c	2010-12-07 10:54:27.576404825 -0700
@@ -29,5 +29,4 @@
 #include <resolv.h>
 #include <lber.h>
-#include <ldap.h>
 
 #define MODULE_LOOKUP
@@ -42,4 +41,7 @@
 int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
 
+#define ENV_LDAPTLS_CERT	"LDAPTLS_CERT"
+#define ENV_LDAPTLS_KEY		"LDAPTLS_KEY"
+
 static struct ldap_schema common_schema[] = {
 	{"nisMap", "nisMapName", "nisObject", "cn", "nisMapEntry"},
@@ -60,7 +62,16 @@
 };
 
-static LDAP *auth_init(unsigned logopt, const char *, struct lookup_context *);
 static int decode_percent_hack(const char *, char **);
 
+static int set_env(unsigned logopt, const char *name, const char *val)
+{
+	int ret = setenv(name, val, 1);
+	if (ret == -1) {
+		error(logopt, "failed to set config value for %s", name);
+		return 0;
+	}
+	return 1;
+}
+
 #ifndef HAVE_LDAP_CREATE_PAGE_CONTROL
 int ldap_create_page_control(LDAP *ldap, ber_int_t pagesize,
@@ -139,9 +150,11 @@
 }
 
-int bind_ldap_anonymous(unsigned logopt, LDAP *ldap, const char *uri, struct lookup_context *ctxt)
+int bind_ldap_simple(unsigned logopt, LDAP *ldap, const char *uri, struct lookup_context *ctxt)
 {
 	int rv;
 
-	if (ctxt->version == 2)
+	if (ctxt->auth_required == LDAP_AUTH_USESIMPLE)
+		rv = ldap_simple_bind_s(ldap, ctxt->user, ctxt->secret);
+	else if (ctxt->version == 2)
 		rv = ldap_simple_bind_s(ldap, ctxt->base, NULL);
 	else
@@ -169,16 +182,6 @@
 
 #ifdef WITH_SASL
-	/*
-	 * The OpenSSL library can't handle having its message and error
-	 * string database loaded multiple times and segfaults if the
-	 * TLS environment is not reset at the right times. As there
-	 * is no ldap_stop_tls call in the openldap library we have
-	 * to do the job ourselves, here and in lookup_done when the
-	 * module is closed.
-	 */
-	if (ctxt->use_tls == LDAP_TLS_RELEASE) {
-		ERR_remove_state(0);
+	if (ctxt->use_tls == LDAP_TLS_RELEASE)
 		ctxt->use_tls = LDAP_TLS_INIT;
-	}
 	autofs_sasl_unbind(ctxt);
 #endif
@@ -391,4 +394,8 @@
 				      MODPREFIX "query failed for search dn %s: %s",
 				      this->basedn, ldap_err2string(rv));
+				if (result) {
+					ldap_msgfree(result);
+					result = NULL;
+				}
 			}
 
@@ -397,5 +404,4 @@
 
 		if (!result) {
-			ldap_msgfree(result);
 			error(logopt,
 			      MODPREFIX "failed to find query dn under search base dns");
@@ -516,10 +522,10 @@
 		debug(logopt, MODPREFIX "autofs_sasl_bind returned %d", rv);
 	} else {
-		rv = bind_ldap_anonymous(logopt, ldap, uri, ctxt);
-		debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
+		rv = bind_ldap_simple(logopt, ldap, uri, ctxt);
+		debug(logopt, MODPREFIX "ldap simple bind returned %d", rv);
 	}
 #else
-	rv = bind_ldap_anonymous(logopt, ldap, uri, ctxt);
-	debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
+	rv = bind_ldap_simple(logopt, ldap, uri, ctxt);
+	debug(logopt, MODPREFIX "ldap simple bind returned %d", rv);
 #endif
 
@@ -555,5 +561,5 @@
 	}
 
-	if (!need_base)
+	if (ctxt->schema && ctxt->qdn && !need_base)
 		return 1;
 
@@ -585,11 +591,15 @@
 	LDAP *ldap;
 
-	ldap = init_ldap_connection(logopt, uri, ctxt);
-	if (!ldap)
-		return NULL;
+	if (ctxt->extern_cert && ctxt->extern_key) {
+		set_env(logopt, ENV_LDAPTLS_CERT, ctxt->extern_cert);
+		set_env(logopt, ENV_LDAPTLS_KEY, ctxt->extern_key);
+	}
 
-	if (!do_bind(logopt, ldap, uri, ctxt)) {
-		unbind_ldap_connection(logopt, ldap, ctxt);
-		return NULL;
+	ldap = init_ldap_connection(logopt, uri, ctxt);
+	if (ldap) {
+		if (!do_bind(logopt, ldap, uri, ctxt)) {
+			unbind_ldap_connection(logopt, ldap, ctxt);
+			ldap = NULL;
+		}
 	}
 
@@ -601,31 +611,4 @@
 	LDAP *ldap;
 
-#ifdef WITH_SASL
-	/*
-	 * Determine which authentication mechanism to use if we require
-	 * authentication.
-	 */
-	if (ctxt->auth_required & (LDAP_AUTH_REQUIRED|LDAP_AUTH_AUTODETECT)) {
-		ldap = auth_init(logopt, uri, ctxt);
-		if (!ldap && ctxt->auth_required & LDAP_AUTH_AUTODETECT)
-			info(logopt,
-			     "no authentication mechanisms auto detected.");
-		if (!ldap) {
-			error(logopt, MODPREFIX
-			      "cannot initialize authentication setup");
-			return NULL;
-		}
-
-		if (!do_bind(logopt, ldap, uri, ctxt)) {
-			unbind_ldap_connection(logopt, ldap, ctxt);
-			autofs_sasl_dispose(ctxt);
-			error(logopt, MODPREFIX "cannot bind to server");
-			return NULL;
-		}
-
-		return ldap;
-	}
-#endif
-
 	ldap = do_connect(logopt, uri, ctxt);
 	if (!ldap) {
@@ -639,4 +622,31 @@
 }
 
+static LDAP *find_dc_server(unsigned logopt, const char *uri, struct lookup_context *ctxt)
+{
+	char *str, *tok, *ptr = NULL;
+	LDAP *ldap = NULL;
+
+	str = strdup(uri);
+	if (!str)
+		return NULL;
+
+	tok = strtok_r(str, " ", &ptr);
+	while (tok) {
+		const char *this = (const char *) tok;
+		debug(logopt, "trying server uri %s", this);
+		ldap = connect_to_server(logopt, this, ctxt);
+		if (ldap) {
+			info(logopt, "connected to uri %s", this);
+			free(str);
+			return ldap;
+		}
+		tok = strtok_r(NULL, " ", &ptr);
+	}
+
+	free(str);
+
+	return NULL;
+}
+
 static LDAP *find_server(unsigned logopt, struct lookup_context *ctxt)
 {
@@ -644,16 +654,9 @@
 	struct ldap_uri *this;
 	struct list_head *p, *first;
-	struct dclist *dclist = NULL;
+	struct dclist *dclist;
 	char *uri = NULL;
 
 	uris_mutex_lock(ctxt);
-	if (ctxt->dclist) {
-		dclist = ctxt->dclist;
-		if (ctxt->dclist->expire < time(NULL)) {
-			free_dclist(ctxt->dclist);
-			ctxt->dclist = NULL;
-			dclist = NULL;
-		}
-	}
+	dclist = ctxt->dclist;
 	if (!ctxt->uri)
 		first = ctxt->uris;
@@ -672,7 +675,14 @@
 		}
 		this = list_entry(p, struct ldap_uri, list);
-		if (!strstr(this->uri, ":///"))
+		if (!strstr(this->uri, ":///")) {
 			uri = strdup(this->uri);
-		else {
+			debug(logopt, "trying server uri %s", uri);
+			ldap = connect_to_server(logopt, uri, ctxt);
+			if (ldap) {
+				info(logopt, "connected to uri %s", uri);
+				free(uri);
+				break;
+			}
+		} else {
 			if (dclist)
 				uri = strdup(dclist->uri);
@@ -687,19 +697,9 @@
 				uri = strdup(dclist->uri);
 			}
-		}
-		if (!uri) {
-			if (dclist) {
-				free_dclist(dclist);
-				dclist = NULL;
+			ldap = find_dc_server(logopt, uri, ctxt);
+			if (ldap) {
+				free(uri);
+				break;
 			}
-			p = p->next;
-			continue;
-		}
-		debug(logopt, "trying server uri %s", uri);
-		ldap = connect_to_server(logopt, uri, ctxt);
-		if (ldap) {
-			info(logopt, "connected to uri %s", uri);
-			free(uri);
-			break;
 		}
 		free(uri);
@@ -732,5 +732,5 @@
 static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
 {
-	LDAP *ldap;
+	LDAP *ldap = NULL;
 	char *uri;
 
@@ -747,19 +747,27 @@
 	}
 
+	if (ctxt->dclist) {
+		ldap = find_dc_server(logopt, ctxt->dclist->uri, ctxt);
+		if (ldap)
+			return ldap;
+	}
+
 	uris_mutex_lock(ctxt);
-	if (ctxt->dclist)
-		uri = strdup(ctxt->dclist->uri);
-	else
-		uri = strdup(ctxt->uri->uri);
+	if (ctxt->dclist) {
+		if (!ldap || ctxt->dclist->expire < time(NULL)) {
+			free_dclist(ctxt->dclist);
+			ctxt->dclist = NULL;
+		}
+		/* Make sure we don't skip the domain spec */
+		ctxt->uri = NULL;
+		uris_mutex_unlock(ctxt);
+		goto find_server;
+	}
 	uris_mutex_unlock(ctxt);
 
-	if (!uri) {
-		char buf[MAX_ERR_BUF];
-		char *estr = strerror_r(errno, buf, sizeof(buf));
-		crit(logopt, MODPREFIX "strdup: %s", estr);
-		return NULL;
-	}
+	if (!ctxt->uri)
+		goto find_server;
 
-	ldap = do_connect(logopt, uri, ctxt);
+	ldap = do_connect(logopt, ctxt->uri->uri, ctxt);
 #ifdef WITH_SASL
 	/*
@@ -772,6 +780,4 @@
 	}
 #endif
-	free(uri);
-
 	if (ldap)
 		return ldap;
@@ -779,9 +785,10 @@
 	/* Failed to connect, try to find a new server */
 
+find_server:
 #ifdef WITH_SASL
 	autofs_sasl_dispose(ctxt);
 #endif
 
-	/* Current server failed connect, try the rest */
+	/* Current server failed, try the rest or dc connection */
 	ldap = find_server(logopt, ctxt);
 	if (!ldap)
@@ -849,4 +856,5 @@
 	char         *authrequired, *auth_conf, *authtype;
 	char         *user = NULL, *secret = NULL;
+	char         *extern_cert = NULL, *extern_key = NULL;
 	char         *client_princ = NULL, *client_cc = NULL;
 	char	     *usetls, *tlsrequired;
@@ -992,9 +1000,11 @@
 		else if (!strcasecmp(authrequired, "autodetect"))
 			auth_required = LDAP_AUTH_AUTODETECT;
+		else if (!strcasecmp(authrequired, "simple"))
+			auth_required = LDAP_AUTH_USESIMPLE;
 		else {
 			error(logopt,
 			      MODPREFIX
 			      "The authrequired property must have value "
-			      "\"yes\", \"no\" or \"autodetect\".");
+			      "\"yes\", \"no\", \"autodetect\", or \"simple\".");
 			ret = -1;
 			goto out;
@@ -1012,5 +1022,6 @@
 	}
 
-	if (authtype && authtype_requires_creds(authtype)) {
+	if (auth_required == LDAP_AUTH_USESIMPLE ||
+	   (authtype && authtype_requires_creds(authtype))) {
 		ret = get_property(logopt, root, "user",  &user);
 		ret |= get_property(logopt, root, "secret", &secret);
@@ -1030,4 +1041,24 @@
 			goto out;
 		}
+	} else if (auth_required == LDAP_AUTH_REQUIRED &&
+		  (authtype && !strncmp(authtype, "EXTERNAL", 8))) {
+		ret = get_property(logopt, root, "external_cert",  &extern_cert);
+		ret |= get_property(logopt, root, "external_key",  &extern_key);
+		/*
+		 * For EXTERNAL auth to function we need a client certificate
+		 * and and certificate key. The ca certificate used to verify
+		 * the server certificate must also be set correctly in the
+		 * global configuration as the connection must be encrypted
+		 * and the server and client certificates must have been
+		 * verified for the EXTERNAL method to be offerred by the
+		 * server. If the cert and key have not been set in the autofs
+		 * configuration they must be set in the ldap rc file.
+		 */
+		if (ret != 0 || !extern_cert || !extern_key) {
+			if (extern_cert)
+				free(extern_cert);
+			if (extern_key)
+				free(extern_key);
+		}
 	}
 
@@ -1050,4 +1081,6 @@
 	ctxt->client_princ = client_princ;
 	ctxt->client_cc = client_cc;
+	ctxt->extern_cert = extern_cert;
+	ctxt->extern_key = extern_key;
 
 	debug(logopt, MODPREFIX
@@ -1059,12 +1092,18 @@
 	      "sasl_mech: %s",
 	      use_tls, tls_required, auth_required, authtype);
-	debug(logopt, MODPREFIX
-	      "user: %s, "
-	      "secret: %s, "
-	      "client principal: %s "
-	      "credential cache: %s",
-	      user, secret ? "specified" : "unspecified",
-	      client_princ, client_cc);
-
+	if (authtype && !strncmp(authtype, "EXTERNAL", 8)) {
+		debug(logopt, MODPREFIX "external cert: %s",
+		      extern_cert ? extern_cert : "ldap default");
+		debug(logopt, MODPREFIX "external key: %s ",
+		      extern_key ? extern_key : "ldap default");
+	} else {
+		debug(logopt, MODPREFIX
+		      "user: %s, "
+		      "secret: %s, "
+		      "client principal: %s "
+		      "credential cache: %s",
+		      user, secret ? "specified" : "unspecified",
+		      client_princ, client_cc);
+	}
 out:
 	xmlFreeDoc(doc);
@@ -1075,36 +1114,4 @@
 	return ret;
 }
-
-/*
- *  Reads in the xml configuration file and parses out the relevant
- *  information.  If there is no configuration file, then we fall back to
- *  trying all supported authentication mechanisms until one works.
- *
- *  Returns ldap connection on success, with authtype, user and secret
- *  filled in as appropriate.  Returns NULL on failre.
- */
-static LDAP *auth_init(unsigned logopt, const char *uri, struct lookup_context *ctxt)
-{
-	int ret;
-	LDAP *ldap;
-
-	ldap = init_ldap_connection(logopt, uri, ctxt);
-	if (!ldap)
-		return NULL;
-
-	/*
-	 *  Initialize the sasl library.  It is okay if user and secret
-	 *  are NULL, here.
-	 *
-	 *  The autofs_sasl_init routine will figure out which mechamism
-	 *  to use. If kerberos is used, it will also take care to initialize
-	 *  the credential cache and the client and service principals.
-	 */
-	ret = autofs_sasl_init(logopt, ldap, ctxt);
-	if (ret)
-		return NULL;
-
-	return ldap;
-}
 #endif
 
@@ -1365,4 +1372,8 @@
 	if (ctxt->dclist)
 		free_dclist(ctxt->dclist);
+	if (ctxt->extern_cert)
+		free(ctxt->extern_cert);
+	if (ctxt->extern_key)
+		free(ctxt->extern_key);
 	free(ctxt);
 
@@ -1400,5 +1411,4 @@
 	struct lookup_context *ctxt;
 	char buf[MAX_ERR_BUF];
-	LDAP *ldap = NULL;
 	int ret;
 
@@ -1474,21 +1484,4 @@
 #endif
 
-	if (ctxt->server || !ctxt->uris) {
-		ldap = connect_to_server(LOGOPT_NONE, ctxt->server, ctxt);
-		if (!ldap) {
-			free_context(ctxt);
-			return 1;
-		}
-	} else {
-		ldap = find_server(LOGOPT_NONE, ctxt);
-		if (!ldap) {
-			free_context(ctxt);
-			error(LOGOPT_ANY, MODPREFIX
-			     "failed to find available server");
-			return 1;
-		}
-	}
-	unbind_ldap_connection(LOGOPT_ANY, ldap, ctxt);
-
 	/* Open the parser, if we can. */
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
@@ -1521,4 +1514,9 @@
 	LDAP *ldap;
 
+	/* Initialize the LDAP context. */
+	ldap = do_reconnect(logopt, ctxt);
+	if (!ldap)
+		return NSS_STATUS_UNAVAIL;
+
 	class = ctxt->schema->entry_class;
 	entry = ctxt->schema->entry_attr;
@@ -1544,11 +1542,4 @@
 	}
 
-	/* Initialize the LDAP context. */
-	ldap = do_reconnect(logopt, ctxt);
-	if (!ldap) {
-		free(query);
-		return NSS_STATUS_UNAVAIL;
-	}
-
 	/* Look around. */
 	debug(logopt,
@@ -2015,4 +2006,10 @@
 	}
 
+	if (rv != LDAP_SUCCESS) {
+		debug(ap->logopt,
+		      MODPREFIX "ldap_parse_result failed with %d", rv);
+		goto out_free;
+	}
+
 	/*
 	 * Parse the page control returned to get the cookie and
@@ -2031,6 +2028,6 @@
 		ldap_controls_free(returnedControls);
 
+out_free:
 	ldap_control_free(pageControl);
-
 	return rv;
 }
@@ -2316,4 +2313,9 @@
 	sp.age = age;
 
+	/* Initialize the LDAP context. */
+	sp.ldap = do_reconnect(ap->logopt, ctxt);
+	if (!sp.ldap)
+		return NSS_STATUS_UNAVAIL;
+
 	class = ctxt->schema->entry_class;
 	entry = ctxt->schema->entry_attr;
@@ -2341,11 +2343,4 @@
 	}
 
-	/* Initialize the LDAP context. */
-	sp.ldap = do_reconnect(ap->logopt, ctxt);
-	if (!sp.ldap) {
-		free(sp.query);
-		return NSS_STATUS_UNAVAIL;
-	}
-
 	/* Look around. */
 	debug(ap->logopt,
@@ -2453,4 +2448,9 @@
 	}
 
+	/* Initialize the LDAP context. */
+	ldap = do_reconnect(ap->logopt, ctxt);
+	if (!ldap)
+		return CHE_UNAVAIL;
+
 	class = ctxt->schema->entry_class;
 	entry = ctxt->schema->entry_attr;
@@ -2531,11 +2531,4 @@
 	}
 
-	/* Initialize the LDAP context. */
-	ldap = do_reconnect(ap->logopt, ctxt);
-	if (!ldap) {
-		free(query);
-		return CHE_UNAVAIL;
-	}
-
 	debug(ap->logopt,
 	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
@@ -2747,5 +2740,4 @@
 
 	/* Failed to find wild entry, update cache if needed */
-	pthread_cleanup_push(cache_lock_cleanup, mc);
 	cache_writelock(mc);
 	we = cache_lookup_distinct(mc, "*");
@@ -2773,5 +2765,5 @@
 		}
 	}
-	pthread_cleanup_pop(1);
+	cache_unlock(mc);
 	free(query);
 
@@ -2883,11 +2875,20 @@
 			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
-
-		/* Negative timeout expired for non-existent entry. */
-		if (!me->mapent)
-			cache_delete(me->mc, key);
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		cache_unlock(me->mc);
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, key);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, key);
+				cache_unlock(smc);
+			}
+		}
 	}
 
@@ -2930,5 +2931,5 @@
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && (me->source == source || *me->key == '/')) {
+	if (me && me->mapent && (me->source == source || *me->key == '/')) {
 		strcpy(mapent_buf, me->mapent);
 		mapent = mapent_buf;
diff -r -U2 autofs-5.0.5/modules/lookup_nisplus.c autofs-5.0.5/modules/lookup_nisplus.c
--- autofs-5.0.5/modules/lookup_nisplus.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_nisplus.c	2010-12-07 10:54:27.499751201 -0700
@@ -422,5 +422,4 @@
 	}
 
-	pthread_cleanup_push(cache_lock_cleanup, mc);
 	cache_writelock(mc);
 	t_last_read = ap->exp_runfreq + 1;
@@ -443,6 +442,6 @@
 		}
 	}
-	pthread_cleanup_pop(1);
-	
+	cache_unlock(mc);
+
 	if (t_last_read > ap->exp_runfreq && ret & CHE_UPDATED)
 		source->stale = 1;
@@ -460,5 +459,4 @@
 		 * following cache lookup.
 		*/
-		pthread_cleanup_push(cache_lock_cleanup, mc);
 		cache_writelock(mc);
 		we = cache_lookup_distinct(mc, "*");
@@ -474,5 +472,5 @@
 				source->stale = 1;
 		}
-		pthread_cleanup_pop(1);
+		cache_unlock(mc);
 
 		if (wild & (CHE_UPDATED | CHE_OK))
@@ -517,11 +515,20 @@
 			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
-
-		/* Negative timeout expired for non-existent entry. */
-		if (!me->mapent)
-			cache_delete(me->mc, key);
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		cache_unlock(me->mc);
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, key);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, key);
+				cache_unlock(smc);
+			}
+		}
 	}
 
@@ -563,5 +570,5 @@
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && (me->source == source || *me->key == '/')) {
+	if (me && me->mapent && (me->source == source || *me->key == '/')) {
 		mapent_len = strlen(me->mapent);
 		mapent = malloc(mapent_len + 1);
diff -r -U2 autofs-5.0.5/modules/lookup_program.c autofs-5.0.5/modules/lookup_program.c
--- autofs-5.0.5/modules/lookup_program.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_program.c	2010-12-07 10:54:27.469756305 -0700
@@ -136,15 +136,24 @@
 			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
-
-		/* Negative timeout expired for non-existent entry. */
-		if (!me->mapent)
-			cache_delete(me->mc, name);
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		cache_unlock(me->mc);
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, name);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, name);
+				cache_unlock(smc);
+			}
+		}
 	}
 
 	/* Catch installed direct offset triggers */
-	cache_writelock(mc);
+	cache_readlock(mc);
 	me = cache_lookup_distinct(mc, name);
 	if (!me) {
@@ -192,5 +201,9 @@
 				return NSS_STATUS_UNAVAIL;
 			}
-			cache_delete(mc, name);
+			cache_unlock(mc);
+			cache_writelock(mc);
+			me = cache_lookup_distinct(mc, name);
+			if (me)
+				cache_delete(mc, name);
 			cache_unlock(mc);
 		}
diff -r -U2 autofs-5.0.5/modules/lookup_yp.c autofs-5.0.5/modules/lookup_yp.c
--- autofs-5.0.5/modules/lookup_yp.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/lookup_yp.c	2010-12-07 10:54:27.503083967 -0700
@@ -534,5 +534,4 @@
 	}
 
-	pthread_cleanup_push(cache_lock_cleanup, mc);
 	cache_writelock(mc);
 	exists = cache_lookup_distinct(mc, key);
@@ -546,5 +545,5 @@
 		}
 	}
-	pthread_cleanup_pop(1);
+	cache_unlock(mc);
 
 	if (ret == CHE_MISSING) {
@@ -560,5 +559,4 @@
 		 * following cache lookup.
 		 */
-		pthread_cleanup_push(cache_lock_cleanup, mc);
 		cache_writelock(mc);
 		we = cache_lookup_distinct(mc, "*");
@@ -574,5 +572,5 @@
 				source->stale = 1;
 		}
-		pthread_cleanup_pop(1);
+		cache_unlock(mc);
 
 		if (wild & (CHE_OK | CHE_UPDATED))
@@ -617,11 +615,20 @@
 			cache_unlock(me->mc);
 			return NSS_STATUS_NOTFOUND;
-		}
-
-		/* Negative timeout expired for non-existent entry. */
-		if (!me->mapent)
-			cache_delete(me->mc, key);
+		} else {
+			struct mapent_cache *smc = me->mc;
+			struct mapent *sme;
 
-		cache_unlock(me->mc);
+			if (me->mapent)
+				cache_unlock(smc);
+			else {
+				cache_unlock(smc);
+				cache_writelock(smc);
+				sme = cache_lookup_distinct(smc, key);
+				/* Negative timeout expired for non-existent entry. */
+				if (sme && !sme->mapent)
+					cache_delete(smc, key);
+				cache_unlock(smc);
+			}
+		}
 	}
 
@@ -664,5 +671,5 @@
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && (me->source == source || *me->key == '/')) {
+	if (me && me->mapent && (me->source == source || *me->key == '/')) {
 		mapent_len = strlen(me->mapent);
 		mapent = alloca(mapent_len + 1);
diff -r -U2 autofs-5.0.5/modules/mount_autofs.c autofs-5.0.5/modules/mount_autofs.c
--- autofs-5.0.5/modules/mount_autofs.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/mount_autofs.c	2010-12-07 10:54:27.496418435 -0700
@@ -120,5 +120,5 @@
 				char *val = strchr(cp, '=');
 				unsigned tout;
-				if (val++) {
+				if (val) {
 					int ret = sscanf(cp, "timeout=%u", &tout);
 					if (ret)
@@ -201,12 +201,4 @@
 	free_map_type_info(info);
 
-	source->mc = cache_init(entry->ap, source);
-	if (!source->mc) {
-		error(ap->logopt, MODPREFIX "failed to init source cache");
-		master_free_map_source(source, 0);
-		master_free_mapent(entry);
-		return 1;
-	}
-
 	mounts_mutex_lock(ap);
 
diff -r -U2 autofs-5.0.5/modules/mount_changer.c autofs-5.0.5/modules/mount_changer.c
--- autofs-5.0.5/modules/mount_changer.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/mount_changer.c	2010-12-07 10:54:27.543077163 -0700
@@ -130,5 +130,5 @@
 		return 1;
 	} else {
-		info(ap->logopt, MODPREFIX "mounted %s type %s on %s",
+		debug(ap->logopt, MODPREFIX "mounted %s type %s on %s",
 		    what, fstype, fullpath);
 		return 0;
diff -r -U2 autofs-5.0.5/modules/mount_ext2.c autofs-5.0.5/modules/mount_ext2.c
--- autofs-5.0.5/modules/mount_ext2.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/mount_ext2.c	2010-12-07 10:54:27.543077163 -0700
@@ -84,11 +84,12 @@
 	}
 
+	fsck_prog = PATH_E2FSCK;
 #ifdef HAVE_E3FSCK
-	if (!strcmp(fstype,"ext3") || !strcmp(fstype,"auto"))
+	if (!strcmp(fstype,"ext3"))
 		fsck_prog = PATH_E3FSCK;
-	else
-		fsck_prog = PATH_E2FSCK;
-#else
-	fsck_prog = PATH_E2FSCK;
+#endif
+#ifdef HAVE_E4FSCK
+	if (!strcmp(fstype,"ext4"))
+		fsck_prog = PATH_E4FSCK;
 #endif
 	if (ro) {
@@ -140,5 +141,5 @@
 		return 1;
 	} else {
-		info(ap->logopt,
+		debug(ap->logopt,
 		      MODPREFIX "mounted %s type %s on %s",
 		      what, fstype, fullpath);
diff -r -U2 autofs-5.0.5/modules/mount_generic.c autofs-5.0.5/modules/mount_generic.c
--- autofs-5.0.5/modules/mount_generic.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/mount_generic.c	2010-12-07 10:54:27.543077163 -0700
@@ -40,4 +40,5 @@
 	char fullpath[PATH_MAX];
 	char buf[MAX_ERR_BUF];
+	char *loc;
 	int err;
 	int len, status, existed = 1;
@@ -75,20 +76,42 @@
 		existed = 0;
 
+	/*
+	 * Special case quoting for cifs share names.
+	 *
+	 * Since "\" is a valid seperator for cifs shares it can't be
+	 * used to escape characters in the share name passed to
+	 * mount.cifs. So we have no choice but to require that the
+	 * seperator we use is "/" and de-quote the string before
+	 * sending it to mount.cifs.
+	 */
+	loc = NULL;
+	if (strcmp(fstype, "cifs"))
+		loc = strdup(what);
+	else
+		loc = dequote(what, strlen(what), ap->logopt);
+	if (!loc) {
+		error(ap->logopt,
+		      MODPREFIX "failed to alloc buffer for mount location");
+		return 1;
+	}
+
 	if (options && options[0]) {
 		debug(ap->logopt,
 		      MODPREFIX "calling mount -t %s " SLOPPY "-o %s %s %s",
-		      fstype, options, what, fullpath);
+		      fstype, options, loc, fullpath);
 
 		err = spawn_mount(ap->logopt, "-t", fstype,
-			     SLOPPYOPT "-o", options, what, fullpath, NULL);
+			     SLOPPYOPT "-o", options, loc, fullpath, NULL);
 	} else {
 		debug(ap->logopt, MODPREFIX "calling mount -t %s %s %s",
-		      fstype, what, fullpath);
-		err = spawn_mount(ap->logopt, "-t", fstype, what, fullpath, NULL);
+		      fstype, loc, fullpath);
+		err = spawn_mount(ap->logopt, "-t", fstype, loc, fullpath, NULL);
 	}
 
 	if (err) {
 		info(ap->logopt, MODPREFIX "failed to mount %s (type %s) on %s",
-		     what, fstype, fullpath);
+		     loc, fstype, fullpath);
+
+		free(loc);
 
 		if (ap->type != LKP_INDIRECT)
@@ -100,6 +123,7 @@
 		return 1;
 	} else {
-		info(ap->logopt, MODPREFIX "mounted %s type %s on %s",
-		    what, fstype, fullpath);
+		debug(ap->logopt, MODPREFIX "mounted %s type %s on %s",
+		     loc, fstype, fullpath);
+		free(loc);
 		return 0;
 	}
diff -r -U2 autofs-5.0.5/modules/mount_nfs.c autofs-5.0.5/modules/mount_nfs.c
--- autofs-5.0.5/modules/mount_nfs.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/mount_nfs.c	2010-12-07 10:54:27.543077163 -0700
@@ -138,5 +138,5 @@
 		vers = vers | NFS4_VERS_MASK;
 
-	if (!parse_location(ap->logopt, &hosts, what)) {
+	if (!parse_location(ap->logopt, &hosts, what, random_selection)) {
 		info(ap->logopt, MODPREFIX "no hosts available");
 		return 1;
@@ -252,5 +252,5 @@
 
 		if (!err) {
-			info(ap->logopt, MODPREFIX "mounted %s on %s", loc, fullpath);
+			debug(ap->logopt, MODPREFIX "mounted %s on %s", loc, fullpath);
 			free(loc);
 			free_host_list(&hosts);
diff -r -U2 autofs-5.0.5/modules/parse_sun.c autofs-5.0.5/modules/parse_sun.c
--- autofs-5.0.5/modules/parse_sun.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/parse_sun.c	2010-12-07 10:54:27.479754603 -0700
@@ -46,4 +46,20 @@
 static struct mount_mod *mount_nfs = NULL;
 static int init_ctr = 0;
+static int macro_init_done = 0;
+static pthread_mutex_t instance_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void instance_mutex_lock(void)
+{
+	int status = pthread_mutex_lock(&instance_mutex);
+	if (status)
+		fatal(status);
+}
+
+static void instance_mutex_unlock(void)
+{
+	int status = pthread_mutex_unlock(&instance_mutex);
+	if (status)
+		fatal(status);
+}
 
 extern const char *global_options;
@@ -277,7 +293,10 @@
 
 	/* Get processor information for predefined escapes */
-
-	if (!init_ctr)
+	macro_lock();
+	if (!macro_init_done) {
+		macro_init_done = 1;
 		macro_init();
+	}
+	macro_unlock();
 
 	/* Set up context and escape chain */
@@ -435,17 +454,19 @@
 	/* We only need this once.  NFS mounts are so common that we cache
 	   this module. */
-	if (!mount_nfs) {
+	instance_mutex_lock();
+	if (mount_nfs)
+		init_ctr++;
+	else {
 		if ((mount_nfs = open_mount("nfs", MODPREFIX))) {
 			init_ctr++;
-			return 0;
 		} else {
 			kill_context(ctxt);
 			*context = NULL;
+			instance_mutex_unlock();
 			return 1;
 		}
-	} else {
-		init_ctr++;
-		return 0;
 	}
+	instance_mutex_unlock();
+	return 0;
 }
 
@@ -1137,17 +1158,4 @@
 	rv = 0;
 
-	if (!me || !me->multi) {
-		int loclen = strlen(loc);
-		int namelen = strlen(name);
-		const char *root = ap->path;
-
-		if (!strcmp(ap->path, "/-"))
-			root = name;
-
-		rv = sun_mount(ap, root, name, namelen, loc, loclen, options, ctxt);
-
-		goto done;
-	}
-
 	mm = me->multi;
 	mm_key = mm->key;
@@ -1295,5 +1303,4 @@
 		return rv;
 
-done:
 	/*
 	 * Convert fail on nonstrict, non-empty multi-mount
@@ -1335,5 +1342,5 @@
 	const char *p;
 	int mapent_len, rv = 0;
-	int optlen, cur_state;
+	int cur_state;
 	int slashify = ctxt->slashify_colons;
 	unsigned int append_options;
@@ -1390,5 +1397,4 @@
 		return 1;
 	}
-	optlen = strlen(options);
 
 	p = skipspace(pmapent);
@@ -1624,4 +1630,5 @@
 		 * has already been stripped so just use the remainder.
 		 */
+		cache_readlock(mc);
 		if (*name == '/' &&
 		   (me = cache_lookup_distinct(mc, name)) && me->multi) {
@@ -1629,10 +1636,17 @@
 			if (!loc) {
 				free(options);
+				cache_unlock(mc);
 				warn(ap->logopt, MODPREFIX "out of memory");
 				return 1;
 			}
-			loclen = strlen(p);
-			goto mount_it;
+			cache_multi_writelock(me);
+			rv = mount_subtree(ap, me, name, loc, options, ctxt);
+			cache_multi_unlock(me);
+			cache_unlock(mc);
+			free(loc);
+			free(options);
+			return rv;
 		}
+		cache_unlock(mc);
 
 		l = chunklen(p, check_colon(p));
@@ -1718,19 +1732,18 @@
 			return 1;
 		}
-mount_it:
+
 		debug(ap->logopt,
 		      MODPREFIX "core of entry: options=%s, loc=%.*s",
 		      options, loclen, loc);
 
-		cache_readlock(mc);
-		cache_multi_writelock(me);
-
-		rv = mount_subtree(ap, me, name, loc, options, ctxt);
+		if (!strcmp(ap->path, "/-"))
+			rv = sun_mount(ap, name, name, name_len,
+				       loc, loclen, options, ctxt);
+		else
+			rv = sun_mount(ap, ap->path, name, name_len,
+				       loc, loclen, options, ctxt);
 
 		free(loc);
 		free(options);
-
-		cache_multi_unlock(me);
-		cache_unlock(mc);
 		pthread_setcancelstate(cur_state, NULL);
 	}
@@ -1743,8 +1756,10 @@
 	struct parse_context *ctxt = (struct parse_context *) context;
 
+	instance_mutex_lock();
 	if (--init_ctr == 0) {
 		rv = close_mount(mount_nfs);
 		mount_nfs = NULL;
 	}
+	instance_mutex_unlock();
 	if (ctxt)
 		kill_context(ctxt);
diff -r -U2 autofs-5.0.5/modules/replicated.c autofs-5.0.5/modules/replicated.c
--- autofs-5.0.5/modules/replicated.c	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/modules/replicated.c	2010-12-07 10:54:27.456425238 -0700
@@ -232,5 +232,5 @@
 
 		case AF_INET6:
-#ifndef INET6
+#ifdef INET6
 			if (host_addr->sa_family == AF_INET)
 				break;
@@ -314,5 +314,5 @@
 
 		case AF_INET6:
-#ifndef INET6
+#ifdef INET6
 			if (host_addr->sa_family == AF_INET)
 				break;
@@ -1042,5 +1042,6 @@
 static int add_new_host(struct host **list,
 			const char *host, unsigned int weight,
-			struct addrinfo *host_addr)
+			struct addrinfo *host_addr,
+			unsigned int random_selection)
 {
 	struct host *new;
@@ -1048,5 +1049,14 @@
 	int addr_len;
 
-	prx = get_proximity(host_addr->ai_addr);
+	/*
+	 * If we are using random selection we pretend all hosts are at
+	 * the same proximity so hosts further away don't get excluded.
+	 * We can't use PROXIMITY_LOCAL or we won't perform an RPC ping
+	 * to remove hosts that may be down.
+	 */
+	if (random_selection)
+		prx = PROXIMITY_SUBNET;
+	else
+		prx = get_proximity(host_addr->ai_addr);
 	/*
 	 * If we tried to add an IPv6 address and we don't have IPv6
@@ -1072,5 +1082,6 @@
 }
 
-static int add_host_addrs(struct host **list, const char *host, unsigned int weight)
+static int add_host_addrs(struct host **list, const char *host,
+			  unsigned int weight, unsigned int random_selection)
 {
 	struct addrinfo hints, *ni, *this;
@@ -1088,5 +1099,5 @@
 	this = ni;
 	while (this) {
-		ret = add_new_host(list, host, weight, this);
+		ret = add_new_host(list, host, weight, this, random_selection);
 		if (!ret)
 			break;
@@ -1111,5 +1122,5 @@
 	this = ni;
 	while (this) {
-		ret = add_new_host(list, host, weight, this);
+		ret = add_new_host(list, host, weight, this, random_selection);
 		if (!ret)
 			break;
@@ -1198,5 +1209,6 @@
 }
 
-int parse_location(unsigned logopt, struct host **hosts, const char *list)
+int parse_location(unsigned logopt, struct host **hosts,
+		   const char *list, unsigned int random_selection)
 {
 	char *str, *p, *delim;
@@ -1253,5 +1265,5 @@
 
 				if (p != delim) {
-					if (!add_host_addrs(hosts, p, weight)) {
+					if (!add_host_addrs(hosts, p, weight, random_selection)) {
 						if (empty) {
 							p = next;
@@ -1275,5 +1287,5 @@
 				next = delim + 1;
 
-				if (!add_host_addrs(hosts, p, weight)) {
+				if (!add_host_addrs(hosts, p, weight, random_selection)) {
 					p = next;
 					continue;
Only in autofs-5.0.5/patches: autofs4-2.6.18-v5-update-20100114.patch
Only in autofs-5.0.5/patches: autofs4-2.6.19-v5-update-20100114.patch
diff -r -U2 autofs-5.0.5/redhat/autofs.init.in autofs-5.0.5/redhat/autofs.init.in
--- autofs-5.0.5/redhat/autofs.init.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/redhat/autofs.init.in	2010-12-07 10:54:27.556408227 -0700
@@ -87,5 +87,5 @@
 
 	echo -n $"Starting $prog: "
-	$prog $OPTIONS 
+	$prog $OPTIONS --pid-file /var/run/autofs.pid
 	RETVAL=$?
 	if [ $RETVAL -eq 0 ] ; then
@@ -94,5 +94,9 @@
 		failure "$prog startup"
 	fi
-	[ $RETVAL -eq 0 ] && touch /var/lock/subsys/autofs
+	if [ $RETVAL -eq 0 ]; then
+		touch /var/lock/subsys/autofs
+	else
+		RETVAL=1
+	fi
 	echo
 	return $RETVAL
@@ -102,12 +106,16 @@
 	echo -n $"Stopping $prog: "
 	count=0
-	while [ -n "`pidof $DAEMON`" -a $count -lt 15 ] ; do
+	while [ -n "`pidof $prog`" -a $count -lt 15 ] ; do
 		killproc $prog -TERM >& /dev/null
 		RETVAL=$?
-		[ $RETVAL = 0 -a -z "`pidof $DAEMON`" ] || sleep 3
+		[ $RETVAL = 0 -a -z "`pidof $prog`" ] || sleep 3
 		count=`expr $count + 1`
 	done
-	[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/autofs
-	if [ -n "`pidof $DAEMON`" ] ; then
+	if [ $RETVAL -eq 0 ]; then
+		rm -f /var/lock/subsys/autofs
+	else
+		RETVAL=1
+	fi
+	if [ -n "`pidof $prog`" ] ; then
 		failure "$prog shutdown"
 	else
@@ -119,5 +127,8 @@
 
 function restart() {
-	stop
+	status autofs > /dev/null 2>&1
+	if [ $? -eq 0 ]; then
+		stop
+	fi
 	start
 }
@@ -129,5 +140,5 @@
 		return $RETVAL
 	fi
-	pid=`pidof $DAEMON`
+	pid=`pidof $prog`
 	if [ -z $pid ]; then
 		echo $"$prog not running"
@@ -143,4 +154,10 @@
 RETVAL=0
 
+# Only the root user may change the service status
+if [ `id -u` -ne 0 ] && [ "$1" != "status" ]; then
+	echo "insufficient privilege to change service status"
+	exit 4
+fi
+
 case "$1" in
 	start)
@@ -155,5 +172,5 @@
 		;;
 	status)
-		status $prog
+		status -p /var/run/autofs.pid -l autofs $prog
 		;;
 	restart)
@@ -172,7 +189,15 @@
 		fi
 		;;
+	usage)
+		echo $"Usage: $0 {start|forcestart|stop|status|restart|forcerestart|reload|condrestart}"
+		exit 0
+		;;
+	try-restart|force-reload)
+		echo "$1 service action not supported"
+		exit 3
+		;;
 	*)
-		echo $"Usage: $0 {start|forcestart|stop|status|restart|orcerestart|reload|condrestart}"
-		exit 1;
+		echo "unknown, invalid or excess argument(s)"
+		exit 2
 		;;
 esac
diff -r -U2 autofs-5.0.5/redhat/autofs.sysconfig.in autofs-5.0.5/redhat/autofs.sysconfig.in
--- autofs-5.0.5/redhat/autofs.sysconfig.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/redhat/autofs.sysconfig.in	2010-12-07 10:54:27.433095876 -0700
@@ -15,4 +15,13 @@
 #NEGATIVE_TIMEOUT=60
 #
+# MOUNT_WAIT - time to wait for a response from umount(8).
+# 	       Setting this timeout can cause problems when
+# 	       mount would otherwise wait for a server that
+# 	       is temporarily unavailable, such as when it's
+# 	       restarting. The defailt of waiting for mount(8)
+# 	       usually results in a wait of around 3 minutes.
+#
+#MOUNT_WAIT=-1
+#
 # UMOUNT_WAIT - time to wait for a response from umount(8).
 #
@@ -32,4 +41,5 @@
 #
 #MOUNT_NFS_DEFAULT_PROTOCOL=3
+MOUNT_NFS_DEFAULT_PROTOCOL=4
 #
 # APPEND_OPTIONS - append to global options instead of replace.
diff -r -U2 autofs-5.0.5/samples/auto.smb autofs-5.0.5/samples/auto.smb
--- autofs-5.0.5/samples/auto.smb	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/samples/auto.smb	2010-12-07 10:54:27.426430343 -0700
@@ -27,4 +27,5 @@
 		  # Double quote "$" in location as it is special
 		  gsub(/\$$/, "\\$", loc);
+		  gsub(/\&/,"\\\\&",loc)
 		  print " \\\n\t \"/" dir "\"", "\"://" key "/" loc "\""
 		}
diff -r -U2 autofs-5.0.5/samples/autofs.conf.default.in autofs-5.0.5/samples/autofs.conf.default.in
--- autofs-5.0.5/samples/autofs.conf.default.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/samples/autofs.conf.default.in	2010-12-07 10:54:27.313116289 -0700
@@ -15,4 +15,13 @@
 #NEGATIVE_TIMEOUT=60
 #
+# MOUNT_WAIT - time to wait for a response from umount(8).
+# 	       Setting this timeout can cause problems when
+# 	       mount would otherwise wait for a server that
+# 	       is temporarily unavailable, such as when it's
+# 	       restarting. The defailt of waiting for mount(8)
+# 	       usually results in a wait of around 3 minutes.
+#
+#MOUNT_WAIT=-1
+#
 # UMOUNT_WAIT - time to wait for a response from umount(8).
 #
diff -r -U2 autofs-5.0.5/samples/autofs_ldap_auth.conf autofs-5.0.5/samples/autofs_ldap_auth.conf
--- autofs-5.0.5/samples/autofs_ldap_auth.conf	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/samples/autofs_ldap_auth.conf	2010-12-07 10:54:27.449759706 -0700
@@ -2,64 +2,5 @@
 <!--
 This files contains a single entry with multiple attributes tied to it.
-The attributes are:
-
-usetls  -  Determines whether an encrypted connection to the ldap server
-	   should be attempted.  Legal values for the entry are:
-	   "yes"
-	   "no"
-
-tlsrequired  -  This flag tells whether the ldap connection must be
-	   encrypted.  If set to "yes", the automounter will fail to start
-	   if an encrypted connection cannot be established.  Legal values
-	   for this option include:
-	   "yes"
-	   "no"
-
-authrequired  -  This option tells whether an authenticated connection to
-	    the ldap server is required in order to perform ldap queries.
-	    If this flag is set to yes, then only authenticated connections
-	    will be allowed. If it is set to no then authentication is not
-	    needed for ldap server connections. Finally, if it is set to
-	    autodetect then the ldap server will be queried to establish
-	    a suitable authentication mechanism. If no suitable mechanism
-	    can be found, connections to the ldap server are made without
-	    authentication.
-	    Legal values for this option include:
-	    "yes"
-	    "no"
-	    "autodetect"
-
-authtype  -  This attribute can be used to specify a preferred
-	    authentication mechanism.  In normal operations, the
-	    automounter will attempt to authenticate to the ldap server
-	    using the list of supportedSASLmechanisms obtained from the
-	    directory server.  Explicitly setting the authtype will bypass
-	    this selection and only try the mechanism specified.  Legal
-	    values for this attribute include:
-	    "GSSAPI"
-	    "LOGIN"
-	    "PLAIN"
-	    "ANONYMOUS"
-	    "DIGEST-MD5"
-
-user  -  This attribute holds the authentication identity used by
-	    authentication mechanisms that require it.  Legal values for
-	    this attribute include any printable characters that can be
-	    used by the selected authentication mechanism.
-
-secret  -  This attribute holds the secret used by authentication
-	    mechanisms that require it.  Legal values for this attribute
-	    include any printable characters that can be used by the
-	    selected authentication mechanism.
-
-clientprinc  -  When using GSSAPI authentication, this attribute is
-	    consulted to determine the principal name to use when
-	    authenticating to the directory server.  By default, this will
-	    be set to "autofsclient/<fqdn>@<REALM>.
-
-credentialcache - When using GSSAPI authentication, this attribute
-	    can be used to specify an externally configured credential
-	    cache that is used during authentication. By default, autofs
-	    will setup a memory based credential cache.
+See autofs_ldap_auth.conf(5) for more information.
 -->
 
diff -r -U2 autofs-5.0.5/samples/rc.autofs.in autofs-5.0.5/samples/rc.autofs.in
--- autofs-5.0.5/samples/rc.autofs.in	2009-09-03 03:00:12.000000000 -0700
+++ autofs-5.0.5/samples/rc.autofs.in	2010-12-07 10:54:27.359775017 -0700
@@ -89,11 +89,11 @@
 	echo -n $"Stopping $prog: "
 	count=0
-	while [ -n "`pidof $DAEMON`" -a $count -lt 15 ] ; do
+	while [ -n "`pidof $prog`" -a $count -lt 15 ] ; do
 		killall -TERM $prog >& /dev/null
 		RETVAL=$?
-		[ $RETVAL = 0 -a -z "`pidof $DAEMON`" ] || sleep 3
+		[ $RETVAL = 0 -a -z "`pidof $prog`" ] || sleep 3
 		count=`expr $count + 1`
 	done
-	if [ -z "`pidof $DAEMON`" ] ; then
+	if [ -z "`pidof $prog`" ] ; then
 		echo "done."
 	else
@@ -109,5 +109,5 @@
 
 function reload() {
-	pid=`pidof $DAEMON`
+	pid=`pidof $prog`
 	if [ -z $pid ]; then
 		echo $"$prog not running"

diff -r -U2 -N phonon-4.3.0/cmake/FindGLIB2.cmake phonon-4.3.0/cmake/FindGLIB2.cmake
--- phonon-4.3.0/cmake/FindGLIB2.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/cmake/FindGLIB2.cmake	2009-11-29 17:56:43.000000000 -0700
@@ -27,5 +27,5 @@
 
 find_path(GLIB2_INTERNAL_INCLUDE_DIR glibconfig.h
-          PATH_SUFFIXES glib-2.0/include
+          PATH_SUFFIXES glib-2.0/include ../lib/glib-2.0/include
           PATHS ${PKG_GLIB_INCLUDE_DIRS} ${PKG_GLIB_LIBRARIES} ${CMAKE_SYSTEM_LIBRARY_PATH})
 
diff -r -U2 -N phonon-4.3.0/cmake/FindGObject.cmake phonon-4.3.0/cmake/FindGObject.cmake
--- phonon-4.3.0/cmake/FindGObject.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/cmake/FindGObject.cmake	2009-11-29 17:30:25.000000000 -0700
@@ -26,10 +26,9 @@
 ENDIF (NOT WIN32)
 
-FIND_PATH(GOBJECT_INCLUDE_DIR gobject.h
+FIND_PATH(GOBJECT_INCLUDE_DIR gobject/gobject.h
    PATHS
    ${PKG_GOBJECT2_INCLUDE_DIRS}
-   ${PKG_GOBJECT2_INCLUDE_DIRS}/glib-2.0/gobject/
-   /usr/include/glib-2.0/gobject/
-   #PATH_SUFFIXES gst
+   /usr/include/glib-2.0/
+   PATH_SUFFIXES glib-2.0
    )
 
@@ -51,5 +50,9 @@
    )
 
-SET( GOBJECT_LIBRARIES ${PKG_GOBJECT2_LIBRARIES} )
+IF (WIN32)
+SET (GOBJECT_LIBRARIES ${_GObjectLibs} ${_GModuleLibs} ${_GThreadLibs} ${_GLibs})
+ELSE (WIN32)
+SET (GOBJECT_LIBRARIES ${PKG_GOBJECT2_LIBRARIES})
+ENDIF (WIN32)
 
 IF (GOBJECT_INCLUDE_DIR AND GOBJECT_LIBRARIES)
diff -r -U2 -N phonon-4.3.0/cmake/FindGStreamer.cmake phonon-4.3.0/cmake/FindGStreamer.cmake
--- phonon-4.3.0/cmake/FindGStreamer.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/cmake/FindGStreamer.cmake	2009-11-29 16:14:44.000000000 -0700
@@ -34,4 +34,5 @@
    PATHS
    ${PKG_GSTREAMER_INCLUDE_DIRS}
+   PATH_SUFFIXES gstreamer-0.10
    )
 
diff -r -U2 -N phonon-4.3.0/cmake/FindGStreamerPlugins.cmake phonon-4.3.0/cmake/FindGStreamerPlugins.cmake
--- phonon-4.3.0/cmake/FindGStreamerPlugins.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/cmake/FindGStreamerPlugins.cmake	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
 #  GSTREAMERPLUGINSBASE_DEFINITIONS - Compiler switches required for using GStreamer_Plugins
 #
-#  (c)2007, Trolltech ASA
+#  (c)2009 Nokia Corporation
 
 FIND_PACKAGE(PkgConfig REQUIRED)
diff -r -U2 -N phonon-4.3.0/cmake/FindPulseAudio.cmake phonon-4.3.0/cmake/FindPulseAudio.cmake
--- phonon-4.3.0/cmake/FindPulseAudio.cmake	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/cmake/FindPulseAudio.cmake	2009-11-19 20:04:44.000000000 -0700
@@ -0,0 +1,76 @@
+# Try to find the PulseAudio library
+#
+# Once done this will define:
+#
+#  PULSEAUDIO_FOUND - system has the PulseAudio library
+#  PULSEAUDIO_INCLUDE_DIR - the PulseAudio include directory
+#  PULSEAUDIO_LIBRARY - the libraries needed to use PulseAudio
+#  PULSEAUDIO_MAINLOOP_LIBRARY - the libraries needed to use PulsAudio Mailoop
+#
+# Copyright (c) 2008, Matthias Kretz, <kretz@kde.org>
+# Copyright (c) 2009, Marcus Hufgard, <Marcus.Hufgard@hufgard.de>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+if (NOT PULSEAUDIO_MINIMUM_VERSION)
+  set(PULSEAUDIO_MINIMUM_VERSION "0.9.9")
+endif (NOT PULSEAUDIO_MINIMUM_VERSION)
+
+if (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY AND PULSEAUDIO_MAINLOOP_LIBRARY)
+   # Already in cache, be silent
+   set(PULSEAUDIO_FIND_QUIETLY TRUE)
+endif (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY AND PULSEAUDIO_MAINLOOP_LIBRARY)
+
+if (NOT WIN32)
+   include(FindPkgConfig)
+   pkg_check_modules(PC_PULSEAUDIO libpulse>=${PULSEAUDIO_MINIMUM_VERSION})
+   pkg_check_modules(PC_PULSEAUDIO_MAINLOOP libpulse-mainloop-glib)
+endif (NOT WIN32)
+
+FIND_PATH(PULSEAUDIO_INCLUDE_DIR pulse/pulseaudio.h
+   HINTS
+   ${PC_PULSEAUDIO_INCLUDEDIR}
+   ${PC_PULSEAUDIO_INCLUDE_DIRS}
+   )
+
+FIND_LIBRARY(PULSEAUDIO_LIBRARY NAMES pulse libpulse
+   HINTS
+   ${PC_PULSEAUDIO_LIBDIR}
+   ${PC_PULSEAUDIO_LIBRARY_DIRS}
+   )
+
+FIND_LIBRARY(PULSEAUDIO_MAINLOOP_LIBRARY NAMES pulse-mainloop pulse-mainloop-glib libpulse-mainloop-glib
+   HINTS
+   ${PC_PULSEAUDIO_LIBDIR}
+   ${PC_PULSEAUDIO_LIBRARY_DIRS}
+   )
+
+if (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+   include(MacroEnsureVersion)
+
+   # get PulseAudio's version from its version.h, and compare it with our minimum version
+   file(STRINGS "${PULSEAUDIO_INCLUDE_DIR}/pulse/version.h" pulse_version_h
+        REGEX ".*pa_get_headers_version\\(\\).*"
+        )
+   string(REGEX REPLACE ".*pa_get_headers_version\\(\\)\ \\(\"([0-9]+\\.[0-9]+\\.[0-9]+)\"\\).*" "\\1"
+                         PULSEAUDIO_VERSION "${pulse_version_h}")
+   macro_ensure_version("${PULSEAUDIO_MINIMUM_VERSION}" "${PULSEAUDIO_VERSION}" PULSEAUDIO_FOUND)
+else (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+   set(PULSEAUDIO_FOUND FALSE)
+endif (PULSEAUDIO_INCLUDE_DIR AND PULSEAUDIO_LIBRARY)
+
+if (PULSEAUDIO_FOUND)
+   if (NOT PULSEAUDIO_FIND_QUIETLY)
+      message(STATUS "Found PulseAudio: ${PULSEAUDIO_LIBRARY}")
+      if (PULSEAUDIO_MAINLOOP_LIBRARY)
+          message(STATUS "Found PulseAudio Mainloop: ${PULSEAUDIO_MAINLOOP_LIBRARY}")
+      else (PULSAUDIO_MAINLOOP_LIBRARY)
+          message(STATUS "Could NOT find PulseAudio Mainloop Library")
+      endif (PULSEAUDIO_MAINLOOP_LIBRARY)
+   endif (NOT PULSEAUDIO_FIND_QUIETLY)
+else (PULSEAUDIO_FOUND)
+   message(STATUS "Could NOT find PulseAudio")
+endif (PULSEAUDIO_FOUND)
+
+mark_as_advanced(PULSEAUDIO_INCLUDE_DIR PULSEAUDIO_LIBRARY PULSEAUDIO_MAINLOOP_LIBRARY)
diff -r -U2 -N phonon-4.3.0/cmake/FindXCB.cmake phonon-4.3.0/cmake/FindXCB.cmake
--- phonon-4.3.0/cmake/FindXCB.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/cmake/FindXCB.cmake	2009-11-18 13:06:00.000000000 -0700
@@ -22,6 +22,7 @@
   # use pkg-config to get the directories and then use these values
   # in the FIND_PATH() and FIND_LIBRARY() calls
+  FIND_PACKAGE(PkgConfig)
   PKG_CHECK_MODULES(PKG_XCB xcb)
-	  
+
   SET(LIBXCB_DEFINITIONS ${PKG_XCB_CFLAGS})
 
diff -r -U2 -N phonon-4.3.0/cmake/PhononMacros.cmake phonon-4.3.0/cmake/PhononMacros.cmake
--- phonon-4.3.0/cmake/PhononMacros.cmake	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/cmake/PhononMacros.cmake	2009-04-10 02:27:57.000000000 -0700
@@ -59,7 +59,7 @@
    else (Q_WS_MAC AND NOT _nogui)
       # Use .shell wrapper where available, to use uninstalled libs.
-      if (UNIX)
-         set(_executable ${_executable}.shell)
-      endif (UNIX)
+      #if (UNIX)
+      #   set(_executable ${_executable}.shell)
+      #endif (UNIX)
    endif (Q_WS_MAC AND NOT _nogui)
 
diff -r -U2 -N phonon-4.3.0/CMakeLists.txt phonon-4.3.0/CMakeLists.txt
--- phonon-4.3.0/CMakeLists.txt	2009-01-22 01:20:44.000000000 -0700
+++ phonon-4.3.0/CMakeLists.txt	2009-12-03 12:27:28.000000000 -0700
@@ -56,5 +56,5 @@
      set ( CMAKE_C_FLAGS     "${CMAKE_C_FLAGS} -Wno-long-long -std=iso9899:1990 -Wundef -Wcast-align -Werror-implicit-function-declaration -Wchar-subscripts -Wall -W -Wpointer-arith -Wwrite-strings -Wformat-security -Wmissing-format-attribute -fno-common")
      set ( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wnon-virtual-dtor -Wno-long-long -ansi -Wundef -Wcast-align -Wchar-subscripts -Wall -W -Wpointer-arith -Wformat-security -fno-exceptions -fno-check-new -fno-common")
-     add_definitions (-D_BSD_SOURCE)
+     add_definitions (-D_BSD_SOURCE -DQT_NO_EXCEPTIONS)
    endif (CMAKE_SYSTEM_NAME MATCHES Linux)
 
@@ -116,5 +116,5 @@
    endif (GCC_IS_NEWER_THAN_4_1)
 
-   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
+   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
       set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
       set (KDE4_C_FLAGS "-fvisibility=hidden")
@@ -138,7 +138,7 @@
           set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")
       endif (GCC_IS_NEWER_THAN_4_2)
-   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
+   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
       set (__KDE_HAVE_GCC_VISIBILITY 0)
-   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
+   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
 
 endif (CMAKE_COMPILER_IS_GNUCXX)
@@ -150,6 +150,6 @@
 set(PHONON_LIB_MAJOR_VERSION "4")
 set(PHONON_LIB_MINOR_VERSION "3")
-set(PHONON_LIB_PATCH_VERSION "0")
-set(PHONON_LIB_VERSION "${PHONON_LIB_MAJOR_VERSION}.3.0")
+set(PHONON_LIB_PATCH_VERSION "80")
+set(PHONON_LIB_VERSION "${PHONON_LIB_MAJOR_VERSION}.4.0")
 set(PHONON_LIB_SOVERSION ${PHONON_LIB_MAJOR_VERSION})
 
@@ -178,9 +178,13 @@
 set(LIB_SUFFIX "" CACHE STRING "Define suffix of directory name (32/64)" )
 
-_set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"                   "Base directory for executables and libraries")
-_set_fancy(SHARE_INSTALL_PREFIX        "${CMAKE_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
+if (WIN32)
+    _set_fancy(EXEC_INSTALL_PREFIX         "."                                     "Base directory for executables and libraries")
+else(WIN32)
+    _set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"              "Base directory for executables and libraries")
+endif(WIN32)
+_set_fancy(SHARE_INSTALL_PREFIX        "${EXEC_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
+_set_fancy(INCLUDE_INSTALL_DIR         "${EXEC_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
 _set_fancy(BIN_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/bin"                "The install dir for executables (default ${EXEC_INSTALL_PREFIX}/bin)")
 _set_fancy(LIB_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX}"   "The subdirectory relative to the install prefix where libraries will be installed (default is ${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX})")
-_set_fancy(INCLUDE_INSTALL_DIR         "${CMAKE_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
 _set_fancy(PLUGIN_INSTALL_DIR          "${LIB_INSTALL_DIR}/kde4"                   "The subdirectory relative to the install prefix where plugins will be installed (default is ${LIB_INSTALL_DIR}/kde4)")
 _set_fancy(ICON_INSTALL_DIR            "${SHARE_INSTALL_PREFIX}/icons"             "The icon install dir (default ${SHARE_INSTALL_PREFIX}/share/icons/)")
@@ -197,4 +201,6 @@
    set(INSTALL_TARGETS_DEFAULT_ARGS  ${INSTALL_TARGETS_DEFAULT_ARGS}
                                      BUNDLE DESTINATION "${BUNDLE_INSTALL_DIR}" )
+	set(CMAKE_SHARED_MODULE_CREATE_C_FLAGS   "${CMAKE_SHARED_MODULE_CREATE_C_FLAGS}   -flat_namespace -undefined dynamic_lookup")
+	set(CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS "${CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS} -flat_namespace -undefined dynamic_lookup")
 endif(APPLE)
 
@@ -250,5 +256,4 @@
 
 
-add_subdirectory(cmake)
 add_subdirectory(phonon)
 add_subdirectory(includes)
diff -r -U2 -N phonon-4.3.0/ds9/abstractvideorenderer.cpp phonon-4.3.0/ds9/abstractvideorenderer.cpp
--- phonon-4.3.0/ds9/abstractvideorenderer.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/abstractvideorenderer.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/abstractvideorenderer.h phonon-4.3.0/ds9/abstractvideorenderer.h
--- phonon-4.3.0/ds9/abstractvideorenderer.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/abstractvideorenderer.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/audiooutput.cpp phonon-4.3.0/ds9/audiooutput.cpp
--- phonon-4.3.0/ds9/audiooutput.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/audiooutput.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/audiooutput.h phonon-4.3.0/ds9/audiooutput.h
--- phonon-4.3.0/ds9/audiooutput.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/audiooutput.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/backend.cpp phonon-4.3.0/ds9/backend.cpp
--- phonon-4.3.0/ds9/backend.cpp	2009-01-22 01:20:43.000000000 -0700
+++ phonon-4.3.0/ds9/backend.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -102,5 +102,4 @@
         {
             QStringList ret;
-#if (QT_VERSION >= QT_VERSION_CHECK(4, 5, 0))
             {
                 QSettings settings(QLatin1String("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Multimedia\\mplayer2\\mime types"), QSettings::NativeFormat);
@@ -113,18 +112,4 @@
 
             ret.removeDuplicates();
-#else
-            {
-                QSettings settings(QLatin1String("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Multimedia\\mplayer2\\mime types"), QSettings::NativeFormat);
-                Q_FOREACH(const QString &s, settings.childGroups())
-                  if(!ret.contains(s))
-                    ret += s;
-            }
-            {
-                QSettings settings(QLatin1String("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Multimedia\\wmplayer\\mime types"), QSettings::NativeFormat);
-                Q_FOREACH(const QString &s, settings.childGroups())
-                  if(!ret.contains(s))
-                    ret += s;
-            }
-#endif
             ret.replaceInStrings("\\", "/");
             qSort(ret);
@@ -260,6 +245,4 @@
         bool Backend::endConnectionChange(QSet<QObject *> objects)
         {
-            if (objects.isEmpty())
-                return true;
             //end of a transaction
             for(QSet<QObject *>::const_iterator it = objects.begin(); it != objects.end(); ++it) {
@@ -275,17 +258,20 @@
                             break;
                         case Phonon::PausedState:
+                            mo->transactionState = Phonon::StoppedState;
                             mo->pause();
                             break;
                         default:
+                            mo->transactionState = Phonon::StoppedState;
                             mo->play();
                             break;
                         }
 
-                        return mo->state() != Phonon::ErrorState;
+                        if (mo->state() == Phonon::ErrorState)
+                            return false;
                     }
                 }
             }
 
-            return false;
+            return true;
         }
 
@@ -293,7 +279,4 @@
         bool Backend::startConnectionChange(QSet<QObject *> objects)
         {
-            if (objects.isEmpty())
-                return true;
-
             //let's save the state of the graph (before we stop it)
             for(QSet<QObject *>::const_iterator it = objects.begin(); it != objects.end(); ++it) {
@@ -303,11 +286,12 @@
                             mo->transactionState = mo->state();
                             mo->ensureStopped(); //we have to stop the graph..
+                            if (mo->state() == Phonon::ErrorState)
+                                return false;
                         }
-                        return true;
                     }
                 }
             }
 
-            return false;
+            return true;
         }
 
diff -r -U2 -N phonon-4.3.0/ds9/backend.h phonon-4.3.0/ds9/backend.h
--- phonon-4.3.0/ds9/backend.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/backend.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/backendnode.cpp phonon-4.3.0/ds9/backendnode.cpp
--- phonon-4.3.0/ds9/backendnode.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/backendnode.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/backendnode.h phonon-4.3.0/ds9/backendnode.h
--- phonon-4.3.0/ds9/backendnode.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/backendnode.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/CMakeLists.txt phonon-4.3.0/ds9/CMakeLists.txt
--- phonon-4.3.0/ds9/CMakeLists.txt	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/CMakeLists.txt	2009-03-19 13:32:53.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 #
 # This library is free software: you can redistribute it and/or modify
@@ -41,12 +41,13 @@
 
     add_definitions(-DPHONON_MAKE_QT_ONLY_BACKEND -DUNICODE)
-    automoc4_add_library(phonon_ds9 SHARED ${phonon_ds9_SRCS})
+    automoc4_add_library(phonon_ds9 MODULE ${phonon_ds9_SRCS})
     set_target_properties(phonon_ds9 PROPERTIES PREFIX "")
     target_link_libraries(phonon_ds9
                 ${PHONON_LIBS}  ${QT_QTOPENGL_LIBRARY} ${OPENGL_gl_LIBRARY}
                 dxguid strmiids dmoguids msdmo ole32 oleaut32 uuid gdi32)
+    # 'MODULE' is treated as a LIBRARY
     install(TARGETS phonon_ds9
 	    RUNTIME DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
-	    LIBRARY DESTINATION ${LIB_INSTALL_DIR}
+	    LIBRARY DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
 	    ARCHIVE DESTINATION ${LIB_INSTALL_DIR})
     install(FILES ds9.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
diff -r -U2 -N phonon-4.3.0/ds9/compointer.h phonon-4.3.0/ds9/compointer.h
--- phonon-4.3.0/ds9/compointer.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/compointer.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/ConfigureChecks.cmake phonon-4.3.0/ds9/ConfigureChecks.cmake
--- phonon-4.3.0/ds9/ConfigureChecks.cmake	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/ConfigureChecks.cmake	2009-02-23 09:48:10.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 #
 # This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/ds9.desktop phonon-4.3.0/ds9/ds9.desktop
--- phonon-4.3.0/ds9/ds9.desktop	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/ds9.desktop	2010-02-04 04:25:54.000000000 -0700
@@ -10,27 +10,80 @@
 
 Name=DirectShow9
+Name[bg]=DirectShow9
+Name[ca]=DirectShow9
+Name[ca@valencia]=DirectShow9
+Name[cs]=DirectShow9
+Name[da]=DirectShow9
+Name[de]=DirectShow9
+Name[el]=DirectShow9
+Name[en_GB]=DirectShow9
+Name[es]=DirectShow9
+Name[et]=DirectShow9
+Name[eu]=DirectShow9
+Name[fi]=DirectShow9
+Name[fr]=DirectShow9
+Name[ga]=DirectShow9
+Name[gl]=DirectShow9
+Name[hr]=DirectShow9
+Name[hsb]=DirectShow9
+Name[hu]=DirectShow9
+Name[id]=DirectShow9
+Name[is]=DirectShow9
+Name[it]=DirectShow9
+Name[ja]=DirectShow9
+Name[ko]=DirectShow9
+Name[ku]=DirectShow9
+Name[lt]=DirectShow9
+Name[lv]=DirectShow9
+Name[nb]=DirectShow9
+Name[nds]=DirectShow9
+Name[nl]=DirectShow9
+Name[nn]=DirectShow9
 Name[pa]=ਡਾਇਰੈਕਸ਼ੋ9
+Name[pl]=DirectShow9
+Name[pt]=DirectShow9
+Name[pt_BR]=DirectShow9
+Name[ru]=DirectShow9
+Name[se]=DirectShow9
 Name[sk]=DirectShow 9
 Name[sl]=DirectShow 9
 Name[sr]=Директшоу‑9
+Name[sr@ijekavian]=Директшоу‑9
+Name[sr@ijekavianlatin]=DirectShow‑9
 Name[sr@latin]=DirectShow‑9
 Name[sv]=Directshow 9
+Name[tr]=DirectShow9
+Name[uk]=DirectShow9
 Name[x-test]=xxDirectShow9xx
+Name[zh_CN]=DirectShow9
+Name[zh_TW]=DirectShow9
 
 Comment=Phonon DirectShow9 backend
 Comment[bg]=Phonon DirectShow9
 Comment[ca]=Dorsal DirectShow9 del Phonon
+Comment[ca@valencia]=Dorsal DirectShow9 del Phonon
+Comment[cs]=Phonon DirectShow9 backend
 Comment[da]=DirectShow9-backend til Phonon
 Comment[de]=Phonon-Treiber für DirectShow9
 Comment[el]=Σύστημα υποστήριξης DirectShow9 του Phonon
+Comment[en_GB]=Phonon DirectShow9 backend
 Comment[es]=Motor DirectShow9 para Phonon
 Comment[et]=Phononi DirectShow9 taustaprogramm
+Comment[eu]=Phonon DirectShow9 backend
+Comment[fi]=Phonon DirectShow9-taustaohjelma
 Comment[fr]=Système de gestion DirectShow9 pour Phonon 
 Comment[ga]=Inneall DirectShow9 le haghaidh Phonon
 Comment[gl]=Infraestrutura de DirectShow9 para Phonon
+Comment[hsb]=Phonon DirectShow9 backend
+Comment[hu]=Phonon DirectShow9 modul
+Comment[id]=Phonon DirectShow9 backend
+Comment[is]=Phonon DirectShow9 bakendi
 Comment[it]=Motore DirectShow9 di Phonon
 Comment[ja]=Phonon DirectShow9 バックエンド
 Comment[ko]=Phonon DirectShow9 백엔드
+Comment[ku]=Binesaza Phonon DirectShow9
+Comment[lt]=Phonon DirectShow9 galinė sąsaja
 Comment[lv]=Phonon DirectShow9 aizmugure
+Comment[nb]=Phonon-motor for DirectShow9
 Comment[nds]=Phonon-Hülpprogrmm DirectShow9
 Comment[nl]=DirectShow9-backend (Phonon)
@@ -40,7 +93,11 @@
 Comment[pt]=Infra-estrutura do DirectShow9 para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon DirectShow9
+Comment[ru]=Механизм DirectShow9 для Phonon
+Comment[se]=Phonon DirectShow9 duogášmohtor
 Comment[sk]=Phonon DirectShow 9 podsystém
 Comment[sl]=Phononova Hrbtenica DirectShow 9
 Comment[sr]=Директшоу‑9 као позадина Фонона
+Comment[sr@ijekavian]=Директшоу‑9 као позадина Фонона
+Comment[sr@ijekavianlatin]=DirectShow‑9 kao pozadina Phonona
 Comment[sr@latin]=DirectShow‑9 kao pozadina Phonona
 Comment[sv]=Phonon Directshow 9-gränssnitt
diff -r -U2 -N phonon-4.3.0/ds9/effect.cpp phonon-4.3.0/ds9/effect.cpp
--- phonon-4.3.0/ds9/effect.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/effect.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/effect.h phonon-4.3.0/ds9/effect.h
--- phonon-4.3.0/ds9/effect.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/effect.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/fakesource.cpp phonon-4.3.0/ds9/fakesource.cpp
--- phonon-4.3.0/ds9/fakesource.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/fakesource.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/fakesource.h phonon-4.3.0/ds9/fakesource.h
--- phonon-4.3.0/ds9/fakesource.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/fakesource.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/iodevicereader.cpp phonon-4.3.0/ds9/iodevicereader.cpp
--- phonon-4.3.0/ds9/iodevicereader.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/iodevicereader.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/iodevicereader.h phonon-4.3.0/ds9/iodevicereader.h
--- phonon-4.3.0/ds9/iodevicereader.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/iodevicereader.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/mediagraph.cpp phonon-4.3.0/ds9/mediagraph.cpp
--- phonon-4.3.0/ds9/mediagraph.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/mediagraph.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -123,10 +123,4 @@
                 return;
             }
-
-            connect(mo->workerThread(), SIGNAL(asyncRenderFinished(quint16, HRESULT, Graph)),
-                SLOT(finishLoading(quint16, HRESULT, Graph)));
-
-            connect(mo->workerThread(), SIGNAL(asyncSeekingFinished(quint16, qint64)),
-                SLOT(finishSeeking(quint16, qint64)));
         }
 
@@ -548,5 +542,5 @@
                         }
                     }
-                    //we shoud never go here
+                    //we should never go here
                     return false;
                 } else {
@@ -827,5 +821,5 @@
             for (int i = 0; i < connections.count(); ++i) {
                 const GraphConnection &connection = connections.at(i);
-                //check if we shoud transfer the sink node
+                //check if we should transfer the sink node
 
                 grabFilter(connection.input);
@@ -1104,4 +1098,2 @@
 
 QT_END_NAMESPACE
-
-#include "moc_mediagraph.cpp"
diff -r -U2 -N phonon-4.3.0/ds9/mediagraph.h phonon-4.3.0/ds9/mediagraph.h
--- phonon-4.3.0/ds9/mediagraph.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/mediagraph.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -38,5 +38,4 @@
         class MediaGraph : public QObject
         {
-            Q_OBJECT
         public:
             MediaGraph(MediaObject *mo, short index);
@@ -91,5 +90,4 @@
             Graph graph() const;
 
-        private Q_SLOTS:
             void finishLoading(quint16 workId, HRESULT hr, Graph);
             void finishSeeking(quint16 workId, qint64 time);
diff -r -U2 -N phonon-4.3.0/ds9/mediaobject.cpp phonon-4.3.0/ds9/mediaobject.cpp
--- phonon-4.3.0/ds9/mediaobject.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/mediaobject.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -53,6 +53,4 @@
           : QThread(), m_currentRenderId(0), m_finished(false), m_currentWorkId(1)
         {
-            //TODO: find a replacement
-//            m_handles << m_waitCondition;
         }
 
@@ -368,4 +366,5 @@
 
         MediaObject::MediaObject(QObject *parent) : BackendNode(parent),
+            transactionState(Phonon::StoppedState),
             m_errorType(Phonon::NoError),
             m_state(Phonon::LoadingState),
@@ -386,5 +385,5 @@
 
             for(int i = 0; i < FILTER_COUNT; ++i) {
-                m_graphs[i] = new MediaGraph(this, i);
+                m_graphs[i] = new MediaGraph(this, i);                
             }
 
@@ -394,7 +393,12 @@
             connect(&m_thread, SIGNAL(eventReady(Graph, long, long)), 
                                SLOT(handleEvents(Graph, long, long)));
+
+            connect(&m_thread, SIGNAL(asyncRenderFinished(quint16, HRESULT, Graph)),
+                SLOT(finishLoading(quint16, HRESULT, Graph)));
+
+            connect(&m_thread, SIGNAL(asyncSeekingFinished(quint16, qint64)),
+                SLOT(finishSeeking(quint16, qint64)));
             //really special case
             m_mediaObject = this;
-
             m_thread.start();
         }
@@ -964,4 +968,19 @@
         }
 
+        void MediaObject::finishLoading(quint16 workId, HRESULT hr, Graph graph)
+        {
+            for(int i = 0; i < FILTER_COUNT; ++i) {
+                m_graphs[i]->finishLoading(workId, hr, graph);
+            }
+        }
+
+        void MediaObject::finishSeeking(quint16 workId, qint64 time)
+        {
+            for(int i = 0; i < FILTER_COUNT; ++i) {
+                m_graphs[i]->finishSeeking(workId, time);
+            }
+        }
+
+
         void MediaObject::handleEvents(Graph graph, long eventCode, long param1)
         {
diff -r -U2 -N phonon-4.3.0/ds9/mediaobject.h phonon-4.3.0/ds9/mediaobject.h
--- phonon-4.3.0/ds9/mediaobject.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/mediaobject.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -227,4 +227,6 @@
             void slotStateReady(Graph, Phonon::State);
             void handleEvents(Graph, long eventCode, long param1);
+            void finishLoading(quint16 workId, HRESULT hr, Graph);
+            void finishSeeking(quint16 workId, qint64 time);
 
          Q_SIGNALS:
diff -r -U2 -N phonon-4.3.0/ds9/phononds9_namespace.h phonon-4.3.0/ds9/phononds9_namespace.h
--- phonon-4.3.0/ds9/phononds9_namespace.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/phononds9_namespace.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qasyncreader.cpp phonon-4.3.0/ds9/qasyncreader.cpp
--- phonon-4.3.0/ds9/qasyncreader.cpp	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/qasyncreader.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qasyncreader.h phonon-4.3.0/ds9/qasyncreader.h
--- phonon-4.3.0/ds9/qasyncreader.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qasyncreader.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qaudiocdreader.cpp phonon-4.3.0/ds9/qaudiocdreader.cpp
--- phonon-4.3.0/ds9/qaudiocdreader.cpp	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/qaudiocdreader.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qaudiocdreader.h phonon-4.3.0/ds9/qaudiocdreader.h
--- phonon-4.3.0/ds9/qaudiocdreader.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/qaudiocdreader.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qbasefilter.cpp phonon-4.3.0/ds9/qbasefilter.cpp
--- phonon-4.3.0/ds9/qbasefilter.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qbasefilter.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qbasefilter.h phonon-4.3.0/ds9/qbasefilter.h
--- phonon-4.3.0/ds9/qbasefilter.h	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/ds9/qbasefilter.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qmeminputpin.cpp phonon-4.3.0/ds9/qmeminputpin.cpp
--- phonon-4.3.0/ds9/qmeminputpin.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qmeminputpin.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qmeminputpin.h phonon-4.3.0/ds9/qmeminputpin.h
--- phonon-4.3.0/ds9/qmeminputpin.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qmeminputpin.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qpin.cpp phonon-4.3.0/ds9/qpin.cpp
--- phonon-4.3.0/ds9/qpin.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qpin.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/qpin.h phonon-4.3.0/ds9/qpin.h
--- phonon-4.3.0/ds9/qpin.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/qpin.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/videorenderer_soft.cpp phonon-4.3.0/ds9/videorenderer_soft.cpp
--- phonon-4.3.0/ds9/videorenderer_soft.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videorenderer_soft.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -739,7 +739,8 @@
                 m_sampleBuffer->GetPointer(&data);
 
+
                 //let's update the current image
                 if (m_inputPin->connectedType().subtype == MEDIASUBTYPE_YV12) {
-                    convertYUY2toRGB(data, m_size, m_currentImage,
+                    convertYV12toRGB(data, m_size, m_currentImage,
                         m_brightness, m_contrast, m_hue, m_saturation);
                 } else if (m_inputPin->connectedType().subtype == MEDIASUBTYPE_YUY2) {
diff -r -U2 -N phonon-4.3.0/ds9/videorenderer_soft.h phonon-4.3.0/ds9/videorenderer_soft.h
--- phonon-4.3.0/ds9/videorenderer_soft.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videorenderer_soft.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/videorenderer_vmr9.cpp phonon-4.3.0/ds9/videorenderer_vmr9.cpp
--- phonon-4.3.0/ds9/videorenderer_vmr9.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videorenderer_vmr9.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/videorenderer_vmr9.h phonon-4.3.0/ds9/videorenderer_vmr9.h
--- phonon-4.3.0/ds9/videorenderer_vmr9.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videorenderer_vmr9.h	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/videowidget.cpp phonon-4.3.0/ds9/videowidget.cpp
--- phonon-4.3.0/ds9/videowidget.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videowidget.cpp	2009-04-22 08:48:59.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -176,12 +176,6 @@
 
             for(int i = 0; i< FILTER_COUNT ;++i) {
-                //First we try the native renderer
+                //This might return a non native (ie Qt) renderer in case native is not supported
                 AbstractVideoRenderer *renderer = getRenderer(i, Native, true);
-                if (renderer->getFilter() == 0) {
-                    m_noNativeRendererSupported = true;
-                    delete renderer;
-                    //if it fails, we create the software renderer
-                    renderer = getRenderer(i, NonNative, true);
-                }
                 m_filters[i] = renderer->getFilter();
             }
@@ -252,5 +246,8 @@
 
             //we determine dynamically if it is native or non native
-            m_widget->setCurrentRenderer(getRenderer(index, !r || r->isNative() ? Native : NonNative));
+            r = getRenderer(index, !r || r->isNative() ? Native : NonNative);
+			if (!r)
+				r = getRenderer(index, NonNative);
+            m_widget->setCurrentRenderer(r);
         }
 
@@ -333,10 +330,27 @@
         AbstractVideoRenderer *VideoWidget::getRenderer(int graphIndex, RendererType type, bool autoCreate)
         {
-            const int index = graphIndex * 2 + type;
+            int index = graphIndex * 2 + type;
             if (m_renderers[index] == 0 && autoCreate) {
-                if (type == Native)
-                    m_renderers[index] = new VideoRendererVMR9(m_widget);
-                else
-                    m_renderers[index] = new VideoRendererSoft(m_widget);
+                AbstractVideoRenderer *renderer = 0;
+				if (type == Native) {
+                    renderer = new VideoRendererVMR9(m_widget);
+                    if (renderer->getFilter() == 0) {
+                        //instanciating the renderer might fail with error VFW_E_DDRAW_CAPS_NOT_SUITABLE (0x80040273)
+                        m_noNativeRendererSupported = true;
+                        delete renderer;
+                        renderer = 0;
+                    }
+                }
+
+                if (renderer == 0) {
+                    type = NonNative;
+                    index = graphIndex * 2 + type;
+                    if (m_renderers[index] == 0)
+                        renderer = new VideoRendererSoft(m_widget); //this always succeeds
+                    else
+                        renderer = m_renderers[index];
+                }
+
+                m_renderers[index] = renderer;
 
                 //be sure to update all the things that needs an update
diff -r -U2 -N phonon-4.3.0/ds9/videowidget.h phonon-4.3.0/ds9/videowidget.h
--- phonon-4.3.0/ds9/videowidget.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/videowidget.h	2009-04-22 08:48:59.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/volumeeffect.cpp phonon-4.3.0/ds9/volumeeffect.cpp
--- phonon-4.3.0/ds9/volumeeffect.cpp	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/volumeeffect.cpp	2009-02-23 09:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/ds9/volumeeffect.h phonon-4.3.0/ds9/volumeeffect.h
--- phonon-4.3.0/ds9/volumeeffect.h	2009-01-08 07:47:17.000000000 -0700
+++ phonon-4.3.0/ds9/volumeeffect.h	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -48,5 +48,5 @@
             float m_volume;
 
-            //paramaters used to fade
+            //parameters used to fade
             Phonon::VolumeFaderEffect::FadeCurve m_fadeCurve;
 
diff -r -U2 -N phonon-4.3.0/gstreamer/abstractrenderer.cpp phonon-4.3.0/gstreamer/abstractrenderer.cpp
--- phonon-4.3.0/gstreamer/abstractrenderer.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/abstractrenderer.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -44,4 +44,9 @@
 }
 
+void AbstractRenderer::movieSizeChanged(const QSize &size)
+{
+    Q_UNUSED(size);
+}
+
 }
 } //namespace Phonon::Gstreamer
diff -r -U2 -N phonon-4.3.0/gstreamer/abstractrenderer.h phonon-4.3.0/gstreamer/abstractrenderer.h
--- phonon-4.3.0/gstreamer/abstractrenderer.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/abstractrenderer.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2    //Copyright (C) 2007 Trolltech ASA. All rights reserved.007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2    //Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).007 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -44,4 +44,5 @@
     virtual void aspectRatioChanged(Phonon::VideoWidget::AspectRatio aspectRatio);
     virtual void scaleModeChanged(Phonon::VideoWidget::ScaleMode scaleMode);
+    virtual void movieSizeChanged(const QSize &movieSize);
     virtual void handleMediaNodeEvent(const MediaNodeEvent *event) = 0;
     virtual bool eventFilter(QEvent *) = 0;
diff -r -U2 -N phonon-4.3.0/gstreamer/artssink.cpp phonon-4.3.0/gstreamer/artssink.cpp
--- phonon-4.3.0/gstreamer/artssink.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/artssink.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -196,8 +196,12 @@
 static void arts_sink_base_init (gpointer g_class) {
     GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
-    GstElementDetails details = GST_ELEMENT_DETAILS ("Experimental aRts sink",
-                                          "Sink/Audio",
-                                          "aRts Audio Output Device",
-                                          "Trolltech ASA <info@trolltech.com>");
+    static gchar longname[] = "Experimental aRts sink",
+                    klass[] = "Sink/Audio",
+              description[] = "aRts Audio Output Device",
+                   author[] = "Nokia Corporation and/or its subsidiary(-ies) <qt-info@nokia.com>";
+    GstElementDetails details = GST_ELEMENT_DETAILS (longname,
+                                          klass,
+                                          description,
+                                          author);
     gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&sinktemplate));
     gst_element_class_set_details (gstelement_class, &details);
diff -r -U2 -N phonon-4.3.0/gstreamer/artssink.h phonon-4.3.0/gstreamer/artssink.h
--- phonon-4.3.0/gstreamer/artssink.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/artssink.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/audiodataoutput.cpp phonon-4.3.0/gstreamer/audiodataoutput.cpp
--- phonon-4.3.0/gstreamer/audiodataoutput.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/gstreamer/audiodataoutput.cpp	2009-08-17 10:50:55.000000000 -0700
@@ -0,0 +1,143 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "gsthelper.h"
+#include "medianode.h"
+#include "mediaobject.h"
+#include <QtCore/QVector>
+#include <QtCore/QMap>
+#include <phonon/audiooutput.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+AudioDataOutput::AudioDataOutput(Backend *backend, QObject *parent)
+    : QObject(parent),
+    MediaNode(backend, AudioSink | AudioSource)
+{
+    static int count = 0;
+    m_name = "AudioDataOutput" + QString::number(count++);
+
+    m_queue = gst_element_factory_make ("identity", NULL);
+    gst_object_ref(m_queue);
+    m_isValid = true;
+}
+
+AudioDataOutput::~AudioDataOutput()
+{
+    gst_element_set_state(m_queue, GST_STATE_NULL);
+    gst_object_unref(m_queue);
+}
+
+int AudioDataOutput::dataSize() const
+{
+    return m_dataSize;
+}
+
+int AudioDataOutput::sampleRate() const
+{
+    return 44100;
+}
+
+void AudioDataOutput::setDataSize(int size)
+{
+    m_dataSize = size;
+}
+
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<float> > FloatMap;
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > IntMap;
+
+inline void AudioDataOutput::convertAndEmit(const QVector<qint16> &leftBuffer, const QVector<qint16> &rightBuffer)
+{
+    //TODO: Floats
+    IntMap map;
+    map.insert(Phonon::AudioDataOutput::LeftChannel, leftBuffer);
+    map.insert(Phonon::AudioDataOutput::RightChannel, rightBuffer);
+    emit dataReady(map);
+}
+
+void AudioDataOutput::processBuffer(GstPad*, GstBuffer* buffer, gpointer gThat)
+{
+    // TODO emit endOfMedia
+    AudioDataOutput *that = reinterpret_cast<AudioDataOutput*>(gThat);
+
+    // determine the number of channels
+    GstStructure* structure = gst_caps_get_structure (GST_BUFFER_CAPS(buffer), 0);
+    gst_structure_get_int (structure, "channels", &that->m_channels);
+
+    if (that->m_channels > 2 || that->m_channels < 0) {
+        qWarning() << Q_FUNC_INFO << ": Number of channels not supported: " << that->m_channels;
+        return;
+    }
+
+    gint16 *data = reinterpret_cast<gint16*>(GST_BUFFER_DATA(buffer));
+    guint size = GST_BUFFER_SIZE(buffer) / sizeof(gint16);
+
+    that->m_pendingData.reserve(that->m_pendingData.size() + size);
+
+    for (uint i=0; i<size; i++) {
+        // 8 bit? interleaved? yay for lacking documentation!
+        that->m_pendingData.append(data[i]);
+    }
+
+    while (that->m_pendingData.size() > that->m_dataSize * that->m_channels) {
+        if (that->m_channels == 1) {
+            QVector<qint16> intBuffer(that->m_dataSize);
+            memcpy(intBuffer.data(), that->m_pendingData.constData(), that->m_dataSize * sizeof(qint16));
+
+            that->convertAndEmit(intBuffer, intBuffer);
+            int newSize = that->m_pendingData.size() - that->m_dataSize;
+            memmove(that->m_pendingData.data(), that->m_pendingData.constData() + that->m_dataSize, newSize * sizeof(qint16));
+            that->m_pendingData.resize(newSize);
+        } else {
+            QVector<qint16> left(that->m_dataSize), right(that->m_dataSize);
+            for (int i=0; i<that->m_dataSize; i++) {
+                left[i] = that->m_pendingData[i*2];
+                right[i] = that->m_pendingData[i*2+1];
+            }
+            that->m_pendingData.resize(that->m_pendingData.size() - that->m_dataSize*2);
+            that->convertAndEmit(left, right);
+        }
+    }
+}
+
+void AudioDataOutput::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    if (event->type() == MediaNodeEvent::MediaObjectConnected && root()) {
+        g_object_set(G_OBJECT(audioElement()), "sync", true, (const char*)NULL);
+        GstPad *audiopad = gst_element_get_pad (audioElement(), "src");
+        gst_pad_add_buffer_probe (audiopad, G_CALLBACK(processBuffer), this);
+        gst_object_unref (audiopad);
+        return;
+    }
+
+    MediaNode::mediaNodeEvent(event);
+}
+
+}} //namespace Phonon::Gstreamer
+
+#include "moc_audiodataoutput.cpp"
+// vim: sw=4 ts=4
+
diff -r -U2 -N phonon-4.3.0/gstreamer/audiodataoutput.h phonon-4.3.0/gstreamer/audiodataoutput.h
--- phonon-4.3.0/gstreamer/audiodataoutput.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/gstreamer/audiodataoutput.h	2009-08-12 15:26:02.000000000 -0700
@@ -0,0 +1,84 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+#define Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+
+#include "abstractaudiooutput.h"
+#include "backend.h"
+#include "medianode.h"
+#include <phonon/audiodataoutput.h>
+#include <phonon/audiodataoutputinterface.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+    /**
+     * \author Martin Sandsmark <sandsmark@samfundet.no>
+     */
+    class AudioDataOutput : public QObject,
+                            public AudioDataOutputInterface,
+                            public MediaNode
+    {
+        Q_OBJECT
+        Q_INTERFACES(Phonon::AudioDataOutputInterface Phonon::Gstreamer::MediaNode)
+
+        public:
+            AudioDataOutput(Backend *, QObject *);
+            ~AudioDataOutput();
+
+        public Q_SLOTS:
+            int dataSize() const;
+            int sampleRate() const;
+            void setDataSize(int size);
+
+        public:
+            /// callback function for handling new audio data
+            static void processBuffer(GstPad*, GstBuffer*, gpointer);
+
+            Phonon::AudioDataOutput* frontendObject() const { return m_frontend; }
+            void setFrontendObject(Phonon::AudioDataOutput *frontend) { m_frontend = frontend; }
+
+            GstElement *audioElement() { return m_queue; }
+
+            void mediaNodeEvent(const MediaNodeEvent *event);
+
+
+        signals:
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<float> > &data);
+            void endOfMedia(int remainingSamples);
+
+        private:
+            void convertAndEmit(const QVector<qint16>&, const QVector<qint16>&);
+
+            GstElement *m_queue;
+            int m_dataSize;
+            QVector<qint16> m_pendingData;
+            Phonon::AudioDataOutput *m_frontend;
+            int m_channels;
+    };
+}} //namespace Phonon::Gstreamer
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_FAKE_AUDIODATAOUTPUT_H
diff -r -U2 -N phonon-4.3.0/gstreamer/audioeffect.cpp phonon-4.3.0/gstreamer/audioeffect.cpp
--- phonon-4.3.0/gstreamer/audioeffect.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/audioeffect.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/audioeffect.h phonon-4.3.0/gstreamer/audioeffect.h
--- phonon-4.3.0/gstreamer/audioeffect.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/audioeffect.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/audiooutput.cpp phonon-4.3.0/gstreamer/audiooutput.cpp
--- phonon-4.3.0/gstreamer/audiooutput.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/audiooutput.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
     Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
 
@@ -42,5 +42,4 @@
     static int count = 0;
     m_name = "AudioOutput" + QString::number(count++);
-
     if (m_backend->isValid()) {
         m_audioBin = gst_bin_new (NULL);
@@ -126,4 +125,6 @@
 bool AudioOutput::setOutputDevice(int newDevice)
 {
+    m_backend->logMessage(Q_FUNC_INFO + QString::number(newDevice), Backend::Info, this);
+
     if (newDevice == m_device)
         return true;
@@ -136,10 +137,9 @@
 
     bool success = false;
-    const QList<AudioDevice> deviceList = m_backend->deviceManager()->audioOutputDevices();
-    if (m_audioSink &&  newDevice >= 0 && newDevice < deviceList.size()) {
+    if (m_audioSink &&  newDevice >= 0) {
         // Save previous state
         GstState oldState = GST_STATE(m_audioSink);
         const QByteArray oldDeviceValue = GstHelper::property(m_audioSink, "device");
-        const QByteArray deviceId = deviceList.at(newDevice).gstId;
+        const QByteArray deviceId = m_backend->deviceManager()->gstId(newDevice);
         m_device = newDevice;
 
@@ -151,8 +151,17 @@
         }
         if (!success) { // Revert state
+            m_backend->logMessage(Q_FUNC_INFO +
+                                  QLatin1String(" Failed to change device ") +
+                                  deviceId, Backend::Info, this);
+
             GstHelper::setProperty(m_audioSink, "device", oldDeviceValue);
             gst_element_set_state(m_audioSink, oldState);
+        } else {
+            m_backend->logMessage(Q_FUNC_INFO +
+                                  QLatin1String(" Successfully changed device ") +
+                                  deviceId, Backend::Info, this);
         }
-        // Note the stopped state should not really be neccessary, but seems to be required to 
+
+        // Note the stopped state should not really be necessary, but seems to be required to
         // properly reset after changing the audio state
         if (root()) {
@@ -167,5 +176,5 @@
 bool AudioOutput::setOutputDevice(const AudioOutputDevice &newDevice)
 {
-    qDebug() << Q_FUNC_INFO << newDevice;
+    m_backend->logMessage(Q_FUNC_INFO, Backend::Info, this);
     if (!m_audioSink || !newDevice.isValid()) {
         return false;
@@ -203,5 +212,4 @@
         deviceIds += deviceIdsProperty.toString();
     }
-    qDebug() << Q_FUNC_INFO << deviceIds;
 
     // We test if the device can be opened by checking if it can go from NULL to READY state
@@ -209,7 +217,9 @@
         gst_element_set_state(m_audioSink, GST_STATE_NULL);
         if (GstHelper::setProperty(m_audioSink, "device", deviceId.toUtf8())) {
-            qDebug() << Q_FUNC_INFO << "setProperty(device," << deviceId.toUtf8() << ") succeeded";
+            m_backend->logMessage(Q_FUNC_INFO + QLatin1String("setProperty(device,") +
+                                  deviceId + QLatin1String(") succeeded"), Backend::Info, this);
             if (gst_element_set_state(m_audioSink, oldState) == GST_STATE_CHANGE_SUCCESS) {
-                qDebug() << Q_FUNC_INFO << "go to old state on device" << deviceId.toUtf8() << " succeeded";
+                m_backend->logMessage(Q_FUNC_INFO + QLatin1String("go to old state on device") +
+                                      deviceId + QLatin1String(" succeeded"), Backend::Info, this);
                 m_device = newDevice.index();
                 if (root()) {
@@ -219,8 +229,10 @@
                 return true;
             } else {
-                qDebug() << Q_FUNC_INFO << "go to old state on device" << deviceId.toUtf8() << " failed";
+                m_backend->logMessage(Q_FUNC_INFO + QLatin1String("go to old state on device") +
+                                      deviceId + QLatin1String(" failed"), Backend::Info, this);
             }
         } else {
-            qDebug() << Q_FUNC_INFO << "setProperty(device," << deviceId.toUtf8() << ") failed";
+            m_backend->logMessage(Q_FUNC_INFO + QLatin1String("setProperty(device,") +
+                                  deviceId + QLatin1String(") failed"), Backend::Info, this);
         }
     }
diff -r -U2 -N phonon-4.3.0/gstreamer/audiooutput.h phonon-4.3.0/gstreamer/audiooutput.h
--- phonon-4.3.0/gstreamer/audiooutput.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/audiooutput.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
     Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
 
diff -r -U2 -N phonon-4.3.0/gstreamer/backend.cpp phonon-4.3.0/gstreamer/backend.cpp
--- phonon-4.3.0/gstreamer/backend.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/backend.cpp	2010-01-30 04:47:18.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,4 +19,5 @@
 #include "backend.h"
 #include "audiooutput.h"
+#include "audiodataoutput.h"
 #include "audioeffect.h"
 #include "mediaobject.h"
@@ -27,4 +28,5 @@
 #include "volumefadereffect.h"
 #include <gst/interfaces/propertyprobe.h>
+#include <phonon/pulsesupport.h>
 
 #include <QtCore/QSet>
@@ -50,4 +52,15 @@
         , m_isValid(false)
 {
+    // Initialise PulseAudio support
+    PulseSupport *pulse = PulseSupport::getInstance();
+    pulse->enable();
+    connect(pulse, SIGNAL(objectDescriptionChanged(ObjectDescriptionType)), SIGNAL(objectDescriptionChanged(ObjectDescriptionType)));
+
+    // In order to support reloading, we only set the app name once...
+    static bool first = true;
+    if (first) {
+        first = false;
+        g_set_application_name(qApp->applicationName().toUtf8());
+    }
     GError *err = 0;
     bool wasInit = gst_init_check(0, 0, &err);  //init gstreamer: must be called before any gst-related functions
@@ -60,6 +73,6 @@
     setProperty("backendName",    QLatin1String("Gstreamer"));
     setProperty("backendComment", QLatin1String("Gstreamer plugin for Phonon"));
-    setProperty("backendVersion", QLatin1String("0.1"));
-    setProperty("backendWebsite", QLatin1String("http://www.trolltech.com/"));
+    setProperty("backendVersion", QLatin1String("0.2"));
+    setProperty("backendWebsite", QLatin1String("http://qtsoftware.com/"));
 
     //check if we should enable debug output
@@ -85,5 +98,7 @@
 Backend::~Backend() 
 {
-    gst_deinit();
+    delete m_effectManager;
+    delete m_deviceManager;
+    PulseSupport::shutdown();
 }
 
@@ -113,15 +128,12 @@
         return new MediaObject(this, parent);
 
-    case AudioOutputClass: {
-            AudioOutput *ao = new AudioOutput(this, parent);
-            m_audioOutputs.append(ao);
-            return ao;
-        }
+    case AudioOutputClass:
+        return new AudioOutput(this, parent);
+
     case EffectClass:
         return new AudioEffect(this, args[0].toInt(), parent);
 
     case AudioDataOutputClass:
-        logMessage("createObject() : AudioDataOutput not implemented");
-        break;
+        return new AudioDataOutput(this, parent);
 
     case VideoDataOutputClass:
@@ -204,6 +216,13 @@
         QString klass = gst_element_factory_get_klass(GST_ELEMENT_FACTORY(feature));
 
-        if (klass == QLatin1String("Codec/Decoder/Audio") || 
-            klass == QLatin1String("Codec/Decoder/Video")) {
+        if (klass == QLatin1String("Codec/Decoder") || 
+            klass == QLatin1String("Codec/Decoder/Audio") || 
+            klass == QLatin1String("Codec/Decoder/Video") || 
+            klass == QLatin1String("Codec/Demuxer") || 
+            klass == QLatin1String("Codec/Demuxer/Audio") || 
+            klass == QLatin1String("Codec/Demuxer/Video") || 
+            klass == QLatin1String("Codec/Parser") || 
+            klass == QLatin1String("Codec/Parser/Audio") || 
+            klass == QLatin1String("Codec/Parser/Video")) {
 
             const GList *static_templates;
@@ -227,4 +246,13 @@
     }
     g_list_free(factoryList);
+    if (availableMimeTypes.contains("audio/x-vorbis")
+        && availableMimeTypes.contains("application/x-ogm-audio")) {
+        if (!availableMimeTypes.contains("audio/x-vorbis+ogg"))
+            availableMimeTypes.append("audio/x-vorbis+ogg");
+        if (!availableMimeTypes.contains("application/ogg"))  /* *.ogg */
+            availableMimeTypes.append("application/ogg");
+        if (!availableMimeTypes.contains("audio/ogg")) /* *.oga */
+            availableMimeTypes.append("audio/ogg");
+    }
     availableMimeTypes.sort();
     return availableMimeTypes;
@@ -257,4 +285,6 @@
         }
         break;
+    default:
+        break;
     }
     return list;
@@ -274,9 +304,9 @@
     switch (type) {
     case Phonon::AudioOutputDeviceType: {
-            QList<AudioDevice> audioDevices = deviceManager()->audioOutputDevices();
-            if (index >= 0 && index < audioDevices.size()) {
-                ret.insert("name", audioDevices[index].gstId);
-                ret.insert("description", audioDevices[index].description);
-                ret.insert("icon", QLatin1String("audio-card"));
+            AudioDevice* ad;
+            if ((ad = deviceManager()->audioDevice(index))) {
+                ret.insert("name", ad->gstId);
+                ret.insert("description", ad->description);
+                ret.insert("icon", ad->icon);
             }
         }
@@ -293,4 +323,6 @@
                 Q_ASSERT(1); // Since we use list position as ID, this should not happen
         }
+    default:
+        break;
     }
     return ret;
@@ -405,5 +437,5 @@
 /**
  * Returns a debuglevel that is determined by the
- * PHONON_GSTREAMER_DEBUG environment variable.
+ * PHONON_GST_DEBUG environment variable.
  *
  *  Warning - important warnings
diff -r -U2 -N phonon-4.3.0/gstreamer/backend.h phonon-4.3.0/gstreamer/backend.h
--- phonon-4.3.0/gstreamer/backend.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/backend.h	2009-11-19 17:10:41.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -87,5 +87,4 @@
 private:
     static gboolean busCall(GstBus *bus, GstMessage *msg, gpointer data);
-    QList<QPointer<AudioOutput> > m_audioOutputs;
 
     DeviceManager *m_deviceManager;
diff -r -U2 -N phonon-4.3.0/gstreamer/CMakeLists.txt phonon-4.3.0/gstreamer/CMakeLists.txt
--- phonon-4.3.0/gstreamer/CMakeLists.txt	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/CMakeLists.txt	2009-11-29 18:04:42.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2007 Trolltech ASA. All rights reserved.
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 # Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
 #
@@ -18,11 +18,21 @@
 
 if (BUILD_PHONON_GSTREAMER)
-   include_directories(${GSTREAMER_INCLUDE_DIR} ${GLIB2_INCLUDE_DIR}
-      ${LIBXML2_INCLUDE_DIR})
+   include_directories(
+	  ${CMAKE_CURRENT_BINARY_DIR}
+	  ${GSTREAMER_INCLUDE_DIR}
+	  ${GLIB2_INCLUDE_DIR}
+      ${LIBXML2_INCLUDE_DIR}
+	  ${X11_X11_INCLUDE_PATH})
    add_definitions(-DPHONON_BACKEND_VERSION_4_2)
 
+   # configure plugin api
+   if(USE_INSTALL_PLUGIN)
+      set(PLUGIN_INSTALL_API TRUE)
+   endif(USE_INSTALL_PLUGIN)
+
+   configure_file(phonon-config-gstreamer.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/phonon-config-gstreamer.h )
+
    set(phonon_gstreamer_SRCS
       audiooutput.cpp
-      artssink.cpp
       backend.cpp
       devicemanager.cpp
@@ -40,12 +50,18 @@
       audioeffect.cpp
       abstractrenderer.cpp
-      x11renderer.cpp
       widgetrenderer.cpp
       glrenderer.cpp
       volumefadereffect.cpp
+      audiodataoutput.cpp
       )
 
-   find_package(Alsa)
-   macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   if(NOT WIN32)
+      set(phonon_gstreamer_SRCS
+          ${phonon_gstreamer_SRCS}
+          artssink.cpp
+          x11renderer.cpp)
+      macro_optional_find_package(Alsa)
+      macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   endif(NOT WIN32)
    if(ALSA_FOUND AND NOT GSTREAMER_HAS_NONBLOCKING_ALSASINK)
       add_definitions(-DUSE_ALSASINK2)
@@ -57,5 +73,5 @@
    endif(ALSA_FOUND AND NOT GSTREAMER_HAS_NONBLOCKING_ALSASINK)
 
-   automoc4_add_library(phonon_gstreamer SHARED ${phonon_gstreamer_SRCS})
+   automoc4_add_library(phonon_gstreamer MODULE ${phonon_gstreamer_SRCS})
    set_target_properties(phonon_gstreamer PROPERTIES PREFIX "")
    target_link_libraries(phonon_gstreamer
@@ -68,4 +84,7 @@
       target_link_libraries(phonon_gstreamer ${ASOUND_LIBRARY})
    endif(ALSA_FOUND)
+   if(USE_INSTALL_PLUGIN)
+       target_link_libraries(phonon_gstreamer ${GSTREAMER_PLUGIN_PBUTILS_LIBRARIES})
+   endif(USE_INSTALL_PLUGIN)
 
    install(TARGETS phonon_gstreamer DESTINATION ${PLUGIN_INSTALL_DIR}/plugins/phonon_backend)
diff -r -U2 -N phonon-4.3.0/gstreamer/common.h phonon-4.3.0/gstreamer/common.h
--- phonon-4.3.0/gstreamer/common.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/common.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/ConfigureChecks.cmake phonon-4.3.0/gstreamer/ConfigureChecks.cmake
--- phonon-4.3.0/gstreamer/ConfigureChecks.cmake	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/ConfigureChecks.cmake	2009-02-26 14:33:54.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2007 Trolltech ASA. All rights reserved.
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 #
 # This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/devicemanager.cpp phonon-4.3.0/gstreamer/devicemanager.cpp
--- phonon-4.3.0/gstreamer/devicemanager.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/devicemanager.cpp	2010-01-30 04:47:18.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -25,4 +25,5 @@
 #include "x11renderer.h"
 #include "artssink.h"
+#include "pulsesupport.h"
 
 #ifdef USE_ALSASINK2
@@ -45,7 +46,10 @@
         : gstId(gstId)
 {
-    //get an id
-    static int counter = 0;
-    id = counter++;
+    // This should never be called when PulseAudio is active.
+    Q_ASSERT(!PulseSupport::getInstance()->isActive());
+
+    id = manager->allocateDeviceId();
+    icon = "audio-card";
+
     //get name from device
     if (gstId == "default") {
@@ -72,12 +76,18 @@
         : QObject(backend)
         , m_backend(backend)
+        , m_audioDeviceCounter(0)
 {
     QSettings settings(QLatin1String("Trolltech"));
     settings.beginGroup(QLatin1String("Qt"));
 
+    PulseSupport *pulse = PulseSupport::getInstance();
     m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
     if (m_audioSink.isEmpty()) {
         m_audioSink = settings.value(QLatin1String("audiosink"), "Auto").toByteArray().toLower();
+        if (m_audioSink == "auto" && pulse->isActive())
+            m_audioSink = "pulsesink";
     }
+    if ("pulsesink" != m_audioSink)
+        pulse->enable(false);
 
     m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
@@ -235,7 +245,5 @@
         sink = gst_element_factory_make("fakesink", NULL);
         if (sink) {
-            if (m_backend) {
-                m_backend->logMessage("AudioOutput Using fake audio sink");
-            }
+            m_backend->logMessage("AudioOutput Using fake audio sink");
             //without sync the sink will pull the pipeline as fast as the CPU allows
             g_object_set (G_OBJECT (sink), "sync", TRUE, (const char*)NULL);
@@ -269,7 +277,15 @@
 }
 
-/*
- * Returns a positive device id or -1 if device
- * does not exist
+/**
+ * Allocate a device id for a new audio device
+ */
+int DeviceManager::allocateDeviceId()
+{
+    return m_audioDeviceCounter++;
+}
+
+
+/**
+ * Returns a positive device id or -1 if device does not exist
  *
  * The gstId is typically in the format hw:1,0
@@ -286,14 +302,28 @@
 
 /**
- * Get a human-readable description from a device id
+ * Returns a gstId or "default" if device does not exist
+ *
+ * The gstId is typically in the format hw:1,0
  */
-QByteArray DeviceManager::deviceDescription(int id) const
+const QByteArray DeviceManager::gstId(int deviceId)
+{
+    if (!PulseSupport::getInstance()->isActive()) {
+        AudioDevice *ad = audioDevice(deviceId);
+        if (ad)
+            return QByteArray(ad->gstId);
+    }
+    return QByteArray("default");
+}
+
+/**
+* Get the AudioDevice for a given device id
+*/
+AudioDevice* DeviceManager::audioDevice(int id)
 {
     for (int i = 0 ; i < m_audioDeviceList.size() ; ++i) {
-        if (m_audioDeviceList[i].id == id) {
-            return m_audioDeviceList[i].description;
-        }
+        if (m_audioDeviceList[i].id == id)
+            return &m_audioDeviceList[i];
     }
-    return QByteArray();
+    return NULL;
 }
 
@@ -309,6 +339,9 @@
 
     if (audioSink) {
-        list = GstHelper::extractProperties(audioSink, "device");
-        list.prepend("default");
+        if (!PulseSupport::getInstance()->isActive()) {
+            // If we're using pulse, the PulseSupport class takes care of things for us.
+            list = GstHelper::extractProperties(audioSink, "device");
+            list.prepend("default");
+        }
 
         for (int i = 0 ; i < list.size() ; ++i) {
diff -r -U2 -N phonon-4.3.0/gstreamer/devicemanager.h phonon-4.3.0/gstreamer/devicemanager.h
--- phonon-4.3.0/gstreamer/devicemanager.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/devicemanager.h	2009-11-19 17:09:28.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -43,4 +43,5 @@
     QByteArray gstId;
     QByteArray description;
+    QString icon;
 };
 
@@ -52,6 +53,8 @@
     const QList<AudioDevice> audioOutputDevices() const;
     GstPad *requestPad(int device) const;
+    int allocateDeviceId();
     int deviceId(const QByteArray &gstId) const;
-    QByteArray deviceDescription(int id) const;
+    const QByteArray gstId(int id);
+    AudioDevice* audioDevice(int id);
     GstElement *createGNOMEAudioSink(Category category);
     GstElement *createAudioSink(Category category = NoCategory);
@@ -69,4 +72,5 @@
     Backend *m_backend;
     QList <AudioDevice> m_audioDeviceList;
+    int m_audioDeviceCounter;
     QTimer m_devicePollTimer;
     QByteArray m_audioSink;
diff -r -U2 -N phonon-4.3.0/gstreamer/effect.cpp phonon-4.3.0/gstreamer/effect.cpp
--- phonon-4.3.0/gstreamer/effect.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/effect.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/effect.h phonon-4.3.0/gstreamer/effect.h
--- phonon-4.3.0/gstreamer/effect.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/effect.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/effectmanager.cpp phonon-4.3.0/gstreamer/effectmanager.cpp
--- phonon-4.3.0/gstreamer/effectmanager.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/effectmanager.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -55,5 +55,5 @@
             // "equalizer-nbands" not really useful at the moment
 
-            // These plugins simply dont work or have major stability issues:
+            // These plugins simply don't work or have major stability issues:
             // "iir" Does not seem to do much at the moment
             // "audioinvert" Only works for some streams, should be invesigated
diff -r -U2 -N phonon-4.3.0/gstreamer/effectmanager.h phonon-4.3.0/gstreamer/effectmanager.h
--- phonon-4.3.0/gstreamer/effectmanager.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/effectmanager.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/glrenderer.cpp phonon-4.3.0/gstreamer/glrenderer.cpp
--- phonon-4.3.0/gstreamer/glrenderer.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/glrenderer.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -267,5 +267,5 @@
     setPalette(palette);
     setAutoFillBackground(true);
-    // Videowidget allways have this property to allow hiding the mouse cursor
+    // Videowidget always have this property to allow hiding the mouse cursor
     setMouseTracking(true);
 }
diff -r -U2 -N phonon-4.3.0/gstreamer/glrenderer.h phonon-4.3.0/gstreamer/glrenderer.h
--- phonon-4.3.0/gstreamer/glrenderer.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/glrenderer.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/gsthelper.cpp phonon-4.3.0/gstreamer/gsthelper.cpp
--- phonon-4.3.0/gstreamer/gsthelper.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/gsthelper.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/gsthelper.h phonon-4.3.0/gstreamer/gsthelper.h
--- phonon-4.3.0/gstreamer/gsthelper.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/gsthelper.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/gstreamer.desktop phonon-4.3.0/gstreamer/gstreamer.desktop
--- phonon-4.3.0/gstreamer/gstreamer.desktop	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/gstreamer.desktop	2010-02-04 04:25:54.000000000 -0700
@@ -11,24 +11,79 @@
 
 Name=GStreamer
+Name[bg]=GStreamer
+Name[ca]=GStreamer
+Name[ca@valencia]=GStreamer
+Name[cs]=GStreamer
+Name[da]=GStreamer
+Name[de]=GStreamer
+Name[el]=GStreamer
+Name[en_GB]=GStreamer
+Name[es]=GStreamer
+Name[et]=GStreamer
+Name[eu]=GStreamer
+Name[fi]=GStreamer
+Name[fr]=GStreamer
+Name[ga]=GStreamer
+Name[gl]=GStreamer
+Name[hsb]=GStreamer
+Name[hu]=GStreamer
+Name[id]=GStreamer
+Name[is]=GStreamer
+Name[it]=GStreamer
+Name[ja]=GStreamer
+Name[ko]=GStreamer
+Name[ku]=GStreamer
+Name[lt]=GStreamer
+Name[lv]=GStreamer
+Name[nb]=GStreamer
+Name[nds]=GStreamer
+Name[nl]=GStreamer
+Name[nn]=GStreamer
 Name[pa]=ਜੀਸਟੀਰਮਰ
+Name[pl]=GStreamer
+Name[pt]=GStreamer
+Name[pt_BR]=GStreamer
+Name[ru]=GStreamer
+Name[se]=GStreamer
+Name[sk]=GStreamer
+Name[sl]=GStreamer
 Name[sr]=Гстример
+Name[sr@ijekavian]=Гстример
+Name[sr@ijekavianlatin]=GStreamer
+Name[sr@latin]=GStreamer
 Name[sv]=Gstreamer
+Name[tr]=GStreamer
+Name[uk]=GStreamer
 Name[x-test]=xxGStreamerxx
+Name[zh_CN]=GStreamer
+Name[zh_TW]=GStreamer
 
 Comment=Phonon GStreamer backend
 Comment[bg]=Phonon GStreamer
 Comment[ca]=Dorsal GStreamer del Phonon
+Comment[ca@valencia]=Dorsal GStreamer del Phonon
+Comment[cs]=Phonon GStreamer backend
 Comment[da]=GStreamer-backend til Phonon
 Comment[de]=Phonon-Treiber für GStreamer
 Comment[el]=Σύστημα υποστήριξης GStreamer του Phonon
+Comment[en_GB]=Phonon GStreamer backend
 Comment[es]=Motor GStreamer para Phonon
 Comment[et]=Phononi GStreameri taustaprogramm
+Comment[eu]=Phonon GStreamer backend
+Comment[fi]=Phonon GStreamer-taustaohjelma
 Comment[fr]=Système de gestion GStreamer pour Phonon 
 Comment[ga]=Inneall GStreamer le haghaidh Phonon
 Comment[gl]=Infraestrutura de GStreamer para Phonon
+Comment[hsb]=Phonon GStreamer backend
+Comment[hu]=Phonon GStreamer modul
+Comment[id]=Phonon GStreamer backend
+Comment[is]=Phonon GStreamer bakendi
 Comment[it]=Motore Gstreamer di Phonon
 Comment[ja]=Phonon GStreamer バックエンド
 Comment[ko]=Phonon GStreamer 백엔드
+Comment[ku]=Binesaza Phonon GStreamer
+Comment[lt]=Phonon GStreamer galinė sąsaja
 Comment[lv]=Phonon GStreamer aizmugure
+Comment[nb]=Phonon-motor for GStreamer
 Comment[nds]=Phonon-Hülpprogramm GStreamer
 Comment[nl]=GStreamer-backend (Phonon)
@@ -38,7 +93,11 @@
 Comment[pt]=Infra-estrutura do GStreamer para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon GStreamer
+Comment[ru]=Механизм GStreamer для Phonon
+Comment[se]=Phonon GStreamer duogášmohtor
 Comment[sk]=GStreamer podsystém
 Comment[sl]=Phononova hrbtenica GStreamer
 Comment[sr]=Гстример као позадина Фонона
+Comment[sr@ijekavian]=Гстример као позадина Фонона
+Comment[sr@ijekavianlatin]=GStreamer kao pozadina Phonona
 Comment[sr@latin]=GStreamer kao pozadina Phonona
 Comment[sv]=Phonon Gstreamer-gränssnitt
diff -r -U2 -N phonon-4.3.0/gstreamer/medianode.cpp phonon-4.3.0/gstreamer/medianode.cpp
--- phonon-4.3.0/gstreamer/medianode.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/medianode.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -199,7 +199,7 @@
         // potential deadlock. Hence we force the pipeline into ready state
         // before any nodes are disconnected.
-        gst_element_set_state(root()->pipeline(), GST_STATE_READY);    
+        gst_element_set_state(root()->pipeline(), GST_STATE_READY);
 
-        Q_ASSERT(sink->root()); //sink has to have a root since it is onnected
+        Q_ASSERT(sink->root()); //sink has to have a root since it is connected
 
         if (sink->description() & (AudioSink)) {
diff -r -U2 -N phonon-4.3.0/gstreamer/medianodeevent.cpp phonon-4.3.0/gstreamer/medianodeevent.cpp
--- phonon-4.3.0/gstreamer/medianodeevent.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/medianodeevent.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/medianodeevent.h phonon-4.3.0/gstreamer/medianodeevent.h
--- phonon-4.3.0/gstreamer/medianodeevent.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/medianodeevent.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/medianode.h phonon-4.3.0/gstreamer/medianode.h
--- phonon-4.3.0/gstreamer/medianode.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/medianode.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/mediaobject.cpp phonon-4.3.0/gstreamer/mediaobject.cpp
--- phonon-4.3.0/gstreamer/mediaobject.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/mediaobject.cpp	2010-01-21 11:23:15.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -15,7 +15,7 @@
     along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */
-
 #include <cmath>
 #include <gst/interfaces/propertyprobe.h>
+#include <gst/pbutils/install-plugins.h>
 #include "common.h"
 #include "mediaobject.h"
@@ -25,5 +25,5 @@
 #include "streamreader.h"
 #include "phononsrc.h"
-
+#include "phonon-config-gstreamer.h"
 #include <QtCore>
 #include <QtCore/QTimer>
@@ -56,4 +56,6 @@
         , m_prefinishMark(0)
         , m_transitionTime(0)
+        , m_isStream(false)
+        , m_posAtSeek(-1)
         , m_prefinishMarkReachedNotEmitted(true)
         , m_aboutToFinishEmitted(false)
@@ -78,4 +80,8 @@
         , m_previousTickTime(-1)
         , m_resetNeeded(false)
+        , m_autoplayTitles(true)
+        , m_availableTitles(0)
+        , m_currentTitle(1)
+        , m_pendingTitle(1)
 {
     qRegisterMetaType<GstCaps*>("GstCaps*");
@@ -94,5 +100,5 @@
         connect(m_tickTimer, SIGNAL(timeout()), SLOT(emitTick()));
     }
-    connect(this, SIGNAL(stateChanged(Phonon::State, Phonon::State)), 
+    connect(this, SIGNAL(stateChanged(Phonon::State, Phonon::State)),
             this, SLOT(notifyStateChange(Phonon::State, Phonon::State)));
 
@@ -135,4 +141,12 @@
 }
 
+void
+pluginInstallationDone( GstInstallPluginsReturn res, gpointer userData )
+{
+    // Nothing inside yet
+    Q_UNUSED(res);
+    Q_UNUSED(userData);
+}
+
 void MediaObject::saveState()
 {
@@ -141,7 +155,7 @@
         return;
 
-    if (m_state == Phonon::PlayingState || m_state == Phonon::PausedState) {
+    if (m_pendingState == Phonon::PlayingState || m_pendingState == Phonon::PausedState) {
         m_resumeState = true;
-        m_oldState = m_state;
+        m_oldState = m_pendingState;
         m_oldPos = getPipelinePos();
     }
@@ -194,11 +208,33 @@
         bool canPlay = (m_hasAudio || m_videoStreamFound);
         Phonon::ErrorType error = canPlay ? Phonon::NormalError : Phonon::FatalError;
+#ifdef PLUGIN_INSTALL_API
+        GstInstallPluginsContext *ctx = gst_install_plugins_context_new ();
+        gchar *details[2];
+        details[0] = m_missingCodecs[0].toLocal8Bit().data();
+        details[1] = NULL;
+        GstInstallPluginsReturn status;
+
+        status = gst_install_plugins_async( details, ctx, pluginInstallationDone, NULL );
+        gst_install_plugins_context_free ( ctx );
+
+        if ( status != GST_INSTALL_PLUGINS_STARTED_OK )
+        {
+            if( status == GST_INSTALL_PLUGINS_HELPER_MISSING )
+                setError(QString(tr("Missing codec helper script assistant.")), Phonon::FatalError );
+            else
+                setError(QString(tr("Plugin codec installation failed for codec: %0"))
+                        .arg(m_missingCodecs[0].split("|")[3]), error);
+        }
+        m_missingCodecs.clear();
+#else
+        QString codecs = m_missingCodecs.join(", ");
+
         if (error == Phonon::NormalError && m_hasVideo && !m_videoStreamFound) {
             m_hasVideo = false;
             emit hasVideoChanged(false);
         }
-        QString codecs = m_missingCodecs.join(", ");
-        setError(QString(tr("A required codec is missing. You need to install the following codec(s) to play this content: %0", 
-                            "", m_missingCodecs.size())).arg(codecs), error);
+        setError(QString(tr("A required codec is missing. You need to install the following codec(s) to play this content: %0")).arg(codecs), error);
+        m_missingCodecs.clear();
+#endif
     }
 }
@@ -243,5 +279,14 @@
         value = QString::fromUtf8(gst_structure_get_name (str));
     }
-    media->addMissingCodecName(value);
+
+#ifdef PLUGIN_INSTALL_API
+    QString plugins = QString("gstreamer|0.10|%0|%1|decoder-%2")
+        .arg( qApp->applicationName() )
+        .arg( value )
+        .arg( QString::fromUtf8(gst_caps_to_string (caps) ) );
+    media->addMissingCodecName( plugins );
+#else
+    media->addMissingCodecName( value );
+#endif
 }
 
@@ -268,4 +313,10 @@
     if ((str = gst_caps_get_structure (caps, 0))) {
         if (gst_structure_get_int (str, "width", &width) && gst_structure_get_int (str, "height", &height)) {
+            gint aspectNum = 0;
+            gint aspectDenum = 0;
+            if (gst_structure_get_fraction(str, "pixel-aspect-ratio", &aspectNum, &aspectDenum)) {
+                if (aspectDenum > 0)
+                    width = width*aspectNum/aspectDenum;
+            }
             // Let child nodes know about our new video size
             QSize size(width, height);
@@ -298,4 +349,9 @@
             // Note that the notify::caps _must_ be installed after linking to work with Dapper
             m_capsHandler = g_signal_connect(pad, "notify::caps", G_CALLBACK(notifyVideoCaps), this);
+
+            if (!m_loading && !m_hasVideo) {
+                m_hasVideo = m_videoStreamFound;
+                emit hasVideoChanged(m_hasVideo);
+            }
         }
         gst_object_unref (videopad);
@@ -321,4 +377,14 @@
 }
 
+void MediaObject::cb_pad_added(GstElement *decodebin,
+                               GstPad     *pad,
+                               gpointer    data)
+{
+    Q_UNUSED(decodebin);
+    GstPad *decodepad = static_cast<GstPad*>(data);
+    gst_pad_link (pad, decodepad);
+    //gst_object_unref (decodepad);
+}
+
 /**
  * Create a media source from a given URL.
@@ -326,9 +392,6 @@
  * returns true if successful
  */
-bool MediaObject::createPipefromURL(const QString &encodedUrl)
+bool MediaObject::createPipefromURL(const QUrl &url)
 {
-    // Convert back to URL
-    QUrl url(encodedUrl, QUrl::StrictMode);
-
     // Remove any existing data source
     if (m_datasource) {
@@ -340,20 +403,50 @@
     // Verify that the uri can be parsed
     if (!url.isValid()) {
-        m_backend->logMessage(QString("%1 is not a valid URI").arg(encodedUrl));
+        m_backend->logMessage(QString("%1 is not a valid URI").arg(url.toString()));
         return false;
     }
 
     // Create a new datasource based on the input URL
-    QByteArray encoded_cstr_url = url.toEncoded();
-    m_datasource = gst_element_make_from_uri(GST_URI_SRC, encoded_cstr_url.constData(), NULL);
+    // add the 'file' scheme if it's missing; the double '/' is needed!
+    QByteArray encoded_cstr_url = (url.scheme() == QLatin1String("") ?
+                    "file://" + url.toEncoded() :
+                    url.toEncoded());
+    m_datasource = gst_element_make_from_uri(GST_URI_SRC, encoded_cstr_url.constData(), (const char*)NULL);
     if (!m_datasource)
         return false;
 
+    // Set the device for MediaSource::Disc
+    if (m_source.type() == MediaSource::Disc) {
+
+        if (g_object_class_find_property (G_OBJECT_GET_CLASS (m_datasource), "device")) {
+            QByteArray mediaDevice = QFile::encodeName(m_source.deviceName());
+            if (!mediaDevice.isEmpty())
+                g_object_set (G_OBJECT (m_datasource), "device", mediaDevice.constData(), (const char*)NULL);
+        }
+
+        // Also Set optical disc speed to 2X for Audio CD
+        if (m_source.discType() == Phonon::Cd
+            && (g_object_class_find_property (G_OBJECT_GET_CLASS (m_datasource), "read-speed"))) {
+            g_object_set (G_OBJECT (m_datasource), "read-speed", 2, (const char*)NULL);
+            m_backend->logMessage(QString("new device speed : 2X"), Backend::Info, this);
+        }
+  }
+
+    /* make HTTP sources send extra headers so we get icecast
+     * metadata in case the stream is an icecast stream */
+    if (encoded_cstr_url.startsWith("http://")
+        && g_object_class_find_property (G_OBJECT_GET_CLASS (m_datasource), "iradio-mode")) {
+        g_object_set (m_datasource, "iradio-mode", TRUE, NULL);
+        m_isStream = true;
+    }
+
     // Link data source into pipeline
     gst_bin_add(GST_BIN(m_pipeline), m_datasource);
     if (!gst_element_link(m_datasource, m_decodebin)) {
-        gst_bin_remove(GST_BIN(m_pipeline), m_datasource);
-        return false;
+        // For sources with dynamic pads (such as RtspSrc) we need to connect dynamically
+        GstPad *decodepad = gst_element_get_pad (m_decodebin, "sink");
+        g_signal_connect (m_datasource, "pad-added", G_CALLBACK (&cb_pad_added), decodepad);
     }
+
     return true;
 }
@@ -599,5 +692,5 @@
         } else if (currentState == GST_STATE_PLAYING) {
             changeState(Phonon::PlayingState);
-        } else if (!m_atEndOfStream && gst_element_set_state(m_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
+        } else if (gst_element_set_state(m_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
             m_pendingState = Phonon::PlayingState;
         } else {
@@ -629,5 +722,5 @@
 
     Phonon::State oldState = m_state;
-    m_state = newstate; // m_state must be set before emitting, since 
+    m_state = newstate; // m_state must be set before emitting, since
                         // Error state requires that state() will return the new value
     m_pendingState = newstate;
@@ -649,4 +742,6 @@
     case Phonon::StoppedState:
         m_backend->logMessage("phonon state changed: Stopped", Backend::Info, this);
+        // We must reset the pipeline when playing again
+        m_resetNeeded = true;
         m_tickTimer->stop();
         break;
@@ -715,5 +810,6 @@
 void MediaObject::setNextSource(const MediaSource &source)
 {
-    if (source.type() == MediaSource::Invalid)
+    if (source.type() == MediaSource::Invalid &&
+        source.type() == MediaSource::Empty)
         return;
     m_nextSource = source;
@@ -777,4 +873,6 @@
     if (m_atStartOfStream)
         return 0;
+    if (m_posAtSeek >= 0)
+        return m_posAtSeek;
 
     gint64 pos = 0;
@@ -811,5 +909,5 @@
     GstState state;
     gst_element_set_state(m_pipeline, GST_STATE_NULL);
-    gst_element_get_state (m_pipeline, &state, NULL, 2000);
+    gst_element_get_state(m_pipeline, &state, NULL, 2000);
 
     m_source = source;
@@ -821,5 +919,7 @@
     changeState(Phonon::LoadingState);
     m_loading = true;
-    m_resetNeeded = false;
+    // IMPORTANT: Honor the m_resetNeeded flag as it currently stands.
+    // See https://qa.mandriva.com/show_bug.cgi?id=56807
+    //m_resetNeeded = false;
     m_resumeState = false;
     m_pendingState = Phonon::StoppedState;
@@ -834,6 +934,6 @@
     m_aboutToFinishEmitted = false;
     m_error = NoError;
-    m_errorString = QString();
-    
+    m_errorString.clear();
+
     m_bufferPercent = 0;
     m_prefinishMarkReachedNotEmitted = true;
@@ -844,13 +944,22 @@
     m_atEndOfStream = false;
 
-    // Clear exising meta tags
+    m_availableTitles = 0;
+    m_pendingTitle = 1;
+    m_currentTitle = 1;
+
+    // Clear existing meta tags
     m_metaData.clear();
+    m_isStream = false;
 
     switch (source.type()) {
-    case MediaSource::Url:
-    case MediaSource::LocalFile:
-        if (!createPipefromURL(source.url().toString())) {
-            setError(tr("Could not open media source."));
-            return;
+    case MediaSource::Url: {
+            if (!createPipefromURL(source.url()))
+                setError(tr("Could not open media source."));
+        }
+        break;
+
+    case MediaSource::LocalFile: {
+            if (!createPipefromURL(QUrl::fromLocalFile(source.fileName())))
+                setError(tr("Could not open media source."));
         }
         break;
@@ -860,14 +969,35 @@
         break;
 
+    case MediaSource::Empty:
+        break;
+
     case MediaSource::Stream:
-        if (!createPipefromStream(source)) {
+        if (!createPipefromStream(source))
             setError(tr("Could not open media source."));
-            return;
-        }
         break;
 
-    case MediaSource::Disc: // CD tracks can be specified by setting the url in the following way uri=cdda:4
-        m_backend->logMessage("Source type Disc not currently supported", Backend::Warning, this);
-        setError(tr("Could not open media source."), Phonon::NormalError);
+    case MediaSource::Disc:
+        {
+       QString mediaUrl;
+       switch (source.discType()) {
+       case Phonon::NoDisc:
+                qWarning() << "I should never get to see a MediaSource that is a disc but doesn't specify which one";
+                return;
+            case Phonon::Cd:  // CD tracks can be specified by setting the url in the following way uri=cdda:4
+                mediaUrl = QLatin1String("cdda://");
+                break;
+            case Phonon::Dvd:
+                mediaUrl = QLatin1String("dvd://");
+                break;
+            case Phonon::Vcd:
+                mediaUrl = QLatin1String("vcd://");
+                break;
+            default:
+                qWarning() <<  "media " << source.discType() << " not implemented";
+                return;
+            }
+            if (mediaUrl.isEmpty() || !createPipefromURL(QUrl(mediaUrl)))
+                setError(tr("Could not open media source."));
+        }
         break;
 
@@ -875,8 +1005,7 @@
         m_backend->logMessage("Source type not currently supported", Backend::Warning, this);
         setError(tr("Could not open media source."), Phonon::NormalError);
-        return;
+        break;
     }
 
-    // Setting to state paused will trigger fetching meta data and duration
     MediaNodeEvent event(MediaNodeEvent::SourceChanged);
     notify(&event);
@@ -885,5 +1014,4 @@
     // before loading, otherwise the stream will be blocked
     link();
-
     beginLoad();
 }
@@ -921,4 +1049,18 @@
         emit hasVideoChanged(m_hasVideo);
     }
+
+    if (m_source.discType() == Phonon::Cd) {
+        gint64 titleCount;
+        GstFormat format = gst_format_get_by_nick("track");
+        if (gst_element_query_duration (m_pipeline, &format, &titleCount)) {
+            int oldAvailableTitles = m_availableTitles;
+            m_availableTitles = (int)titleCount;
+            if (m_availableTitles != oldAvailableTitles) {
+                emit availableTitlesChanged(m_availableTitles);
+                m_backend->logMessage(QString("Available titles changed: %0").arg(m_availableTitles), Backend::Info, this);
+            }
+        }
+    }
+
 }
 
@@ -952,6 +1094,4 @@
         return;
 
-    Phonon::State oldState = state();
-
     if (isSeekable()) {
         switch (state()) {
@@ -967,9 +1107,10 @@
                 m_atStartOfStream = false;
 
-            // Go to buffering state, we resume paused state when ready
+            m_posAtSeek = getPipelinePos();
+            m_tickTimer->stop();
+
             if (gst_element_seek(m_pipeline, 1.0, GST_FORMAT_TIME,
                                  GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET,
                                  time * GST_MSECOND, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
-            setState(oldState);
             break;
         case Phonon::LoadingState:
@@ -979,5 +1120,5 @@
 
         quint64 current = currentTime();
-        quint64 total = totalTime(); 
+        quint64 total = totalTime();
 
         if (current < total - m_prefinishMark)
@@ -1000,5 +1141,5 @@
     if (m_tickInterval > 0 && currentTime != m_previousTickTime) {
         emit tick(currentTime);
-        m_previousTickTime = currentTime;        
+        m_previousTickTime = currentTime;
     }
     if (m_state == Phonon::PlayingState) {
@@ -1011,5 +1152,10 @@
         // Prepare load of next source
         if (currentTime >= totalTime - ABOUT_TO_FINNISH_TIME) {
-            if (!m_aboutToFinishEmitted) {
+            if (m_source.type() == MediaSource::Disc &&
+                m_autoplayTitles &&
+                m_availableTitles > 1 &&
+                m_currentTitle < m_availableTitles) {
+                m_aboutToFinishEmitted = false;
+            } else if (!m_aboutToFinishEmitted) {
                 m_aboutToFinishEmitted = true; // track is about to finish
                 emit aboutToFinish();
@@ -1115,5 +1261,6 @@
     switch (GST_MESSAGE_TYPE (gstMessage)) {
 
-    case GST_MESSAGE_EOS: 
+    case GST_MESSAGE_EOS:
+        m_backend->logMessage("EOS received", Backend::Info, this);
         handleEndOfStream();
         break;
@@ -1123,12 +1270,96 @@
             gst_message_parse_tag(gstMessage, &tag_list);
             if (tag_list) {
+                TagMap newTags;
+                gst_tag_list_foreach (tag_list, &foreach_tag_function, &newTags);
+                gst_tag_list_free(tag_list);
+
+                // Determine if we should no fake the album/artist tags.
+                // This is a little confusing as we want to fake it on initial
+                // connection where title, album and artist are all missing.
+                // There are however times when we get just other information,
+                // e.g. codec, and so we want to only do clever stuff if we
+                // have a commonly available tag (ORGANIZATION) or we have a
+                // change in title
+                bool fake_it =
+                   (m_isStream
+                    && ((!newTags.contains("TITLE")
+                         && newTags.contains("ORGANIZATION"))
+                        || (newTags.contains("TITLE")
+                            && m_metaData.value("TITLE") != newTags.value("TITLE")))
+                    && !newTags.contains("ALBUM")
+                    && !newTags.contains("ARTIST"));
+
                 TagMap oldMap = m_metaData; // Keep a copy of the old one for reference
-                // Append any new meta tags to the existing tag list
-                gst_tag_list_foreach (tag_list, &foreach_tag_function, &m_metaData);
+
+                // Now we've checked the new data, append any new meta tags to the existing tag list
+                // We cannot use TagMap::iterator as this is a multimap and when streaming data
+                // could in theory be lost.
+                QList<QString> keys = newTags.keys();
+                for (QList<QString>::iterator i = keys.begin(); i != keys.end(); ++i) {
+                    QString key = *i;
+                    if (m_isStream) {
+                        // If we're streaming, we need to remove data in m_metaData
+                        // in order to stop it filling up indefinitely (as it's a multimap)
+                        m_metaData.remove(key);
+                    }
+                    QList<QString> values = newTags.values(key);
+                    for (QList<QString>::iterator j = values.begin(); j != values.end(); ++j) {
+                        QString value = *j;
+                        QString currVal = m_metaData.value(key);
+                        if (!m_metaData.contains(key) || currVal != value) {
+                            m_metaData.insert(key, value);
+                        }
+                    }
+                }
+
                 m_backend->logMessage("Meta tags found", Backend::Info, this);
-                if (oldMap != m_metaData && !m_loading)
-                    emit metaDataChanged(m_metaData);
-                gst_tag_list_free(tag_list);
-            }
+                if (oldMap != m_metaData) {
+                    // This is a bit of a hack to ensure that stream metadata is
+                    // returned. We get as much as we can from the Shoutcast server's
+                    // StreamTitle= header. If further info is decoded from the stream
+                    // itself later, then it will overwrite this info.
+                    if (m_isStream && fake_it) {
+                        m_metaData.remove("ALBUM");
+                        m_metaData.remove("ARTIST");
+
+                        // Detect whether we want to "fill in the blanks"
+                        QString str;
+                        if (m_metaData.contains("TITLE"))
+                        {
+                            str = m_metaData.value("TITLE");
+                            int splitpoint;
+                            // Check to see if our title matches "%s - %s"
+                            // Where neither %s are empty...
+                            if ((splitpoint = str.indexOf(" - ")) > 0
+                                && str.size() > (splitpoint+3)) {
+                                m_metaData.insert("ARTIST", str.left(splitpoint));
+                                m_metaData.replace("TITLE", str.mid(splitpoint+3));
+                            }
+                        } else {
+                            str = m_metaData.value("GENRE");
+                            if (!str.isEmpty())
+                                m_metaData.insert("TITLE", str);
+                            else
+                                m_metaData.insert("TITLE", "Streaming Data");
+                        }
+                        if (!m_metaData.contains("ARTIST")) {
+                            str = m_metaData.value("LOCATION");
+                            if (!str.isEmpty())
+                                m_metaData.insert("ARTIST", str);
+                            else
+                                m_metaData.insert("ARTIST", "Streaming Data");
+                        }
+                        str = m_metaData.value("ORGANIZATION");
+                        if (!str.isEmpty())
+                            m_metaData.insert("ALBUM", str);
+                        else
+                            m_metaData.insert("ALBUM", "Streaming Data");
+                    }
+                    // As we manipulate the title, we need to recompare
+                    // oldMap and m_metaData here...
+                    if (oldMap != m_metaData && !m_loading)
+                        emit metaDataChanged(m_metaData);
+                }
+			}
         }
         break;
@@ -1141,5 +1372,11 @@
             GstState oldState;
             GstState newState;
-            gst_message_parse_state_changed (gstMessage, &oldState, &newState, 0);
+            GstState pendingState;
+            gst_message_parse_state_changed (gstMessage, &oldState, &newState, &pendingState);
+
+            if (newState == pendingState)
+                return;
+
+            m_posAtSeek = -1;
 
             switch (newState) {
@@ -1150,4 +1387,7 @@
                 m_tickTimer->start();
                 changeState(Phonon::PlayingState);
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 if (m_resumeState && m_oldState == Phonon::PlayingState) {
                     seek(m_oldPos);
@@ -1165,4 +1405,6 @@
                 m_tickTimer->start();
                 if (state() == Phonon::LoadingState) {
+                    // No_more_pads is not emitted from the decodebin in older versions (0.10.4)
+                    noMorePadsAvailable();
                     loadingComplete();
                 } else if (m_resumeState && m_oldState == Phonon::PausedState) {
@@ -1183,4 +1425,7 @@
                 m_backend->logMessage("gstreamer: pipeline state set to ready", Backend::Debug, this);
                 m_tickTimer->stop();
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 break;
 
@@ -1221,5 +1466,5 @@
                         gst_caps_unref (caps);
                         gst_object_unref (sinkPad);
-                   } 
+                   }
                } else {
                     setError(QString(err->message), Phonon::FatalError);
@@ -1293,6 +1538,6 @@
         //case GST_MESSAGE_LATENCY: only from 0.10.12
         //case GST_MESSAGE_ASYNC_DONE: only from 0.10.13
-    default: 
-        break; 
+    default:
+        break;
     }
 }
@@ -1300,18 +1545,47 @@
 void MediaObject::handleEndOfStream()
 {
+    // If the stream is not seekable ignore
+    // otherwise chained radio broadcasts would stop
+
+
     if (m_atEndOfStream)
         return;
 
-    m_atEndOfStream = true;
+    if (!m_seekable)
+        m_atEndOfStream = true;
+
+    if (m_source.type() == MediaSource::Disc &&
+        m_autoplayTitles &&
+        m_availableTitles > 1 &&
+        m_currentTitle < m_availableTitles) {
+        _iface_setCurrentTitle(m_currentTitle + 1);
+        return;
+    }
 
-    if (m_nextSource.type() != MediaSource::Invalid) {  // We only emit finish when the queue is actually empty
+    if (m_nextSource.type() != MediaSource::Invalid
+        && m_nextSource.type() != MediaSource::Empty) {  // We only emit finish when the queue is actually empty
         QTimer::singleShot (qMax(0, transitionTime()), this, SLOT(beginPlay()));
     } else {
         m_pendingState = Phonon::PausedState;
         emit finished();
-        // Only emit paused if the finished signal
-        // did not result in a new state
-        if (m_pendingState == Phonon::PausedState)
-            setState(m_pendingState);
+        if (!m_seekable) {
+            setState(Phonon::StoppedState);
+            // Note the behavior for live streams is not properly defined
+            // But since we cant seek to 0, we don't have much choice other than stopping
+            // the stream
+        } else {
+            // Only emit paused if the finished signal
+            // did not result in a new state
+            if (m_pendingState == Phonon::PausedState)
+                setState(m_pendingState);
+        }
+    }
+}
+
+void MediaObject::invalidateGraph()
+{
+    m_resetNeeded = true;
+    if (m_state == Phonon::PlayingState || m_state == Phonon::PausedState) {
+        changeState(Phonon::StoppedState);
     }
 }
@@ -1325,4 +1599,85 @@
 }
 
+#ifndef QT_NO_PHONON_MEDIACONTROLLER
+//interface management
+bool MediaObject::hasInterface(Interface iface) const
+{
+    return iface == AddonInterface::TitleInterface;
+}
+
+QVariant MediaObject::interfaceCall(Interface iface, int command, const QList<QVariant> &params)
+{
+    if (hasInterface(iface)) {
+
+        switch (iface)
+        {
+        case TitleInterface:
+            switch (command)
+            {
+            case availableTitles:
+                return _iface_availableTitles();
+            case title:
+                return _iface_currentTitle();
+            case setTitle:
+                _iface_setCurrentTitle(params.first().toInt());
+                break;
+            case autoplayTitles:
+                return m_autoplayTitles;
+            case setAutoplayTitles:
+                m_autoplayTitles = params.first().toBool();
+                break;
+            }
+            break;
+                default:
+            break;
+        }
+    }
+    return QVariant();
+}
+#endif
+
+int MediaObject::_iface_availableTitles() const
+{
+    return m_availableTitles;
+}
+
+int MediaObject::_iface_currentTitle() const
+{
+    return m_currentTitle;
+}
+
+void MediaObject::_iface_setCurrentTitle(int title)
+{
+    m_backend->logMessage(QString("setCurrentTitle %0").arg(title), Backend::Info, this);
+    if ((title == m_currentTitle) || (title == m_pendingTitle))
+        return;
+
+    m_pendingTitle = title;
+
+    if (m_state == Phonon::PlayingState || m_state == Phonon::StoppedState) {
+        setTrack(m_pendingTitle);
+    } else {
+        setState(Phonon::StoppedState);
+    }
+}
+
+void MediaObject::setTrack(int title)
+{
+    if (((m_state != Phonon::PlayingState) && (m_state != Phonon::StoppedState)) || (title < 1) || (title > m_availableTitles))
+        return;
+
+
+    //let's seek to the beginning of the song
+    GstFormat trackFormat = gst_format_get_by_nick("track");
+    m_backend->logMessage(QString("setTrack %0").arg(title), Backend::Info, this);
+    if (gst_element_seek_simple(m_pipeline, trackFormat, GST_SEEK_FLAG_FLUSH, title - 1)) {
+        m_currentTitle = title;
+        updateTotalTime();
+        m_atEndOfStream = false;
+        emit titleChanged(title);
+        emit totalTimeChanged(totalTime());
+    }
+}
+
 } // ns Gstreamer
 } // ns Phonon
diff -r -U2 -N phonon-4.3.0/gstreamer/mediaobject.h phonon-4.3.0/gstreamer/mediaobject.h
--- phonon-4.3.0/gstreamer/mediaobject.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/mediaobject.h	2010-01-21 11:23:15.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -22,5 +22,4 @@
 #include "common.h"
 #include "medianode.h"
-
 #include <phonon/mediaobjectinterface.h>
 #include <phonon/addoninterface.h>
@@ -33,5 +32,4 @@
 #include <QtCore/QEvent>
 #include <QtCore/QUrl>
-
 #include <gst/gst.h>
 
@@ -51,9 +49,19 @@
 class AudioOutput;
 
-class MediaObject : public QObject, public MediaObjectInterface, public AddonInterface, public MediaNode
+class MediaObject : public QObject, public MediaObjectInterface
+#ifndef QT_NO_PHONON_MEDIACONTROLLER
+        , public AddonInterface
+#endif
+        , public MediaNode
 {
     friend class Stream;
+    friend class AudioDataOutput;
     Q_OBJECT
-    Q_INTERFACES(Phonon::MediaObjectInterface Phonon::AddonInterface Phonon::Gstreamer::MediaNode)
+    Q_INTERFACES(Phonon::MediaObjectInterface
+#ifndef QT_NO_PHONON_MEDIACONTROLLER
+                 Phonon::AddonInterface
+#endif
+                 Phonon::Gstreamer::MediaNode
+    )
 
 public:
@@ -94,14 +102,8 @@
 
     // No additional interfaces currently supported
-    bool hasInterface(Interface) const
-    {
-        return false;
-    }
-
-    QVariant interfaceCall(Interface, int, const QList<QVariant> &)
-    {
-        return QVariant();
-    }
-
+#ifndef QT_NO_PHONON_MEDIACONTROLLER
+    bool hasInterface(Interface) const;
+    QVariant interfaceCall(Interface, int, const QList<QVariant> &);
+#endif
     bool isLoading()
     {
@@ -144,11 +146,8 @@
     void handleEndOfStream();
     void addMissingCodecName(const QString &codec) { m_missingCodecs.append(codec); }
-    void invalidateGraph() {
-        m_resetNeeded = true;
-        if (m_state == Phonon::PlayingState || m_state == Phonon::PausedState) {
-            changeState(Phonon::StoppedState);
-        }
-    }
+    void invalidateGraph();
+
     static void cb_newpad (GstElement *decodebin, GstPad *pad, gboolean last, gpointer data);
+    static void cb_pad_added (GstElement *decodebin, GstPad *pad, gpointer data);
     static void cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *caps, gpointer data);
     static void cb_no_more_pads (GstElement * decodebin, gpointer data);
@@ -176,4 +175,17 @@
     void setMetaData(QMultiMap<QString, QString> newData);
 
+    // AddonInterface:
+    void titleChanged(int);
+    void availableTitlesChanged(int);
+
+    // Not implemented
+    void chapterChanged(int);
+    void availableChaptersChanged(int);
+    void angleChanged(int);
+    void availableAnglesChanged(int);
+
+    void availableSubtitlesChanged();
+    void availableAudioChannelsChanged();
+
 protected:
     void beginLoad();
@@ -185,5 +197,5 @@
      * @param encodedUrl percent-encoded QString for source compat reasons.  Should change to QUrl
      */
-    bool createPipefromURL(const QString &encodedUrl);
+    bool createPipefromURL(const QUrl &url);
     bool createPipefromStream(const MediaSource &);
 
@@ -219,4 +231,9 @@
     qint64 getPipelinePos() const;
 
+    int _iface_availableTitles() const;
+    int _iface_currentTitle() const;
+    void _iface_setCurrentTitle(int title);
+    void setTrack(int title);
+
     bool m_resumeState;
     State m_oldState;
@@ -232,4 +249,7 @@
     qint32 m_prefinishMark;
     qint32 m_transitionTime;
+	bool m_isStream;
+
+    qint64 m_posAtSeek;
 
     bool m_prefinishMarkReachedNotEmitted;
@@ -262,4 +282,8 @@
     QStringList m_missingCodecs;
     QMultiMap<QString, QString> m_metaData;
+    bool m_autoplayTitles;
+    int m_availableTitles;
+    int m_currentTitle;
+    int m_pendingTitle;
 };
 }
diff -r -U2 -N phonon-4.3.0/gstreamer/message.cpp phonon-4.3.0/gstreamer/message.cpp
--- phonon-4.3.0/gstreamer/message.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/message.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/message.h phonon-4.3.0/gstreamer/message.h
--- phonon-4.3.0/gstreamer/message.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/message.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/phonon-config-gstreamer.h.cmake phonon-4.3.0/gstreamer/phonon-config-gstreamer.h.cmake
--- phonon-4.3.0/gstreamer/phonon-config-gstreamer.h.cmake	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/gstreamer/phonon-config-gstreamer.h.cmake	2009-09-14 09:53:07.000000000 -0700
@@ -0,0 +1,5 @@
+/* GStreamer install plugin definitions */
+
+/* If api-plugin is defined */
+#cmakedefine PLUGIN_INSTALL_API 1
+
diff -r -U2 -N phonon-4.3.0/gstreamer/phononsrc.cpp phonon-4.3.0/gstreamer/phononsrc.cpp
--- phonon-4.3.0/gstreamer/phononsrc.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/phononsrc.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
@@ -69,8 +69,12 @@
 static void phonon_src_base_init (gpointer g_class) {
     GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
-    GstElementDetails details = GST_ELEMENT_DETAILS ("Phonon Stream Source",
-                                          "Source/File",
-                                          "Read from a Phonon StreamInterface",
-                                          "Trolltech ASA <info@trolltech.com>");
+    static gchar longname[] = "Phonon Stream Source",
+                    klass[] = "Source/File",
+              description[] = "Read from a Phonon StreamInterface",
+                   author[] = "Nokia Corporation and/or its subsidiary(-ies) <qt-info@nokia.com>";
+    GstElementDetails details = GST_ELEMENT_DETAILS (longname,
+                                          klass,
+                                          description,
+                                          author);
     gst_element_class_set_details (gstelement_class, &details);
     gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&srctemplate));
@@ -80,7 +84,9 @@
 {
     GObjectClass *gobject_class;
+    GstElementClass *gstelement_class;
     GstBaseSrcClass *gstbasesrc_class;
 
     gobject_class = G_OBJECT_CLASS (klass);
+    gstelement_class = GST_ELEMENT_CLASS (klass);
     gstbasesrc_class = GST_BASE_SRC_CLASS (klass);
 
@@ -164,5 +170,5 @@
                                         GParamSpec * pspec)
 {
-    PhononSrc *src = 0;
+    PhononSrc *src;
     g_return_if_fail (GST_IS_PHONON_SRC (object));
     src = GST_PHONON_SRC (object);
@@ -197,5 +203,5 @@
     }
 
-    g_object_unref(buf);
+    gst_mini_object_unref(GST_MINI_OBJECT(buf));
     return GST_FLOW_ERROR;
 }
diff -r -U2 -N phonon-4.3.0/gstreamer/phononsrc.h phonon-4.3.0/gstreamer/phononsrc.h
--- phonon-4.3.0/gstreamer/phononsrc.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/phononsrc.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2008 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/qwidgetvideosink.cpp phonon-4.3.0/gstreamer/qwidgetvideosink.cpp
--- phonon-4.3.0/gstreamer/qwidgetvideosink.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/qwidgetvideosink.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/qwidgetvideosink.h phonon-4.3.0/gstreamer/qwidgetvideosink.h
--- phonon-4.3.0/gstreamer/qwidgetvideosink.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/qwidgetvideosink.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -20,4 +20,5 @@
 
 #include "common.h"
+#include "qwidgetvideosink.h"
 
 #include <QtCore/QByteArray>
diff -r -U2 -N phonon-4.3.0/gstreamer/streamreader.cpp phonon-4.3.0/gstreamer/streamreader.cpp
--- phonon-4.3.0/gstreamer/streamreader.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/streamreader.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2007 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/streamreader.h phonon-4.3.0/gstreamer/streamreader.h
--- phonon-4.3.0/gstreamer/streamreader.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/streamreader.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-Copyright (C) 2007 Trolltech ASA. All rights reserved.
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
 This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/videowidget.cpp phonon-4.3.0/gstreamer/videowidget.cpp
--- phonon-4.3.0/gstreamer/videowidget.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/videowidget.cpp	2009-04-22 08:48:59.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -204,6 +204,4 @@
 /***
  * Calculates the actual rectangle the movie will be presented with
- *
- * ### This function does currently asume a 1:1 pixel aspect
  **/
 QRect VideoWidget::calculateDrawFrameRect() const
@@ -360,4 +358,7 @@
     widget()->updateGeometry();
     widget()->update();
+
+    if (m_renderer)
+        m_renderer->movieSizeChanged(m_movieSize);
 }
 
diff -r -U2 -N phonon-4.3.0/gstreamer/videowidget.h phonon-4.3.0/gstreamer/videowidget.h
--- phonon-4.3.0/gstreamer/videowidget.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/videowidget.h	2009-04-22 08:48:59.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2    //Copyright (C) 2007 Trolltech ASA. All rights reserved.007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2    //Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).007 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -26,4 +26,5 @@
 #include "medianode.h"
 #include "abstractrenderer.h"
+#include "videowidget.h"
 
 #include <gst/gst.h>
diff -r -U2 -N phonon-4.3.0/gstreamer/volumefadereffect.cpp phonon-4.3.0/gstreamer/volumefadereffect.cpp
--- phonon-4.3.0/gstreamer/volumefadereffect.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/volumefadereffect.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/volumefadereffect.h phonon-4.3.0/gstreamer/volumefadereffect.h
--- phonon-4.3.0/gstreamer/volumefadereffect.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/volumefadereffect.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/widgetrenderer.cpp phonon-4.3.0/gstreamer/widgetrenderer.cpp
--- phonon-4.3.0/gstreamer/widgetrenderer.cpp	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/widgetrenderer.cpp	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/widgetrenderer.h phonon-4.3.0/gstreamer/widgetrenderer.h
--- phonon-4.3.0/gstreamer/widgetrenderer.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/widgetrenderer.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/gstreamer/x11renderer.cpp phonon-4.3.0/gstreamer/x11renderer.cpp
--- phonon-4.3.0/gstreamer/x11renderer.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/gstreamer/x11renderer.cpp	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -91,5 +91,5 @@
             videoSink = 0;
         } else {
-            // Note that this should not really be neccessary as these are 
+            // Note that this should not really be necessary as these are
             // default values, though under certain conditions values are retained
             // even between application instances. (reproducible on 0.10.16/Gutsy)
@@ -133,4 +133,13 @@
     if (m_renderWidget) {
         m_renderWidget->setGeometry(m_videoWidget->calculateDrawFrameRect());
+    }
+}
+
+void X11Renderer::movieSizeChanged(const QSize &movieSize)
+{
+    Q_UNUSED(movieSize);
+
+    if (m_renderWidget) {
+        m_renderWidget->setGeometry(m_videoWidget->calculateDrawFrameRect());
     }
 }
diff -r -U2 -N phonon-4.3.0/gstreamer/x11renderer.h phonon-4.3.0/gstreamer/x11renderer.h
--- phonon-4.3.0/gstreamer/x11renderer.h	2008-11-24 10:12:02.000000000 -0700
+++ phonon-4.3.0/gstreamer/x11renderer.h	2009-02-25 13:29:05.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -46,4 +46,5 @@
     void aspectRatioChanged(Phonon::VideoWidget::AspectRatio aspectRatio);
     void scaleModeChanged(Phonon::VideoWidget::ScaleMode scaleMode);
+    void movieSizeChanged(const QSize &movieSize);
     void handleMediaNodeEvent(const MediaNodeEvent *event);
     bool eventFilter(QEvent *);
diff -r -U2 -N phonon-4.3.0/includes/CMakeLists.txt phonon-4.3.0/includes/CMakeLists.txt
--- phonon-4.3.0/includes/CMakeLists.txt	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/includes/CMakeLists.txt	2009-02-19 05:51:41.000000000 -0700
@@ -36,5 +36,5 @@
   Phonon/VolumeFaderInterface
   Phonon/VolumeSlider
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon COMPONENT Devel)
 
 install(FILES
@@ -47,3 +47,3 @@
   Phonon/Experimental/VideoFrame2
   Phonon/Experimental/Visualization
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental COMPONENT Devel)
diff -r -U2 -N phonon-4.3.0/Mainpage.dox phonon-4.3.0/Mainpage.dox
--- phonon-4.3.0/Mainpage.dox	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/Mainpage.dox	2009-01-10 11:44:22.000000000 -0700
@@ -1,161 +1,41 @@
-/** @mainpage The KDE Library API Reference
+/** @mainpage The Phonon Library API Reference
 
 <p><b>
 Overview |
-@ref components |
-@ref development |
-@ref search
+@ref development
 </b></p>
 
-This is the online reference for developing with the KDE libraries
-(kdelibs).
-
-The KDE libraries build on the
-<a href="http://www.trolltech.com/products/qt/">Qt</a> framework to
-provide a powerful framework to make writing applications easier,
-and provide consistency across the KDE desktop envionment.
-
-Among other things, the KDE libraries provide:
-- standard user interface elements, on top of those provided by Qt
-  (<a href="kdeui/html/index.html">KDEUI</a>)
-- a standard configuration format and method of reading and writing
-  configuration data (<a href="kdecore/html/classKConfig.html">KConfig</a>)
-- site-independent access to standard directories, for finding resources such
-  as icons (<a href="kdecore/html/classKStandardDirs.html">KStandardDirs</a>)
-- network transparent input and output (<a href="kio/html/index.html">KIO</a>)
-- a method of embedding application components in other applications
-  (<a href="kparts/html/index.html">KParts</a>)
-- straightforward multimedia and hardware interaction
-  (<a href="/kdesupport-api/kdesupport-apidocs/phonon/html/">Phonon</a> and
-  <a href="solid/html/index.html">Solid</a>)
-- fully-fledged JavaScript and HTML engines
-  (<a href="kjs/html/index.html">KJS</a> and
-  <a href="khtml/html/index.html">KHTML</a>)
-- an application scripting framework
-  (<a href="kross/html/index.html">Kross</a>)
-- semantic information and tagging
-  (<a href="nepomuk/html/index.html">Nepomuk</a>)
-
-Visit the <a href="http://techbase.kde.org/Development">development section of KDE
-Techbase</a> for tutorials, architectural overviews and other useful information.
+<a href="http://phonon.kde.org/">Phonon</a> provides a Qt-style interface for audio
+and video.  It is aimed at the average desktop application, whether that is a game
+that needs sound effects or a full-blown multimedia playback application like
+<a href="http://amarok.kde.org/">Amarok</a> or
+<a href="http://www.dragonplayer.org/">Dragon Player</a>.
+
+If you writing a Qt program and want audio or video playback, then Phonon is almost
+certainly the right choice for you.  It provides an API that any Qt developer will
+be comfortable with, and uses the native sound systems on Windows and MacOS.  On
+UNIX systems, where there is no one standard multimedia system, it offers
+<a href="http://www.gstreamer.net/">GStreamer</a> and <a href="http://xinehq.de/">Xine</a>
+backends, and more (such as <a href="http://www.videolan.org/">VLC</a>) are available
+from third parties.
+
+However, Phonon is not aimed at professional audio applications (in the style of
+<a href="http://audacity.sourceforge.net/">Audacity</a>, say).  For these applications,
+you will probably want more control over the audio layer than Phonon will give you,
+and you should probably be using something like <a href="http://jackaudio.org/">JACK</a>.
 
 @authors
-Far too many to list.  See the copyright notices on the individual files,
-as well as the pages for individual components.
+Matthias Kretz \<kretz@kde.org\><br>
+Ricardo Villalba \<rvm@escomposlinux.org\><br>
+Ian Monroe \<ian@monroe.nu\><br>
+Nokia Corporation and/or its subsidiary(-ies)
 
 @maintainers
-There is no single maintainer for kdelibs.  Overall direction is governed by the
-<a href="https://mail.kde.org/mailman/listinfo/kde-core-devel">kde-core-devel
-mailing list</a>.  Some of the individual components have their own maintainers:
-see the component pages for more information.
+Matthias Kretz \<kretz@kde.org\>
 
 @licenses
 Libraries: @lgpl<br>
-Some helper binaries: @gpl<br>
-Some code may have more permissive licenses.
-
-
-*/
-
-/** @page components Components
-
-<p><b>
-@ref index "Overview" |
-Components |
-@ref development |
-@ref search
-</b></p>
-
-Below is a brief summary of the various libraries you may want to use
-when developing a KDE application.
-
-Note that there is more to kdelibs than these libraries: on the left
-is a complete list of kdelibs components.  However, in almost all cases
-you will only be interested in the ones listed below.  The remaining
-ones are mostly implementation details that you don't need to worry
-about.
-
-There are also several components you can use.  Interfaces to most of
-these can be found in the <a href="interfaces/html/index.html">interfaces
-section</a>, but you should also be aware of KHTMLPart, which
-provides a full web browser component.
-
-<dl>
-    <dt>KDECore</dt>
-    <dd>Core KDE classes that are not related to the user interface.<br>
-        [ <a href="kdecore/html/index.html">Documentation</a> |
-          <a href="kdecore/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KIO</dt>
-    <dd>KDE's network-transparent input/output system: provides
-        just about every file-management function you'll ever need.<br>
-        [ <a href="kio/html/index.html">Documentation</a> |
-          <a href="kio/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KDEUI</dt>
-    <dd>KDE User Interface classes such as widgets.<br>
-        [ <a href="kdeui/html/index.html">Documentation</a> |
-          <a href="kdeui/html/classes.html">Classes</a> ]</dd>
-
-    <dt>Phonon</dt>
-    <dd>KDE's multimedia framework.<br>
-        [ <a href="/kdesupport-api/kdesupport-apidocs/phonon/html/index.html">Documentation</a> |
-          <a href="/kdesupport-api/kdesupport-apidocs/phonon/html/group__Frontend.html">Classes</a> ]</dd>
-
-    <dt>Solid</dt>
-    <dd>KDE Hardware Discovery and Management classes.<br>
-        [ <a href="solid/html/index.html">Documentation</a> |
-          <a href="solid/html/classes.html">Classes</a> ]</dd>
-
-    <dt>Nepomuk</dt>
-    <dd>The KDE Meta Data library, for metadata assigned to a
-        resource (such as a file or an email) by the user or
-        by an application, such as tags or download locations.<br>
-        [ <a href="nepomuk/html/index.html">Documentation</a> |
-          <a href="nepomuk/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KParts</dt>
-    <dd>The KDE component library: provides support for re-usable,
-        embeddable, extendible components for use in applications.<br>
-        [ <a href="kparts/html/index.html">Documentation</a> |
-          <a href="kparts/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KNewStuff</dt>
-    <dd>Upload and download of application data.<br>
-        [ <a href="knewstuff/html/index.html">Documentation</a> |
-          <a href="knewstuff/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KDEPrint</dt>
-    <dd>The KDE printing system.<br>
-        [ <a href="kdeprint/html/index.html">Documentation</a> |
-          <a href="kdeprint/html/classes.html">Classes</a> ]</dd>
-
-    <dt>DNSSD</dt>
-    <dd>Access to the DNSSD (aka Bonjour, Zeroconf) service publishing
-        and discovery protocol.<br>
-        [ <a href="dnssd/html/index.html">Documentation</a> |
-          <a href="dnssd/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KJS</dt>
-    <dd>JavaScript (aka. ECMAScript and JScript) support.<br>
-        [ <a href="kjs/html/index.html">Documentation</a> |
-          <a href="kjs/html/classes.html">Classes</a> ]</dd>
-
-    <dt>Kross</dt>
-    <dd>Allows scripting to be added to an application in an
-        interpreter-independent way.<br>
-        [ <a href="kross/html/index.html">Documentation</a> |
-          <a href="kross/html/classes.html">Classes</a> ]</dd>
-
-    <dt>ThreadWeaver</dt>
-    <dd>A job-based multi-threading library<br>
-        [ <a href="threadweaver/html/index.html">Documentation</a> |
-          <a href="threadweaver/html/classes.html">Classes</a> ]</dd>
-
-    <dt>KDESU</dt>
-    <dd>Run processes remotely or with elevated privileges.<br>
-        [ <a href="kdesu/html/index.html">Documentation</a> |
-          <a href="kdesu/html/classes.html">Classes</a> ]</dd>
-</dl>
+Examples: @mit<br>
+Backends: @lgpl or @gpl
 
 */
@@ -165,50 +45,20 @@
 <p><b>
 @ref index "Overview" |
-@ref components |
-Development |
-@ref search
+Development
 </b></p>
 
-To follow or get involved with the development of the KDE libraries,
-join the <a href="https://mail.kde.org/mailman/listinfo/kde-core-devel">kde-core-devel
-mailing list</a>.
-
-Instructions for building a development version of KDE can be found in the
-<a href="http://techbase.kde.org/Getting_Started">getting started</a> section
-of the <a href="http://techbase.kde.org">KDE Techbase</a>.
-
-*/
+If you want to get involved with Phonon backend development please subscribe to <a href="https://mail.kde.org/mailman/listinfo/phonon-backends">phonon-backends@kde.org</a>.
 
-/** @page search Search
-
-<p><b>
-@ref index "Overview" |
-@ref components |
-@ref development |
-Search
-</b></p>
-
-You can search for any class in the public API of the KDE libraries
-here.
-
-Note: only enter the class name, without any namespace qualifiers.
-
-@htmlonly
-<form action="http://api.kde.org/classmapper.php" method="get">
-<input type="text" name="class" value="[classname]" style="width:100%;" onClick="this.value='';"/>
-<input type="submit" name="go" value="Go" />
-<input type=hidden name="module" value="kdelibs">
-<input type=hidden name="version" value="4.2">
-</form>
-@endhtmlonly
-
-If you want to search for any sort of identifier in kdelibs (and other code
-in the KDE SVN repository), you can do so using the
-<a href="http://lxr.kde.org">KDE Source Cross-Reference</a> tool.
+If you want to contribute, make comments or useful suggestions you can also write to the <a href="mailto:kde-multimedia@kde.org">KDE Multimedia mailinglist</a> or <a href="mailto:kretz@kde.org">Matthias Kretz</a>. You can join the mailinglist using the <a href="https://mail.kde.org/mailman/listinfo/kde-multimedia">webinterface</a> or take a look at the <a href="http://lists.kde.org/?l=kde-multimedia">archives</a>
 
 */
 
-// DOXYGEN_VERSION=4.2
-// DOXYGEN_NAME=kdelibs
+// DOXYGEN_VERSION=4.3
+// DOXYGEN_NAME=Phonon
 // DOXYGEN_ENABLE=YES
+// DOXYGEN_SET_INPUT = @topdir@/phonon/phonon @topdir@/phonon/Mainpage.dox
+// DOXYGEN_SET_FILE_PATTERNS = *.h *.dox */phononnamespace.h.in
+// ignore backend docs
+// DOXYGEN_SET_EXCLUDE_PATTERNS = *interface.h */phonon/examples/* */tests/* *_p.h */experimental/videocapturedevice/* */phonon/backend*
+
 // vim:ts=4:sw=4:expandtab:filetype=doxygen
diff -r -U2 -N phonon-4.3.0/phonon/abstractaudiooutput.cpp phonon-4.3.0/phonon/abstractaudiooutput.cpp
--- phonon-4.3.0/phonon/abstractaudiooutput.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractaudiooutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractaudiooutput.h phonon-4.3.0/phonon/abstractaudiooutput.h
--- phonon-4.3.0/phonon/abstractaudiooutput.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractaudiooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractaudiooutput_p.cpp phonon-4.3.0/phonon/abstractaudiooutput_p.cpp
--- phonon-4.3.0/phonon/abstractaudiooutput_p.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractaudiooutput_p.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractaudiooutput_p.h phonon-4.3.0/phonon/abstractaudiooutput_p.h
--- phonon-4.3.0/phonon/abstractaudiooutput_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractaudiooutput_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractmediastream.cpp phonon-4.3.0/phonon/abstractmediastream.cpp
--- phonon-4.3.0/phonon/abstractmediastream.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractmediastream.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractmediastream.h phonon-4.3.0/phonon/abstractmediastream.h
--- phonon-4.3.0/phonon/abstractmediastream.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractmediastream.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractmediastream_p.h phonon-4.3.0/phonon/abstractmediastream_p.h
--- phonon-4.3.0/phonon/abstractmediastream_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/abstractmediastream_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractvideooutput.cpp phonon-4.3.0/phonon/abstractvideooutput.cpp
--- phonon-4.3.0/phonon/abstractvideooutput.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractvideooutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractvideooutput.h phonon-4.3.0/phonon/abstractvideooutput.h
--- phonon-4.3.0/phonon/abstractvideooutput.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractvideooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -61,5 +61,5 @@
              * Constructor that is called from derived classes.
              *
-             * \param parent Standard QObject parent.
+             * \param d the private object
              */
             AbstractVideoOutput(AbstractVideoOutputPrivate &d);
diff -r -U2 -N phonon-4.3.0/phonon/abstractvideooutput_p.cpp phonon-4.3.0/phonon/abstractvideooutput_p.cpp
--- phonon-4.3.0/phonon/abstractvideooutput_p.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractvideooutput_p.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/abstractvideooutput_p.h phonon-4.3.0/phonon/abstractvideooutput_p.h
--- phonon-4.3.0/phonon/abstractvideooutput_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/abstractvideooutput_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/addoninterface.h phonon-4.3.0/phonon/addoninterface.h
--- phonon-4.3.0/phonon/addoninterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/addoninterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/audiodataoutput.cpp phonon-4.3.0/phonon/audiodataoutput.cpp
--- phonon-4.3.0/phonon/audiodataoutput.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiodataoutput.cpp	2009-08-12 15:26:02.000000000 -0700
@@ -0,0 +1,68 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "audiodataoutput_p.h"
+#include "factory_p.h"
+
+#define PHONON_CLASSNAME AudioDataOutput
+
+namespace Phonon
+{
+
+PHONON_HEIR_IMPL(AbstractAudioOutput)
+
+PHONON_GETTER(int, dataSize, d->dataSize)
+PHONON_GETTER(int, sampleRate, -1)
+PHONON_SETTER(setDataSize, dataSize, int)
+
+bool AudioDataOutputPrivate::aboutToDeleteBackendObject()
+{
+    Q_ASSERT(m_backendObject);
+    pBACKEND_GET(int, dataSize, "dataSize");
+
+    return AbstractAudioOutputPrivate::aboutToDeleteBackendObject();
+}
+
+void AudioDataOutputPrivate::setupBackendObject()
+{
+    Q_Q(AudioDataOutput);
+    Q_ASSERT(m_backendObject);
+    AbstractAudioOutputPrivate::setupBackendObject();
+
+    // set up attributes
+    pBACKEND_CALL1("setDataSize", int, dataSize);
+
+    qRegisterMetaType<QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > >("QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> >");
+
+    QObject::connect(m_backendObject,
+            SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)),
+            q, SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)));
+    QObject::connect(m_backendObject, SIGNAL(endOfMedia(int)), q, SIGNAL(endOfMedia(int)));
+}
+
+} // namespace Phonon
+
+#include "audiodataoutput.moc"
+
+#undef PHONON_CLASSNAME
+// vim: sw=4 ts=4 tw=80
diff -r -U2 -N phonon-4.3.0/phonon/audiodataoutput.h phonon-4.3.0/phonon/audiodataoutput.h
--- phonon-4.3.0/phonon/audiodataoutput.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiodataoutput.h	2009-08-18 12:14:57.000000000 -0700
@@ -0,0 +1,129 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005-2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#ifndef Phonon_AUDIODATAOUTPUT_H
+#define Phonon_AUDIODATAOUTPUT_H
+
+#include "phonon_export.h"
+#include "abstractaudiooutput.h"
+#include "phonondefs.h"
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+template<typename T> class QVector;
+template<typename Key, typename T> class QMap;
+#endif
+
+namespace Phonon
+{
+    class AudioDataOutputPrivate;
+
+    /**
+     * \short This class gives you the audio data (for visualizations).
+     *
+     * This class implements a special AbstractAudioOutput that gives your
+     * application the audio data. Don't expect realtime performance. But
+     * the latencies should be low enough to use the audio data for
+     * visualizations. You can also use the audio data for further processing
+     * (e.g. encoding and saving to a file).
+     *
+     * \author Matthias Kretz <kretz@kde.org>
+     */
+    class PHONON_EXPORT AudioDataOutput : public AbstractAudioOutput
+    {
+        Q_OBJECT
+        K_DECLARE_PRIVATE(AudioDataOutput)
+        Q_ENUMS(Channel)
+        Q_PROPERTY(int dataSize READ dataSize WRITE setDataSize)
+        PHONON_HEIR(AudioDataOutput)
+        public:
+            /**
+             * Specifies the channel the audio data belongs to.
+             */
+            enum Channel
+            {
+                LeftChannel,
+                RightChannel,
+                CenterChannel,
+                LeftSurroundChannel,
+                RightSurroundChannel,
+                SubwooferChannel
+            };
+
+            /**
+             * Returns the currently used number of samples passed through
+             * the signal.
+             *
+             * \see setDataSize
+             */
+            int dataSize() const;
+
+            /**
+             * Returns the sample rate in Hz. Common sample rates are 44100 Hz
+             * and 48000 Hz. AudioDataOutput will not do any sample rate
+             * conversion for you. If you need to convert the sample rate you
+             * might want to take a look at libsamplerate. For visualizations it
+             * is often enough to do simple interpolation or even drop/duplicate
+             * samples.
+             *
+             * \return The sample rate as reported by the backend. If the
+             * backend is unavailable -1 is returned.
+             */
+            int sampleRate() const;
+
+        public Q_SLOTS:
+            /**
+             * Sets the number of samples to be passed in one signal emission.
+             *
+             * Defaults to 512 samples per emitted signal.
+             *
+             * \param size the number of samples
+             */
+            void setDataSize(int size);
+
+        Q_SIGNALS:
+            /**
+             * Emitted whenever another dataSize number of samples are ready.
+             *
+             * \param data A mapping of Channel to a vector holding the audio data.
+             */
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+
+
+            /**
+             * This signal is emitted before the last dataReady signal of a
+             * media is emitted.
+             *
+             * If, for example, the playback of a media file has finished and the
+             * last audio data of that file is going to be passed with the next
+             * dataReady signal, and only the 28 first samples of the data
+             * vector are from that media file endOfMedia will be emitted right
+             * before dataReady with \p remainingSamples = 28.
+             *
+             * \param remainingSamples The number of samples in the next
+             * dataReady vector that belong to the media that was playing to
+             * this point.
+             */
+            void endOfMedia(int remainingSamples);
+    };
+} // namespace Phonon
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_AUDIODATAOUTPUT_H
diff -r -U2 -N phonon-4.3.0/phonon/audiodataoutputinterface.h phonon-4.3.0/phonon/audiodataoutputinterface.h
--- phonon-4.3.0/phonon/audiodataoutputinterface.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiodataoutputinterface.h	2009-08-08 08:34:09.000000000 -0700
@@ -0,0 +1,44 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_AUDIODATAOUTPUTINTERFACE_H
+#define PHONON_AUDIODATAOUTPUTINTERFACE_H
+
+namespace Phonon
+{
+
+class AudioDataOutput;
+
+class AudioDataOutputInterface
+{
+    public:
+        virtual ~AudioDataOutputInterface() {}
+
+        virtual AudioDataOutput *frontendObject() const = 0;
+        virtual void setFrontendObject(AudioDataOutput *) = 0;
+};
+
+} // namespace Phonon
+
+Q_DECLARE_INTERFACE(Phonon::AudioDataOutputInterface, "0AudioDataOutputInterface.phonon.kde.org")
+
+#endif // PHONON_AUDIODATAOUTPUTINTERFACE_H
diff -r -U2 -N phonon-4.3.0/phonon/audiodataoutput_p.h phonon-4.3.0/phonon/audiodataoutput_p.h
--- phonon-4.3.0/phonon/audiodataoutput_p.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiodataoutput_p.h	2009-08-12 15:26:02.000000000 -0700
@@ -0,0 +1,48 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef AUDIODATAOUTPUT_P_H
+#define AUDIODATAOUTPUT_P_H
+
+#include "audiodataoutput.h"
+#include "abstractaudiooutput_p.h"
+
+namespace Phonon
+{
+
+class AudioDataOutputPrivate : public AbstractAudioOutputPrivate
+{
+    Q_DECLARE_PUBLIC(AudioDataOutput)
+    PHONON_PRIVATECLASS
+    protected:
+        AudioDataOutputPrivate()
+            : dataSize(512)
+        {
+        }
+
+        int dataSize;
+};
+
+} // namespace Phonon
+
+#endif // AUDIODATAOUTPUT_P_H
+// vim: sw=4 ts=4 tw=80
diff -r -U2 -N phonon-4.3.0/phonon/audiooutputadaptor.cpp phonon-4.3.0/phonon/audiooutputadaptor.cpp
--- phonon-4.3.0/phonon/audiooutputadaptor.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutputadaptor.cpp	2009-01-22 09:38:28.000000000 -0700
@@ -3,5 +3,5 @@
  * when processing input file org.kde.Phonon.AudioOutput.xml
  *
- * dbusidl2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ * dbusidl2cpp is Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
  *
  * This is an auto-generated file. This file has been hand-edited.
diff -r -U2 -N phonon-4.3.0/phonon/audiooutputadaptor_p.h phonon-4.3.0/phonon/audiooutputadaptor_p.h
--- phonon-4.3.0/phonon/audiooutputadaptor_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutputadaptor_p.h	2009-01-22 09:38:28.000000000 -0700
@@ -3,5 +3,5 @@
  * when processing input file org.kde.Phonon.AudioOutput.xml
  *
- * dbusidl2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ * dbusidl2cpp is Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
  *
  * This is an auto-generated file. This file has been hand-edited.
diff -r -U2 -N phonon-4.3.0/phonon/audiooutput.cpp phonon-4.3.0/phonon/audiooutput.cpp
--- phonon-4.3.0/phonon/audiooutput.cpp	2009-01-22 01:20:44.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutput.cpp	2010-01-30 04:47:21.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -25,10 +25,11 @@
 #include "objectdescription.h"
 #include "audiooutputadaptor_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "audiooutputinterface.h"
 #include "phononnamespace_p.h"
 #include "platform_p.h"
+#include "pulsesupport.h"
 
-#include <qmath.h>
+#include <QtCore/qmath.h>
 
 #define PHONON_CLASSNAME AudioOutput
@@ -43,6 +44,10 @@
 {
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, int index)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, int index)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), index);
+
     Iface<IFACES2> iface(d);
     if (iface) {
@@ -52,6 +57,10 @@
 }
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, const AudioOutputDevice &dev)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, const AudioOutputDevice &dev)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), dev.index());
+
     Iface<IFACES2> iface(d);
     if (iface) {
@@ -78,10 +87,4 @@
 {
     Q_Q(AudioOutput);
-    category = c;
-
-    // select hardware device according to the category
-    device = AudioOutputDevice::fromIndex(GlobalConfig().audioOutputDeviceFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices));
-
-    createBackendObject();
 #ifndef QT_NO_DBUS
     adaptor = new AudioOutputAdaptor(q);
@@ -95,8 +98,17 @@
 #endif
 
+    category = c;
+    streamUuid = QUuid::createUuid().toString();
+    PulseSupport::getInstance()->setStreamPropList(category, streamUuid);
+
+    createBackendObject();
+
     q->connect(Factory::sender(), SIGNAL(availableAudioOutputDevicesChanged()), SLOT(_k_deviceListChanged()));
 }
 
-
+QString AudioOutputPrivate::getStreamUuid()
+{
+    return streamUuid;
+}
 
 void AudioOutputPrivate::createBackendObject()
@@ -106,4 +118,5 @@
     Q_Q(AudioOutput);
     m_backendObject = Factory::createAudioOutput(q);
+    device = AudioOutputDevice::fromIndex(GlobalConfig().audioOutputDeviceFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices));
     if (m_backendObject) {
         setupBackendObject();
@@ -126,10 +139,12 @@
     setVolume(Platform::loadVolume(newName));
 #ifndef QT_NO_DBUS
-    emit d->adaptor->nameChanged(newName);
+    if (d->adaptor) {
+        emit d->adaptor->nameChanged(newName);
+    }
 #endif
 }
 
-static const qreal LOUDNESS_TO_VOLTAGE_EXPONENT = 0.67;
-static const qreal VOLTAGE_TO_LOUDNESS_EXPONENT = 1.0/LOUDNESS_TO_VOLTAGE_EXPONENT;
+static const qreal LOUDNESS_TO_VOLTAGE_EXPONENT = qreal(0.67);
+static const qreal VOLTAGE_TO_LOUDNESS_EXPONENT = qreal(1.0/LOUDNESS_TO_VOLTAGE_EXPONENT);
 
 void AudioOutput::setVolume(qreal volume)
@@ -160,5 +175,5 @@
 #ifndef PHONON_LOG10OVER20
 #define PHONON_LOG10OVER20
-static const qreal log10over20 = 0.1151292546497022842; // ln(10) / 20
+static const qreal log10over20 = qreal(0.1151292546497022842); // ln(10) / 20
 #endif // PHONON_LOG10OVER20
 
@@ -232,5 +247,5 @@
     }
     if (k_ptr->backendObject()) {
-        return callSetOutputDevice(k_ptr, d->device.index());
+        return callSetOutputDevice(d, d->device.index());
     }
     return true;
@@ -400,6 +415,9 @@
 AudioOutputPrivate::~AudioOutputPrivate()
 {
+    PulseSupport::getInstance()->clearStreamCache(streamUuid);
 #ifndef QT_NO_DBUS
-    emit adaptor->outputDestroyed();
+    if (adaptor) {
+        emit adaptor->outputDestroyed();
+    }
 #endif
 }
diff -r -U2 -N phonon-4.3.0/phonon/audiooutput.h phonon-4.3.0/phonon/audiooutput.h
--- phonon-4.3.0/phonon/audiooutput.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/audiooutputinterface.cpp phonon-4.3.0/phonon/audiooutputinterface.cpp
--- phonon-4.3.0/phonon/audiooutputinterface.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutputinterface.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/audiooutputinterface.h phonon-4.3.0/phonon/audiooutputinterface.h
--- phonon-4.3.0/phonon/audiooutputinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutputinterface.h	2009-12-27 09:57:19.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -65,5 +65,5 @@
          * samples are multiplied by 2).
          *
-         * Everytime the volume in the backend changes it should emit volumeChanged(qreal), also
+         * Every time the volume in the backend changes it should emit volumeChanged(qreal), also
          * inside this function.
          */
diff -r -U2 -N phonon-4.3.0/phonon/audiooutput_p.h phonon-4.3.0/phonon/audiooutput_p.h
--- phonon-4.3.0/phonon/audiooutput_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/audiooutput_p.h	2009-11-19 17:10:15.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -47,4 +47,5 @@
         }
         void init(Phonon::Category c);
+        QString getStreamUuid();
 
 
@@ -80,4 +81,5 @@
         Phonon::AudioOutputDevice device;
         qreal volume;
+        QString streamUuid;
 #ifndef QT_NO_DBUS
         Phonon::AudioOutputAdaptor *adaptor;
diff -r -U2 -N phonon-4.3.0/phonon/backend/Mainpage.dox phonon-4.3.0/phonon/backend/Mainpage.dox
--- phonon-4.3.0/phonon/backend/Mainpage.dox	2008-11-24 10:11:55.000000000 -0700
+++ phonon-4.3.0/phonon/backend/Mainpage.dox	2009-01-10 11:08:49.000000000 -0700
@@ -105,4 +105,5 @@
 // DOXYGEN_SET_HIDE_UNDOC_MEMBERS = YES
 // DOXYGEN_SET_SOURCE_BROWSER = NO
-// DOXYGEN_SET_INPUT += @topdir@/phonon/addoninterface.h @topdir@/phonon/audiooutputinterface.h @topdir@/phonon/backendinterface.h @topdir@/phonon/effectinterface.h @topdir@/phonon/frontendinterface_p.h @topdir@/phonon/mediaobjectinterface.h @topdir@/phonon/streaminterface.h @topdir@/phonon/videowidgetinterface.h @topdir@/phonon/volumefaderinterface.h
+// DOXYGEN_SET_INPUT = @topdir@/phonon/phonon
+// DOXYGEN_SET_FILE_PATTERNS = *interface.h */phonon/backend/Mainpage.dox */backend.dox
 // vim: tw=100 ts=4 sw=4 expandtab filetype=doxygen
diff -r -U2 -N phonon-4.3.0/phonon/backendcapabilities.cpp phonon-4.3.0/phonon/backendcapabilities.cpp
--- phonon-4.3.0/phonon/backendcapabilities.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/backendcapabilities.cpp	2009-11-19 17:09:40.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -27,5 +27,5 @@
 #include "backendinterface.h"
 #include "factory_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "globalstatic_p.h"
 #include "objectdescription.h"
diff -r -U2 -N phonon-4.3.0/phonon/backendcapabilities.h phonon-4.3.0/phonon/backendcapabilities.h
--- phonon-4.3.0/phonon/backendcapabilities.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/backendcapabilities.h	2009-10-03 12:00:19.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -32,4 +32,10 @@
 QT_BEGIN_NAMESPACE
 
+#ifdef __QT_SYNCQT__
+// Tell syncqt that the BackendCapabilities namespace should be treated like a class
+#pragma qt_class(Phonon::BackendCapabilities)
+#pragma qt_sync_stop_processing
+#endif
+
 template<class T> class QList;
 class QStringList;
diff -r -U2 -N phonon-4.3.0/phonon/backendcapabilities_p.h phonon-4.3.0/phonon/backendcapabilities_p.h
--- phonon-4.3.0/phonon/backendcapabilities_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/backendcapabilities_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/backendinterface.h phonon-4.3.0/phonon/backendinterface.h
--- phonon-4.3.0/phonon/backendinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/backendinterface.h	2009-11-19 17:08:40.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/CMakeLists.txt phonon-4.3.0/phonon/CMakeLists.txt
--- phonon-4.3.0/phonon/CMakeLists.txt	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/CMakeLists.txt	2010-01-23 08:05:58.000000000 -0700
@@ -9,4 +9,28 @@
 add_subdirectory(experimental)
 
+set(PULSEAUDIO_MINIMUM_VERSION "0.9.15")
+macro_optional_find_package(PulseAudio)
+if (PULSEAUDIO_FOUND)
+    # PULSEAUDIO_DEVICE_MANAGER feature check could be moved to FindPulseAudio.cmake, hint hint. -- Rex
+    macro_ensure_version("0.9.21" "${PULSEAUDIO_VERSION}" PULSEAUDIO_DEVICE_MANAGER)
+endif (PULSEAUDIO_FOUND)
+macro_log_feature(PULSEAUDIO_FOUND "PulseAudio" "A cross-platform, networked sound server." "http://www.pulseaudio.org" FALSE "" "Allows audio playback via the PulseAudio soundserver when it is running")
+macro_optional_find_package(GLIB2)
+macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the pulseaudio for Phonon" "http://www.gtk.org/download/" FALSE)
+
+
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   add_definitions(-DHAVE_PULSEAUDIO)
+   include_directories(${GLIB2_INCLUDE_DIR} ${PULSEAUDIO_INCLUDE_DIR})
+   if (PULSEAUDIO_DEVICE_MANAGER)
+      add_definitions(-DHAVE_PULSEAUDIO_DEVICE_MANAGER)
+   endif(PULSEAUDIO_DEVICE_MANAGER)
+else(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   set(PULSEAUDIO_INCLUDE_DIR "")
+   set(PULSEAUDIO_LIBRARY "")
+   set(PULSEAUDIO_MAINLOOP_LIBRARY "")
+endif(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
+
 set(phonon_LIB_SRCS
    objectdescription.cpp
@@ -36,7 +60,10 @@
    videoplayer.cpp
    seekslider.cpp
+   swiftslider.cpp
    volumeslider.cpp
    effectwidget.cpp
    iodevicestream.cpp
+   audiodataoutput.cpp
+   pulsesupport.cpp
    )
 
@@ -51,4 +78,8 @@
 automoc4_add_library(phonon SHARED ${phonon_LIB_SRCS})
 target_link_libraries(phonon ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY})
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+target_link_libraries(phonon ${GLIB2_LIBRARIES} ${GOBJECT_LIBRARIES} ${PULSEAUDIO_LIBRARY} ${PULSEAUDIO_MAINLOOP_LIBRARY})
+endif (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
 if (QT_QTDBUS_FOUND)
   target_link_libraries(phonon ${QT_QTDBUS_LIBRARY})
@@ -100,4 +131,8 @@
    effectwidget.h
    platformplugin.h
+   audiodataoutput.h
+   audiodataoutputinterface.h
+   globalconfig.h
+   pulsesupport.h
    DESTINATION ${INCLUDE_INSTALL_DIR}/phonon COMPONENT Devel)
 
diff -r -U2 -N phonon-4.3.0/phonon/effect.cpp phonon-4.3.0/phonon/effect.cpp
--- phonon-4.3.0/phonon/effect.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effect.cpp	2009-10-03 12:00:19.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effect.h phonon-4.3.0/phonon/effect.h
--- phonon-4.3.0/phonon/effect.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effect.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -80,6 +80,5 @@
              *
              * \param description An EffectDescription object to determine the
-             * type of effect. See \ref
-             * BackendCapabilities::availableAudioEffects().
+             * type of effect. See BackendCapabilities::availableAudioEffects().
              * \param parent QObject parent
              */
diff -r -U2 -N phonon-4.3.0/phonon/effectinterface.h phonon-4.3.0/phonon/effectinterface.h
--- phonon-4.3.0/phonon/effectinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effectparameter.cpp phonon-4.3.0/phonon/effectparameter.cpp
--- phonon-4.3.0/phonon/effectparameter.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectparameter.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effectparameter.h phonon-4.3.0/phonon/effectparameter.h
--- phonon-4.3.0/phonon/effectparameter.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectparameter.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effectparameter_p.h phonon-4.3.0/phonon/effectparameter_p.h
--- phonon-4.3.0/phonon/effectparameter_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectparameter_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effect_p.h phonon-4.3.0/phonon/effect_p.h
--- phonon-4.3.0/phonon/effect_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effect_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effectwidget.cpp phonon-4.3.0/phonon/effectwidget.cpp
--- phonon-4.3.0/phonon/effectwidget.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/effectwidget.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/effectwidget.h phonon-4.3.0/phonon/effectwidget.h
--- phonon-4.3.0/phonon/effectwidget.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectwidget.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -40,5 +40,5 @@
 
     /** \class EffectWidget effectwidget.h Phonon/EffectWidget
-     * \brief Widget to control the parameters of an \ref Effect.
+     * \brief Widget to control the parameters of an Effect.
      *
      * \ingroup PhononWidgets
diff -r -U2 -N phonon-4.3.0/phonon/effectwidget_p.h phonon-4.3.0/phonon/effectwidget_p.h
--- phonon-4.3.0/phonon/effectwidget_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/effectwidget_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/examples/CMakeLists.txt phonon-4.3.0/phonon/examples/CMakeLists.txt
--- phonon-4.3.0/phonon/examples/CMakeLists.txt	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/examples/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
@@ -1,27 +0,0 @@
-include_directories(${KDE4_KIO_INCLUDES} ${CMAKE_SOURCE_DIR}/includes)
-
-# Examples don't need to go into toplevel/bin, they are fine in the current dir.
-set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR} )
-
-macro(PHONON_DECLARE_EXAMPLES)
-   foreach(_examplename ${ARGN})
-      set(_SRCS ${_examplename}.cpp)
-      automoc4_add_executable(${_examplename} ${_SRCS})
-      target_link_libraries(${_examplename} ${PHONON_LIBS})
-   endforeach(_examplename)
-endmacro(PHONON_DECLARE_EXAMPLES)
-
-phonon_declare_examples(
-    tutorial1
-    tutorial2
-    tutorial3
-    tutorial4
-    outputselector
-    #videoplayer
-    #crossfade
-    #videoplayandforget
-    #pcmoutput
-    #videoplayback
-    )
-
-#target_link_libraries(videoplayer ${KDE4_KDEUI_LIBS})
diff -r -U2 -N phonon-4.3.0/phonon/examples/crossfade.cpp phonon-4.3.0/phonon/examples/crossfade.cpp
--- phonon-4.3.0/phonon/examples/crossfade.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/crossfade.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,94 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "crossfade.h"
-#include <phonon/mediaqueue.h>
-#include <phonon/audiopath.h>
-#include <phonon/audiooutput.h>
-#include <phonon/ui/seekslider.h>
-#include <kurl.h>
-#include <QtCore/QTimer>
-#include <kaboutdata.h>
-#include <kcmdlineargs.h>
-#include <kapplication.h>
-#include <klocale.h>
-
-Crossfader::Crossfader(const KUrl &url1, const KUrl &url2, QObject *parent)
-    : QObject(parent)
-    , media(new MediaQueue(this))
-    , path(new AudioPath(this))
-    , output(new AudioOutput(Phonon::MusicCategory, this))
-{
-    media->addAudioPath(path);
-    path->addOutput(output);
-    media->setUrl(url1);
-    media->setNextUrl(url2);
-    connect(media, SIGNAL(finished()), SLOT(finished()));
-    SeekSlider *slider = new SeekSlider();
-    slider->setMediaProducer(media);
-    slider->resize(1000, 50);
-    slider->show();
-    media->play();
-    media->seek(media->totalTime() * 97 / 100);
-    //QTimer::singleShot(0, media, SLOT(play()));
-}
-
-void Crossfader::finished()
-{
-    static int count = 0;
-    ++count;
-    if (count == 2)
-    {
-        qApp->quit();
-    }
-}
-
-int main(int argc, char ** argv)
-{
-    KCmdLineOptions options;
-    options.add("+URL1", ki18n("The first URL to play"));
-    options.add("+URL2", ki18n("The second URL to play"));
-
-    KAboutData about("crossfade", 0, ki18n("Phonon Crossfade Example"),
-            "1.0", KLocalizedString(),
-            KAboutData::License_LGPL);
-    about.addAuthor(ki18n("Matthias Kretz"), KLocalizedString(), "kretz@kde.org");
-    KCmdLineArgs::init(argc, argv, &about);
-    KCmdLineArgs::addCmdLineOptions(options);
-    KApplication app;
-    KUrl url1;
-    KUrl url2;
-    KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
-    if (args->count() == 2)
-    {
-        url1 = args->url(0);
-        url2 = args->url(1);
-        if (url1.isValid() && url2.isValid())
-        {
-            Crossfader xfader(url1, url2);
-            return app.exec();
-        }
-    }
-    return 1;
-}
-
-#include "crossfade.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/crossfade.h phonon-4.3.0/phonon/examples/crossfade.h
--- phonon-4.3.0/phonon/examples/crossfade.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/crossfade.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,50 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef CROSSFADE_H
-#define CROSSFADE_H
-
-#include <QtCore/QObject>
-
-namespace Phonon {
-    class MediaQueue;
-    class AudioPath;
-    class AudioOutput;
-}
-class KUrl;
-using namespace Phonon;
-
-class Crossfader : public QObject
-{
-    Q_OBJECT
-    public:
-        Crossfader(const KUrl &url1, const KUrl &url2, QObject *parent = 0);
-
-    private Q_SLOTS:
-        void finished();
-
-    private:
-        MediaQueue *media;
-        AudioPath *path;
-        AudioOutput *output;
-};
-#endif // CROSSFADE_H
diff -r -U2 -N phonon-4.3.0/phonon/examples/outputselector.cpp phonon-4.3.0/phonon/examples/outputselector.cpp
--- phonon-4.3.0/phonon/examples/outputselector.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/examples/outputselector.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,391 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include <QtCore/QtDebug>
-#include <QtXml/QDomDocument>
-#include <QtDBus/QDBusConnection>
-#include <QtDBus/QDBusInterface>
-#include <QtDBus/QDBusConnectionInterface>
-#include <QtGui/QApplication>
-#include <QtGui/QToolButton>
-#include <QtGui/QGridLayout>
-#include <QtGui/QComboBox>
-#include <QtGui/QLabel>
-#include <QtGui/QMessageBox>
-#include <Phonon/AudioOutputDevice>
-#include <Phonon/BackendCapabilities>
-#include <Phonon/AudioOutputDeviceModel>
-
-class OrgKdePhononAudioOutputInterface: public QDBusAbstractInterface
-{
-    Q_OBJECT
-public:
-    static inline const char *staticInterfaceName()
-    { return "org.kde.Phonon.AudioOutput"; }
-
-public:
-    OrgKdePhononAudioOutputInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
-
-    ~OrgKdePhononAudioOutputInterface();
-
-    Q_PROPERTY(bool muted READ muted WRITE setMuted)
-    inline bool muted() const
-    { return qvariant_cast< bool >(internalPropGet("muted")); }
-    inline void setMuted(bool value)
-    { internalPropSet("muted", qVariantFromValue(value)); }
-
-    Q_PROPERTY(int outputDeviceIndex READ outputDeviceIndex WRITE setOutputDeviceIndex)
-    inline int outputDeviceIndex() const
-    { return qvariant_cast< int >(internalPropGet("outputDeviceIndex")); }
-    inline void setOutputDeviceIndex(int value)
-    { internalPropSet("outputDeviceIndex", qVariantFromValue(value)); }
-
-    Q_PROPERTY(double volume READ volume WRITE setVolume)
-    inline double volume() const
-    { return qvariant_cast< double >(internalPropGet("volume")); }
-    inline void setVolume(double value)
-    { internalPropSet("volume", qVariantFromValue(value)); }
-
-public Q_SLOTS: // METHODS
-    inline QDBusReply<QString> category()
-    {
-        QList<QVariant> argumentList;
-        return callWithArgumentList(QDBus::Block, QLatin1String("category"), argumentList);
-    }
-
-    inline QDBusReply<QString> name()
-    {
-        QList<QVariant> argumentList;
-        return callWithArgumentList(QDBus::Block, QLatin1String("name"), argumentList);
-    }
-
-Q_SIGNALS: // SIGNALS
-    void mutedChanged(bool in0);
-    void nameChanged(const QString &newName);
-    void newOutputAvailable(const QString &service, const QString &path);
-    void outputDestroyed();
-    void outputDeviceIndexChanged(int in0);
-    void volumeChanged(double in0);
-};
-
-namespace org {
-  namespace kde {
-    namespace Phonon {
-      typedef ::OrgKdePhononAudioOutputInterface AudioOutput;
-    }
-  }
-}
-
-OrgKdePhononAudioOutputInterface::OrgKdePhononAudioOutputInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
-    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
-{
-}
-
-OrgKdePhononAudioOutputInterface::~OrgKdePhononAudioOutputInterface()
-{
-}
-
-using Phonon::AudioOutputDevice;
-using Phonon::AudioOutputDeviceModel;
-
-class RemoteAudioOutput : public QWidget
-{
-    Q_OBJECT
-    public:
-        RemoteAudioOutput(const QList<AudioOutputDevice> &m,
-                const QString &service, const QString &path, QDBusConnection &connection, QWidget *parent);
-        ~RemoteAudioOutput()
-        {
-            delete nameLabel;
-            delete muteButton;
-            delete volumeSlider;
-            delete deviceCombo;
-        }
-
-        inline QString name() const { return m_name; }
-        inline QString category() const { return m_category; }
-        inline Phonon::AudioOutputDevice device() const { return m_device; }
-        inline double volume() const { return m_volume; }
-        inline bool muted() const { return m_muted; }
-
-        inline void setDevice(const Phonon::AudioOutputDevice &d) { iface->setOutputDeviceIndex(d.index()); }
-        inline void setVolume(double v) { iface->setVolume(v); }
-        inline void setMuted(bool m) { iface->setMuted(m); }
-
-    signals:
-        void changed();
-
-    private slots:
-        void nameChanged(const QString &newName);
-        void volumeChanged(double v);
-        void mutedChanged(bool m);
-        void outputDeviceIndexChanged(int i);
-        void toggleMute(bool m);
-        void sliderValue(int v);
-        void deviceSelected(int i);
-
-    private:
-        const QList<AudioOutputDevice> &m_modelData;
-        QString m_name;
-        QString m_category;
-        Phonon::AudioOutputDevice m_device;
-        double m_volume;
-        bool m_muted;
-        org::kde::Phonon::AudioOutput *iface;
-
-    public:
-        QLabel *nameLabel;
-        QToolButton *muteButton;
-        QSlider *volumeSlider;
-        QComboBox *deviceCombo;
-};
-
-void RemoteAudioOutput::nameChanged(const QString &newName)
-{
-    m_name = newName;
-    nameLabel->setText(m_name);
-    emit changed();
-}
-
-void RemoteAudioOutput::volumeChanged(double v)
-{
-    m_volume = v;
-    volumeSlider->setValue(static_cast<int>(m_volume * 1000));
-    emit changed();
-}
-
-void RemoteAudioOutput::mutedChanged(bool m)
-{
-    m_muted = m;
-    muteButton->setChecked(m_muted);
-    emit changed();
-}
-
-void RemoteAudioOutput::outputDeviceIndexChanged(int i)
-{
-    m_device = Phonon::AudioOutputDevice::fromIndex(i);
-    QAbstractItemModel *model = deviceCombo->model();
-    deviceCombo->setCurrentIndex(model->index(m_modelData.indexOf(m_device), 0).row());
-    emit changed();
-}
-
-RemoteAudioOutput::RemoteAudioOutput(const QList<AudioOutputDevice> &m,
-        const QString &service, const QString &path,
-        QDBusConnection &connection, QWidget *parent)
-    : QWidget(parent),
-    m_modelData(m),
-    iface(new org::kde::Phonon::AudioOutput(service, path, connection, this))
-{
-    connect(iface, SIGNAL(nameChanged(QString)), SLOT(nameChanged(QString)));
-    connect(iface, SIGNAL(volumeChanged(double)), SLOT(volumeChanged(double)));
-    connect(iface, SIGNAL(mutedChanged(bool)), SLOT(mutedChanged(bool)));
-    connect(iface, SIGNAL(outputDeviceIndexChanged(int)), SLOT(outputDeviceIndexChanged(int)));
-    connect(iface, SIGNAL(outputDestroyed()), SLOT(deleteLater()));
-    m_name = iface->name();
-    m_category = iface->category();
-    m_device = Phonon::AudioOutputDevice::fromIndex(iface->outputDeviceIndex());
-    m_volume = iface->volume();
-    m_muted = iface->muted();
-
-    nameLabel = new QLabel(m_name, parent);
-
-    muteButton = new QToolButton(parent);
-    muteButton->setCheckable(true);
-    muteButton->setChecked(m_muted);
-    connect(muteButton, SIGNAL(toggled(bool)), SLOT(toggleMute(bool)));
-
-    volumeSlider = new QSlider(Qt::Horizontal, parent);
-    volumeSlider->setMinimumSize(100, 10);
-    volumeSlider->setRange(0, 1000);
-    volumeSlider->setValue(static_cast<int>(m_volume * 1000));
-    connect(volumeSlider, SIGNAL(valueChanged(int)), SLOT(sliderValue(int)));
-
-    deviceCombo = new QComboBox(parent);
-    AudioOutputDeviceModel *model = new AudioOutputDeviceModel(deviceCombo);
-    model->setModelData(m_modelData);
-    deviceCombo->setModel(model);
-    deviceCombo->setCurrentIndex(model->index(m_modelData.indexOf(m_device), 0).row());
-    connect(deviceCombo, SIGNAL(activated(int)), SLOT(deviceSelected(int)));
-}
-
-void RemoteAudioOutput::toggleMute(bool m)
-{
-    iface->setMuted(m);
-}
-
-void RemoteAudioOutput::sliderValue(int v)
-{
-    iface->setVolume(v * 0.001);
-}
-
-void RemoteAudioOutput::deviceSelected(int i)
-{
-    iface->setOutputDeviceIndex(m_modelData.at(i).index());
-}
-
-class OutputSelector : public QWidget
-{
-    Q_OBJECT
-    public:
-        OutputSelector();
-
-    private slots:
-        void newOutputAvailable(const QString &service, const QString &path);
-        void introspectDone(const QDBusMessage &msg);
-        void cleanupOutput(QObject *o);
-        void updateModel();
-
-    private:
-        void addOutput(RemoteAudioOutput *);
-        QDBusConnection connection;
-        QList<RemoteAudioOutput *> m_outputs;
-        QList<AudioOutputDevice> m_modelData;
-        QGridLayout *layout;
-};
-
-void OutputSelector::updateModel()
-{
-    m_modelData = Phonon::BackendCapabilities::availableAudioOutputDevices();
-}
-
-OutputSelector::OutputSelector()
-    : connection(QDBusConnection::sessionBus()),
-    layout(new QGridLayout(this))
-{
-    if (!connection.isConnected()) {
-        QMessageBox::information(0, "D-Bus Connection Failed",
-                QString("Could not connect to D-Bus server %1: %1")
-                .arg(connection.lastError().name())
-                .arg(connection.lastError().message()));
-        exit(1);
-    }
-
-    layout->addWidget(new QLabel("Audio Output", this), 0, 0, Qt::AlignCenter);
-    layout->addWidget(new QLabel("Mute", this), 0, 1, Qt::AlignCenter);
-    layout->addWidget(new QLabel("Loudness", this), 0, 2, Qt::AlignCenter);
-    layout->addWidget(new QLabel("Device", this), 0, 3, Qt::AlignCenter);
-
-    m_modelData = Phonon::BackendCapabilities::availableAudioOutputDevices();
-    connect(Phonon::BackendCapabilities::notifier(), SIGNAL(availableAudioOutputDevicesChanged()),
-            SLOT(updateModel()));
-
-    connection.connect(QString(), QString(), QLatin1String(org::kde::Phonon::AudioOutput::staticInterfaceName()),
-            QLatin1String("newOutputAvailable"), this, SLOT(newOutputAvailable(QString, QString)));
-
-    QDBusConnectionInterface *bus = connection.interface();
-    QMap<uint, QString> serviceNameForPid;
-    {
-        const QStringList &services = bus->registeredServiceNames();
-        foreach (const QString &serviceName, services) {
-            QDBusReply<uint> reply = bus->servicePid(serviceName);
-            if (!reply.isValid()) {
-                continue;
-            }
-            const uint pid = reply;
-            if (!serviceNameForPid.value(pid).isEmpty()) {
-                continue;
-            }
-            const QString &s = bus->serviceOwner(serviceName);
-            if (s != connection.baseService()) {
-                serviceNameForPid[pid] = s;
-            }
-        }
-    }
-
-    for (QMapIterator<uint, QString> it(serviceNameForPid); it.hasNext();) {
-        it.next();
-        connection.callWithCallback(QDBusMessage::createMethodCall(it.value(),
-                    QLatin1String("/AudioOutputs"),
-                    QLatin1String("org.freedesktop.DBus.Introspectable"),
-                    QLatin1String("Introspect")),
-                this, SLOT(introspectDone(QDBusMessage)), 0, -1);
-    }
-}
-
-void OutputSelector::introspectDone(const QDBusMessage &msg)
-{
-    if (msg.arguments().size() != 1 || msg.arguments().first().type() != QVariant::String) {
-        return;
-    }
-    const QString &xml = msg.arguments().first().toString();
-
-    QDomDocument doc;
-    doc.setContent(xml);
-    QDomElement node = doc.documentElement();
-    for (QDomElement child = node.firstChildElement(); !child.isNull();
-            child = child.nextSiblingElement()) {
-        if (child.tagName() == QLatin1String("node")) {
-            const QString &path = QLatin1String("/AudioOutputs/") + child.attribute(QLatin1String("name"));
-            addOutput(new RemoteAudioOutput(m_modelData, msg.service(), path, connection, this));
-        }
-    }
-}
-
-void OutputSelector::newOutputAvailable(const QString &service, const QString &path)
-{
-    addOutput(new RemoteAudioOutput(m_modelData, service, path, connection, this));
-}
-
-void OutputSelector::addOutput(RemoteAudioOutput *r)
-{
-    layout->addWidget(r->nameLabel, 1 + m_outputs.size(), 0);
-    layout->addWidget(r->muteButton, 1 + m_outputs.size(), 1);
-    layout->addWidget(r->volumeSlider, 1 + m_outputs.size(), 2);
-    layout->addWidget(r->deviceCombo, 1 + m_outputs.size(), 3);
-    connect(r, SIGNAL(destroyed(QObject*)), SLOT(cleanupOutput(QObject*)));
-    m_outputs << r;
-    qDebug() << m_outputs.size();
-}
-
-void OutputSelector::cleanupOutput(QObject *o)
-{
-    RemoteAudioOutput *r = static_cast<RemoteAudioOutput *>(o);
-    const int row = m_outputs.indexOf(r);
-    for (int i = row; i < layout->rowCount() - 1; ++i) {
-        for (int j = 0; j < 4; ++j) {
-            QLayoutItem *item = layout->itemAtPosition(i + 2, j);
-            if (item) {
-                layout->addItem(item, i + 1, j);
-            }
-        }
-        for (int j = 0; j < 4; ++j) {
-            QLayoutItem *item = layout->itemAtPosition(i + 2, j);
-            if (item) {
-                layout->removeItem(item);
-            }
-        }
-    }
-    m_outputs.removeAt(row);
-}
-
-int main(int argc, char **argv)
-{
-    QApplication app(argc, argv);
-
-    OutputSelector s;
-    s.show();
-
-    return app.exec();
-}
-
-#include "outputselector.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/pcmoutput.cpp phonon-4.3.0/phonon/examples/pcmoutput.cpp
--- phonon-4.3.0/phonon/examples/pcmoutput.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/pcmoutput.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,148 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-
-#include "pcmoutput.h"
-
-#include <kaboutdata.h>
-#include <kcmdlineargs.h>
-#include <kapplication.h>
-#include <QtCore/QByteRef>
-#include <QtCore/QDataStream>
-#include <QtGui/QSlider>
-#include <QtGui/QBoxLayout>
-#include <phonon/audiooutput.h>
-#include <phonon/audiopath.h>
-#include <phonon/bytestream.h>
-#include <QtCore/QTimer>
-#include <QtCore/QFile>
-#include <QtGui/QLabel>
-
-static const int SAMPLE_RATE = 48000;
-
-PcmPlayer::PcmPlayer(QWidget *parent)
-    : QWidget(parent),
-    m_frequency(440)
-{
-    Phonon::AudioOutput *m_output = new Phonon::AudioOutput(Phonon::MusicCategory, this);
-    Phonon::AudioPath *m_path = new Phonon::AudioPath(this);
-    m_path->addOutput(m_output);
-    m_stream = new Phonon::ByteStream(this);
-    m_stream->addAudioPath(m_path);
-    m_stream->setStreamSeekable(false);
-    m_stream->setStreamSize(0x7FFFFFFF);
-
-    QTimer *m_timer = new QTimer(this);
-    m_timer->setInterval(0);
-    connect(m_timer, SIGNAL(timeout()), SLOT(sendData()));
-
-    connect(m_stream, SIGNAL(needData()), m_timer, SLOT(start()));
-    connect(m_stream, SIGNAL(enoughData()), m_timer, SLOT(stop()));
-
-    m_stream->writeData(wavHeader());
-
-    setLayout(new QHBoxLayout);
-    QSlider *slider = new QSlider(this);
-    layout()->addWidget(slider);
-    slider->setRange(200, 4000);
-    slider->setValue(m_frequency);
-    connect(slider, SIGNAL(valueChanged(int)), SLOT(setFrequency(int)));
-
-    QTimer::singleShot(0, m_timer, SLOT(start()));
-    QTimer::singleShot(0, m_stream, SLOT(play()));
-
-    m_fLabel = new QLabel(this);
-    layout()->addWidget(m_fLabel);
-    m_fLabel->setText(QString::number(m_frequency));
-}
-
-void PcmPlayer::setFrequency(int f)
-{
-    m_frequency = f;
-    m_fLabel->setText(QString::number(m_frequency));
-}
-
-void PcmPlayer::sendData()
-{
-    m_stream->writeData(pcmBlock(m_frequency));
-}
-
-QByteArray PcmPlayer::wavHeader() const
-{
-    QByteArray data;
-    QDataStream stream(&data, QIODevice::WriteOnly);
-    stream.setByteOrder(QDataStream::LittleEndian);
-    stream
-        << 0x46464952 //"RIFF"
-        << static_cast<quint32>(0x7FFFFFFF)
-        << 0x45564157 //"WAVE"
-        << 0x20746D66 //"fmt "           //Subchunk1ID
-        << static_cast<quint32>(16)    //Subchunk1Size
-        << static_cast<quint16>(1)     //AudioFormat
-        << static_cast<quint16>(2)     //NumChannels
-        << static_cast<quint32>(SAMPLE_RATE) //SampleRate
-        << static_cast<quint32>(2 *2 *SAMPLE_RATE)//ByteRate
-        << static_cast<quint16>(2 *2)   //BlockAlign
-        << static_cast<quint16>(16)    //BitsPerSample
-        << 0x61746164 //"data"                   //Subchunk2ID
-        << static_cast<quint32>(0x7FFFFFFF-36)//Subchunk2Size
-        ;
-    return data;
-}
-
-QByteArray PcmPlayer::pcmBlock(int freq) const
-{
-    QByteArray data;
-    QDataStream stream(&data, QIODevice::WriteOnly);
-    stream.setByteOrder(QDataStream::LittleEndian);
-
-    const int samplesPerHalfWave = SAMPLE_RATE / (2 *freq);
-    const int sampleDiff = (1 << 16) / samplesPerHalfWave;
-    const int samplesPerQuarterWave = samplesPerHalfWave / 2;
-
-    for (int i = 0; i < samplesPerQuarterWave; ++i)
-        stream << static_cast<quint16>(i * sampleDiff)
-            << static_cast<quint16>(-i * sampleDiff);
-    for (int i = 0; i < samplesPerHalfWave; ++i)
-        stream << static_cast<quint16>(32767 - i * sampleDiff)
-            << static_cast<quint16>(-32768 + i * sampleDiff);
-    for (int i = 0; i < samplesPerQuarterWave; ++i)
-        stream << static_cast<quint16>(-32768 + i * sampleDiff)
-            << static_cast<quint16>(32767 - i * sampleDiff);
-
-    return data;
-}
-
-int main(int argc, char ** argv)
-{
-    KAboutData about("videoplayandforget", 0, ki18n("Phonon VideoPlayer Example"),
-            "1.0", KLocalizedString(),
-            KAboutData::License_LGPL);
-    about.addAuthor(ki18n("Matthias Kretz"), KLocalizedString(), "kretz@kde.org");
-    KCmdLineArgs::init(argc, argv, &about);
-    KApplication app;
-    PcmPlayer player;
-    player.show();
-    app.exec();
-}
-
-#include "pcmoutput.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/pcmoutput.h phonon-4.3.0/phonon/examples/pcmoutput.h
--- phonon-4.3.0/phonon/examples/pcmoutput.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/pcmoutput.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,50 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PCMOUTPUT_H
-#define PCMOUTPUT_H
-
-#include <QtGui/QWidget>
-
-class QByteArray;
-class QLabel;
-namespace Phonon { class ByteStream; }
-
-class PcmPlayer : public QWidget
-{
-    Q_OBJECT
-    public:
-        PcmPlayer(QWidget *parent = 0);
-
-    private Q_SLOTS:
-        void setFrequency(int f);
-        void sendData();
-
-    private:
-        QByteArray wavHeader() const;
-        QByteArray pcmBlock(int freq) const;
-        int m_frequency;
-        Phonon::ByteStream *m_stream;
-        QLabel *m_fLabel;
-};
-
-#endif // PCMOUTPUT_H
diff -r -U2 -N phonon-4.3.0/phonon/examples/playback.cpp phonon-4.3.0/phonon/examples/playback.cpp
--- phonon-4.3.0/phonon/examples/playback.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/playback.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,27 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-MediaObject *media = new MediaObject;
-media->setUrl(url);
-media->play();
-connect(media, SIGNAL(finished()), media, SLOT(deleteLater()));
diff -r -U2 -N phonon-4.3.0/phonon/examples/simpleplay.cpp phonon-4.3.0/phonon/examples/simpleplay.cpp
--- phonon-4.3.0/phonon/examples/simpleplay.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/simpleplay.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,3 +0,0 @@
-SimplePlayer *player = new SimplePlayer;
-player->play(url);
-connect(player, SIGNAL(finished()), player, SLOT(deleteLater()));
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial1.cpp phonon-4.3.0/phonon/examples/tutorial1.cpp
--- phonon-4.3.0/phonon/examples/tutorial1.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial1.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,44 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include <Phonon/MediaObject>
-#include <Phonon/AudioOutput>
-#include <QtCore/QCoreApplication>
-#include <QtCore/QStringList>
-
-int main(int argc, char **argv)
-{
-    QCoreApplication app(argc, argv);
-    if (app.arguments().size() != 2) {
-        return -1;
-    }
-    QCoreApplication::setApplicationName("Phonon Tutorial 1");
-    Phonon::MediaObject media;
-    media.setCurrentSource(app.arguments().at(1));
-    Phonon::AudioOutput output;
-    Phonon::createPath(&media, &output);
-    QObject::connect(&media, SIGNAL(finished()), &app, SLOT(quit()));
-    media.play();
-
-    return app.exec();
-}
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial1.pro phonon-4.3.0/phonon/examples/tutorial1.pro
--- phonon-4.3.0/phonon/examples/tutorial1.pro	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial1.pro	1969-12-31 17:00:00.000000000 -0700
@@ -1,10 +0,0 @@
-######################################################################
-# Automatically generated by qmake (1.07a) Sat Jun 16 16:32:00 2007
-######################################################################
-
-TEMPLATE = app
-INCLUDEPATH += ../../includes
-LIBS += -L.. -lphonon -Wl,-rpath,..
-
-# Input
-SOURCES += tutorial1.cpp
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial2.cpp phonon-4.3.0/phonon/examples/tutorial2.cpp
--- phonon-4.3.0/phonon/examples/tutorial2.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial2.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,88 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include <Phonon/MediaObject>
-#include <Phonon/Path>
-#include <Phonon/AudioOutput>
-#include <Phonon/Global>
-
-#include <QtGui/QApplication>
-#include <QtGui/QMainWindow>
-#include <QtGui/QDirModel>
-#include <QtGui/QColumnView>
-
-class MainWindow : public QMainWindow
-{
-    Q_OBJECT
-    public:
-        MainWindow();
-
-    private slots:
-        void play(const QModelIndex &index);
-
-    private:
-        void delayedInit();
-
-        QColumnView m_fileView;
-        QDirModel m_model;
-
-        Phonon::MediaObject *m_media;
-};
-
-MainWindow::MainWindow()
-    : m_fileView(this),
-    m_media(0)
-{
-    setCentralWidget(&m_fileView);
-    m_fileView.setModel(&m_model);
-    m_fileView.setFrameStyle(QFrame::NoFrame);
-
-    connect(&m_fileView, SIGNAL(updatePreviewWidget(const QModelIndex &)), SLOT(play(const QModelIndex &)));
-}
-
-void MainWindow::play(const QModelIndex &index)
-{
-    delayedInit();
-    m_media->setCurrentSource(m_model.filePath(index));
-    m_media->play();
-}
-
-void MainWindow::delayedInit()
-{
-    if (!m_media) {
-        m_media = new Phonon::MediaObject(this);
-        Phonon::AudioOutput *audioOutput = new Phonon::AudioOutput(Phonon::MusicCategory, this);
-        createPath(m_media, audioOutput);
-    }
-}
-
-int main(int argc, char **argv)
-{
-    QApplication app(argc, argv);
-    QApplication::setApplicationName("Phonon Tutorial 2");
-    MainWindow mw;
-    mw.show();
-    return app.exec();
-}
-
-#include "tutorial2.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial2.pro phonon-4.3.0/phonon/examples/tutorial2.pro
--- phonon-4.3.0/phonon/examples/tutorial2.pro	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial2.pro	1969-12-31 17:00:00.000000000 -0700
@@ -1,10 +0,0 @@
-######################################################################
-# Automatically generated by qmake (2.07a) Sat Jun 26 26:32:00 2007
-######################################################################
-
-TEMPLATE = app
-INCLUDEPATH += ../../includes
-LIBS += -L.. -lphonon -Wl,-rpath,..
-
-# Input
-SOURCES += tutorial2.cpp
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial3.cpp phonon-4.3.0/phonon/examples/tutorial3.cpp
--- phonon-4.3.0/phonon/examples/tutorial3.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial3.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,138 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include <Phonon/AudioOutput>
-#include <Phonon/Global>
-#include <Phonon/MediaObject>
-#include <Phonon/Path>
-#include <Phonon/SeekSlider>
-#include <Phonon/VolumeSlider>
-
-#include <QtGui/QApplication>
-#include <QtGui/QColumnView>
-#include <QtGui/QDirModel>
-#include <QtGui/QFrame>
-#include <QtGui/QHBoxLayout>
-#include <QtGui/QMainWindow>
-#include <QtGui/QPushButton>
-#include <QtGui/QVBoxLayout>
-#include <QtGui/QWidget>
-
-class PlayerWidget : public QWidget
-{
-    Q_OBJECT
-    public:
-        PlayerWidget();
-
-        void play(const QString &);
-
-    private:
-        void delayedInit();
-
-        Phonon::MediaObject *m_media;
-};
-
-class MainWindow : public QMainWindow
-{
-    Q_OBJECT
-    public:
-        MainWindow();
-
-    private slots:
-        void providePlayer(const QModelIndex &index);
-
-    private:
-        QColumnView m_fileView;
-        QDirModel m_model;
-        PlayerWidget m_player;
-};
-PlayerWidget::PlayerWidget()
-    : m_media(0)
-{
-}
-
-void PlayerWidget::delayedInit()
-{
-    if (!m_media) {
-        m_media = new Phonon::MediaObject(this);
-        Phonon::AudioOutput *audioOutput = new Phonon::AudioOutput(Phonon::MusicCategory, this);
-        createPath(m_media, audioOutput);
-
-        QHBoxLayout *topLayout = new QHBoxLayout(this);
-        QVBoxLayout *leftLayout = new QVBoxLayout(this);
-        QHBoxLayout *buttonLayout = new QHBoxLayout(this);
-
-        Phonon::VolumeSlider *vs = new Phonon::VolumeSlider(audioOutput, this);
-        vs->setOrientation(Qt::Vertical);
-
-        QPushButton *playButton = new QPushButton(QLatin1String("play"), this);
-        connect(playButton, SIGNAL(clicked()), m_media, SLOT(play()));
-
-        QPushButton *stopButton = new QPushButton(QLatin1String("stop"), this);
-        connect(stopButton, SIGNAL(clicked()), m_media, SLOT(stop()));
-
-        topLayout->addLayout(leftLayout);
-        topLayout->addWidget(vs);
-
-        leftLayout->addLayout(buttonLayout);
-        leftLayout->addWidget(new Phonon::SeekSlider(m_media, this));
-        leftLayout->addStretch();
-
-        buttonLayout->addWidget(playButton);
-        buttonLayout->addWidget(stopButton);
-    }
-}
-
-void PlayerWidget::play(const QString &filename)
-{
-    delayedInit();
-    m_media->setCurrentSource(filename);
-    m_media->play();
-}
-
-MainWindow::MainWindow()
-    : m_fileView(this)
-{
-    setCentralWidget(&m_fileView);
-    m_fileView.setModel(&m_model);
-    m_fileView.setPreviewWidget(&m_player);
-    m_fileView.setFrameStyle(QFrame::NoFrame);
-
-    connect(&m_fileView, SIGNAL(updatePreviewWidget(const QModelIndex &)), SLOT(providePlayer(const QModelIndex &)));
-}
-
-void MainWindow::providePlayer(const QModelIndex &index)
-{
-    m_player.play(m_model.filePath(index));
-}
-
-int main(int argc, char **argv)
-{
-    QApplication app(argc, argv);
-    QApplication::setApplicationName("Phonon Tutorial 3");
-    MainWindow mw;
-    mw.show();
-    return app.exec();
-}
-
-#include "tutorial3.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial3.pro phonon-4.3.0/phonon/examples/tutorial3.pro
--- phonon-4.3.0/phonon/examples/tutorial3.pro	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial3.pro	1969-12-31 17:00:00.000000000 -0700
@@ -1,10 +0,0 @@
-######################################################################
-# Automatically generated by qmake (3.07a) Sat Jun 36 36:32:00 2007
-######################################################################
-
-TEMPLATE = app
-INCLUDEPATH += ../../includes
-LIBS += -L.. -lphonon -Wl,-rpath,..
-
-# Input
-SOURCES += tutorial3.cpp
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial4.cpp phonon-4.3.0/phonon/examples/tutorial4.cpp
--- phonon-4.3.0/phonon/examples/tutorial4.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial4.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,145 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include <Phonon/AudioOutput>
-#include <Phonon/Global>
-#include <Phonon/MediaObject>
-#include <Phonon/Path>
-#include <Phonon/SeekSlider>
-#include <Phonon/VolumeSlider>
-
-#include <QtGui/QApplication>
-#include <QtGui/QColumnView>
-#include <QtGui/QDirModel>
-#include <QtGui/QFrame>
-#include <QtGui/QHBoxLayout>
-#include <QtGui/QMainWindow>
-#include <QtGui/QPushButton>
-#include <QtGui/QVBoxLayout>
-#include <QtGui/QWidget>
-
-class PlayerWidget : public QWidget
-{
-    Q_OBJECT
-    public:
-        PlayerWidget();
-
-        void play(const QDirModel *model, const QModelIndex &index);
-
-    private:
-        void delayedInit();
-
-        Phonon::MediaObject *m_media;
-};
-
-class MainWindow : public QMainWindow
-{
-    Q_OBJECT
-    public:
-        MainWindow();
-
-    private slots:
-        void providePlayer(const QModelIndex &index);
-
-    private:
-        QColumnView m_fileView;
-        QDirModel m_model;
-        PlayerWidget m_player;
-};
-
-PlayerWidget::PlayerWidget()
-    : m_media(0)
-{
-}
-
-void PlayerWidget::delayedInit()
-{
-    if (!m_media) {
-        m_media = new Phonon::MediaObject(this);
-        Phonon::AudioOutput *audioOutput = new Phonon::AudioOutput(Phonon::MusicCategory, this);
-        createPath(m_media, audioOutput);
-
-        QHBoxLayout *topLayout = new QHBoxLayout(this);
-        QVBoxLayout *leftLayout = new QVBoxLayout(this);
-        QHBoxLayout *buttonLayout = new QHBoxLayout(this);
-
-        Phonon::VolumeSlider *vs = new Phonon::VolumeSlider(audioOutput, this);
-        vs->setOrientation(Qt::Vertical);
-
-        QPushButton *playButton = new QPushButton(QLatin1String("play"), this);
-        connect(playButton, SIGNAL(clicked()), m_media, SLOT(play()));
-
-        QPushButton *stopButton = new QPushButton(QLatin1String("stop"), this);
-        connect(stopButton, SIGNAL(clicked()), m_media, SLOT(stop()));
-
-        topLayout->addLayout(leftLayout);
-        topLayout->addWidget(vs);
-
-        leftLayout->addLayout(buttonLayout);
-        leftLayout->addWidget(new Phonon::SeekSlider(m_media, this));
-        leftLayout->addStretch();
-
-        buttonLayout->addWidget(playButton);
-        buttonLayout->addWidget(stopButton);
-    }
-}
-
-void PlayerWidget::play(const QDirModel *model, const QModelIndex &index)
-{
-    delayedInit();
-    m_media->clearQueue();
-    m_media->setCurrentSource(model->filePath(index));
-    m_media->play();
-    QModelIndex nextIndex = index.sibling(index.row() + 1, index.column());
-    while (nextIndex.isValid()) {
-        m_media->enqueue(model->filePath(nextIndex));
-        nextIndex = index.sibling(nextIndex.row() + 1, nextIndex.column());
-    }
-}
-
-MainWindow::MainWindow()
-    : m_fileView(this)
-{
-    setCentralWidget(&m_fileView);
-    m_fileView.setModel(&m_model);
-    m_fileView.setPreviewWidget(&m_player);
-    m_fileView.setFrameStyle(QFrame::NoFrame);
-
-    connect(&m_fileView, SIGNAL(updatePreviewWidget(const QModelIndex &)), SLOT(providePlayer(const QModelIndex &)));
-}
-
-void MainWindow::providePlayer(const QModelIndex &index)
-{
-    m_player.play(&m_model, index);
-}
-
-int main(int argc, char **argv)
-{
-    QApplication app(argc, argv);
-    QApplication::setApplicationName("Phonon Tutorial 4");
-    MainWindow mw;
-    mw.show();
-    return app.exec();
-}
-
-#include "tutorial4.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/tutorial4.pro phonon-4.3.0/phonon/examples/tutorial4.pro
--- phonon-4.3.0/phonon/examples/tutorial4.pro	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/tutorial4.pro	1969-12-31 17:00:00.000000000 -0700
@@ -1,10 +0,0 @@
-######################################################################
-# Automatically generated by qmake (4.07a) Sat Jun 46 46:32:00 2007
-######################################################################
-
-TEMPLATE = app
-INCLUDEPATH += ../../includes
-LIBS += -L.. -lphonon -Wl,-rpath,..
-
-# Input
-SOURCES += tutorial4.cpp
diff -r -U2 -N phonon-4.3.0/phonon/examples/videoplayandforget.cpp phonon-4.3.0/phonon/examples/videoplayandforget.cpp
--- phonon-4.3.0/phonon/examples/videoplayandforget.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/videoplayandforget.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,61 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <phonon/ui/videoplayer.h>
-#include <kaboutdata.h>
-#include <kcmdlineargs.h>
-#include <kapplication.h>
-#include <kurl.h>
-#include <klocale.h>
-
-using namespace Phonon;
-
-int main(int argc, char ** argv)
-{
-    KCmdLineOptions options;
-    options.add("+URL", ki18n("An URL to a video"));
-
-    KAboutData about("videoplayandforget", 0, ki18n("Phonon VideoPlayer Example"),
-            "1.0", KLocalizedString(),
-            KAboutData::License_LGPL);
-    about.addAuthor(ki18n("Matthias Kretz"), KLocalizedString(), "kretz@kde.org");
-    KCmdLineArgs::init(argc, argv, &about);
-    KCmdLineArgs::addCmdLineOptions(options);
-    KApplication app;
-    KUrl url;
-    KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
-    if (args->count() == 1)
-    {
-        url = args->url(0);
-        if (url.isValid())
-        {
-            VideoPlayer player(Phonon::VideoCategory);
-            QObject::connect(&player, SIGNAL(finished()), &app, SLOT(quit()));
-            player.show();
-            player.resize(640, 480);
-            player.play(url);
-            player.seek(player.totalTime() * 9 / 10);
-            return app.exec();
-        }
-    }
-    return 1;
-}
diff -r -U2 -N phonon-4.3.0/phonon/examples/videoplayback.cpp phonon-4.3.0/phonon/examples/videoplayback.cpp
--- phonon-4.3.0/phonon/examples/videoplayback.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/videoplayback.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,82 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#include "videoplayback.h"
-
-#include <QtGui/QBoxLayout>
-
-#include <phonon/videopath.h>
-#include <phonon/audiooutput.h>
-#include <phonon/audiopath.h>
-#include <phonon/mediaobject.h>
-#include <phonon/ui/videowidget.h>
-#include <phonon/ui/mediacontrols.h>
-
-using namespace Phonon;
-
-MediaPlayer::MediaPlayer(QWidget *parent)
-    : QWidget(parent)
-{
-    QVBoxLayout *layout = new QVBoxLayout(this);
-
-    m_vwidget = new VideoWidget(this);
-    layout->addWidget(m_vwidget);
-    m_vwidget->hide();
-
-    m_vpath = new VideoPath(this);
-
-        // might need VideoCategory here
-        m_aoutput = new AudioOutput(Phonon::MusicCategory, this);
-    m_apath = new AudioPath(this);
-
-    m_media = new MediaObject(this);
-    m_media->addVideoPath(m_vpath);
-    m_vpath->addOutput(m_vwidget);
-    m_media->addAudioPath(m_apath);
-    m_apath->addOutput(m_aoutput);
-
-    m_controls = new MediaControls(this);
-    layout->addWidget(m_controls);
-    m_controls->setMediaProducer(m_media);
-    m_controls->setAudioOutput(m_aoutput);
-
-        connect(m_media, SIGNAL(hasVideoChanged(bool)), SLOT(hasVideoChanged(bool)));
-}
-
-void MediaPlayer::setUrl(const KUrl &url)
-{
-    m_media->setUrl(url);
-    m_vwidget->setVisible(m_media->hasVideo());
-}
-
-void MediaPlayer::hasVideoChanged(bool hasVideo)
-{
-    m_vwidget->setVisible(hasVideo);
-}
-
-int main()
-{
-    return 0;
-}
-
-#include "videoplayback.moc"
diff -r -U2 -N phonon-4.3.0/phonon/examples/videoplayback.h phonon-4.3.0/phonon/examples/videoplayback.h
--- phonon-4.3.0/phonon/examples/videoplayback.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/examples/videoplayback.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,62 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-
-    Permission to use, copy, modify, and distribute this software
-    and its documentation for any purpose and without fee is hereby
-    granted, provided that the above copyright notice appear in all
-    copies and that both that the copyright notice and this
-    permission notice and warranty disclaimer appear in supporting
-    documentation, and that the name of the author not be used in
-    advertising or publicity pertaining to distribution of the
-    software without specific, written prior permission.
-
-    The author disclaim all warranties with regard to this
-    software, including all implied warranties of merchantability
-    and fitness.  In no event shall the author be liable for any
-    special, indirect or consequential damages or any damages
-    whatsoever resulting from loss of use, data or profits, whether
-    in an action of contract, negligence or other tortious action,
-    arising out of or in connection with the use or performance of
-    this software.
-
-*/
-
-#ifndef EXAMPLES_VIDEOPLAYBACK_H
-#define EXAMPLES_VIDEOPLAYBACK_H
-
-#include <QtGui/QWidget>
-
-class KUrl;
-
-namespace Phonon
-{
-    class VideoWidget;
-    class VideoPath;
-    class AudioOutput;
-    class AudioPath;
-    class MediaObject;
-    class MediaControls;
-} // namespace Phonon
-
-using namespace Phonon;
-
-class MediaPlayer : public QWidget
-{
-    Q_OBJECT
-    public:
-        MediaPlayer(QWidget *parent);
-        void setUrl(const KUrl &url);
-
-    private Q_SLOTS:
-        void hasVideoChanged(bool hasVideo);
-
-    private:
-        VideoWidget *m_vwidget;
-        VideoPath *m_vpath;
-        AudioOutput *m_aoutput;
-        AudioPath *m_apath;
-        MediaObject *m_media;
-        MediaControls *m_controls;
-};
-
-#endif // EXAMPLES_VIDEOPLAYBACK_H
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.cpp phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.cpp
--- phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.h phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.h
--- phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractaudiodataoutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractaudiodataoutput_p.h phonon-4.3.0/phonon/experimental/abstractaudiodataoutput_p.h
--- phonon-4.3.0/phonon/experimental/abstractaudiodataoutput_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractaudiodataoutput_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractmediastream2.cpp phonon-4.3.0/phonon/experimental/abstractmediastream2.cpp
--- phonon-4.3.0/phonon/experimental/abstractmediastream2.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractmediastream2.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractmediastream2.h phonon-4.3.0/phonon/experimental/abstractmediastream2.h
--- phonon-4.3.0/phonon/experimental/abstractmediastream2.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractmediastream2.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractmediastream2_p.h phonon-4.3.0/phonon/experimental/abstractmediastream2_p.h
--- phonon-4.3.0/phonon/experimental/abstractmediastream2_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractmediastream2_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractvideodataoutput.cpp phonon-4.3.0/phonon/experimental/abstractvideodataoutput.cpp
--- phonon-4.3.0/phonon/experimental/abstractvideodataoutput.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractvideodataoutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractvideodataoutput.h phonon-4.3.0/phonon/experimental/abstractvideodataoutput.h
--- phonon-4.3.0/phonon/experimental/abstractvideodataoutput.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractvideodataoutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/abstractvideodataoutput_p.h phonon-4.3.0/phonon/experimental/abstractvideodataoutput_p.h
--- phonon-4.3.0/phonon/experimental/abstractvideodataoutput_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/abstractvideodataoutput_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audiodataoutput.cpp phonon-4.3.0/phonon/experimental/audiodataoutput.cpp
--- phonon-4.3.0/phonon/experimental/audiodataoutput.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audiodataoutput.cpp	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audiodataoutput.h phonon-4.3.0/phonon/experimental/audiodataoutput.h
--- phonon-4.3.0/phonon/experimental/audiodataoutput.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audiodataoutput.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audiodataoutputinterface.h phonon-4.3.0/phonon/experimental/audiodataoutputinterface.h
--- phonon-4.3.0/phonon/experimental/audiodataoutputinterface.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audiodataoutputinterface.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audiodataoutput_p.h phonon-4.3.0/phonon/experimental/audiodataoutput_p.h
--- phonon-4.3.0/phonon/experimental/audiodataoutput_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audiodataoutput_p.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audioformat.cpp phonon-4.3.0/phonon/experimental/audioformat.cpp
--- phonon-4.3.0/phonon/experimental/audioformat.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audioformat.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audioformat.h phonon-4.3.0/phonon/experimental/audioformat.h
--- phonon-4.3.0/phonon/experimental/audioformat.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audioformat.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/audiowriter.h phonon-4.3.0/phonon/experimental/audiowriter.h
--- phonon-4.3.0/phonon/experimental/audiowriter.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/audiowriter.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avcapture.cpp phonon-4.3.0/phonon/experimental/avcapture.cpp
--- phonon-4.3.0/phonon/experimental/avcapture.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avcapture.cpp	2009-11-19 17:09:40.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -26,5 +26,5 @@
 #include "factory_p.h"
 #include "objectdescription.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 
 #define PHONON_CLASSNAME AvCapture
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avcapture.h phonon-4.3.0/phonon/experimental/avcapture.h
--- phonon-4.3.0/phonon/experimental/avcapture.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avcapture.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avcaptureinterface.h phonon-4.3.0/phonon/experimental/avcaptureinterface.h
--- phonon-4.3.0/phonon/experimental/avcaptureinterface.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avcaptureinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avcapture_p.h phonon-4.3.0/phonon/experimental/avcapture_p.h
--- phonon-4.3.0/phonon/experimental/avcapture_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avcapture_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avwriter.cpp phonon-4.3.0/phonon/experimental/avwriter.cpp
--- phonon-4.3.0/phonon/experimental/avwriter.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avwriter.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avwriter.h phonon-4.3.0/phonon/experimental/avwriter.h
--- phonon-4.3.0/phonon/experimental/avwriter.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avwriter.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/avwriter_p.h phonon-4.3.0/phonon/experimental/avwriter_p.h
--- phonon-4.3.0/phonon/experimental/avwriter_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/avwriter_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/backendcapabilities.cpp phonon-4.3.0/phonon/experimental/backendcapabilities.cpp
--- phonon-4.3.0/phonon/experimental/backendcapabilities.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/backendcapabilities.cpp	2009-11-19 17:09:43.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
@@ -21,5 +21,5 @@
 */
 #include "backendcapabilities.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 
 namespace Phonon
diff -r -U2 -N phonon-4.3.0/phonon/experimental/backendcapabilities.h phonon-4.3.0/phonon/experimental/backendcapabilities.h
--- phonon-4.3.0/phonon/experimental/backendcapabilities.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/backendcapabilities.h	2009-11-20 02:12:00.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/backendinterface.h phonon-4.3.0/phonon/experimental/backendinterface.h
--- phonon-4.3.0/phonon/experimental/backendinterface.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/backendinterface.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/CMakeLists.txt phonon-4.3.0/phonon/experimental/CMakeLists.txt
--- phonon-4.3.0/phonon/experimental/CMakeLists.txt	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/CMakeLists.txt	2009-11-19 17:09:40.000000000 -0700
@@ -54,3 +54,4 @@
     videowidget.h
     visualization.h
+    globalconfig.h
     DESTINATION ${INCLUDE_INSTALL_DIR}/phonon/experimental COMPONENT Devel)
diff -r -U2 -N phonon-4.3.0/phonon/experimental/export.h phonon-4.3.0/phonon/experimental/export.h
--- phonon-4.3.0/phonon/experimental/export.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/export.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/factory.cpp phonon-4.3.0/phonon/experimental/factory.cpp
--- phonon-4.3.0/phonon/experimental/factory.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/factory.cpp	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
@@ -87,5 +87,5 @@
     if (b) {
         return Phonon::Factory::registerQObject(b->createObject(
-                    static_cast<Phonon::BackendInterface::Class>(Phonon::Experimental::BackendInterface::AudioDataOutputClass),
+                    static_cast<Phonon::BackendInterface::Class>(Phonon::BackendInterface::AudioDataOutputClass),
                     parent));
     }
diff -r -U2 -N phonon-4.3.0/phonon/experimental/factory_p.h phonon-4.3.0/phonon/experimental/factory_p.h
--- phonon-4.3.0/phonon/experimental/factory_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/factory_p.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/globalconfig.cpp phonon-4.3.0/phonon/experimental/globalconfig.cpp
--- phonon-4.3.0/phonon/experimental/globalconfig.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/globalconfig.cpp	2009-11-19 17:10:44.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -21,5 +21,6 @@
 */
 
-#include "globalconfig_p.h"
+#include "globalconfig.h"
+#include "../globalconfig_p.h"
 
 #include "../factory_p.h"
@@ -68,7 +69,9 @@
 QList<int> GlobalConfig::videoCaptureDeviceListFor(Phonon::Category category, int override) const
 {
+    K_D(const GlobalConfig);
+
     //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("VideoCaptureDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("VideoCaptureDevice")); // + Factory::identifier());
+    const QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
     const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
             ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
@@ -100,8 +103,8 @@
     }
 
-    //Now the list from m_config
+    //Now the list from d->config
     QList<int> deviceList = backendConfig.value(categoryKey, QList<int>());
 
-    //if there are devices in m_config that the backend doesn't report, remove them from the list
+    //if there are devices in d->config that the backend doesn't report, remove them from the list
     QMutableListIterator<int> i(deviceList);
     while (i.hasNext()) {
@@ -111,5 +114,5 @@
     }
 
-    //if the backend reports more devices that are not in m_config append them to the list
+    //if the backend reports more devices that are not in d->config append them to the list
     deviceList += defaultList;
 
diff -r -U2 -N phonon-4.3.0/phonon/experimental/globalconfig.h phonon-4.3.0/phonon/experimental/globalconfig.h
--- phonon-4.3.0/phonon/experimental/globalconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/globalconfig.h	2009-11-26 10:22:04.000000000 -0700
@@ -0,0 +1,57 @@
+/*  This file is part of the KDE project
+Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
+#define PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
+
+#include <QtCore/QObject>
+#include <QtCore/QSettings>
+
+#include "../phononnamespace.h"
+#include "../globalconfig.h"
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace Experimental
+{
+
+class GlobalConfig : public Phonon::GlobalConfig
+{
+    K_DECLARE_PRIVATE(Phonon::GlobalConfig)
+public:
+    QList<int> videoCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+    int videoCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+
+Q_SIGNALS:
+    void videoCaptureDeviceConfigChanged();
+};
+
+} // namespace Experimental
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
diff -r -U2 -N phonon-4.3.0/phonon/experimental/globalconfig_p.h phonon-4.3.0/phonon/experimental/globalconfig_p.h
--- phonon-4.3.0/phonon/experimental/globalconfig_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/globalconfig_p.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,56 +0,0 @@
-/*  This file is part of the KDE project
-Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
-#define PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
-
-#include <QtCore/QObject>
-#include <QtCore/QSettings>
-
-#include "../phononnamespace.h"
-#include "../globalconfig_p.h"
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace Experimental
-{
-
-class GlobalConfig : public Phonon::GlobalConfig
-{
-public:
-    QList<int> videoCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-    int videoCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-
-Q_SIGNALS:
-    void videoCaptureDeviceConfigChanged();
-};
-
-} // namespace Experimental
-} // namespace Phonon
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // PHONON_EXPERIMENTAL_GLOBALCONFIG_P_H
diff -r -U2 -N phonon-4.3.0/phonon/experimental/lockfreequeue.cpp phonon-4.3.0/phonon/experimental/lockfreequeue.cpp
--- phonon-4.3.0/phonon/experimental/lockfreequeue.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/lockfreequeue.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/lockfreequeue_p.h phonon-4.3.0/phonon/experimental/lockfreequeue_p.h
--- phonon-4.3.0/phonon/experimental/lockfreequeue_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/lockfreequeue_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/mediasource.cpp phonon-4.3.0/phonon/experimental/mediasource.cpp
--- phonon-4.3.0/phonon/experimental/mediasource.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/mediasource.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/mediasource.h phonon-4.3.0/phonon/experimental/mediasource.h
--- phonon-4.3.0/phonon/experimental/mediasource.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/mediasource.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/mediasource_p.h phonon-4.3.0/phonon/experimental/mediasource_p.h
--- phonon-4.3.0/phonon/experimental/mediasource_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/mediasource_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/objectdescription.h phonon-4.3.0/phonon/experimental/objectdescription.h
--- phonon-4.3.0/phonon/experimental/objectdescription.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/objectdescription.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/packetpool.h phonon-4.3.0/phonon/experimental/packetpool.h
--- phonon-4.3.0/phonon/experimental/packetpool.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/packetpool.h	2009-01-10 11:10:05.000000000 -0700
@@ -41,5 +41,5 @@
     public:
         /**
-         * Allocates \p numberOfPackets packets of \packetSize bytes each. The memory can be
+         * Allocates \p numberOfPackets packets of \p packetSize bytes each. The memory can be
          * accessed through Packet objects.
          */
diff -r -U2 -N phonon-4.3.0/phonon/experimental/packetpool_p.h phonon-4.3.0/phonon/experimental/packetpool_p.h
--- phonon-4.3.0/phonon/experimental/packetpool_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/packetpool_p.h	2009-03-19 13:56:12.000000000 -0700
@@ -28,5 +28,5 @@
 {
 
-class PacketPrivate;
+struct PacketPrivate;
 class PacketPoolPrivate
 {
diff -r -U2 -N phonon-4.3.0/phonon/experimental/phononnamespace.h phonon-4.3.0/phonon/experimental/phononnamespace.h
--- phonon-4.3.0/phonon/experimental/phononnamespace.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/phononnamespace.h	2009-08-08 08:31:18.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/rtpreceiver.h phonon-4.3.0/phonon/experimental/rtpreceiver.h
--- phonon-4.3.0/phonon/experimental/rtpreceiver.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/rtpreceiver.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/snapshotinterface.h phonon-4.3.0/phonon/experimental/snapshotinterface.h
--- phonon-4.3.0/phonon/experimental/snapshotinterface.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/snapshotinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/streameventqueue.cpp phonon-4.3.0/phonon/experimental/streameventqueue.cpp
--- phonon-4.3.0/phonon/experimental/streameventqueue.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/streameventqueue.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/streameventqueue_p.h phonon-4.3.0/phonon/experimental/streameventqueue_p.h
--- phonon-4.3.0/phonon/experimental/streameventqueue_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/streameventqueue_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.cpp phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.cpp
--- phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,134 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006-2007 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include "../audiodataoutput.h"
-#include "../../mediaobject.h"
-#include "../../path.h"
-#include "../../audiooutput.h"
-#include "../../tests/loadfakebackend.h"
-
-#include <QtTest/QTest>
-#include <cstdlib>
-#include <QtCore/QUrl>
-#include <QtCore/QObject>
-
-class AudioDataOutputTest : public QObject
-{
-    Q_OBJECT
-    private slots:
-        void initTestCase();
-        void testSampleRate();
-        void testFormat();
-        void testDataSize();
-        void cleanupTestCase();
-};
-
-using namespace Phonon;
-using namespace Phonon::Experimental;
-
-void AudioDataOutputTest::initTestCase()
-{
-    QCoreApplication::setApplicationName("audiodataoutputtest");
-    Phonon::loadFakeBackend();
-    AudioDataOutput test(this);
-}
-
-void AudioDataOutputTest::testSampleRate()
-{
-    AudioDataOutput test(this);
-    QVERIFY(test.sampleRate() > 0);
-}
-
-void AudioDataOutputTest::testFormat()
-{
-    qRegisterMetaType<QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > >
-        ("QMap<Phonon::Experimental::AudioDataOutput::Channel,QVector<float> >");
-    qRegisterMetaType<QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > >
-        ("QMap<Phonon::Experimental::AudioDataOutput::Channel,QVector<qint16> >");
-    AudioDataOutput test(this);
-    QSignalSpy floatReadySpy(&test, SIGNAL(dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > &)));
-    QSignalSpy intReadySpy(&test, SIGNAL(dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > &)));
-    QCOMPARE(floatReadySpy.size(), 0);
-    QCOMPARE(intReadySpy.size(), 0);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    test.setFormat(Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    test.setFormat(Phonon::Experimental::AudioDataOutput::FloatFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::FloatFormat);
-    test.setFormat(Phonon::Experimental::AudioDataOutput::FloatFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::FloatFormat);
-    test.setFormat(Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::IntegerFormat);
-
-    MediaObject media(this);
-    QUrl url(testUrl());
-    media.setCurrentSource(url);
-    Path path = createPath(&media, &test);
-    QVERIFY(media.outputPaths().contains(path));
-    QVERIFY(test.inputPaths().contains(path));
-
-    QCOMPARE(floatReadySpy.size(), 0);
-    QCOMPARE(intReadySpy.size(), 0);
-
-    media.play();
-    QTime startTime;
-    startTime.start();
-    while (startTime.elapsed() < 1000)
-        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
-    QVERIFY(intReadySpy.size() > 0);
-    QCOMPARE(floatReadySpy.size(), 0);
-
-    media.pause();
-    test.setFormat(Phonon::Experimental::AudioDataOutput::FloatFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::FloatFormat);
-    intReadySpy.clear();
-    media.play();
-    startTime.start();
-    while (startTime.elapsed() < 1000)
-        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
-    QVERIFY(floatReadySpy.size() > 0);
-    QCOMPARE(intReadySpy.size(), 0);
-
-    media.pause();
-    test.setFormat(Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    QCOMPARE(test.format(), Phonon::Experimental::AudioDataOutput::IntegerFormat);
-    floatReadySpy.clear();
-    media.play();
-    startTime.start();
-    while (startTime.elapsed() < 1000)
-        QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
-    QVERIFY(intReadySpy.size() > 0);
-    QCOMPARE(floatReadySpy.size(), 0);
-}
-
-void AudioDataOutputTest::testDataSize()
-{
-    AudioDataOutput test(this);
-    QVERIFY(test.dataSize() > 0);
-}
-
-void AudioDataOutputTest::cleanupTestCase()
-{
-}
-
-QTEST_MAIN(AudioDataOutputTest)
-#include "audiodataoutputtest.moc"
diff -r -U2 -N phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.h phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.h
--- phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/tests/audiodataoutputtest.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,26 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) version 3, or any
-    later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
-    (or its successors, if any) and the KDE Free Qt Foundation, which shall
-    act as a proxy defined in Section 6 of version 3 of the license.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public 
-    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef AUDIODATAOUTPUTTEST_H
-#define AUDIODATAOUTPUTTEST_H
-
-#endif // AUDIODATAOUTPUTTEST_H
diff -r -U2 -N phonon-4.3.0/phonon/experimental/tests/CMakeLists.txt phonon-4.3.0/phonon/experimental/tests/CMakeLists.txt
--- phonon-4.3.0/phonon/experimental/tests/CMakeLists.txt	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/tests/CMakeLists.txt	2009-08-08 05:04:12.000000000 -0700
@@ -48,9 +48,7 @@
 
 PHONON_EXECUTABLE_TESTS(
-	audiodataoutputtest
    videodataoutputtest
 	)
 
 PHONON_UNIT_TESTS_FAKE(
-	audiodataoutputtest
 	)
diff -r -U2 -N phonon-4.3.0/phonon/experimental/tests/videodataoutputtest.cpp phonon-4.3.0/phonon/experimental/tests/videodataoutputtest.cpp
--- phonon-4.3.0/phonon/experimental/tests/videodataoutputtest.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/tests/videodataoutputtest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/CMakeLists.txt phonon-4.3.0/phonon/experimental/videocapturedevice/CMakeLists.txt
--- phonon-4.3.0/phonon/experimental/videocapturedevice/CMakeLists.txt	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/CMakeLists.txt	2009-12-29 00:26:43.000000000 -0700
@@ -11,4 +11,6 @@
 endif(NOT V4L2_FOUND)
 
+find_package(Qt4 REQUIRED)
+include(${QT_USE_FILE})
 find_package(KDE4 REQUIRED)
 
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/CMakeLists.txt phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/CMakeLists.txt
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/CMakeLists.txt	2008-11-24 10:11:58.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/CMakeLists.txt	2009-12-29 00:26:58.000000000 -0700
@@ -4,9 +4,10 @@
 add_definitions( ${KDE4_DEFINITIONS} )
 
-set(videocapture_LIB_SRCS bayer.cpp  sonix_compress.cpp  videodevice.cpp  videodevicemodelpool.cpp  videodevicepool.cpp  videoinput.cpp)
+set(videocapture_LIB_SRCS bayer.cpp  sonix_compress.cpp  videodevice.cpp
+videodevicemodelpool.cpp  videodevicepool.cpp  videoinput.cpp dummyvideodevice.cpp videodevicevector.cpp)
 
 kde4_add_library(videocapture SHARED ${videocapture_LIB_SRCS} )
 
-target_link_libraries(videocapture  ${KDE4_KDECORE_LIBS} ${KDE4_SOLID_LIBS})
+target_link_libraries(videocapture  ${KDE4_KDECORE_LIBS} ${KDE4_SOLID_LIBS} ${QT_LIBRARIES})
 
 install(TARGETS videocapture ${INSTALL_TARGETS_DEFAULT_ARGS})
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.cpp phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.cpp
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.cpp	2009-12-29 00:26:58.000000000 -0700
@@ -0,0 +1,196 @@
+/*
+    dummyvideodevice.cpp  -  Dummy Video Device
+
+    Copyright (c) 2009 by Alan Jones <skyphyr@gmail.com>
+
+    Kopete    (c) 2002-2009      by the Kopete developers  <kopete-devel@kde.org>
+
+    *************************************************************************
+    *                                                                       *
+    * This library is free software; you can redistribute it and/or         *
+    * modify it under the terms of the GNU Lesser General Public            *
+    * License as published by the Free Software Foundation; either          *
+    * version 2 of the License, or (at your option) any later version.      *
+    *                                                                       *
+    * This program is distributed in the hope that it will be useful,       *
+    * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+    * GNU General Public License for more details.                          *
+    *                                                                       *
+    * You should have received a copy of the GNU General Public License     *
+    * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+    *************************************************************************
+*/
+
+#include "dummyvideodevice.h"
+#include "videoinput.h"
+
+namespace Phonon {
+
+namespace VideoCapture {
+
+DummyVideoDevice::DummyVideoDevice()
+	{
+	//need to set a bunch of defaults for members
+	m_pixelformat = PIXELFORMAT_RGB32;
+	m_driver=VIDEODEV_DRIVER_NONE;
+	m_input.append(VideoInput());
+	minwidth = 160;
+	maxwidth = 1280;
+	minheight = 120;
+	maxheight = 960;
+	//let's be opened by default seeing this is a fallback 
+	opened = true;
+	setSize(320, 240);
+	}
+
+int DummyVideoDevice::open()
+	{
+	//wow - we always succeed in opening our dummy device
+	opened = true;
+	return EXIT_SUCCESS;
+	}
+	
+bool DummyVideoDevice::isOpen()
+	{
+	//we'll track it just incase there is situations where it's expected not to be open
+	return opened;
+	}
+	
+int DummyVideoDevice::checkDevice()
+	{
+	//again this is just incase anything ever relies on it failing when closed
+	if(isOpen())
+		{
+		//need to check which, if any, of these need to be enabled for this to function properly
+		m_videocapture=false;
+		m_videochromakey=false;
+		m_videoscale=false;
+		m_videooverlay=false;
+		m_videoread=false;
+		m_videoasyncio=false;
+		m_videostream=false;
+
+		m_driver=VIDEODEV_DRIVER_NONE;
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::initDevice()
+	{
+	//again this is just incase anything ever relies on it failing when closed
+	if(isOpen())
+		{
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::setSize( int newwidth, int newheight)
+	{
+	if (isOpen())
+		{
+		if(newwidth  > maxwidth ) newwidth  = maxwidth;
+		if(newheight > maxheight) newheight = maxheight;
+		if(newwidth  < minwidth ) newwidth  = minwidth;
+		if(newheight < minheight) newheight = minheight;
+
+		currentwidth  = newwidth;
+		currentheight = newheight;
+		
+		m_currentbuffer.width = currentwidth;
+		m_currentbuffer.height = currentheight;
+		m_currentbuffer.pixelformat = m_pixelformat;
+		
+		//let's fill the buffer up with something
+		//TODO: replace this with an .svg that says there is no camera available
+		m_currentbuffer.data.resize(currentwidth * currentheight * 4);
+		for (int i=0; i<m_currentbuffer.data.size(); i++)
+			{
+			m_currentbuffer.data[i] = 255;
+			}
+		
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+pixel_format DummyVideoDevice::setPixelFormat(pixel_format newformat)
+	{
+	pixel_format ret = PIXELFORMAT_NONE;
+	
+	if (newformat == PIXELFORMAT_RGB32)
+		{
+		m_pixelformat = newformat;
+		ret = m_pixelformat;
+		}
+	
+	return ret;
+	}
+	
+int DummyVideoDevice::startCapturing()
+	{
+	//again this is just incase anything ever relies on it failing when closed
+	if(isOpen())
+		{
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::getFrame()
+	{
+	//again this is just incase anything ever relies on it failing when closed
+	if(isOpen())
+		{
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::getFrame(imagebuffer *imgbuffer)
+	{
+	if(imgbuffer)
+	{
+		imgbuffer->height      = m_currentbuffer.height;
+		imgbuffer->width       = m_currentbuffer.width;
+		imgbuffer->pixelformat = m_currentbuffer.pixelformat;
+		imgbuffer->data        = m_currentbuffer.data;
+		return EXIT_SUCCESS;
+	}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::getImage(QImage *qimage)
+	{
+	// do NOT delete qimage here, as it is received as a parameter
+	if (qimage->width() != width() || qimage->height() != height())
+		*qimage = QImage(width(), height(), QImage::Format_RGB32);
+
+	uchar *bits=qimage->bits();
+	memcpy(bits,&m_currentbuffer.data[0], m_currentbuffer.data.size());
+	
+	return EXIT_SUCCESS;
+	}
+	
+int DummyVideoDevice::stopCapturing()
+	{
+	//again this is just incase anything ever relies on it failing when closed
+	if(isOpen())
+		{
+		return EXIT_SUCCESS;
+		}
+	return EXIT_FAILURE;
+	}
+	
+int DummyVideoDevice::close()
+	{
+	//we always manage to close it too - amazing :)
+	opened = false;
+	return EXIT_SUCCESS;
+	}
+
+}
+
+}
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.h phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.h
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/dummyvideodevice.h	2009-12-29 00:26:58.000000000 -0700
@@ -0,0 +1,70 @@
+/*
+    dummyvideodevice.h  -  Kopete Dummy Video Device
+
+    Copyright (c) 2009 by Alan Jones <skyphyr@gmail.com>
+
+    Kopete    (c) 2002-2009      by the Kopete developers  <kopete-devel@kde.org>
+
+    *************************************************************************
+    *                                                                       *
+    * This library is free software; you can redistribute it and/or         *
+    * modify it under the terms of the GNU Lesser General Public            *
+    * License as published by the Free Software Foundation; either          *
+    * version 2 of the License, or (at your option) any later version.      *
+    *                                                                       *
+    * This program is distributed in the hope that it will be useful,       *
+    * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+    * GNU General Public License for more details.                          *
+    *                                                                       *
+    * You should have received a copy of the GNU General Public License     *
+    * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+    *************************************************************************
+*/
+
+#ifndef PHONON_AVDUMMYVIDEODEVICE_H
+#define PHONON_AVDUMMYVIDEODEVICE_H
+
+#include "videodevice.h"
+
+namespace Phonon {
+
+namespace VideoCapture {
+
+/**
+@author Kopete Developers
+*/
+
+class DummyVideoDevice : public VideoDevice
+{
+
+public:
+	DummyVideoDevice();
+	virtual ~DummyVideoDevice() {}
+	
+	virtual int open();
+	virtual bool isOpen();
+	virtual int checkDevice();
+	virtual int initDevice();
+
+	virtual int setSize( int newwidth, int newheight);
+
+	virtual pixel_format setPixelFormat(pixel_format newformat);
+
+	virtual int startCapturing();
+	virtual int getFrame();
+	virtual int getFrame(imagebuffer *imgbuffer);
+	virtual int getImage(QImage *qimage);
+	virtual int stopCapturing();
+	virtual int close();
+	
+	
+private:
+	bool opened;
+};
+
+}
+
+}
+
+#endif
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevice.cpp phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevice.cpp
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevice.cpp	2008-11-24 10:11:58.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevice.cpp	2009-12-29 00:26:50.000000000 -0700
@@ -145,5 +145,9 @@
 	int r;
 
+#ifdef HAVE_LIBV4L2
+	do r = v4l2_ioctl (descriptor, request, arg);
+#else
 	do r = ioctl (descriptor, request, arg);
+#endif
 	while (-1 == r && EINTR == errno);
 	return r;
@@ -183,5 +187,9 @@
 		return EXIT_SUCCESS;
 	}
+#ifdef HAVE_LIBV4L2
+	descriptor = ::v4l2_open (QFile::encodeName(full_filename), O_RDWR, 0);
+#else
 	descriptor = ::open (QFile::encodeName(full_filename), O_RDWR, 0);
+#endif
 	if(isOpen())
 	{
@@ -253,6 +261,8 @@
 			CLEAR (fmt);
 			fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    			if (-1 == xioctl (VIDIOC_G_FMT, &fmt))
+			if (-1 == xioctl (VIDIOC_G_FMT, &fmt))
+			{
 				kDebug() << "VIDIOC_G_FMT failed (" << errno << ").";
+			}
 			fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 			fmt.fmt.pix.width       = 32767;
@@ -270,5 +280,7 @@
 			}
 			if (-1 == xioctl (VIDIOC_G_FMT, &fmt))
+			{
 				kDebug() << "VIDIOC_G_FMT failed (" << errno << ").";
+			}
 			fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 			fmt.fmt.pix.width       = 1;
@@ -446,17 +458,31 @@
 		kDebug() << "Capabilities:";
 		if(canCapture())
+		{
 			kDebug() << "    Video capture";
+		}
 		if(canRead())
+		{
 			kDebug() << "        Read";
+		}
 		if(canAsyncIO())
+		{
 			kDebug() << "        Asynchronous input/output";
+		}
 		if(canStream())
+		{
 			kDebug() << "        Streaming";
+		}
 		if(canChromakey())
+		{
 			kDebug() << "    Video chromakey";
+		}
 		if(canScale())
+		{
 			kDebug() << "    Video scales";
+		}
 		if(canOverlay())
+		{
 			kDebug() << "    Video overlay";
+		}
 //		kDebug() << "libkopete (avdevice):     Audios : " << V4L_capabilities.audios;
 		kDebug() << "    Max res: " << maxWidth() << " x " << maxHeight();
@@ -628,5 +654,7 @@
 											kDebug() <<  "Device doesn't seem to support SBGGR8 format. Trying SN9C10X.";
 											if(PIXELFORMAT_NONE == setPixelFormat(PIXELFORMAT_SN9C10X))
+											{
 												kDebug() <<  "Device doesn't seem to support BGR32 format. Fallback to it is not yet implemented.";
+											}
 										}
 									}
@@ -656,5 +684,7 @@
 //				CLEAR (fmt);
 				if (-1 == xioctl (VIDIOC_G_FMT, &fmt))
+				{
 					kDebug() << "VIDIOC_G_FMT failed (" << errno << ").Returned width: " << pixelFormatName(fmt.fmt.pix.pixelformat) << " " << fmt.fmt.pix.width << "x" << fmt.fmt.pix.height;
+				}
 				fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 				fmt.fmt.pix.width       = width();
@@ -672,8 +702,12 @@
 					unsigned int min = fmt.fmt.pix.width * 2;
 					if (fmt.fmt.pix.bytesperline < min)
+					{
 						fmt.fmt.pix.bytesperline = min;
+					}
 					min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;
 					if (fmt.fmt.pix.sizeimage < min)
+					{
 						fmt.fmt.pix.sizeimage = min;
+					}
 					m_buffer_size=fmt.fmt.pix.sizeimage ;
 				}
@@ -770,5 +804,5 @@
 			else
 			{
-				if (fmt.fmt.pix.pixelformat == pixelFormatCode(newformat)) // Thih "if" (not what is contained within) is a fix for a bug in sn9c102 driver.
+				if (fmt.fmt.pix.pixelformat == (unsigned int) pixelFormatCode(newformat)) // Thih "if" (not what is contained within) is a fix for a bug in sn9c102 driver.
 				{
 					m_pixelformat = newformat;
@@ -782,5 +816,7 @@
 			struct video_picture V4L_picture;
 			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+			{
 				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+			}
 //			kDebug() << "V4L_picture.palette: " << V4L_picture.palette << " Depth: " << V4L_picture.depth;
 			V4L_picture.palette = pixelFormatCode(newformat);
@@ -792,5 +828,7 @@
 
 			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+			{
 				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+			}
 
 //			kDebug() << "V4L_picture.palette: " << V4L_picture.palette << " Depth: " << V4L_picture.depth;
@@ -983,5 +1021,12 @@
 			case IO_METHOD_READ:
 // 				kDebug() << "Using IO_METHOD_READ.File descriptor: " << descriptor << " Buffer address: " << &m_currentbuffer.data[0] << " Size: " << m_currentbuffer.data.size();
+				if (m_currentbuffer.data.isEmpty())
+					return EXIT_FAILURE;
+
+#ifdef HAVE_LIBV4L2
+				bytesread = v4l2_read (descriptor, &m_currentbuffer.data[0], m_currentbuffer.data.size());
+#else
 				bytesread = read (descriptor, &m_currentbuffer.data[0], m_currentbuffer.data.size());
+#endif
 				if (-1 == bytesread) // must verify this point with ov511 driver.
 				{
@@ -1025,6 +1070,10 @@
 					return EXIT_FAILURE;*/ //it was an assert()
 // kDebug() << "m_rawbuffers[" << v4l2buffer.index << "].start: " << (void *)m_rawbuffers[v4l2buffer.index].start << "   Size: " << m_currentbuffer.data.size();
+				if (m_currentbuffer.data.isEmpty() ||
+//					v4l2buffer.index < 0 ||  	// is always false: v4l2buffer.index is unsigned
+					(uint) m_rawbuffers.size() <= v4l2buffer.index)
+					return EXIT_FAILURE;
 
-memcpy(&m_currentbuffer.data[0], m_rawbuffers[v4l2buffer.index].start, m_currentbuffer.data.size());
+				memcpy(&m_currentbuffer.data[0], m_rawbuffers[v4l2buffer.index].start, m_currentbuffer.data.size());
 				if (-1 == xioctl (VIDIOC_QBUF, &v4l2buffer))
 					return errnoReturn ("VIDIOC_QBUF");
@@ -1051,4 +1100,7 @@
 						}
 					}
+					if ((unsigned int) m_rawbuffers.size() < m_streambuffers)
+						return EXIT_FAILURE;
+					
 					for (i = 0; i < m_streambuffers; ++i)
 						if (v4l2buffer.m.userptr == (unsigned long) m_rawbuffers[i].start && v4l2buffer.length == m_rawbuffers[i].length)
@@ -1097,4 +1149,12 @@
 		*qimage = QImage(width(), height(), QImage::Format_RGB32);
 
+	if (!m_currentbuffer.data.size())
+		{
+		//there is no data so if we continue something will try access it (as in bug 161536) and crash kopete
+		//perhaps we should look at having the interface reflect when the camera isn't available? as it thinks 
+		//it is for some reason, though the data size seems to be an ok check
+		return EXIT_FAILURE;
+		}
+
 	uchar *bits=qimage->bits();
 // kDebug() << "Capturing in " << pixelFormatName(m_currentbuffer.pixelformat);
@@ -1330,12 +1390,11 @@
 	if (getAutoBrightnessContrast()||getAutoColorCorrection())
 	{
-		unsigned long long result=0;
 		unsigned long long R=0, G=0, B=0, A=0, global=0;
 		int Rmax=0, Gmax=0, Bmax=0, Amax=0, globalmax=0;
 		int Rmin=255, Gmin=255, Bmin=255, Amin=255, globalmin=255;
-		int Rrange=255, Grange=255, Brange=255, Arange=255, globarange=255;
+		int Rrange=255, Grange=255, Brange=255;
 
 // Finds minimum and maximum intensity for each color component
-		for(unsigned int loop=0;loop < qimage->numBytes();loop+=4)
+		for(unsigned int loop=0;loop < (unsigned int) qimage->numBytes();loop+=4)
 		{
 			R+=bits[loop];
@@ -1376,5 +1435,5 @@
 			" Rmax: " << Rmax << " Gmax: " << Gmax << " Bmax: " << Bmax << " Amax: " << Amax << " globalmax: " << globalmax ;
 
-		for(unsigned int loop=0;loop < qimage->numBytes();loop+=4)
+		for(unsigned int loop=0;loop < (unsigned int) qimage->numBytes();loop+=4)
 		{
 			bits[loop]   = (bits[loop]   - Rmin) * 255 / (Rrange);
@@ -1416,5 +1475,9 @@
 						for (loop = 0; loop < m_streambuffers; ++loop)
 						{
+#ifdef HAVE_LIBV4L2
+							if (v4l2_munmap(m_rawbuffers[loop].start,m_rawbuffers[loop].length) != 0)
+#else
 							if (munmap(m_rawbuffers[loop].start,m_rawbuffers[loop].length) != 0)
+#endif
 							{
 								kDebug() << "unable to munmap.";
@@ -1444,5 +1507,10 @@
 		kDebug() << " Device is open. Trying to properly shutdown the device.";
 		stopCapturing();
-		kDebug() << "::close() returns " << ::close(descriptor);
+#ifdef HAVE_LIBV4L2
+		int ret = ::v4l2_close(descriptor);
+#else
+		int ret = ::close(descriptor);
+#endif
+		kDebug() << "::close() returns " << ret;
 	}
 	descriptor = -1;
@@ -1493,4 +1561,5 @@
 					control.id = V4L2_CID_BRIGHTNESS;
 					control.value = (__s32)((queryctrl.maximum - queryctrl.minimum)*getBrightness());
+					control.value += queryctrl.minimum;
 
 					if (-1 == xioctl (VIDIOC_S_CTRL, &control))
@@ -1506,8 +1575,12 @@
 				struct video_picture V4L_picture;
 				if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+				{
 					kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+				}
 				V4L_picture.brightness = uint(65535 * getBrightness());
 				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
+				{
 					kDebug() << "Device seems to not support adjusting image brightness. Fallback to it is not yet implemented.";
+				}
 			}
 			break;
@@ -1563,4 +1636,5 @@
 					control.id = V4L2_CID_CONTRAST;
 					control.value = (__s32)((queryctrl.maximum - queryctrl.minimum)*getContrast());
+					control.value += queryctrl.minimum;
 
 					if (-1 == xioctl (VIDIOC_S_CTRL, &control))
@@ -1576,8 +1650,12 @@
 				struct video_picture V4L_picture;
 				if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+				{
 					kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+				}
 				V4L_picture.contrast = uint(65535*getContrast());
-				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
+				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture)) 
+				{
 					kDebug() << "Device seems to not support adjusting image contrast. Fallback to it is not yet implemented.";
+				}
 			}
 		break;
@@ -1633,4 +1711,5 @@
 					control.id = V4L2_CID_SATURATION;
 					control.value = (__s32)((queryctrl.maximum - queryctrl.minimum)*getSaturation());
+					control.value += queryctrl.minimum;
 
 					if (-1 == xioctl (VIDIOC_S_CTRL, &control))
@@ -1646,8 +1725,12 @@
 				struct video_picture V4L_picture;
 				if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+				{
 					kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+				}
 				V4L_picture.colour = uint(65535*getSaturation());
 				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
+				{
 					kDebug() << "Device seems to not support adjusting image saturation. Fallback to it is not yet implemented.";
+				}
 			}
 		break;
@@ -1703,4 +1786,5 @@
 					control.id = V4L2_CID_WHITENESS;
 					control.value = (__s32)((queryctrl.maximum - queryctrl.minimum)*getWhiteness());
+					control.value += queryctrl.minimum;
 
 					if (-1 == xioctl (VIDIOC_S_CTRL, &control))
@@ -1716,8 +1800,12 @@
 				struct video_picture V4L_picture;
 				if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+				{
 					kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+				}
 				V4L_picture.whiteness = uint(65535*getWhiteness());
 				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
+				{
 					kDebug() << "Device seems to not support adjusting white level. Fallback to it is not yet implemented.";
+				}
 			}
 		break;
@@ -1773,4 +1861,5 @@
 					control.id = V4L2_CID_HUE;
 					control.value = (__s32)((queryctrl.maximum - queryctrl.minimum)*getHue());
+					control.value += queryctrl.minimum;
 
 					if (-1 == xioctl (VIDIOC_S_CTRL, &control))
@@ -1786,8 +1875,12 @@
 				struct video_picture V4L_picture;
 				if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
+				{
 					kDebug() << "VIDIOCGPICT failed (" << errno << ").";
+				}
 				V4L_picture.hue = uint(65535*getHue());
 				if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
+				{
 					kDebug() << "Device seems to not support adjusting image hue. Fallback to it is not yet implemented.";
+				}
 			}
 		break;
@@ -2260,40 +2353,40 @@
 // Packed RGB formats
 			kDebug() << "Supported pixel formats:";
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB332))	kDebug() << pixelFormatName(PIXELFORMAT_RGB332);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB444))	kDebug() << pixelFormatName(PIXELFORMAT_RGB444);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555))	kDebug() << pixelFormatName(PIXELFORMAT_RGB555);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565))	kDebug() << pixelFormatName(PIXELFORMAT_RGB565);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555X))	kDebug() << pixelFormatName(PIXELFORMAT_RGB555X);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565X))	kDebug() << pixelFormatName(PIXELFORMAT_RGB565X);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR24))	kDebug() << pixelFormatName(PIXELFORMAT_BGR24);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB24))	kDebug() << pixelFormatName(PIXELFORMAT_RGB24);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR32))	kDebug() << pixelFormatName(PIXELFORMAT_BGR32);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB32))	kDebug() << pixelFormatName(PIXELFORMAT_RGB32);
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB332))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB332); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB444))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB444); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB555); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB565); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555X))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB555X); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565X))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB565X); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR24))	{ kDebug() << pixelFormatName(PIXELFORMAT_BGR24); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB24))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB24); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR32))	{ kDebug() << pixelFormatName(PIXELFORMAT_BGR32); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB32))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB32); }
 
 // Bayer RGB format
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SBGGR8))	kDebug() << pixelFormatName(PIXELFORMAT_SBGGR8);
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SBGGR8))	{ kDebug() << pixelFormatName(PIXELFORMAT_SBGGR8); }
 
 // YUV formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_GREY))	kDebug() << pixelFormatName(PIXELFORMAT_GREY);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUYV))	kDebug() << pixelFormatName(PIXELFORMAT_YUYV);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_UYVY))	kDebug() << pixelFormatName(PIXELFORMAT_UYVY);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV420P))	kDebug() << pixelFormatName(PIXELFORMAT_YUV420P);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV422P))	kDebug() << pixelFormatName(PIXELFORMAT_YUV422P);
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_GREY))	{ kDebug() << pixelFormatName(PIXELFORMAT_GREY); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUYV))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUYV); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_UYVY))	{ kDebug() << pixelFormatName(PIXELFORMAT_UYVY); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV420P))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUV420P); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV422P))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUV422P); }
 
 // Compressed formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_JPEG))	kDebug() << pixelFormatName(PIXELFORMAT_JPEG);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MPEG))	kDebug() << pixelFormatName(PIXELFORMAT_MPEG);
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_JPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_JPEG); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_MPEG); }
 
 // Reserved formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_DV))		kDebug() << pixelFormatName(PIXELFORMAT_DV);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_ET61X251))	kDebug() << pixelFormatName(PIXELFORMAT_ET61X251);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HI240))	kDebug() << pixelFormatName(PIXELFORMAT_HI240);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HM12))	kDebug() << pixelFormatName(PIXELFORMAT_HM12);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MJPEG))	kDebug() << pixelFormatName(PIXELFORMAT_MJPEG);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC1))	kDebug() << pixelFormatName(PIXELFORMAT_PWC1);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC2))	kDebug() << pixelFormatName(PIXELFORMAT_PWC2);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SN9C10X))	kDebug() << pixelFormatName(PIXELFORMAT_SN9C10X);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_WNVA))	kDebug() << pixelFormatName(PIXELFORMAT_WNVA);
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YYUV))	kDebug() << pixelFormatName(PIXELFORMAT_YYUV);
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_DV))		{ kDebug() << pixelFormatName(PIXELFORMAT_DV); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_ET61X251))	{ kDebug() << pixelFormatName(PIXELFORMAT_ET61X251); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HI240))	{ kDebug() << pixelFormatName(PIXELFORMAT_HI240); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HM12))	{ kDebug() << pixelFormatName(PIXELFORMAT_HM12); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MJPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_MJPEG); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC1))	{ kDebug() << pixelFormatName(PIXELFORMAT_PWC1); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC2))	{ kDebug() << pixelFormatName(PIXELFORMAT_PWC2); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SN9C10X))	{ kDebug() << pixelFormatName(PIXELFORMAT_SN9C10X); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_WNVA))	{ kDebug() << pixelFormatName(PIXELFORMAT_WNVA); }
+			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YYUV))	{ kDebug() << pixelFormatName(PIXELFORMAT_YYUV); }
 			break;
 #endif
@@ -2606,6 +2699,8 @@
 				while (0 == xioctl (VIDIOC_ENUMSTD, &standard)) {
 					if (standard.id & input.std)
+					{
 //						kDebug() << standard.name;
 						kDebug() << signalStandardName(standard.id) << " (" << standard.id << ")" << V4L2_STD_NTSC;
+					}
 
 					standard.index++;
@@ -2730,5 +2825,9 @@
 
 			m_rawbuffers[m_streambuffers].length = v4l2buffer.length;
+#ifdef HAVE_LIBV4L2
+			m_rawbuffers[m_streambuffers].start = (uchar *) v4l2_mmap (NULL /* start anywhere */, v4l2buffer.length, PROT_READ | PROT_WRITE /* required */, MAP_SHARED /* recommended */, descriptor, v4l2buffer.m.offset);
+#else
 			m_rawbuffers[m_streambuffers].start = (uchar *) mmap (NULL /* start anywhere */, v4l2buffer.length, PROT_READ | PROT_WRITE /* required */, MAP_SHARED /* recommended */, descriptor, v4l2buffer.m.offset);
+#endif
 
 			if (MAP_FAILED == m_rawbuffers[m_streambuffers].start)
@@ -2845,3 +2944,4 @@
 
 }
+
 }
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.cpp phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.cpp
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.cpp	2008-11-24 10:11:58.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.cpp	2009-12-29 00:27:05.000000000 -0700
@@ -58,4 +58,5 @@
 
 VideoDevicePool::VideoDevicePool()
+: m_current_device(0)
 {
 	connect( Solid::DeviceNotifier::instance(), SIGNAL(deviceAdded(const QString&)), SLOT(deviceAdded(const QString &)) );
@@ -483,4 +484,5 @@
 			case PIXELFORMAT_YUV420P: break;
 			case PIXELFORMAT_YUV422P: break;
+			default: break;
 		}
 	}
@@ -879,16 +881,21 @@
 	kDebug() << "("<< udi << ") called";
 	int i = 0;
-	foreach ( VideoDevice vd, m_videodevice ) {
-		
-		if ( vd.udi() == udi ) {
+	foreach ( VideoDevice vd, m_videodevice )
+	{
+		if ( vd.udi() == udi )
+		{
 			kDebug() << "Video device '" << udi << "' has been removed!";
+			emit deviceUnregistered( udi );
+			// not sure if this is safe but at this point the device node is gone already anyway
+			m_videodevice.remove( i );
+		}
+		else
+		{
+			i++;
 		}
-		emit deviceUnregistered( udi );
-		m_videodevice.remove( i ); // not sure if this is safe but at this point the device node is
-								   // gone already anyway
-		i++;
 	}
 }
 
-} 
+}
+
 }
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.h phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.h
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.h	2008-11-24 10:11:58.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicepool.h	2009-12-29 00:27:12.000000000 -0700
@@ -22,4 +22,5 @@
 #include "videoinput.h"
 #include "videodevicemodelpool.h"
+#include "videodevicevector.h"
 #include <qstring.h>
 #include <qimage.h>
@@ -41,5 +42,5 @@
 */
 
-typedef QVector<Phonon::VideoCapture::VideoDevice> VideoDeviceVector;
+
 
 
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.cpp phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.cpp
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.cpp	2009-12-29 00:26:58.000000000 -0700
@@ -0,0 +1,62 @@
+/*
+    videodevicevector.cpp  -  Kopete Video Device List Abstration
+
+    Copyright (c) 2009 by Alan Jones <skyphyr@gmail.com>
+
+    Kopete    (c) 2002-2009      by the Kopete developers  <kopete-devel@kde.org>
+
+    *************************************************************************
+    *                                                                       *
+    * This library is free software; you can redistribute it and/or         *
+    * modify it under the terms of the GNU General Public                   *
+    * License as published by the Free Software Foundation; either          *
+    * version 3 of the License, or (at your option) any later version.      *
+    *                                                                       *
+    * This program is distributed in the hope that it will be useful,       *
+    * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+    * GNU General Public License for more details.                          *
+    *                                                                       *
+    * You should have received a copy of the GNU General Public License     *
+    * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+    *************************************************************************
+*/
+
+#include "videodevicevector.h"
+
+namespace Phonon {
+
+namespace VideoCapture {
+
+VideoDevice& VideoDeviceVector::operator[] (int i)
+	{
+	if (i>=size())
+		{
+		//we're outside the range so let's return a default camera not available VideoDevice
+		return fallback;
+		}
+	
+	//if we've made it here then we're within range
+	return QVector<VideoDevice>::operator[](i);
+	}
+	
+const VideoDevice& VideoDeviceVector::operator[] (int i) const
+	{
+	return at(i);
+	}
+
+const VideoDevice& VideoDeviceVector::at(int i) const
+	{
+	if (i>=size())
+		{
+		//we're outside the range so let's return a default camera not available VideoDevice
+		return fallback;
+		}
+	
+	//if we've made it here then we're within range
+	return QVector<VideoDevice>::operator[](i);
+	}
+
+}
+
+}
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.h phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.h
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapture/videodevicevector.h	2009-12-29 00:26:58.000000000 -0700
@@ -0,0 +1,63 @@
+/*
+    videodevicevector.h  -  Kopete Video Device List Abstration
+
+    Copyright (c) 2009 by Alan Jones <skyphyr@gmail.com>
+
+    Kopete    (c) 2002-2009      by the Kopete developers  <kopete-devel@kde.org>
+
+    *************************************************************************
+    *                                                                       *
+    * This library is free software; you can redistribute it and/or         *
+    * modify it under the terms of the GNU General Public                   *
+    * License as published by the Free Software Foundation; either          *
+    * version 3 of the License, or (at your option) any later version.      *
+    *                                                                       *
+    * This program is distributed in the hope that it will be useful,       *
+    * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+    * GNU General Public License for more details.                          *
+    *                                                                       *
+    * You should have received a copy of the GNU General Public License     *
+    * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+    *************************************************************************
+*/
+
+#ifndef PHONON_VIDEODEVICEVECTOR_H
+#define PHONON_VIDEODEVICEVECTOR_H
+
+#include "videodevice.h"
+#include "dummyvideodevice.h"
+
+namespace Phonon {
+
+namespace VideoCapture {
+
+/**
+@author Kopete Developers
+*/
+
+class VideoDeviceVector : public QVector<VideoDevice>
+{
+
+public:
+	VideoDeviceVector() {}
+	~VideoDeviceVector() {}
+	
+	VideoDevice& operator[] (int i);
+
+	const VideoDevice& operator[] (int i) const;
+	
+	const VideoDevice& at(int i) const;
+	
+private:
+	
+	DummyVideoDevice fallback;
+};
+
+}
+
+}
+
+
+
+#endif
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/mainwidget.ui phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/mainwidget.ui
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/mainwidget.ui	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/mainwidget.ui	2009-09-22 01:09:34.000000000 -0700
@@ -52,7 +52,4 @@
         <enum>QFrame::Box</enum>
        </property>
-       <property name="pixmap" >
-        <pixmap/>
-       </property>
        <property name="scaledContents" >
         <bool>true</bool>
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/videocapturetestapp.desktop phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/videocapturetestapp.desktop
--- phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/videocapturetestapp.desktop	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videocapturedevice/videocapturetestapp/videocapturetestapp.desktop	2010-02-04 04:25:54.000000000 -0700
@@ -4,22 +4,45 @@
 Exec=videocapturetestapp
 GenericName=Video Capture Test Application
+GenericName[bg]=Пробно приложение за прихващане на видео
 GenericName[ca]=Aplicació de proves de captura de vídeo
+GenericName[ca@valencia]=Aplicació de proves de captura de vídeo
 GenericName[cs]=Testovací aplikace pro nahrávání videa
+GenericName[da]=Testprogram til videooptagelse
 GenericName[de]=Videoaufnahme-Testanwendung
 GenericName[el]=Δοκιμαστική εφαρμογή σύλληψης βίντεο
+GenericName[en_GB]=Video Capture Test Application
 GenericName[es]=Aplicación para probar la de captura de vídeo
 GenericName[et]=Videohõive testrakendus
+GenericName[eu]=Bideoa jasotzeko froga egiteko aplikazioa
+GenericName[fi]=Videokaappauksen testaussovellus
+GenericName[fr]=Application de test pour la capture vidéo
 GenericName[ga]=Feidhmchlár Tástála Físghabhála
 GenericName[gl]=Programa de probas para a captura de vídeo
 GenericName[hsb]=Testowa aplikacija za widejo-capture
+GenericName[hu]=Teszt videofelvétel
+GenericName[id]=Aplikasi Pencoba Perekam Video
+GenericName[is]=Prófunarforrit fyrir vídeóupptökur
+GenericName[it]=Applicazione di prova per l'acquisizione video
 GenericName[ja]=映像キャプチャをテストするアプリケーション
 GenericName[ko]=비디오 캡처 테스트 프로그램
+GenericName[ku]=Sepana Ceribandina Girtina Vîdeoyê
+GenericName[lt]=Video įrašymo bandomoji programa
 GenericName[lv]=Video tveršanas testa programma
+GenericName[nb]=Testprogram for videoopptak
 GenericName[nds]=Video-Opnehm-Testprogramm
 GenericName[nl]=Testprogramma voor video-opname
 GenericName[nn]=Testprogram for videoopptak
+GenericName[pa]=ਵੀਡਿਓ ਕੈਪਚਰ ਟੈਸਟ ਐਪਲੀਕੇਸ਼ਨ
+GenericName[pl]=Program testowy do nagrywania wideo
 GenericName[pt]=Aplicação de Testes de Captura de Vídeo
 GenericName[pt_BR]=Aplicativo de teste de captura de vídeo
+GenericName[ru]=Тестовое приложение для захвата видео
+GenericName[se]=Videobádden geahččalanprográmma
 GenericName[sk]=Video testovacia aplikácia
+GenericName[sl]=Program za preizkus zajema videa
+GenericName[sr]=Програм за пробу хватања видеа
+GenericName[sr@ijekavian]=Програм за пробу хватања видеа
+GenericName[sr@ijekavianlatin]=Program za probu hvatanja videa
+GenericName[sr@latin]=Program za probu hvatanja videa
 GenericName[sv]=Testprogram för videoinspelning
 GenericName[tr]=Video Yakalama Test Uygulaması
@@ -31,8 +54,51 @@
 MimeType=
 Name=videocapturetestapp
+Name[bg]=Пробно прихващане на видео
+Name[ca]=videocapturetestapp
+Name[ca@valencia]=videocapturetestapp
+Name[cs]=videocapturetestapp
 Name[da]=videooptager-testprogram
+Name[de]=videocapturetestapp
+Name[el]=videocapturetestapp
+Name[en_GB]=videocapturetestapp
+Name[es]=videocapturetestapp
+Name[et]=videocapturetestapp
+Name[eu]=videocapturetestapp
+Name[fi]=videocapturetestapp
+Name[fr]=videocapturetestapp
+Name[ga]=videocapturetestapp
+Name[gl]=videocapturetestapp
+Name[hsb]=videocapturetestapp
+Name[hu]=videocapturetestapp
+Name[id]=aplikasipencobaperekamvideo
+Name[is]=videocapturetestapp
+Name[it]=videocapturetestapp
+Name[ja]=videocapturetestapp
+Name[ko]=videocapturetestapp
+Name[ku]=videocapturetestapp
+Name[lt]=videocapturetestapp
+Name[lv]=videocapturetestapp
+Name[nb]=videocapturetestapp
+Name[nds]=videocapturetestapp
+Name[nl]=videocapturetestapp
+Name[nn]=videocapturetestapp
+Name[pa]=videocapturetestapp
+Name[pl]=videocapturetestapp
+Name[pt]=videocapturetestapp
+Name[pt_BR]=videocapturetestapp
+Name[ru]=videocapturetestapp
+Name[se]=videocapturetestapp
 Name[sk]=Video testovacia aplikácia
+Name[sl]=videocapturetestapp
+Name[sr]=videocapturetestapp
+Name[sr@ijekavian]=videocapturetestapp
+Name[sr@ijekavianlatin]=videocapturetestapp
+Name[sr@latin]=videocapturetestapp
 Name[sv]=Videoinspelningstest
+Name[tr]=videocapturetestapp
+Name[uk]=videocapturetestapp
 Name[x-test]=xxvideocapturetestappxx
+Name[zh_CN]=videocapturetestapp
+Name[zh_TW]=videocapturetestapp
 Path=
 StartupNotify=true
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput2.cpp phonon-4.3.0/phonon/experimental/videodataoutput2.cpp
--- phonon-4.3.0/phonon/experimental/videodataoutput2.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput2.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput2.h phonon-4.3.0/phonon/experimental/videodataoutput2.h
--- phonon-4.3.0/phonon/experimental/videodataoutput2.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput2.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput2_p.h phonon-4.3.0/phonon/experimental/videodataoutput2_p.h
--- phonon-4.3.0/phonon/experimental/videodataoutput2_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput2_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput.cpp phonon-4.3.0/phonon/experimental/videodataoutput.cpp
--- phonon-4.3.0/phonon/experimental/videodataoutput.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput.h phonon-4.3.0/phonon/experimental/videodataoutput.h
--- phonon-4.3.0/phonon/experimental/videodataoutput.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -77,5 +77,5 @@
 
     Q_SIGNALS:
-        /**
+        /* FIXME: disabled this piece of documentation - add another * to enable
          * Fixme: I don't think this makes sense, but I've been wrong before.
          *
@@ -92,9 +92,10 @@
         /**
          * The signal is emitted whenever a frame should be displayed.
-         * nowStamp is the current time, outStamp tells the users
-         * what time the frame should be displayed with.
          *
          * The relevant frames should be fetched and displayed using frameForTime
          * method.
+         *
+         * \param nowStamp the current time
+         * \param outStamp the time the frame should be displayed with
          */
         void displayFrame(qint64 nowStamp, qint64 outStamp);
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutputinterface.h phonon-4.3.0/phonon/experimental/videodataoutputinterface.h
--- phonon-4.3.0/phonon/experimental/videodataoutputinterface.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutputinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videodataoutput_p.h phonon-4.3.0/phonon/experimental/videodataoutput_p.h
--- phonon-4.3.0/phonon/experimental/videodataoutput_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videodataoutput_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videoframe2.h phonon-4.3.0/phonon/experimental/videoframe2.h
--- phonon-4.3.0/phonon/experimental/videoframe2.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videoframe2.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videoframe.h phonon-4.3.0/phonon/experimental/videoframe.h
--- phonon-4.3.0/phonon/experimental/videoframe.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videoframe.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videowidget.cpp phonon-4.3.0/phonon/experimental/videowidget.cpp
--- phonon-4.3.0/phonon/experimental/videowidget.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videowidget.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videowidget.h phonon-4.3.0/phonon/experimental/videowidget.h
--- phonon-4.3.0/phonon/experimental/videowidget.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videowidget.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/videowidget_p.h phonon-4.3.0/phonon/experimental/videowidget_p.h
--- phonon-4.3.0/phonon/experimental/videowidget_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/videowidget_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/visualization.cpp phonon-4.3.0/phonon/experimental/visualization.cpp
--- phonon-4.3.0/phonon/experimental/visualization.cpp	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/visualization.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/visualization.h phonon-4.3.0/phonon/experimental/visualization.h
--- phonon-4.3.0/phonon/experimental/visualization.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/visualization.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/experimental/visualization_p.h phonon-4.3.0/phonon/experimental/visualization_p.h
--- phonon-4.3.0/phonon/experimental/visualization_p.h	2008-11-24 10:11:59.000000000 -0700
+++ phonon-4.3.0/phonon/experimental/visualization_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/factory.cpp phonon-4.3.0/phonon/factory.cpp
--- phonon-4.3.0/phonon/factory.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/factory.cpp	2009-08-03 16:24:29.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -177,6 +177,6 @@
     qAddPostRoutine(globalFactory.destroy);
 #ifndef QT_NO_DBUS
-    QDBusConnection::sessionBus().connect(QString(), QString(), "org.kde.Phonon.Factory",
-            "phononBackendChanged", this, SLOT(phononBackendChanged()));
+    QDBusConnection::sessionBus().connect(QString(), QString(), QLatin1String("org.kde.Phonon.Factory"),
+        QLatin1String("phononBackendChanged"), this, SLOT(phononBackendChanged()));
 #endif
 }
@@ -326,4 +326,5 @@
 FACTORY_IMPL(VideoWidget)
 #endif //QT_NO_PHONON_VIDEO
+FACTORY_IMPL(AudioDataOutput)
 
 #undef FACTORY_IMPL
diff -r -U2 -N phonon-4.3.0/phonon/factory_p.h phonon-4.3.0/phonon/factory_p.h
--- phonon-4.3.0/phonon/factory_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/factory_p.h	2009-08-03 16:24:29.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -123,4 +123,11 @@
 
     /**
+    * Create a new backend object for a AudioDataOutput.
+    *
+    * \return a pointer to the AudioDataOutput the backend provides.
+    */
+    PHONON_EXPORT QObject *createAudioDataOutput(QObject *parent = 0);
+
+    /**
      * \return a pointer to the backend interface.
      */
diff -r -U2 -N phonon-4.3.0/phonon/frontendinterface_p.h phonon-4.3.0/phonon/frontendinterface_p.h
--- phonon-4.3.0/phonon/frontendinterface_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/frontendinterface_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/globalconfig.cpp phonon-4.3.0/phonon/globalconfig.cpp
--- phonon-4.3.0/phonon/globalconfig.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/globalconfig.cpp	2010-01-30 04:47:11.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -21,4 +21,5 @@
 */
 
+#include "globalconfig.h"
 #include "globalconfig_p.h"
 
@@ -30,4 +31,5 @@
 #include "qsettingsgroup_p.h"
 #include "phononnamespace_p.h"
+#include "pulsesupport.h"
 
 #include <QtCore/QList>
@@ -39,5 +41,10 @@
 {
 
-GlobalConfig::GlobalConfig() : m_config(QLatin1String("kde.org"), QLatin1String("libphonon"))
+GlobalConfigPrivate::GlobalConfigPrivate() : config(QLatin1String("kde.org"), QLatin1String("libphonon"))
+{
+}
+
+GlobalConfig::GlobalConfig()
+    : k_ptr(new GlobalConfigPrivate)
 {
 }
@@ -45,4 +52,5 @@
 GlobalConfig::~GlobalConfig()
 {
+    delete k_ptr;
 }
 
@@ -57,5 +65,9 @@
     QMutableListIterator<int> it(*list);
     while (it.hasNext()) {
-        const QHash<QByteArray, QVariant> properties = backendIface->objectDescriptionProperties(type, it.next());
+        QHash<QByteArray, QVariant> properties;
+        if (backendIface)
+            properties = backendIface->objectDescriptionProperties(type, it.next());
+        else
+            properties = PulseSupport::getInstance()->objectDescriptionProperties(type, it.next());
         QVariant var;
         if (whatToFilter & FilterAdvancedDevices) {
@@ -83,6 +95,10 @@
 }
 
-static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon::Category category, QList<int> &defaultList)
+static QList<int> sortDevicesByCategoryPriority(const GlobalConfig *config, const QSettingsGroup *backendConfig, ObjectDescriptionType type, Phonon::Category category, QList<int> &defaultList)
 {
+    Q_ASSERT(config);
+    Q_ASSERT(backendConfig);
+    Q_ASSERT(type == AudioOutputDeviceType || type == AudioCaptureDeviceType);
+
     if (defaultList.size() <= 1) {
         // nothing to sort
@@ -101,18 +117,24 @@
     }
 
-    QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
-    if (!backendConfig.hasKey(categoryKey)) {
-        // no list in config for the given category
-        categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
-        if (!backendConfig.hasKey(categoryKey)) {
-            // no list in config for NoCategory
-            return defaultList;
+    QList<int> deviceList;
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        deviceList = pulse->objectIndexesByCategory(type, category);
+    } else {
+        QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
+        if (!backendConfig->hasKey(categoryKey)) {
+            // no list in config for the given category
+            categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
+            if (!backendConfig->hasKey(categoryKey)) {
+                // no list in config for NoCategory
+                return defaultList;
+            }
         }
-    }
 
-    //Now the list from m_config
-    QList<int> deviceList = backendConfig.value(categoryKey, QList<int>());
+        //Now the list from d->config
+        deviceList = backendConfig->value(categoryKey, QList<int>());
+    }
 
-    //if there are devices in m_config that the backend doesn't report, remove them from the list
+    //if there are devices in d->config that the backend doesn't report, remove them from the list
     QMutableListIterator<int> i(deviceList);
     while (i.hasNext()) {
@@ -122,5 +144,5 @@
     }
 
-    //if the backend reports more devices that are not in m_config append them to the list
+    //if the backend reports more devices that are not in d->config append them to the list
     deviceList += defaultList;
 
@@ -128,48 +150,188 @@
 }
 
-QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+bool GlobalConfig::hideAdvancedDevices() const
 {
+    K_D(const GlobalConfig);
     //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    const QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    return generalGroup.value(QLatin1String("HideAdvancedDevices"), true);
+}
+
+void GlobalConfig::setHideAdvancedDevices(bool hide)
+{
+    K_D(GlobalConfig);
+    QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    generalGroup.setValue(QLatin1String("HideAdvancedDevices"), hide);
+}
+
+static bool isHiddenAudioOutputDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioOutputDevice ad = AudioOutputDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+static bool isHiddenAudioCaptureDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioCaptureDevice ad = AudioCaptureDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+#endif
+
+static QList<int> reindexList(const GlobalConfig *config, Phonon::Category category, QList<int>newOrder, bool output)
+{
+    Q_ASSERT(config);
+#ifdef QT_NO_PHONON_AUDIOCAPTURE
+    Q_ASSERT(output);
+#endif
+
+    /*QString sb;
+    sb = QString("(Size %1)").arg(currentList.size());
+    foreach (int i, currentList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Current: %s\n", sb.toUtf8().constData());
+    sb = QString("(Size %1)").arg(newOrder.size());
+    foreach (int i, newOrder)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Before : %s\n", sb.toUtf8().constData());*/
+
+    QList<int> currentList;
+    if (output)
+        currentList = config->audioOutputDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+    else
+        currentList = config->audioCaptureDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#endif
+
+    QList<int> newList;
+
+    foreach (int i, newOrder) {
+        int found = currentList.indexOf(i);
+        if (found < 0) {
+            // It's not in the list, so something is odd (e.g. client error). Ignore it.
+            continue;
+        }
+
+        // Iterate through the list from this point onward. If there are hidden devices
+        // immediately following, take them too.
+        newList.append(currentList.takeAt(found));
+        while (found < currentList.size()) {
+            bool hidden = true;
+            if (output)
+                hidden = isHiddenAudioOutputDevice(config, currentList.at(found));
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+            else
+                hidden = isHiddenAudioCaptureDevice(config, currentList.at(found));
+#endif
+
+            if (!hidden)
+                break;
+            newList.append(currentList.takeAt(found));
+        }
+    }
+
+    // If there are any devices left in.. just tack them on the end.
+    if (currentList.size() > 0)
+        newList += currentList;
+
+    /*sb = QString("(Size %1)").arg(newList.size());
+    foreach (int i, newList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex After  : %s\n", sb.toUtf8().constData());*/
+    return newList;
+}
+
+
+void GlobalConfig::setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setOutputDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, true);
+
+    const QList<int> noCategoryOrder = audioOutputDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
+QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+{
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        defaultList = pulse->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
+        if (hide || (override & HideUnavailableDevices)) {
+            filter(AudioOutputDeviceType, NULL, &defaultList,
+                    (hide ? FilterAdvancedDevices : 0)
+                    | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
+                    );
+        }
+    } else {
+        BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
-    }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
-        // this list already is in default order (as defined by the backend)
-        QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
-            filter(AudioOutputDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
-                    // the platform plugin already provided the hardware devices
-                    | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
-                    | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
-                    );
+        // lookup the available devices directly from the backend
+        if (backendIface) {
+            // this list already is in default order (as defined by the backend)
+            QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
+            if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+                filter(AudioOutputDeviceType, backendIface, &list,
+                        (hide ? FilterAdvancedDevices : 0)
+                        // the platform plugin maybe already provided the hardware devices?
+                        | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
+                        | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
+                        );
+            }
+            defaultList += list;
         }
-        defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioOutputDeviceType, category, defaultList);
 }
 
@@ -183,48 +345,83 @@
 
 #ifndef QT_NO_PHONON_AUDIOCAPTURE
+void GlobalConfig::setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setCaptureDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, false);
+
+    const QList<int> noCategoryOrder = audioCaptureDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
 QList<int> GlobalConfig::audioCaptureDeviceListFor(Phonon::Category category, int override) const
 {
-    //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        defaultList = pulse->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
+        if (hide || (override & HideUnavailableDevices)) {
+            filter(AudioCaptureDeviceType, NULL, &defaultList,
+                    (hide ? FilterAdvancedDevices : 0)
+                    | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
+                    );
+        }
+    } else {
+        BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
-    }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
-        // this list already is in default order (as defined by the backend)
-        QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
-            filter(AudioCaptureDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
-                    // the platform plugin already provided the hardware devices
-                    | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
-                    | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
-                  );
+        // lookup the available devices directly from the backend
+        if (backendIface) {
+            // this list already is in default order (as defined by the backend)
+            QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
+            if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+                filter(AudioCaptureDeviceType, backendIface, &list,
+                        (hide ? FilterAdvancedDevices : 0)
+                        // the platform plugin maybe already provided the hardware devices?
+                        | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
+                        | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
+                      );
+            }
+            defaultList += list;
         }
-        defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioCaptureDeviceType, category, defaultList);
 }
 
diff -r -U2 -N phonon-4.3.0/phonon/globalconfig.h phonon-4.3.0/phonon/globalconfig.h
--- phonon-4.3.0/phonon/globalconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/globalconfig.h	2009-11-19 17:10:44.000000000 -0700
@@ -0,0 +1,71 @@
+/*  This file is part of the KDE project
+Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_GLOBALCONFIG_H
+#define PHONON_GLOBALCONFIG_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "phonondefs.h"
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class GlobalConfigPrivate;
+
+    class PHONON_EXPORT GlobalConfig
+    {
+        K_DECLARE_PRIVATE(GlobalConfig)
+    public:
+        GlobalConfig();
+        virtual ~GlobalConfig();
+
+        enum DevicesToHideFlag {
+            ShowUnavailableDevices = 0,
+            ShowAdvancedDevices = 0,
+            HideAdvancedDevices = 1,
+            AdvancedDevicesFromSettings = 2,
+            HideUnavailableDevices = 4
+        };
+        bool hideAdvancedDevices() const;
+        void setHideAdvancedDevices(bool hide = true);
+        void setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+        void setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+#endif //QT_NO_PHONON_AUDIOCAPTURE
+
+    protected:
+        GlobalConfigPrivate *const k_ptr;
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_GLOBALCONFIG_H
diff -r -U2 -N phonon-4.3.0/phonon/globalconfig_p.h phonon-4.3.0/phonon/globalconfig_p.h
--- phonon-4.3.0/phonon/globalconfig_p.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/globalconfig_p.h	2009-11-19 17:09:40.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -27,5 +27,4 @@
 
 #include "phonon_export.h"
-#include "phononnamespace.h"
 
 QT_BEGIN_HEADER
@@ -34,27 +33,11 @@
 namespace Phonon
 {
-    class PHONON_EXPORT GlobalConfig
+    class GlobalConfigPrivate
     {
-    public:
-        GlobalConfig();
-        virtual ~GlobalConfig();
-
-        enum DevicesToHideFlag {
-            ShowUnavailableDevices = 0,
-            ShowAdvancedDevices = 0,
-            HideAdvancedDevices = 1,
-            AdvancedDevicesFromSettings = 2,
-            HideUnavailableDevices = 4
-        };
-        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-
-#ifndef QT_NO_PHONON_AUDIOCAPTURE
-        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-#endif //QT_NO_PHONON_AUDIOCAPTURE
+        public:
+            GlobalConfigPrivate();
+            virtual ~GlobalConfigPrivate() {}
 
-    protected:
-        QSettings m_config;
+            QSettings config;
     };
 } // namespace Phonon
diff -r -U2 -N phonon-4.3.0/phonon/globalstatic_p.h phonon-4.3.0/phonon/globalstatic_p.h
--- phonon-4.3.0/phonon/globalstatic_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/globalstatic_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/iodevicestream.cpp phonon-4.3.0/phonon/iodevicestream.cpp
--- phonon-4.3.0/phonon/iodevicestream.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/iodevicestream.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/iodevicestream_p.h phonon-4.3.0/phonon/iodevicestream_p.h
--- phonon-4.3.0/phonon/iodevicestream_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/iodevicestream_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediacontroller.cpp phonon-4.3.0/phonon/mediacontroller.cpp
--- phonon-4.3.0/phonon/mediacontroller.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediacontroller.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -8,5 +8,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediacontroller.h phonon-4.3.0/phonon/mediacontroller.h
--- phonon-4.3.0/phonon/mediacontroller.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediacontroller.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/medianode.cpp phonon-4.3.0/phonon/medianode.cpp
--- phonon-4.3.0/phonon/medianode.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/medianode.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project
     Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-    Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
 
     This library is free software; you can redistribute it and/or
@@ -8,5 +8,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/medianodedestructionhandler_p.h phonon-4.3.0/phonon/medianodedestructionhandler_p.h
--- phonon-4.3.0/phonon/medianodedestructionhandler_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/medianodedestructionhandler_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/medianode.h phonon-4.3.0/phonon/medianode.h
--- phonon-4.3.0/phonon/medianode.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/medianode.h	2009-02-26 14:33:54.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project
     Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
-    Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
 
     This library is free software; you can redistribute it and/or
@@ -8,5 +8,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/medianode_p.h phonon-4.3.0/phonon/medianode_p.h
--- phonon-4.3.0/phonon/medianode_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/medianode_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediaobject.cpp phonon-4.3.0/phonon/mediaobject.cpp
--- phonon-4.3.0/phonon/mediaobject.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/mediaobject.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediaobject.h phonon-4.3.0/phonon/mediaobject.h
--- phonon-4.3.0/phonon/mediaobject.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediaobject.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -48,5 +48,5 @@
      * Notice that most functions of this class are asynchronous.
      * That means if you call play() the object only starts playing when the
-     * stateChanged() signal tells you that the object changed into \ref PlayingState.
+     * stateChanged() signal tells you that the object changed into PlayingState.
      * The states you can expect are documented for those methods.
      *
@@ -59,5 +59,5 @@
      * \endcode
      *
-     * If you want to play more that one media file (one after another) you can
+     * If you want to play more than one media file (one after another) you can
      * either tell MediaObject about all those files
      * \code
@@ -119,5 +119,5 @@
          * accurately, therefore the accuracy of the prefinishMarkReached signal
          * can be bad sometimes. Still, it is better to use this method than to
-         * look at \ref totalTime and \ref currentTime to emulate the behaviour
+         * look at totalTime() and currentTime() to emulate the behaviour
          * because the backend might have more information available than your
          * application does through totalTime and currentTime.
@@ -255,5 +255,5 @@
              * Returns the strings associated with the given \p key.
              *
-             * Same as above except that the keys are defined in the \ref
+             * Same as above except that the keys are defined in the
              * Phonon::MetaData enum.
              */
@@ -303,5 +303,5 @@
             /**
              * Returns the queued media sources. This does list does not include
-             * the current source (returned by \ref currentSource).
+             * the current source (returned by currentSource).
              */
             QList<MediaSource> queue() const;
@@ -396,11 +396,11 @@
             /**
              * Requests playback of the media data to start. Playback only
-             * starts when stateChanged() signals that it goes into \ref PlayingState,
+             * starts when stateChanged() signals that it goes into PlayingState,
              * though.
              *
              * \par Possible states right after this call:
-             * \li \ref BufferingState
-             * \li \ref PlayingState
-             * \li (\ref ErrorState)
+             * \li BufferingState
+             * \li PlayingState
+             * \li ErrorState
              */
             void play();
@@ -410,7 +410,7 @@
              *
              * \par Possible states right after this call:
-             * \li \ref PlayingState
-             * \li \ref PausedState
-             * \li (\ref ErrorState)
+             * \li PlayingState
+             * \li PausedState
+             * \li ErrorState
              */
             void pause();
@@ -420,7 +420,7 @@
              *
              * \par Possible states right after this call:
-             * \li the state it was in before (e.g. \ref PlayingState)
-             * \li \ref StoppedState
-             * \li (\ref ErrorState)
+             * \li the state it was in before (e.g. PlayingState)
+             * \li StoppedState
+             * \li ErrorState
              */
             void stop();
@@ -429,5 +429,5 @@
              * Requests a seek to the time indicated.
              *
-             * You can only seek if state() == \ref PlayingState, \ref BufferingState or \ref PausedState.
+             * You can only seek if state() == PlayingState, BufferingState or PausedState.
              *
              * The call is asynchronous, so currentTime can still be the old
@@ -439,7 +439,7 @@
              *
              * \par Possible states right after this call:
-             * \li \ref BufferingState
-             * \li \ref PlayingState
-             * \li (\ref ErrorState)
+             * \li BufferingState
+             * \li PlayingState
+             * \li ErrorState
              *
              * \see SeekSlider
@@ -458,5 +458,5 @@
              * Emitted when the state of the MediaObject has changed.
              * In case you're not interested in the old state you can also
-             * connect to a slot that only has one \ref State argument.
+             * connect to a slot that only has one State argument.
              *
              * @param newstate The state the Player is in now.
@@ -547,5 +547,5 @@
             /**
              * Emitted when the MediaObject makes a transition to the next
-             * MediaSource in the \ref queue.
+             * MediaSource in the queue().
              *
              * In other words, it is emitted when an individual MediaSource is
@@ -560,5 +560,5 @@
              * Emitted before the playback of the whole queue stops. When this
              * signal is emitted you still have time to provide the next
-             * MediaSource (using \ref enqueue) so that playback continues.
+             * MediaSource (using enqueue()) so that playback continues.
              *
              * This signal can be used to provide the next MediaSource just in
diff -r -U2 -N phonon-4.3.0/phonon/mediaobjectinterface.h phonon-4.3.0/phonon/mediaobjectinterface.h
--- phonon-4.3.0/phonon/mediaobjectinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediaobjectinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediaobject_p.h phonon-4.3.0/phonon/mediaobject_p.h
--- phonon-4.3.0/phonon/mediaobject_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediaobject_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediasource.cpp phonon-4.3.0/phonon/mediasource.cpp
--- phonon-4.3.0/phonon/mediasource.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/mediasource.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediasource.h phonon-4.3.0/phonon/mediasource.h
--- phonon-4.3.0/phonon/mediasource.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/mediasource.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/mediasource_p.h phonon-4.3.0/phonon/mediasource_p.h
--- phonon-4.3.0/phonon/mediasource_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/mediasource_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/objectdescription.cpp phonon-4.3.0/phonon/objectdescription.cpp
--- phonon-4.3.0/phonon/objectdescription.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescription.cpp	2010-01-30 04:47:11.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -30,4 +30,5 @@
 #include "backendinterface.h"
 #include "platformplugin.h"
+#include "pulsesupport.h"
 
 QT_BEGIN_NAMESPACE
@@ -109,25 +110,36 @@
 ObjectDescriptionData *ObjectDescriptionData::fromIndex(ObjectDescriptionType type, int index)
 {
-    // prefer to get the ObjectDescriptionData from the platform plugin for audio devices
+    bool is_audio_device = (AudioOutputDeviceType == type || AudioCaptureDeviceType == type);
+
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (is_audio_device && pulse->isActive()) {
+        QList<int> indexes = pulse->objectDescriptionIndexes(type);
+        if (indexes.contains(index)) {
+            QHash<QByteArray, QVariant> properties = pulse->objectDescriptionProperties(type, index);
+            return new ObjectDescriptionData(index, properties);
+        }
+    } else {
+        BackendInterface *iface = qobject_cast<BackendInterface *>(Factory::backend());
+
+        // prefer to get the ObjectDescriptionData from the platform plugin for audio devices
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (type == AudioOutputDeviceType || type == AudioCaptureDeviceType) {
-        PlatformPlugin *platformPlugin = Factory::platformPlugin();
-        if (platformPlugin) {
-            QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
-            if (indexes.contains(index)) {
-                QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
-                return new ObjectDescriptionData(index, properties);
+        if (is_audio_device) {
+            PlatformPlugin *platformPlugin = Factory::platformPlugin();
+            if (platformPlugin) {
+                QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
+                if (indexes.contains(index)) {
+                    QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
+                    return new ObjectDescriptionData(index, properties);
+                }
             }
         }
-    }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    QObject *b = Factory::backend();
-    BackendInterface *iface = qobject_cast<BackendInterface *>(b);
-    if (iface) {
-        QList<int> indexes = iface->objectDescriptionIndexes(type);
-        if (indexes.contains(index)) {
-            QHash<QByteArray, QVariant> properties = iface->objectDescriptionProperties(type, index);
-            return new ObjectDescriptionData(index, properties);
+        if (iface) {
+            QList<int> indexes = iface->objectDescriptionIndexes(type);
+            if (indexes.contains(index)) {
+                QHash<QByteArray, QVariant> properties = iface->objectDescriptionProperties(type, index);
+                return new ObjectDescriptionData(index, properties);
+            }
         }
     }
diff -r -U2 -N phonon-4.3.0/phonon/objectdescription.h phonon-4.3.0/phonon/objectdescription.h
--- phonon-4.3.0/phonon/objectdescription.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescription.h	2009-10-03 12:00:19.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -53,6 +53,6 @@
          * network.
          *
-         * For Hardware devices the backend should use libkaudiodevicelist (\ref
-         * AudioDevice and \ref AudioDeviceEnumerator) which will list removable
+         * For Hardware devices the backend should use libkaudiodevicelist
+         * (AudioDevice and AudioDeviceEnumerator) which will list removable
          * devices even when they are unplugged and provide a unique identifier
          * that can make backends use the same identifiers.
@@ -72,6 +72,6 @@
          * network.
          *
-         * For Hardware devices the backend should use libkaudiodevicelist (\ref
-         * AudioDevice and \ref AudioDeviceEnumerator) which will list removable
+         * For Hardware devices the backend should use libkaudiodevicelist
+         * (AudioDevice and AudioDeviceEnumerator) which will list removable
          * devices even when they are unplugged and provide a unique identifier
          * that can make backends use the same identifiers.
diff -r -U2 -N phonon-4.3.0/phonon/objectdescriptionmodel.cpp phonon-4.3.0/phonon/objectdescriptionmodel.cpp
--- phonon-4.3.0/phonon/objectdescriptionmodel.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescriptionmodel.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/objectdescriptionmodel.h phonon-4.3.0/phonon/objectdescriptionmodel.h
--- phonon-4.3.0/phonon/objectdescriptionmodel.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescriptionmodel.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/objectdescriptionmodel_p.h phonon-4.3.0/phonon/objectdescriptionmodel_p.h
--- phonon-4.3.0/phonon/objectdescriptionmodel_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescriptionmodel_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/objectdescription_p.h phonon-4.3.0/phonon/objectdescription_p.h
--- phonon-4.3.0/phonon/objectdescription_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/objectdescription_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/path.cpp phonon-4.3.0/phonon/path.cpp
--- phonon-4.3.0/phonon/path.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/path.cpp	2009-04-08 02:26:40.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -245,6 +245,6 @@
     QList<QObjectPair> disco;
     if (list.count() >=2 ) {
-        QObjectList::const_iterator it = list.begin();
-        for(;it+1 != list.end();++it) {
+        QObjectList::const_iterator it = list.constBegin();
+        for(;it+1 != list.constEnd();++it) {
             disco << QObjectPair(*it, *(it+1));
         }
diff -r -U2 -N phonon-4.3.0/phonon/path.h phonon-4.3.0/phonon/path.h
--- phonon-4.3.0/phonon/path.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/path.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/path_p.h phonon-4.3.0/phonon/path_p.h
--- phonon-4.3.0/phonon/path_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/path_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/phonondefs.h phonon-4.3.0/phonon/phonondefs.h
--- phonon-4.3.0/phonon/phonondefs.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phonondefs.h	2009-04-23 03:00:49.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -30,4 +30,9 @@
 QT_BEGIN_NAMESPACE
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+# ifndef PHONON_BACKEND_VERSION_4_3
+#  define PHONON_BACKEND_VERSION_4_3
+# endif
+#endif
 #ifdef PHONON_BACKEND_VERSION_4_3
 # ifndef PHONON_BACKEND_VERSION_4_2
diff -r -U2 -N phonon-4.3.0/phonon/phonondefs_p.h phonon-4.3.0/phonon/phonondefs_p.h
--- phonon-4.3.0/phonon/phonondefs_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phonondefs_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/phonon_export.h phonon-4.3.0/phonon/phonon_export.h
--- phonon-4.3.0/phonon/phonon_export.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phonon_export.h	2009-05-19 08:04:53.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -33,5 +33,9 @@
 #  endif
 # else /* UNIX */
-#  define PHONON_EXPORT Q_DECL_EXPORT
+#  ifdef MAKE_PHONON_LIB /* We are building this library */
+#   define PHONON_EXPORT Q_DECL_EXPORT
+#  else /* We are using this library */
+#   define PHONON_EXPORT Q_DECL_IMPORT
+#  endif
 # endif
 #endif
diff -r -U2 -N phonon-4.3.0/phonon/phononnamespace.cpp phonon-4.3.0/phonon/phononnamespace.cpp
--- phonon-4.3.0/phonon/phononnamespace.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phononnamespace.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/phononnamespace.h.in phonon-4.3.0/phonon/phononnamespace.h.in
--- phonon-4.3.0/phonon/phononnamespace.h.in	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phononnamespace.h.in	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -91,5 +91,5 @@
 
     /**
-     * Provided as keys for \ref MediaObject::metaData for convenience, in addition to the strings defined in
+     * Provided as keys for MediaObject::metaData for convenience, in addition to the strings defined in
      * the Ogg Vorbis specification.
      */
diff -r -U2 -N phonon-4.3.0/phonon/phononnamespace_p.h phonon-4.3.0/phonon/phononnamespace_p.h
--- phonon-4.3.0/phonon/phononnamespace_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/phononnamespace_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/platform.cpp phonon-4.3.0/phonon/platform.cpp
--- phonon-4.3.0/phonon/platform.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/platform.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/platform_p.h phonon-4.3.0/phonon/platform_p.h
--- phonon-4.3.0/phonon/platform_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/platform_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/platformplugin.h phonon-4.3.0/phonon/platformplugin.h
--- phonon-4.3.0/phonon/platformplugin.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/platformplugin.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/pulsesupport.cpp phonon-4.3.0/phonon/pulsesupport.cpp
--- phonon-4.3.0/phonon/pulsesupport.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/pulsesupport.cpp	2010-01-30 04:47:18.000000000 -0700
@@ -0,0 +1,1011 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QEventLoop>
+#include <QtCore/QDebug>
+#include <QtCore/QStringList>
+
+#ifdef HAVE_PULSEAUDIO
+#include <glib.h>
+#include <pulse/pulseaudio.h>
+#include <pulse/xmalloc.h>
+#include <pulse/glib-mainloop.h>
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER
+#  include <pulse/ext-device-manager.h>
+#endif
+#endif // HAVE_PULSEAUDIO
+
+#include "pulsesupport.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+
+static PulseSupport* s_instance = NULL;
+
+#ifdef HAVE_PULSEAUDIO
+/***
+* Prints a conditional debug message based on the current debug level
+* If obj is provided, classname and objectname will be printed as well
+*
+* see debugLevel()
+*/
+
+static int debugLevel() {
+    static int level = -1;
+    if (level < 1) {
+        level = 0;
+        QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DEBUG");
+        int l = pulseenv.toInt();
+        if (l > 0)
+            level = (l > 2 ? 2 : l);
+    }
+    return level;
+}
+
+static void logMessage(const QString &message, int priority = 2, QObject *obj=0);
+static void logMessage(const QString &message, int priority, QObject *obj)
+{
+    if (debugLevel() > 0) {
+        QString output;
+        if (obj) {
+            // Strip away namespace from className
+            QString className(obj->metaObject()->className());
+            int nameLength = className.length() - className.lastIndexOf(':') - 1;
+            className = className.right(nameLength);
+            output.sprintf("%s %s (%s %p)", message.toLatin1().constData(), 
+                           obj->objectName().toLatin1().constData(), 
+                           className.toLatin1().constData(), obj);
+        }
+        else {
+            output = message;
+        }
+        if (priority <= debugLevel()) {
+            qDebug() << QString("PulseSupport(%1): %2").arg(priority).arg(output);
+        }
+    }
+}
+
+
+class AudioDevice
+{
+    public:
+        inline
+        AudioDevice(QString name, QString desc, QString icon, uint32_t index)
+        : pulseName(name), pulseIndex(index)
+        {
+            properties["name"] = desc;
+            properties["description"] = ""; // We don't have descriptions (well we do, but we use them as the name!)
+            properties["icon"] = icon;
+            properties["available"] = (index != PA_INVALID_INDEX);
+            properties["isAdvanced"] = false; // Nothing is advanced!
+        }
+
+        // Needed for QMap
+        inline AudioDevice() {}
+
+        QString pulseName;
+        uint32_t pulseIndex;
+        QHash<QByteArray, QVariant> properties;
+};
+bool operator!=(const AudioDevice &a, const AudioDevice &b)
+{
+    return !(a.pulseName == b.pulseName && a.properties == b.properties);
+}
+
+class PulseUserData
+{
+    public:
+        inline 
+        PulseUserData()
+        {
+        }
+
+        QMap<QString, AudioDevice> newOutputDevices;
+        QMap<Phonon::Category, QMap<int, int> > newOutputDevicePriorities; // prio, device
+
+        QMap<QString, AudioDevice> newCaptureDevices;
+        QMap<Phonon::Category, QMap<int, int> > newCaptureDevicePriorities; // prio, device
+};
+
+static QMap<QString, Phonon::Category> s_roleCategoryMap;
+
+static bool s_pulseActive = false;
+
+static pa_glib_mainloop *s_mainloop = NULL;
+static pa_context *s_context = NULL;
+static QEventLoop *s_connectionEventloop = NULL;
+
+
+
+static int s_deviceIndexCounter = 0;
+
+static QMap<QString, int> s_outputDeviceIndexes;
+static QMap<int, AudioDevice> s_outputDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_outputDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_outputStreamIndexMap;
+static QMap<QString, int> s_outputStreamMoveQueue;
+
+static QMap<QString, int> s_captureDeviceIndexes;
+static QMap<int, AudioDevice> s_captureDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_captureDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_captureStreamIndexMap;
+static QMap<QString, int> s_captureStreamMoveQueue;
+
+static void createGenericDevices()
+{
+    // OK so we don't have the device manager extension, but we can show a single device and fake it.
+    int index;
+    s_outputDeviceIndexes.clear();
+    s_outputDevices.clear();
+    s_outputDevicePriorities.clear();
+    index = s_deviceIndexCounter++;
+    s_outputDeviceIndexes.insert("sink:default", index);
+    s_outputDevices.insert(index, AudioDevice("sink:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+    for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+        Phonon::Category cat = static_cast<Phonon::Category>(i);
+        s_outputDevicePriorities[cat].insert(0, index);
+    }
+
+    s_captureDeviceIndexes.clear();
+    s_captureDevices.clear();
+    s_captureDevicePriorities.clear();
+    index = s_deviceIndexCounter++;
+    s_captureDeviceIndexes.insert("source:default", index);
+    s_captureDevices.insert(index, AudioDevice("source:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+    for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+        Phonon::Category cat = static_cast<Phonon::Category>(i);
+        s_captureDevicePriorities[cat].insert(0, index);
+    }
+}
+
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER
+static void ext_device_manager_subscribe_cb(pa_context *, void *);
+static void ext_device_manager_read_cb(pa_context *c, const pa_ext_device_manager_info *info, int eol, void *userdata) {
+    Q_ASSERT(c);
+    Q_ASSERT(userdata);
+
+    // If this is our first iteration, set things up properly
+    if (s_connectionEventloop) {
+        logMessage("Exiting connection event loop (PulseAudio server found)");
+        s_connectionEventloop->exit(0);
+        s_connectionEventloop = NULL;
+        s_pulseActive = true;
+
+        pa_operation *o;
+        pa_ext_device_manager_set_subscribe_cb(c, ext_device_manager_subscribe_cb, NULL);
+        if ((o = pa_ext_device_manager_subscribe(c, 1, NULL, NULL)))
+            pa_operation_unref(o);
+    }
+
+    if (eol < 0) {
+        logMessage(QString("Failed to initialize device manager extension: %1").arg(pa_strerror(pa_context_errno(c))));
+        createGenericDevices();
+        return;
+    }
+
+    PulseUserData *u = reinterpret_cast<PulseUserData*>(userdata);
+    if (eol) {
+        // We're done reading the data, so order it by priority and copy it into the
+        // static variables where it can then be accessed by those classes that need it.
+
+        QMap<QString, AudioDevice>::iterator newdev_it;
+
+        // Check for new output devices or things changing about known output devices.
+        bool output_changed = false;
+        for (newdev_it = u->newOutputDevices.begin(); newdev_it != u->newOutputDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_outputDeviceIndexes.contains(name));
+
+            int index = s_outputDeviceIndexes[name];
+            if (!s_outputDevices.contains(index)) {
+                // This is a totally new device
+                output_changed = true;
+                logMessage(QString("Brand New Output Device Found."));
+                s_outputDevices.insert(index, *newdev_it);
+            } else  if (s_outputDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                output_changed = true;
+                logMessage(QString("Change to Existing Output Device (may be Added/Removed or something else)"));
+                s_outputDevices.remove(index);
+                s_outputDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the output devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> output_existing_it(s_outputDeviceIndexes);
+        while (output_existing_it.hasNext()) {
+            output_existing_it.next();
+            if (!u->newOutputDevices.contains(output_existing_it.key())) {
+                output_changed = true;
+                logMessage(QString("Output Device Completely Removed"));
+                s_outputDevices.remove(output_existing_it.value());
+                output_existing_it.remove();
+            }
+        }
+
+        // Check for new capture devices or things changing about known capture devices.
+        bool capture_changed = false;
+        for (newdev_it = u->newCaptureDevices.begin(); newdev_it != u->newCaptureDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_captureDeviceIndexes.contains(name));
+
+            int index = s_captureDeviceIndexes[name];
+            if (!s_captureDevices.contains(index)) {
+                // This is a totally new device
+                capture_changed = true;
+                logMessage(QString("Brand New Capture Device Found."));
+                s_captureDevices.insert(index, *newdev_it);
+            } else  if (s_captureDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                capture_changed = true;
+                logMessage(QString("Change to Existing Capture Device (may be Added/Removed or something else)"));
+                s_captureDevices.remove(index);
+                s_captureDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the capture devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> capture_existing_it(s_captureDeviceIndexes);
+        while (capture_existing_it.hasNext()) {
+            capture_existing_it.next();
+            if (!u->newCaptureDevices.contains(capture_existing_it.key())) {
+                capture_changed = true;
+                logMessage(QString("Capture Device Completely Removed"));
+                s_captureDevices.remove(capture_existing_it.value());
+                capture_existing_it.remove();
+            }
+        }
+
+        // Just copy accross the new priority lists as we know they are valid
+        if (s_outputDevicePriorities != u->newOutputDevicePriorities) {
+            output_changed = true;
+            s_outputDevicePriorities = u->newOutputDevicePriorities;
+        }
+        if (s_captureDevicePriorities != u->newCaptureDevicePriorities) {
+            capture_changed = true;
+            s_captureDevicePriorities = u->newCaptureDevicePriorities;
+        }
+
+        if (s_instance) {
+            if (output_changed)
+                s_instance->emitObjectDescriptionChanged(AudioOutputDeviceType);
+            if (capture_changed)
+                s_instance->emitObjectDescriptionChanged(AudioCaptureDeviceType);
+        }
+
+        // We can free the user data as we will not be called again.
+        delete u;
+
+        // Some debug
+        logMessage(QString("Output Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_outputDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_outputDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_outputDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+        logMessage(QString("Capture Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_captureDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_captureDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_captureDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+    }
+
+    if (!info)
+        return;
+
+    Q_ASSERT(info->name);
+    Q_ASSERT(info->description);
+    Q_ASSERT(info->icon);
+
+    // QString wrapper
+    QString name(info->name);
+    int index;
+    QMap<Phonon::Category, QMap<int, int> > *new_prio_map_cats; // prio, device
+    QMap<QString, AudioDevice> *new_devices;
+
+    if (name.startsWith("sink:")) {
+        new_devices = &u->newOutputDevices;
+        new_prio_map_cats = &u->newOutputDevicePriorities;
+
+        if (s_outputDeviceIndexes.contains(name))
+            index = s_outputDeviceIndexes[name];
+        else
+            index = s_outputDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else if (name.startsWith("source:")) {
+        new_devices = &u->newCaptureDevices;
+        new_prio_map_cats = &u->newCaptureDevicePriorities;
+
+        if (s_captureDeviceIndexes.contains(name))
+            index = s_captureDeviceIndexes[name];
+        else
+            index = s_captureDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else {
+        // This indicates a bug in pulseaudio.
+        return;
+    }
+
+    // Add the new device itself.
+    new_devices->insert(name, AudioDevice(name, info->description, info->icon, info->index));
+
+    // For each role in the priority, map it to a phonon category and store the order.
+    for (uint32_t i = 0; i < info->n_role_priorities; ++i) {
+        pa_ext_device_manager_role_priority_info* role_prio = &info->role_priorities[i];
+        Q_ASSERT(role_prio->role);
+
+        if (s_roleCategoryMap.contains(role_prio->role)) {
+            Phonon::Category cat = s_roleCategoryMap[role_prio->role];
+
+            (*new_prio_map_cats)[cat].insert(role_prio->priority, index);
+        }
+    }
+}
+#endif
+
+static void set_output_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_outputDevices.size() < 2)
+        return;
+
+    if (!s_outputStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_outputStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_outputStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_outputStreamMoveQueue[streamUuid];
+    if (!s_outputDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioOutput object
+
+    uint32_t pulse_device_index = s_outputDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_outputStreamIndexMap[streamUuid];
+
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Sink Input %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_sink_input_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_sink_input_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+static void set_capture_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_captureDevices.size() < 2)
+        return;
+
+    if (!s_captureStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_captureStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_captureStreamMoveQueue[streamUuid];
+    if (!s_captureDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioCapture object (when it exists!)
+
+    uint32_t pulse_device_index = s_captureDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_captureStreamIndexMap[streamUuid];
+
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Source Output %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_source_output_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_source_output_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+void sink_input_cb(pa_context *c, const pa_sink_input_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Sink input callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Output Stream %2").arg(i->index).arg(t));
+        s_outputStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_output_device(QString(t));
+    }
+}
+
+void source_output_cb(pa_context *c, const pa_source_output_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Source output callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Capture Stream %2").arg(i->index).arg(t));
+        s_captureStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_capture_device(QString(t));
+    }
+}
+
+static void subscribe_cb(pa_context *c, pa_subscription_event_type_t t, uint32_t index, void *userdata) {
+    Q_UNUSED(userdata);
+
+    switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
+        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_outputStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_outputStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Output Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_outputStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Output Stream %1 (it's gone!)").arg(phononid));
+                        s_outputStreamIndexMap.remove(phononid);
+                        s_outputStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_sink_input_info(c, index, sink_input_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_captureStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_captureStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Capture Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_captureStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Capture Stream %1 (it's gone!)").arg(phononid));
+                        s_captureStreamIndexMap.remove(phononid);
+                        s_captureStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_source_output_info(c, index, source_output_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+    }
+}
+
+
+static void ext_device_manager_subscribe_cb(pa_context *c, void *) {
+    Q_ASSERT(c);
+
+    pa_operation *o;
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER 
+    PulseUserData *u = new PulseUserData; /** @todo Make some object to receive the info... */
+    if (!(o = pa_ext_device_manager_read(c, ext_device_manager_read_cb, u))) {
+        // We need to deal with failure on first iteration
+        if (s_connectionEventloop) {
+            logMessage("Entering connection eventloop (initialisation failed)");
+            s_connectionEventloop->exit(0);
+            s_connectionEventloop = NULL;
+        }
+        logMessage(QString("pa_ext_device_manager_read() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+#else
+    // If we do not have Device Manager support. We just bail out now
+    // and say we are active with our single "devices" for playback and capture
+    s_pulseActive = true;
+    logMessage("Entering connection eventloop (successfully detected PulseAudio)");
+    if (s_connectionEventloop) {
+        s_connectionEventloop->exit(0);
+        s_connectionEventloop = NULL;
+    }
+    createGenericDevices();
+#endif
+
+
+    // Register for the stream changes...
+    pa_context_set_subscribe_callback(c, subscribe_cb, NULL);
+
+    if (!(o = pa_context_subscribe(c, (pa_subscription_mask_t)
+                                   (PA_SUBSCRIPTION_MASK_SINK_INPUT|
+                                    PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT), NULL, NULL))) {
+        logMessage(QString("pa_context_subscribe() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+
+static const char* statename(pa_context_state_t state)
+{
+    switch (state)
+    {
+        case PA_CONTEXT_UNCONNECTED:  return "Unconnected";
+        case PA_CONTEXT_CONNECTING:   return "Connecting";
+        case PA_CONTEXT_AUTHORIZING:  return "Authorizing";
+        case PA_CONTEXT_SETTING_NAME: return "Setting Name";
+        case PA_CONTEXT_READY:        return "Ready";
+        case PA_CONTEXT_FAILED:       return "Failed";
+        case PA_CONTEXT_TERMINATED:   return "Terminated";
+    }
+
+    static QString unknown;
+    unknown = QString("Unknown state: %0").arg(state);
+    return unknown.toAscii().constData();
+}
+
+static void context_state_callback(pa_context *c, void *)
+{
+    Q_ASSERT(c);
+
+    logMessage(QString("context_state_callback %1").arg(statename(pa_context_get_state(c))));
+    switch (pa_context_get_state(c)) {
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+            break;
+
+        case PA_CONTEXT_READY:
+            // Attempt to load things up
+            ext_device_manager_subscribe_cb(c, NULL);
+            break;
+
+        case PA_CONTEXT_FAILED:
+            s_pulseActive = false;
+            if (s_connectionEventloop) {
+                logMessage("Entering connection eventloop (connection failed)");
+                s_connectionEventloop->exit(0);
+                s_connectionEventloop = NULL;
+            }
+            break;
+
+        case PA_CONTEXT_TERMINATED:
+        default:
+            s_pulseActive = false;
+            /// @todo Deal with reconnection...
+            break;
+    }
+}
+#endif // HAVE_PULSEAUDIO
+
+
+PulseSupport* PulseSupport::getInstance()
+{
+    if (NULL == s_instance) {
+        s_instance = new PulseSupport();
+    }
+    return s_instance;
+}
+
+void PulseSupport::shutdown()
+{
+    if (NULL != s_instance) {
+        delete s_instance;
+        s_instance = NULL;
+    }
+}
+
+PulseSupport::PulseSupport()
+ : QObject(), mEnabled(false)
+{
+#ifdef HAVE_PULSEAUDIO
+    // Initialise our map (is there a better way to do this?)
+    s_roleCategoryMap["none"] = Phonon::NoCategory;
+    s_roleCategoryMap["video"] = Phonon::VideoCategory;
+    s_roleCategoryMap["music"] = Phonon::MusicCategory;
+    s_roleCategoryMap["game"] = Phonon::GameCategory;
+    s_roleCategoryMap["event"] = Phonon::NotificationCategory;
+    s_roleCategoryMap["phone"] = Phonon::CommunicationCategory;
+    //s_roleCategoryMap["animation"]; // No Mapping
+    //s_roleCategoryMap["production"]; // No Mapping
+    s_roleCategoryMap["a11y"] = Phonon::AccessibilityCategory;
+
+    // To allow for easy debugging, give an easy way to disable this pulseaudio check
+    QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DISABLE");
+    if (pulseenv.toInt())
+        return;
+
+    s_mainloop = pa_glib_mainloop_new(NULL);
+    Q_ASSERT(s_mainloop);
+    pa_mainloop_api *api = pa_glib_mainloop_get_api(s_mainloop);
+
+    // We create a simple event loop to allow the glib loop
+    // to iterate until we've connected or not to the server.
+    s_connectionEventloop = new QEventLoop;
+
+    // XXX I don't want to show up in the client list. All I want to know is the list of sources
+    // and sinks...
+    s_context = pa_context_new(api, "libphonon");
+    // (cg) Convert to PA_CONTEXT_NOFLAGS when PulseAudio 0.9.19 is required
+    if (pa_context_connect(s_context, NULL, static_cast<pa_context_flags_t>(0), 0) >= 0) {
+        pa_context_set_state_callback(s_context, &context_state_callback, s_connectionEventloop);
+        // Now we block until we connect or otherwise...
+        logMessage("Entering connection eventloop...");
+        s_connectionEventloop->exec();
+    }
+#endif
+}
+
+PulseSupport::~PulseSupport()
+{
+#ifdef HAVE_PULSEAUDIO
+    if (s_context) {
+        pa_context_disconnect(s_context);
+        s_context = NULL;
+    }
+
+    if (s_mainloop) {
+        pa_glib_mainloop_free(s_mainloop);
+        s_mainloop = NULL;
+    }
+
+    if (s_connectionEventloop) {
+        delete s_connectionEventloop;
+        s_connectionEventloop = NULL;
+    }
+#endif
+}
+
+bool PulseSupport::isActive()
+{
+#ifdef HAVE_PULSEAUDIO
+    return mEnabled && s_pulseActive;
+#else
+    return false;
+#endif
+}
+
+void PulseSupport::enable(bool enabled)
+{
+    mEnabled = enabled;
+}
+
+QList<int> PulseSupport::objectDescriptionIndexes(ObjectDescriptionType type) const
+{
+    QList<int> list;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return list;
+
+#ifdef HAVE_PULSEAUDIO
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_outputDeviceIndexes.begin(); it != s_outputDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            case AudioCaptureDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_captureDeviceIndexes.begin(); it != s_captureDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            default:
+                break;
+        }
+    }
+#endif
+
+    return list;
+}
+
+QHash<QByteArray, QVariant> PulseSupport::objectDescriptionProperties(ObjectDescriptionType type, int index) const
+{
+    QHash<QByteArray, QVariant> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(index);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                Q_ASSERT(s_outputDevices.contains(index));
+                ret = s_outputDevices[index].properties;
+                break;
+
+            case AudioCaptureDeviceType:
+                Q_ASSERT(s_captureDevices.contains(index));
+                ret = s_captureDevices[index].properties;
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+QList<int> PulseSupport::objectIndexesByCategory(ObjectDescriptionType type, Category category) const
+{
+    QList<int> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                if (s_outputDevicePriorities.contains(category))
+                    ret = s_outputDevicePriorities[category].values();
+                break;
+
+            case AudioCaptureDeviceType:
+                if (s_captureDevicePriorities.contains(category))
+                    ret = s_captureDevicePriorities[category].values();
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+#ifdef HAVE_PULSEAUDIO
+static void setDevicePriority(Category category, QStringList list)
+{
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Reindexing %1: %2").arg(role).arg(list.join(", ")));
+
+    char **devices;
+    devices = pa_xnew(char *, list.size()+1);
+    int i = 0;
+    foreach (QString str, list) {
+        devices[i++] = pa_xstrdup(str.toUtf8().constData());
+    }
+    devices[list.size()] = NULL;
+
+#ifdef HAVE_PULSEAUDIO_DEVICE_MANAGER 
+    pa_operation *o;
+    if (!(o = pa_ext_device_manager_reorder_devices_for_role(s_context, role.toUtf8().constData(), (const char**)devices, NULL, NULL)))
+        logMessage(QString("pa_ext_device_manager_reorder_devices_for_role() failed"));
+    else
+        pa_operation_unref(o);
+#endif
+
+    for (i = 0; i < list.size(); ++i)
+        pa_xfree(devices[i]);
+    pa_xfree(devices);
+}
+#endif
+
+void PulseSupport::setOutputDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_outputDevices.contains(*it)) {
+            list << s_outputDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setCaptureDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_captureDevices.contains(*it)) {
+            list << s_captureDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setStreamPropList(Category category, QString streamUuid)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(streamUuid);
+#else
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Setting role to %1 for streamindex %2").arg(role).arg(streamUuid));
+    setenv("PULSE_PROP_media.role", role.toLatin1().constData(), 1);
+    setenv("PULSE_PROP_phonon.streamid", streamUuid.toLatin1().constData(), 1);
+#endif
+}
+
+void PulseSupport::emitObjectDescriptionChanged(ObjectDescriptionType type)
+{
+    emit objectDescriptionChanged(type);
+}
+
+bool PulseSupport::setOutputDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_outputDevices.size() < 2)
+        return true;
+
+    if (!s_outputDevices.contains(device)) {
+        logMessage(QString("Attempting to set Output Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Output Device to '%1' for Output Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_outputStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_outputStreamIndexMap.contains(streamUuid) && s_outputStreamIndexMap[streamUuid] != PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_output_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+bool PulseSupport::setCaptureDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_captureDevices.size() < 2)
+        return true;
+
+    if (!s_captureDevices.contains(device)) {
+        logMessage(QString("Attempting to set Capture Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Capture Device to '%1' for Capture Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_captureStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_captureStreamIndexMap.contains(streamUuid) && s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_capture_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+void PulseSupport::clearStreamCache(QString streamUuid) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    return;
+#else
+    logMessage(QString("Clearing stream cache for stream %1").arg(streamUuid));
+    s_outputStreamIndexMap.remove(streamUuid);
+    s_outputStreamMoveQueue.remove(streamUuid);
+    s_captureStreamIndexMap.remove(streamUuid);
+    s_captureStreamMoveQueue.remove(streamUuid);
+#endif
+}
+
+} // namespace Phonon
+
+QT_END_NAMESPACE
+
+#include "moc_pulsesupport.cpp"
+
+// vim: sw=4 ts=4
diff -r -U2 -N phonon-4.3.0/phonon/pulsesupport.h phonon-4.3.0/phonon/pulsesupport.h
--- phonon-4.3.0/phonon/pulsesupport.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/pulsesupport.h	2010-01-30 04:47:18.000000000 -0700
@@ -0,0 +1,75 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_PULSESUPPORT_H
+#define PHONON_PULSESUPPORT_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "objectdescription.h"
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QSet>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class PHONON_EXPORT PulseSupport : public QObject
+    {
+        Q_OBJECT
+        public:
+            static PulseSupport* getInstance();
+            static void shutdown();
+
+            bool isActive();
+            void enable(bool enabled = true);
+
+            QList<int> objectDescriptionIndexes(ObjectDescriptionType type) const;
+            QHash<QByteArray, QVariant> objectDescriptionProperties(ObjectDescriptionType type, int index) const;
+            QList<int> objectIndexesByCategory(ObjectDescriptionType type, Category category) const;
+
+            void setOutputDevicePriorityForCategory(Category category, QList<int> order);
+            void setCaptureDevicePriorityForCategory(Category category, QList<int> order);
+
+            void setStreamPropList(Category category, QString streamUuid);
+            void emitObjectDescriptionChanged(ObjectDescriptionType);
+
+            bool setOutputDevice(QString streamUuid, int device);
+            bool setCaptureDevice(QString streamUuid, int device);
+            void clearStreamCache(QString streamUuid);
+
+        signals:
+            void objectDescriptionChanged(ObjectDescriptionType);
+        private:
+            PulseSupport();
+            ~PulseSupport();
+
+            bool mEnabled;
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_PULSESUPPORT_H
diff -r -U2 -N phonon-4.3.0/phonon/qsettingsgroup_p.h phonon-4.3.0/phonon/qsettingsgroup_p.h
--- phonon-4.3.0/phonon/qsettingsgroup_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/qsettingsgroup_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/seekslider.cpp phonon-4.3.0/phonon/seekslider.cpp
--- phonon-4.3.0/phonon/seekslider.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/seekslider.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/seekslider.h phonon-4.3.0/phonon/seekslider.h
--- phonon-4.3.0/phonon/seekslider.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/seekslider.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/seekslider_p.h phonon-4.3.0/phonon/seekslider_p.h
--- phonon-4.3.0/phonon/seekslider_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/seekslider_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -25,6 +25,6 @@
 
 #include "seekslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
@@ -85,5 +85,5 @@
 
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QLabel iconLabel;
         QPointer<MediaObject> media;
diff -r -U2 -N phonon-4.3.0/phonon/streaminterface.cpp phonon-4.3.0/phonon/streaminterface.cpp
--- phonon-4.3.0/phonon/streaminterface.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/streaminterface.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/streaminterface.h phonon-4.3.0/phonon/streaminterface.h
--- phonon-4.3.0/phonon/streaminterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/streaminterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/streaminterface_p.h phonon-4.3.0/phonon/streaminterface_p.h
--- phonon-4.3.0/phonon/streaminterface_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/streaminterface_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/swiftslider.cpp phonon-4.3.0/phonon/swiftslider.cpp
--- phonon-4.3.0/phonon/swiftslider.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/swiftslider.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -0,0 +1,103 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "swiftslider_p.h"
+
+#include <QtGui/QMouseEvent>
+#include <QtGui/QStyle>
+#include <QtGui/QStyleOption>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+SwiftSlider::SwiftSlider(Qt::Orientation orientation, QWidget * parent)
+	: QSlider(orientation, parent)
+{
+}
+
+SwiftSlider::~SwiftSlider()
+{
+}
+
+// Function copied from qslider.cpp
+inline int SwiftSlider::pick(const QPoint &pt) const
+{
+    return orientation() == Qt::Horizontal ? pt.x() : pt.y();
+}
+
+// Function copied from qslider.cpp and modified to make it compile
+int SwiftSlider::pixelPosToRangeValue(int pos) const
+{
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+    QRect gr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderGroove, this);
+    QRect sr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+    int sliderMin, sliderMax, sliderLength;
+
+    if (orientation() == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+    return QStyle::sliderValueFromPosition(minimum(), maximum(), pos - sliderMin,
+                                           sliderMax - sliderMin, opt.upsideDown);
+}
+
+// Based on code from qslider.cpp
+void SwiftSlider::mousePressEvent(QMouseEvent *event)
+{
+    if (event->button() == Qt::LeftButton) {
+        QStyleOptionSlider opt;
+        initStyleOption(&opt);
+        const QRect sliderRect = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+        const QPoint center = sliderRect.center() - sliderRect.topLeft();
+        // to take half of the slider off for the setSliderPosition call we use the center - topLeft
+
+        if (!sliderRect.contains(event->pos())) {
+            event->accept();
+
+            setSliderPosition(pixelPosToRangeValue(pick(event->pos() - center)));
+            triggerAction(SliderMove);
+            setRepeatAction(SliderNoAction);
+        } else {
+            QSlider::mousePressEvent(event);
+        }
+    } else {
+        QSlider::mousePressEvent(event);
+    }
+}
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#include "moc_swiftslider_p.cpp"
diff -r -U2 -N phonon-4.3.0/phonon/swiftslider_p.h phonon-4.3.0/phonon/swiftslider_p.h
--- phonon-4.3.0/phonon/swiftslider_p.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/swiftslider_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -0,0 +1,68 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef SWIFTSLIDER_H
+#define SWIFTSLIDER_H
+
+#include <QtGui/QSlider>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+/** \class SwiftSlider swiftslider_p.h Phonon/SwiftSlider
+ * \short Modified QSlider that allows sudden/quick moves instead of stepped moves ("Click'n'Go" QSlider)
+ *
+ * This is an internal class used by SeekSlider and VolumeSlider.
+ *
+ * Ricardo Villalba, the original author of MySlider.cpp (from the SMPlayer project)
+ * gave his permission for the inclusion of this code inside Phonon by
+ * switching MySlider.cpp to the LGPLv2.1+ license.
+ * See http://smplayer.svn.sourceforge.net/viewvc/smplayer/smplayer/trunk/src/myslider.cpp?revision=2406&view=markup
+ *
+ * The original discussion about a "Click'n'Go QSlider": http://lists.trolltech.com/qt-interest/2006-11/msg00363.html
+ *
+ * \ingroup PhononWidgets
+ */
+class SwiftSlider : public QSlider
+{
+	Q_OBJECT
+public:
+	SwiftSlider(Qt::Orientation orientation, QWidget * parent);
+	~SwiftSlider();
+
+private:
+	void mousePressEvent(QMouseEvent *event);
+	inline int pick(const QPoint &pt) const;
+	int pixelPosToRangeValue(int pos) const;
+};
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#endif //SWIFTSLIDER_H
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiocapturedevicetest.cpp phonon-4.3.0/phonon/tests/audiocapturedevicetest.cpp
--- phonon-4.3.0/phonon/tests/audiocapturedevicetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiocapturedevicetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiodataoutputtest.cpp phonon-4.3.0/phonon/tests/audiodataoutputtest.cpp
--- phonon-4.3.0/phonon/tests/audiodataoutputtest.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiodataoutputtest.cpp	2009-08-12 15:26:02.000000000 -0700
@@ -0,0 +1,70 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2007 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "../audiodataoutput.h"
+#include "../mediaobject.h"
+#include "../path.h"
+#include "../audiooutput.h"
+#include "loadfakebackend.h"
+
+#include <QtTest/QTest>
+#include <cstdlib>
+#include <QtCore/QUrl>
+#include <QtCore/QObject>
+
+class AudioDataOutputTest : public QObject
+{
+    Q_OBJECT
+    private slots:
+        void initTestCase();
+        void testSampleRate();
+        void testDataSize();
+        void cleanupTestCase();
+};
+
+using namespace Phonon;
+
+void AudioDataOutputTest::initTestCase()
+{
+    QCoreApplication::setApplicationName("audiodataoutputtest");
+    Phonon::loadFakeBackend();
+    AudioDataOutput test(this);
+}
+
+void AudioDataOutputTest::testSampleRate()
+{
+    AudioDataOutput test(this);
+    QVERIFY(test.sampleRate() > 0);
+}
+
+void AudioDataOutputTest::testDataSize()
+{
+    AudioDataOutput test(this);
+    QVERIFY(test.dataSize() > 0);
+}
+
+void AudioDataOutputTest::cleanupTestCase()
+{
+}
+
+QTEST_MAIN(AudioDataOutputTest)
+#include "audiodataoutputtest.moc"
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiodataoutputtest.h phonon-4.3.0/phonon/tests/audiodataoutputtest.h
--- phonon-4.3.0/phonon/tests/audiodataoutputtest.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiodataoutputtest.h	2009-08-08 05:04:12.000000000 -0700
@@ -0,0 +1,26 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef AUDIODATAOUTPUTTEST_H
+#define AUDIODATAOUTPUTTEST_H
+
+#endif // AUDIODATAOUTPUTTEST_H
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiodevicelisttest.cpp phonon-4.3.0/phonon/tests/audiodevicelisttest.cpp
--- phonon-4.3.0/phonon/tests/audiodevicelisttest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiodevicelisttest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiooutputdevicetest.cpp phonon-4.3.0/phonon/tests/audiooutputdevicetest.cpp
--- phonon-4.3.0/phonon/tests/audiooutputdevicetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiooutputdevicetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/audiooutputtest.cpp phonon-4.3.0/phonon/tests/audiooutputtest.cpp
--- phonon-4.3.0/phonon/tests/audiooutputtest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/audiooutputtest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/backendcapabilitiestest.cpp phonon-4.3.0/phonon/tests/backendcapabilitiestest.cpp
--- phonon-4.3.0/phonon/tests/backendcapabilitiestest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/backendcapabilitiestest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/backendtester.cpp phonon-4.3.0/phonon/tests/backendtester.cpp
--- phonon-4.3.0/phonon/tests/backendtester.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/backendtester.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/backendtester.h phonon-4.3.0/phonon/tests/backendtester.h
--- phonon-4.3.0/phonon/tests/backendtester.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/backendtester.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/bytestreamtest2.cpp phonon-4.3.0/phonon/tests/bytestreamtest2.cpp
--- phonon-4.3.0/phonon/tests/bytestreamtest2.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/bytestreamtest2.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, if any)
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, if any)
     and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/bytestreamtest2.h phonon-4.3.0/phonon/tests/bytestreamtest2.h
--- phonon-4.3.0/phonon/tests/bytestreamtest2.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/bytestreamtest2.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/bytestreamtest.cpp phonon-4.3.0/phonon/tests/bytestreamtest.cpp
--- phonon-4.3.0/phonon/tests/bytestreamtest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/bytestreamtest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/bytestreamtest.h phonon-4.3.0/phonon/tests/bytestreamtest.h
--- phonon-4.3.0/phonon/tests/bytestreamtest.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/bytestreamtest.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/CMakeLists.txt phonon-4.3.0/phonon/tests/CMakeLists.txt
--- phonon-4.3.0/phonon/tests/CMakeLists.txt	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/CMakeLists.txt	2009-08-08 05:04:12.000000000 -0700
@@ -40,4 +40,5 @@
 	seekslidertest
 	volumeslidertest
+	audiodataoutputtest
 	)
 
@@ -57,4 +58,5 @@
 	seekslidertest
 	volumeslidertest
+	audiodataoutputtest
 )
 target_link_libraries(backendcapabilitiestest ${PHONON_KDECORE_LIBS})
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.cpp phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.h phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.h
--- phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/abstractaudiooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/abstractvideooutput.h phonon-4.3.0/phonon/tests/fakebackend/abstractvideooutput.h
--- phonon-4.3.0/phonon/tests/fakebackend/abstractvideooutput.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/abstractvideooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.cpp phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.cpp	2009-08-17 10:11:28.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -16,5 +16,5 @@
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public 
+    You should have received a copy of the GNU Lesser General Public
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
@@ -38,9 +38,4 @@
 }
 
-Phonon::Experimental::AudioDataOutput::Format AudioDataOutput::format() const
-{
-    return m_format;
-}
-
 int AudioDataOutput::dataSize() const
 {
@@ -53,9 +48,4 @@
 }
 
-void AudioDataOutput::setFormat(Phonon::Experimental::AudioDataOutput::Format format)
-{
-    m_format = format;
-}
-
 void AudioDataOutput::setDataSize(int size)
 {
@@ -63,26 +53,16 @@
 }
 
-typedef QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > FloatMap;
-typedef QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > IntMap;
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<float> > FloatMap;
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > IntMap;
 
 inline void AudioDataOutput::convertAndEmit(const QVector<float> &buffer)
 {
-    if (m_format == Phonon::Experimental::AudioDataOutput::FloatFormat)
-    {
-        FloatMap map;
-        map.insert(Phonon::Experimental::AudioDataOutput::LeftChannel, buffer);
-        map.insert(Phonon::Experimental::AudioDataOutput::RightChannel, buffer);
-        emit dataReady(map);
-    }
-    else
-    {
-        IntMap map;
-        QVector<qint16> intBuffer(m_dataSize);
-        for (int i = 0; i < m_dataSize; ++i)
-            intBuffer[i] = static_cast<qint16>(buffer[i] * static_cast<float>(0x7FFF));
-        map.insert(Phonon::Experimental::AudioDataOutput::LeftChannel, intBuffer);
-        map.insert(Phonon::Experimental::AudioDataOutput::RightChannel, intBuffer);
-        emit dataReady(map);
-    }
+    IntMap map;
+    QVector<qint16> intBuffer(m_dataSize);
+    for (int i = 0; i < m_dataSize; ++i)
+        intBuffer[i] = static_cast<qint16>(buffer[i] * static_cast<float>(0x7FFF));
+    map.insert(Phonon::AudioDataOutput::LeftChannel, intBuffer);
+    map.insert(Phonon::AudioDataOutput::RightChannel, intBuffer);
+    emit dataReady(map);
 }
 
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.h phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.h
--- phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/audiodataoutput.h	2009-08-17 10:11:28.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -16,5 +16,5 @@
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public 
+    You should have received a copy of the GNU Lesser General Public
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
@@ -24,5 +24,5 @@
 
 #include "abstractaudiooutput.h"
-#include <phonon/experimental/audiodataoutput.h>
+#include <phonon/audiodataoutput.h>
 #include <QtCore/QVector>
 
@@ -42,8 +42,6 @@
 
         public Q_SLOTS:
-            Phonon::Experimental::AudioDataOutput::Format format() const;
             int dataSize() const;
             int sampleRate() const;
-            void setFormat(Phonon::Experimental::AudioDataOutput::Format format);
             void setDataSize(int size);
 
@@ -53,6 +51,5 @@
 
         signals:
-            void dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > &data);
-            void dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > &data);
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
             void endOfMedia(int remainingSamples);
 
@@ -60,5 +57,4 @@
             void convertAndEmit(const QVector<float> &buffer);
 
-            Phonon::Experimental::AudioDataOutput::Format m_format;
             int m_dataSize;
             QVector<float> m_pendingData;
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/audionode.h phonon-4.3.0/phonon/tests/fakebackend/audionode.h
--- phonon-4.3.0/phonon/tests/fakebackend/audionode.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/audionode.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/audiooutput.cpp phonon-4.3.0/phonon/tests/fakebackend/audiooutput.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/audiooutput.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/audiooutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/audiooutput.h phonon-4.3.0/phonon/tests/fakebackend/audiooutput.h
--- phonon-4.3.0/phonon/tests/fakebackend/audiooutput.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/audiooutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/avcapture.cpp phonon-4.3.0/phonon/tests/fakebackend/avcapture.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/avcapture.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/avcapture.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/avcapture.h phonon-4.3.0/phonon/tests/fakebackend/avcapture.h
--- phonon-4.3.0/phonon/tests/fakebackend/avcapture.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/avcapture.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/backend.cpp phonon-4.3.0/phonon/tests/fakebackend/backend.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/backend.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/backend.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/backend.h phonon-4.3.0/phonon/tests/fakebackend/backend.h
--- phonon-4.3.0/phonon/tests/fakebackend/backend.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/backend.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/bytestream.cpp phonon-4.3.0/phonon/tests/fakebackend/bytestream.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/bytestream.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/bytestream.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/bytestream.h phonon-4.3.0/phonon/tests/fakebackend/bytestream.h
--- phonon-4.3.0/phonon/tests/fakebackend/bytestream.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/bytestream.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.cpp phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.h phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.h
--- phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/delayaudioeffect.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/effect.cpp phonon-4.3.0/phonon/tests/fakebackend/effect.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/effect.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/effect.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/effect.h phonon-4.3.0/phonon/tests/fakebackend/effect.h
--- phonon-4.3.0/phonon/tests/fakebackend/effect.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/effect.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/effectinterface.h phonon-4.3.0/phonon/tests/fakebackend/effectinterface.h
--- phonon-4.3.0/phonon/tests/fakebackend/effectinterface.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/effectinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/fake.desktop phonon-4.3.0/phonon/tests/fakebackend/fake.desktop
--- phonon-4.3.0/phonon/tests/fakebackend/fake.desktop	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/fake.desktop	2010-02-04 04:25:54.000000000 -0700
@@ -9,15 +9,33 @@
 InitialPreference=1
 Name=Fake
+Name[bg]=Фалшиво
+Name[ca]=Fake
+Name[ca@valencia]=Fake
+Name[cs]=Falešný
+Name[da]=Fake
+Name[de]=Fake
 Name[el]=Εικονικό
+Name[en_GB]=Fake
+Name[eo]=Falsa
 Name[es]=Imitación
 Name[et]=Liba
+Name[eu]=Itxura egin
+Name[fi]=Jäljitelmä
 Name[fr]=Simulation
 Name[ga]=Bréag
 Name[gl]=Falso
 Name[hsb]=Wudawany
+Name[hu]=Nem igazi
+Name[id]=Fake
+Name[is]=Tilbúningur
 Name[it]=Finto
+Name[ja]=Fake
 Name[ko]=가짜
+Name[ku]=Lêp
+Name[lt]=Netikras
 Name[lv]=Neīsts
+Name[nb]=Falsk
 Name[nds]=Namaakt
+Name[nl]=Fake
 Name[nn]=Falsk
 Name[pa]=ਫ਼ਰਜ਼ੀ
@@ -25,7 +43,11 @@
 Name[pt]=Falso
 Name[pt_BR]=Falso
+Name[ru]=Тестовый
+Name[se]=Mahkáš
 Name[sk]=Imitovať
 Name[sl]=Lažna
 Name[sr]=Лажна
+Name[sr@ijekavian]=Лажна
+Name[sr@ijekavianlatin]=Lažna
 Name[sr@latin]=Lažna
 Name[sv]=Testexempel
@@ -34,21 +56,33 @@
 Name[x-test]=xxFakexx
 Name[zh_CN]=虚假
+Name[zh_TW]=Fake
 Comment=Testing Backend
 Comment[bg]=Тестване
 Comment[ca]=Dorsal de proves
+Comment[ca@valencia]=Dorsal de proves
 Comment[cs]=Testovací backend
 Comment[da]=Test-backend
 Comment[de]=Treiber für Testzwecke
 Comment[el]=Δοκιμαστικό σύστημα υποστήριξης
+Comment[en_GB]=Testing Backend
+Comment[eo]=Interno por testado
 Comment[es]=Motor de pruebas
 Comment[et]=Testtaustaprogramm
+Comment[eu]=Frogatarako backend
+Comment[fi]=Testataan taustaohjelmaa
 Comment[fr]=Système de gestion de test
 Comment[ga]=Inneall Tástála
 Comment[gl]=Infraestrutura de probas
 Comment[hsb]=Testowanje backenda
+Comment[hu]=Tesztmodul
+Comment[id]=Mencoba Backend
+Comment[is]=Prófunarbakendi
 Comment[it]=Motore di test
 Comment[ja]=テスト用バックエンド
 Comment[ko]=테스트 백엔드 
+Comment[ku]=Ceribandina Binesazê
+Comment[lt]=Bandomoji galinė sąsaja
 Comment[lv]=Testēšanas aizmugure
+Comment[nb]=Testmotor
 Comment[nds]=Utprobeer-Hülpprogramm
 Comment[nl]=Testbackend
@@ -58,7 +92,11 @@
 Comment[pt]=Infra-Estrutura de Testes
 Comment[pt_BR]=Testando infraestrutura
+Comment[ru]=Тестовый механизм
+Comment[se]=Geahččalanduogášmohtor
 Comment[sk]=Testujem podsystém
 Comment[sl]=Hrbtenica za preizkušanje
 Comment[sr]=Пробна позадина
+Comment[sr@ijekavian]=Пробна позадина
+Comment[sr@ijekavianlatin]=Probna pozadina
 Comment[sr@latin]=Probna pozadina
 Comment[sv]=Testgränssnitt
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/mediaobject.cpp phonon-4.3.0/phonon/tests/fakebackend/mediaobject.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/mediaobject.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/mediaobject.cpp	2009-08-08 08:35:02.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -255,4 +255,5 @@
     switch (m_source.type()) {
     case MediaSource::Invalid:
+    case MediaSource::Empty:
         return;
     case MediaSource::Disc:
@@ -275,4 +276,5 @@
     metaData.insert("ARTIST", "Matthias Kretz");
     emit metaDataChanged(metaData);
+    emit currentSourceChanged(m_source);
     QTimer::singleShot(50, this, SLOT(loadingComplete()));
 }
@@ -392,5 +394,5 @@
     {
         emit aboutToFinish();
-        if (m_nextSource.type() == MediaSource::Invalid) {
+        if (m_nextSource.type() == MediaSource::Empty || m_nextSource.type() == MediaSource::Invalid) {
             stop();
             emit finished();
@@ -400,4 +402,5 @@
             m_nextSource = MediaSource();
             switch (m_source.type()) {
+            case MediaSource::Empty:
             case MediaSource::Invalid:
                 abort();
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/mediaobject.h phonon-4.3.0/phonon/tests/fakebackend/mediaobject.h
--- phonon-4.3.0/phonon/tests/fakebackend/mediaobject.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/mediaobject.h	2009-08-08 08:35:02.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -114,4 +114,6 @@
             void angleChanged(int);
             void availableAnglesChanged(int);
+            void availableAudioChannelsChanged();
+            void availableSubtitlesChanged();
 
             void finished();
@@ -119,4 +121,5 @@
             void aboutToFinish();
             void totalTimeChanged(qint64 length);
+            void currentSourceChanged(const MediaSource &);
 
         protected:
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.cpp phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.h phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.h
--- phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/mediaqueue.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/stream.cpp phonon-4.3.0/phonon/tests/fakebackend/stream.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/stream.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/stream.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/stream.h phonon-4.3.0/phonon/tests/fakebackend/stream.h
--- phonon-4.3.0/phonon/tests/fakebackend/stream.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/stream.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.cpp phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.h phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.h
--- phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/videodataoutput.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/videonode.h phonon-4.3.0/phonon/tests/fakebackend/videonode.h
--- phonon-4.3.0/phonon/tests/fakebackend/videonode.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/videonode.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/videowidget.cpp phonon-4.3.0/phonon/tests/fakebackend/videowidget.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/videowidget.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/videowidget.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/videowidget.h phonon-4.3.0/phonon/tests/fakebackend/videowidget.h
--- phonon-4.3.0/phonon/tests/fakebackend/videowidget.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/videowidget.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/visualization.cpp phonon-4.3.0/phonon/tests/fakebackend/visualization.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/visualization.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/visualization.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/visualization.h phonon-4.3.0/phonon/tests/fakebackend/visualization.h
--- phonon-4.3.0/phonon/tests/fakebackend/visualization.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/visualization.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.cpp phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.cpp
--- phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.h phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.h
--- phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/fakebackend/volumefadereffect.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/loadfakebackend.h phonon-4.3.0/phonon/tests/loadfakebackend.h
--- phonon-4.3.0/phonon/tests/loadfakebackend.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/loadfakebackend.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/lockfreequeuetest2.cpp phonon-4.3.0/phonon/tests/lockfreequeuetest2.cpp
--- phonon-4.3.0/phonon/tests/lockfreequeuetest2.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/lockfreequeuetest2.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/lockfreequeuetest.cpp phonon-4.3.0/phonon/tests/lockfreequeuetest.cpp
--- phonon-4.3.0/phonon/tests/lockfreequeuetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/lockfreequeuetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediacontrols.cpp phonon-4.3.0/phonon/tests/mediacontrols.cpp
--- phonon-4.3.0/phonon/tests/mediacontrols.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediacontrols.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediacontrols.h phonon-4.3.0/phonon/tests/mediacontrols.h
--- phonon-4.3.0/phonon/tests/mediacontrols.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediacontrols.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediacontrols_p.h phonon-4.3.0/phonon/tests/mediacontrols_p.h
--- phonon-4.3.0/phonon/tests/mediacontrols_p.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediacontrols_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediaobjecttest.cpp phonon-4.3.0/phonon/tests/mediaobjecttest.cpp
--- phonon-4.3.0/phonon/tests/mediaobjecttest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediaobjecttest.cpp	2009-08-08 05:07:14.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
@@ -273,5 +273,5 @@
     QSignalSpy totalTimeChangedSignalSpy(m_media, SIGNAL(totalTimeChanged(qint64)));
     QVERIFY(m_media->queue().isEmpty());
-    QCOMPARE(m_media->currentSource().type(), MediaSource::Invalid);
+    QCOMPARE(m_media->currentSource().type(), MediaSource::Empty);
     QCOMPARE(m_media->state(), Phonon::LoadingState);
     QCOMPARE(m_stateChangedSignalSpy->count(), 0);
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediaplayer.cpp phonon-4.3.0/phonon/tests/mediaplayer.cpp
--- phonon-4.3.0/phonon/tests/mediaplayer.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediaplayer.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/mediasourcetest.cpp phonon-4.3.0/phonon/tests/mediasourcetest.cpp
--- phonon-4.3.0/phonon/tests/mediasourcetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/mediasourcetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/methodtest.cpp phonon-4.3.0/phonon/tests/methodtest.cpp
--- phonon-4.3.0/phonon/tests/methodtest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/methodtest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     the License or (at your option) version 3 or any later version
     accepted by the membership of KDE e.V. (or its successor approved
-    by the membership of KDE e.V.), Trolltech ASA (or its successors, 
+    by the membership of KDE e.V.), Nokia Corporation (or its successors, 
     if any) and the KDE Free Qt Foundation, which shall act as a proxy 
     defined in Section 14 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/qtesthelper.h phonon-4.3.0/phonon/tests/qtesthelper.h
--- phonon-4.3.0/phonon/tests/qtesthelper.h	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/qtesthelper.h	2009-08-12 12:47:56.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -82,4 +82,6 @@
         case QVariant::Font:
             return qstrdup("QVariant::Font");
+        case QVariant::Hash:
+            return qstrdup("QVariant::Hash");
         case QVariant::Icon:
             return qstrdup("QVariant::Icon");
diff -r -U2 -N phonon-4.3.0/phonon/tests/seekslidertest.cpp phonon-4.3.0/phonon/tests/seekslidertest.cpp
--- phonon-4.3.0/phonon/tests/seekslidertest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/seekslidertest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/streameventqueuetest.cpp phonon-4.3.0/phonon/tests/streameventqueuetest.cpp
--- phonon-4.3.0/phonon/tests/streameventqueuetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/streameventqueuetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/videocapturedevicetest.cpp phonon-4.3.0/phonon/tests/videocapturedevicetest.cpp
--- phonon-4.3.0/phonon/tests/videocapturedevicetest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/videocapturedevicetest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/tests/volumeslidertest.cpp phonon-4.3.0/phonon/tests/volumeslidertest.cpp
--- phonon-4.3.0/phonon/tests/volumeslidertest.cpp	2008-11-24 10:11:57.000000000 -0700
+++ phonon-4.3.0/phonon/tests/volumeslidertest.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/videoplayer.cpp phonon-4.3.0/phonon/videoplayer.cpp
--- phonon-4.3.0/phonon/videoplayer.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/phonon/videoplayer.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/videoplayer.h phonon-4.3.0/phonon/videoplayer.h
--- phonon-4.3.0/phonon/videoplayer.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/videoplayer.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/videowidget.cpp phonon-4.3.0/phonon/videowidget.cpp
--- phonon-4.3.0/phonon/videowidget.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/videowidget.cpp	2009-08-20 06:39:02.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA
+    successor approved by the membership of KDE e.V.), Nokia Corporation
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -29,6 +29,7 @@
 
 #include <QtGui/QAction>
-
-#define PHONON_INTERFACENAME VideoWidgetInterface
+#define IFACES4 VideoWidgetInterface44
+#define IFACES0 VideoWidgetInterface, IFACES4
+#define PHONON_INTERFACENAME IFACES0
 
 QT_BEGIN_NAMESPACE
@@ -49,4 +50,6 @@
 }
 
+
+
 VideoWidget::VideoWidget(VideoWidgetPrivate &dd, QWidget *parent)
     : QWidget(parent),
@@ -99,4 +102,13 @@
 PHONON_INTERFACE_SETTER(setSaturation, saturation, qreal)
 
+
+QImage VideoWidget::snapshot() const {
+    K_D(const VideoWidget);
+    ConstIface<IFACES4> iface(d);
+    if(iface) return iface->snapshot();
+    return QImage(); // TODO not implemented in VideoInterface
+}
+
+
 void VideoWidget::setFullScreen(bool newFullScreen)
 {
diff -r -U2 -N phonon-4.3.0/phonon/videowidget.h phonon-4.3.0/phonon/videowidget.h
--- phonon-4.3.0/phonon/videowidget.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/videowidget.h	2009-04-22 08:48:59.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -173,4 +173,5 @@
             qreal hue() const;
             qreal saturation() const;
+            QImage snapshot() const;
 
             //TODO: bar colors property
diff -r -U2 -N phonon-4.3.0/phonon/videowidgetinterface.h phonon-4.3.0/phonon/videowidgetinterface.h
--- phonon-4.3.0/phonon/videowidgetinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/videowidgetinterface.h	2009-08-20 06:39:02.000000000 -0700
@@ -1,4 +1,4 @@
 /*  This file is part of the KDE project
-    Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
 
     This library is free software; you can redistribute it and/or
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -54,6 +54,19 @@
 //X        virtual bool createOverlay(QWidget *widget, int type) = 0;
 };
+
+class VideoWidgetInterface44 : public VideoWidgetInterface
+{
+    public:
+        virtual QImage snapshot() const = 0;
+};
 }
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+namespace Phonon { typedef VideoWidgetInterface44 VideoWidgetInterfaceLatest; }
+#else
+namespace Phonon { typedef VideoWidgetInterface VideoWidgetInterfaceLatest; }
+#endif
+
+Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface44, "VideoWidgetInterface44.phonon.kde.org")
 Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface, "VideoWidgetInterface3.phonon.kde.org")
 
diff -r -U2 -N phonon-4.3.0/phonon/videowidget_p.h phonon-4.3.0/phonon/videowidget_p.h
--- phonon-4.3.0/phonon/videowidget_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/videowidget_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumefadereffect.cpp phonon-4.3.0/phonon/volumefadereffect.cpp
--- phonon-4.3.0/phonon/volumefadereffect.cpp	2009-01-22 01:20:44.000000000 -0700
+++ phonon-4.3.0/phonon/volumefadereffect.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumefadereffect.h phonon-4.3.0/phonon/volumefadereffect.h
--- phonon-4.3.0/phonon/volumefadereffect.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumefadereffect.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumefadereffect_p.h phonon-4.3.0/phonon/volumefadereffect_p.h
--- phonon-4.3.0/phonon/volumefadereffect_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumefadereffect_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumefaderinterface.h phonon-4.3.0/phonon/volumefaderinterface.h
--- phonon-4.3.0/phonon/volumefaderinterface.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumefaderinterface.h	2009-02-26 14:33:54.000000000 -0700
@@ -1,4 +1,4 @@
 /*  This file is part of the KDE project
-    Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies). <thierry.bastian@trolltech.com>
 
     This library is free software; you can redistribute it and/or
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumeslider.cpp phonon-4.3.0/phonon/volumeslider.cpp
--- phonon-4.3.0/phonon/volumeslider.cpp	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumeslider.cpp	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumeslider.h phonon-4.3.0/phonon/volumeslider.h
--- phonon-4.3.0/phonon/volumeslider.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumeslider.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/phonon/volumeslider_p.h phonon-4.3.0/phonon/volumeslider_p.h
--- phonon-4.3.0/phonon/volumeslider_p.h	2008-11-24 10:12:00.000000000 -0700
+++ phonon-4.3.0/phonon/volumeslider_p.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
@@ -25,6 +25,6 @@
 
 #include "volumeslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
@@ -84,5 +84,5 @@
     private:
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QToolButton muteButton;
         QIcon volumeIcon;
diff -r -U2 -N phonon-4.3.0/qt7/audioconnection.cpp phonon-4.3.0/qt7/audioconnection.cpp
--- phonon-4.3.0/qt7/audioconnection.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audioconnection.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,152 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audioconnection.h"
-#include "medianode.h"
-#include "audionode.h"
-#include "audiograph.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-    AudioConnection::AudioConnection()
-        :   m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
-            m_sink(0), m_sinkAudioNode(0), m_sinkInputBus(0),
-            m_sourceChannelLayout(0), m_sinkChannelLayout(0),
-            m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
-    {}
-
-    AudioConnection::AudioConnection(MediaNode *source, int output, MediaNode *sink, int input)
-        : m_source(source), m_sourceAudioNode(source->m_audioNode), m_sourceOutputBus(output),
-        m_sink(sink), m_sinkAudioNode(sink->m_audioNode), m_sinkInputBus(input),
-        m_sourceChannelLayout(0), m_sinkChannelLayout(0),
-        m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
-    {}
-
-    AudioConnection::AudioConnection(MediaNode *sink)
-        : m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
-        m_sink(sink), m_sinkAudioNode(sink->m_audioNode), m_sinkInputBus(0),
-        m_sourceChannelLayout(0), m_sinkChannelLayout(0), m_connected(false)
-    {}
-
-    AudioConnection::AudioConnection(AudioNode *source, int output, AudioNode *sink, int input)
-        : m_source(0), m_sourceAudioNode(source), m_sourceOutputBus(output),
-        m_sink(0), m_sinkAudioNode(sink), m_sinkInputBus(input),
-        m_sourceChannelLayout(0), m_sinkChannelLayout(0),
-        m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
-    {}
-
-    AudioConnection::AudioConnection(AudioNode *sink)
-        : m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
-        m_sink(0), m_sinkAudioNode(sink), m_sinkInputBus(0),
-        m_sourceChannelLayout(0), m_sinkChannelLayout(0), m_connected(false)
-    {}
-
-    AudioConnection::~AudioConnection()
-    {
-        freeMemoryAllocations();
-    }
-
-    void AudioConnection::freeMemoryAllocations()
-    {
-        if (m_sinkChannelLayout && m_sourceChannelLayout != m_sinkChannelLayout)
-            free(m_sinkChannelLayout);
-        if (m_sourceChannelLayout)
-            free(m_sourceChannelLayout);
-        m_sinkChannelLayout = 0;
-        m_sourceChannelLayout = 0;
-    }
-
-    bool AudioConnection::updateStreamSpecification()
-    {
-        m_hasSourceSpecification = false;
-        m_hasSinkSpecification = false;
-        freeMemoryAllocations();
-
-        bool updateOk;
-        if (m_sourceAudioNode){
-            updateOk = m_sourceAudioNode->fillInStreamSpecification(this, AudioNode::Source);
-            if (!updateOk)
-                return false;
-            updateOk = m_sourceAudioNode->setStreamSpecification(this, AudioNode::Source);
-            if (!updateOk)
-                return false;
-        }
-        updateOk = m_sinkAudioNode->fillInStreamSpecification(this, AudioNode::Sink);
-        if (!updateOk)
-            return false;
-        updateOk = m_sinkAudioNode->setStreamSpecification(this, AudioNode::Sink);
-        if (!updateOk)
-            return false;
-        return true;
-    }
-
-    bool AudioConnection::connect(AudioGraph *graph)
-    {
-        if (m_connected || !m_sourceAudioNode)
-            return true;
-
-        DEBUG_AUDIO_GRAPH("Connection" << int(this) << "connect"
-        << int(m_sourceAudioNode) << m_sourceOutputBus << "->"
-        << int(m_sinkAudioNode) << m_sinkInputBus)
-
-        AUNode sourceOut = m_sourceAudioNode->getOutputAUNode();
-        AUNode sinkIn = m_sinkAudioNode->getInputAUNode();
-        OSStatus err = AUGraphConnectNodeInput(graph->audioGraphRef(), sourceOut, m_sourceOutputBus, sinkIn, m_sinkInputBus);
-        m_connected = (err == noErr) ? true : false;
-        return m_connected;
-    }
-
-    bool AudioConnection::disconnect(AudioGraph *graph)
-    {
-        if (!m_connected || !m_sourceAudioNode)
-            return true;
-
-        DEBUG_AUDIO_GRAPH("Connection" << int(this) << "disconnect"
-        << int(m_sourceAudioNode) << m_sourceOutputBus << "->"
-        << int(m_sinkAudioNode) << m_sinkInputBus)
-
-        AUNode sinkIn = m_sinkAudioNode->getInputAUNode();
-	    AUGraphDisconnectNodeInput(graph->audioGraphRef(), sinkIn, m_sinkInputBus);
-        m_connected = false;
-        return true;
-    }
-
-    void AudioConnection::invalidate()
-    {
-        m_connected = false;
-    }
-
-    bool AudioConnection::isBetween(MediaNode *source, MediaNode *sink){
-        return (source == m_source) && (sink == m_sink);
-    }
-
-    bool AudioConnection::isValid(){
-        return (m_sourceAudioNode != 0);
-    }
-
-    bool AudioConnection::isSinkOnly(){
-        return (m_sourceAudioNode == 0) && (m_sinkAudioNode != 0);
-    }
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audioconnection.h phonon-4.3.0/qt7/audioconnection.h
--- phonon-4.3.0/qt7/audioconnection.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audioconnection.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_AudioConnection_H
 
-#include <QObject>
+#include <QtCore/QObject>
 #include "backendheader.h"
 
diff -r -U2 -N phonon-4.3.0/qt7/audioconnection.mm phonon-4.3.0/qt7/audioconnection.mm
--- phonon-4.3.0/qt7/audioconnection.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audioconnection.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,152 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audioconnection.h"
+#include "medianode.h"
+#include "audionode.h"
+#include "audiograph.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+    AudioConnection::AudioConnection()
+        :   m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
+            m_sink(0), m_sinkAudioNode(0), m_sinkInputBus(0),
+            m_sourceChannelLayout(0), m_sinkChannelLayout(0),
+            m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
+    {}
+
+    AudioConnection::AudioConnection(MediaNode *source, int output, MediaNode *sink, int input)
+        : m_source(source), m_sourceAudioNode(source->m_audioNode), m_sourceOutputBus(output),
+        m_sink(sink), m_sinkAudioNode(sink->m_audioNode), m_sinkInputBus(input),
+        m_sourceChannelLayout(0), m_sinkChannelLayout(0),
+        m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
+    {}
+
+    AudioConnection::AudioConnection(MediaNode *sink)
+        : m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
+        m_sink(sink), m_sinkAudioNode(sink->m_audioNode), m_sinkInputBus(0),
+        m_sourceChannelLayout(0), m_sinkChannelLayout(0), m_connected(false)
+    {}
+
+    AudioConnection::AudioConnection(AudioNode *source, int output, AudioNode *sink, int input)
+        : m_source(0), m_sourceAudioNode(source), m_sourceOutputBus(output),
+        m_sink(0), m_sinkAudioNode(sink), m_sinkInputBus(input),
+        m_sourceChannelLayout(0), m_sinkChannelLayout(0),
+        m_hasSourceSpecification(false), m_hasSinkSpecification(false), m_connected(false)
+    {}
+
+    AudioConnection::AudioConnection(AudioNode *sink)
+        : m_source(0), m_sourceAudioNode(0), m_sourceOutputBus(0),
+        m_sink(0), m_sinkAudioNode(sink), m_sinkInputBus(0),
+        m_sourceChannelLayout(0), m_sinkChannelLayout(0), m_connected(false)
+    {}
+
+    AudioConnection::~AudioConnection()
+    {
+        freeMemoryAllocations();
+    }
+
+    void AudioConnection::freeMemoryAllocations()
+    {
+        if (m_sinkChannelLayout && m_sourceChannelLayout != m_sinkChannelLayout)
+            free(m_sinkChannelLayout);
+        if (m_sourceChannelLayout)
+            free(m_sourceChannelLayout);
+        m_sinkChannelLayout = 0;
+        m_sourceChannelLayout = 0;
+    }
+
+    bool AudioConnection::updateStreamSpecification()
+    {
+        m_hasSourceSpecification = false;
+        m_hasSinkSpecification = false;
+        freeMemoryAllocations();
+
+        bool updateOk;
+        if (m_sourceAudioNode){
+            updateOk = m_sourceAudioNode->fillInStreamSpecification(this, AudioNode::Source);
+            if (!updateOk)
+                return false;
+            updateOk = m_sourceAudioNode->setStreamSpecification(this, AudioNode::Source);
+            if (!updateOk)
+                return false;
+        }
+        updateOk = m_sinkAudioNode->fillInStreamSpecification(this, AudioNode::Sink);
+        if (!updateOk)
+            return false;
+        updateOk = m_sinkAudioNode->setStreamSpecification(this, AudioNode::Sink);
+        if (!updateOk)
+            return false;
+        return true;
+    }
+
+    bool AudioConnection::connect(AudioGraph *graph)
+    {
+        if (m_connected || !m_sourceAudioNode)
+            return true;
+
+        DEBUG_AUDIO_GRAPH("Connection" << int(this) << "connect"
+        << int(m_sourceAudioNode) << m_sourceOutputBus << "->"
+        << int(m_sinkAudioNode) << m_sinkInputBus)
+
+        AUNode sourceOut = m_sourceAudioNode->getOutputAUNode();
+        AUNode sinkIn = m_sinkAudioNode->getInputAUNode();
+        OSStatus err = AUGraphConnectNodeInput(graph->audioGraphRef(), sourceOut, m_sourceOutputBus, sinkIn, m_sinkInputBus);
+        m_connected = (err == noErr) ? true : false;
+        return m_connected;
+    }
+
+    bool AudioConnection::disconnect(AudioGraph *graph)
+    {
+        if (!m_connected || !m_sourceAudioNode)
+            return true;
+
+        DEBUG_AUDIO_GRAPH("Connection" << int(this) << "disconnect"
+        << int(m_sourceAudioNode) << m_sourceOutputBus << "->"
+        << int(m_sinkAudioNode) << m_sinkInputBus)
+
+        AUNode sinkIn = m_sinkAudioNode->getInputAUNode();
+	    AUGraphDisconnectNodeInput(graph->audioGraphRef(), sinkIn, m_sinkInputBus);
+        m_connected = false;
+        return true;
+    }
+
+    void AudioConnection::invalidate()
+    {
+        m_connected = false;
+    }
+
+    bool AudioConnection::isBetween(MediaNode *source, MediaNode *sink){
+        return (source == m_source) && (sink == m_sink);
+    }
+
+    bool AudioConnection::isValid(){
+        return (m_sourceAudioNode != 0);
+    }
+
+    bool AudioConnection::isSinkOnly(){
+        return (m_sourceAudioNode == 0) && (m_sinkAudioNode != 0);
+    }
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiodevice.cpp phonon-4.3.0/qt7/audiodevice.cpp
--- phonon-4.3.0/qt7/audiodevice.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiodevice.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,178 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiodevice.h"
-#include "audiograph.h"
-#include <QtCore/QVector>
-#include <private/qcore_mac_p.h>
-#include "backendheader.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-QList<AudioDeviceID> AudioDevice::devices(Scope scope)
-{
-    QList<AudioDeviceID> devices;
-
-    // Insert the default device explicit
-    if (AudioDeviceID defdev = defaultDevice(scope))
-        devices << defdev;
-
-    // How many input/output devices are awailable:
-    UInt32 deviceCount = 0;
-	OSStatus err = AudioHardwareGetPropertyInfo(kAudioHardwarePropertyDevices, &deviceCount, 0);
-    BACKEND_ASSERT3(err == noErr, "Could not get number of audio devices awailable.", FATAL_ERROR, devices)
-
-    // Get list of all devices:
-    AudioDeviceID deviceArray[deviceCount];
-    err = AudioHardwareGetProperty(kAudioHardwarePropertyDevices, &deviceCount, &deviceArray);
-    BACKEND_ASSERT3(err == noErr, "Could not get audio devices list.", FATAL_ERROR, devices)
-
-    for (uint i=0; i<deviceCount; i++){
-        if (!devices.contains(deviceArray[i])){
-            // Check if the current device is input or output:
-            UInt32 size;
-	        err = AudioDeviceGetPropertyInfo(deviceArray[i], 0, scope == In, kAudioDevicePropertyStreams, &size, 0);
-	        if (err == noErr && size > 0)
-                devices << deviceArray[i];
-        }
-    }
-    return devices;
-}
-
-AudioDeviceID AudioDevice::defaultSystemDevice(Scope scope)
-{
-    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, 0)
-    AudioDeviceID deviceID = 0;
-    UInt32 size = sizeof(deviceID);
-    OSStatus err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultSystemOutputDevice, &size, &deviceID);
-    BACKEND_ASSERT3(err == noErr, "Could not get default system audio device.", FATAL_ERROR, 0)
-    return deviceID;
-}
-
-AudioDeviceID AudioDevice::defaultDevice(Scope scope)
-{
-    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, 0)
-    AudioDeviceID deviceID = 0;
-    UInt32 size = sizeof(deviceID);
-    OSStatus err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice, &size, &deviceID);
-    BACKEND_ASSERT3(err == noErr, "Could not get default output audio device.", FATAL_ERROR, 0)
-    return deviceID;
-}
-
-AudioDeviceID AudioDevice::currentDevice(AudioUnit /*unit*/, Scope /*scope*/)
-{
-    return 0;
-#if 0
-
-kAudioDevicePropertyDeviceUID
-
-    if (!m_audioUnit)
-        return 0;
-    AudioDeviceID deviceID = 0;
-    UInt32 size = sizeof(deviceID);
-	OSStatus err = AudioUnitGetProperty(m_audioUnit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &size, &deviceID);
-    BACKEND_ASSERT3(err == noErr, "Could not get current audio device.", FATAL_ERROR, 0)
-    return deviceID;
-#endif
-}
-
-bool AudioDevice::setDevice(AudioUnit unit, AudioDeviceID deviceID, Scope scope)
-{
-    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, false)
-    UInt32 size = sizeof(deviceID);
-	OSStatus err = AudioUnitSetProperty(unit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &deviceID, size);
-    if (err != noErr)
-        return false;
-    return true;
-}
-
-QString AudioDevice::deviceSourceNameElseDeviceName(AudioDeviceID deviceID)
-{
-    QString name = deviceSourceName(deviceID);
-    if (name.isEmpty())
-        name = deviceName(deviceID);
-    return name;
-}
-
-QString AudioDevice::deviceNameElseDeviceSourceName(AudioDeviceID deviceID)
-{
-    QString name = deviceName(deviceID);
-    if (name.isEmpty())
-        name = deviceSourceName(deviceID);
-    return name;
-}
-
-QString AudioDevice::deviceName(AudioDeviceID deviceID)
-{
-    if (!deviceID)
-        return QString();
-    CFStringRef cfString = 0;
-    UInt32 size = sizeof(cfString);
-	OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDeviceNameCFString, &size, &cfString);
-	if (err != noErr)
-        return QString();
-    QString name = QCFString::toQString(cfString);
-    CFRelease(cfString);
-    return name;
-}
-
-QString AudioDevice::deviceSourceName(AudioDeviceID deviceID)
-{
-    if (!deviceID)
-        return QString();
-    UInt32 dataSource = 0;
-    UInt32 size = sizeof(dataSource);
-    OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDataSource, &size, &dataSource);
-	if (err != noErr)
-        return QString();
-
-    CFStringRef cfName = 0;
-    AudioValueTranslation translation = {&dataSource, sizeof(dataSource), &cfName, sizeof(cfName)};
-    size = sizeof(translation);
-    err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDataSourceNameForIDCFString, &size, &translation);
-	if (err != noErr){
-        CFRelease(cfName);
-        return QString();
-    }
-	QString name = QCFString::toQString(cfName);
-    CFRelease(cfName);
-    return name;
-}
-
-QString AudioDevice::deviceUID(AudioDeviceID deviceID)
-{
-    if (!deviceID)
-        return QString();
-        
-    CFStringRef cfString = 0;
-    UInt32 size = sizeof(cfString);
-	OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDeviceUID, &size, &cfString);
-	if (err != noErr)
-        return QString();
-    QString uid = QCFString::toQString(cfString);
-    CFRelease(cfString);
-    return uid;
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiodevice.h phonon-4.3.0/qt7/audiodevice.h
--- phonon-4.3.0/qt7/audiodevice.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiodevice.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -21,5 +21,5 @@
 #include <AudioToolbox/AudioToolbox.h>
 #include <AudioUnit/AudioUnit.h>
-#include <QtCore>
+#include <QtCore/QList>
 
 QT_BEGIN_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiodevice.mm phonon-4.3.0/qt7/audiodevice.mm
--- phonon-4.3.0/qt7/audiodevice.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiodevice.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,177 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiodevice.h"
+#include "audiograph.h"
+#include <QtCore/QVector>
+#include "backendheader.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+QList<AudioDeviceID> AudioDevice::devices(Scope scope)
+{
+    QList<AudioDeviceID> devices;
+
+    // Insert the default device explicit
+    if (AudioDeviceID defdev = defaultDevice(scope))
+        devices << defdev;
+
+    // How many input/output devices are awailable:
+    UInt32 deviceCount = 0;
+	OSStatus err = AudioHardwareGetPropertyInfo(kAudioHardwarePropertyDevices, &deviceCount, 0);
+    BACKEND_ASSERT3(err == noErr, "Could not get number of audio devices awailable.", FATAL_ERROR, devices)
+
+    // Get list of all devices:
+    AudioDeviceID deviceArray[deviceCount];
+    err = AudioHardwareGetProperty(kAudioHardwarePropertyDevices, &deviceCount, &deviceArray);
+    BACKEND_ASSERT3(err == noErr, "Could not get audio devices list.", FATAL_ERROR, devices)
+
+    for (uint i=0; i<deviceCount; i++){
+        if (!devices.contains(deviceArray[i])){
+            // Check if the current device is input or output:
+            UInt32 size;
+	        err = AudioDeviceGetPropertyInfo(deviceArray[i], 0, scope == In, kAudioDevicePropertyStreams, &size, 0);
+	        if (err == noErr && size > 0)
+                devices << deviceArray[i];
+        }
+    }
+    return devices;
+}
+
+AudioDeviceID AudioDevice::defaultSystemDevice(Scope scope)
+{
+    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, 0)
+    AudioDeviceID deviceID = 0;
+    UInt32 size = sizeof(deviceID);
+    OSStatus err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultSystemOutputDevice, &size, &deviceID);
+    BACKEND_ASSERT3(err == noErr, "Could not get default system audio device.", FATAL_ERROR, 0)
+    return deviceID;
+}
+
+AudioDeviceID AudioDevice::defaultDevice(Scope scope)
+{
+    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, 0)
+    AudioDeviceID deviceID = 0;
+    UInt32 size = sizeof(deviceID);
+    OSStatus err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice, &size, &deviceID);
+    BACKEND_ASSERT3(err == noErr, "Could not get default output audio device.", FATAL_ERROR, 0)
+    return deviceID;
+}
+
+AudioDeviceID AudioDevice::currentDevice(AudioUnit /*unit*/, Scope /*scope*/)
+{
+    return 0;
+#if 0
+
+kAudioDevicePropertyDeviceUID
+
+    if (!m_audioUnit)
+        return 0;
+    AudioDeviceID deviceID = 0;
+    UInt32 size = sizeof(deviceID);
+	OSStatus err = AudioUnitGetProperty(m_audioUnit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &size, &deviceID);
+    BACKEND_ASSERT3(err == noErr, "Could not get current audio device.", FATAL_ERROR, 0)
+    return deviceID;
+#endif
+}
+
+bool AudioDevice::setDevice(AudioUnit unit, AudioDeviceID deviceID, Scope scope)
+{
+    ARGUMENT_UNSUPPORTED(scope, In, NORMAL_ERROR, false)
+    UInt32 size = sizeof(deviceID);
+	OSStatus err = AudioUnitSetProperty(unit, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &deviceID, size);
+    if (err != noErr)
+        return false;
+    return true;
+}
+
+QString AudioDevice::deviceSourceNameElseDeviceName(AudioDeviceID deviceID)
+{
+    QString name = deviceSourceName(deviceID);
+    if (name.isEmpty())
+        name = deviceName(deviceID);
+    return name;
+}
+
+QString AudioDevice::deviceNameElseDeviceSourceName(AudioDeviceID deviceID)
+{
+    QString name = deviceName(deviceID);
+    if (name.isEmpty())
+        name = deviceSourceName(deviceID);
+    return name;
+}
+
+QString AudioDevice::deviceName(AudioDeviceID deviceID)
+{
+    if (!deviceID)
+        return QString();
+    CFStringRef cfString = 0;
+    UInt32 size = sizeof(cfString);
+	OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDeviceNameCFString, &size, &cfString);
+	if (err != noErr)
+        return QString();
+    QString name = PhononCFString::toQString(cfString);
+    CFRelease(cfString);
+    return name;
+}
+
+QString AudioDevice::deviceSourceName(AudioDeviceID deviceID)
+{
+    if (!deviceID)
+        return QString();
+    UInt32 dataSource = 0;
+    UInt32 size = sizeof(dataSource);
+    OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDataSource, &size, &dataSource);
+	if (err != noErr)
+        return QString();
+
+    CFStringRef cfName = 0;
+    AudioValueTranslation translation = {&dataSource, sizeof(dataSource), &cfName, sizeof(cfName)};
+    size = sizeof(translation);
+    err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDataSourceNameForIDCFString, &size, &translation);
+	if (err != noErr){
+        CFRelease(cfName);
+        return QString();
+    }
+	QString name = PhononCFString::toQString(cfName);
+    CFRelease(cfName);
+    return name;
+}
+
+QString AudioDevice::deviceUID(AudioDeviceID deviceID)
+{
+    if (!deviceID)
+        return QString();
+        
+    CFStringRef cfString = 0;
+    UInt32 size = sizeof(cfString);
+	OSStatus err = AudioDeviceGetProperty(deviceID, 0, 0, kAudioDevicePropertyDeviceUID, &size, &cfString);
+	if (err != noErr)
+        return QString();
+    QString uid = PhononCFString::toQString(cfString);
+    CFRelease(cfString);
+    return uid;
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audioeffects.cpp phonon-4.3.0/qt7/audioeffects.cpp
--- phonon-4.3.0/qt7/audioeffects.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audioeffects.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,256 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audioeffects.h"
-#include <QtCore>
-#include <private/qcore_mac_p.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioEffectAudioNode::AudioEffectAudioNode(int effectType)
-    : AudioNode(1, 1), m_effectType(effectType)
-{
-}
-
-ComponentDescription AudioEffectAudioNode::getAudioNodeDescription() const
-{
-	ComponentDescription d;
-	d.componentType = kAudioUnitType_Effect;
-	d.componentSubType = m_effectType;
-	d.componentManufacturer = kAudioUnitManufacturer_Apple;
-	d.componentFlags = 0;
-	d.componentFlagsMask = 0;
-    return d;
-}
-
-void AudioEffectAudioNode::initializeAudioUnit()
-{
-    if (!m_audioUnit)
-        return;
-    foreach(int id, m_alteredParameters.keys()){
-        Float32 value = m_alteredParameters.value(id);
-        ComponentResult res = AudioUnitSetParameter(m_audioUnit, id, kAudioUnitScope_Global, 0, value, 0);
-        BACKEND_ASSERT2(res == noErr, "Could not initialize audio effect.", NORMAL_ERROR)
-    }
-}
-
-QVariant AudioEffectAudioNode::parameterValue(const Phonon::EffectParameter &parameter) const
-{
-    if (m_audioUnit){
-        Float32 value = 0;
-        AudioUnitGetParameter(m_audioUnit, parameter.id(), kAudioUnitScope_Global, 0, &value);
-        return QVariant(value);
-    } else if (m_alteredParameters.contains(parameter.id())){
-        return QVariant(m_alteredParameters.value(parameter.id()));
-    } else {
-        // Use default value:
-        AudioUnit tmpAudioUnit;
-        ComponentDescription description = getAudioNodeDescription();
-        Component component = FindNextComponent(0, &description);
-        BACKEND_ASSERT3(component, "Could not get parameters of audio effect.", NORMAL_ERROR, QVariant())
-        OSErr err = OpenAComponent(component, &tmpAudioUnit);
-        BACKEND_ASSERT3(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR, QVariant())
-        AudioUnitParameterInfo info;
-        UInt32 size = sizeof(info);
-        ComponentResult res = AudioUnitGetProperty(tmpAudioUnit,
-            kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, parameter.id(), &info, &size);
-        BACKEND_ASSERT3(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR, QVariant())
-        return QVariant(info.defaultValue);
-    }
-}
-
-void AudioEffectAudioNode::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
-{
-    Float32 value = 0;
-    if (newValue.isValid()){
-        value = newValue.toDouble();
-        m_alteredParameters.insert(parameter.id(), value);
-    } else {
-        // Use default value:
-        m_alteredParameters.remove(parameter.id());
-        if (m_audioUnit){
-            AudioUnit tmpAudioUnit;
-            ComponentDescription description = getAudioNodeDescription();
-            Component component = FindNextComponent(0, &description);
-            BACKEND_ASSERT2(component, "Could not get parameters of audio effect.", NORMAL_ERROR)
-            OSErr err = OpenAComponent(component, &tmpAudioUnit);
-            BACKEND_ASSERT2(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR)
-            AudioUnitParameterInfo info;
-            UInt32 size = sizeof(info);
-            ComponentResult res = AudioUnitGetProperty(tmpAudioUnit,
-                kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, parameter.id(), &info, &size);
-            BACKEND_ASSERT2(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR)
-            value = info.defaultValue;
-        }
-    }
-
-    if (m_audioUnit){
-        ComponentResult res = AudioUnitSetParameter(m_audioUnit, parameter.id(), kAudioUnitScope_Global, 0, value, 0);
-        BACKEND_ASSERT2(res == noErr, "Could not set effect parameter value.", NORMAL_ERROR)
-    }
-}
-
-///////////////////////////////////////////////////////////////////////
-
-AudioEffect::AudioEffect(int effectType, QObject *parent)
-    : MediaNode(AudioSink | AudioSource, 0, parent)
-{
-    m_audioNode = new AudioEffectAudioNode(effectType);
-    setAudioNode(m_audioNode);
-}
-
-QList<Phonon::EffectParameter> AudioEffect::parameters() const
-{
-    QList<Phonon::EffectParameter> effectList;
-    // Create a temporary audio unit:
-    AudioUnit audioUnit;
-    ComponentDescription description = m_audioNode->getAudioNodeDescription();
-    Component component = FindNextComponent(0, &description);
-    BACKEND_ASSERT3(component, "Could not get parameters of audio effect.", NORMAL_ERROR, effectList)
-    OSErr err = OpenAComponent(component, &audioUnit);
-    BACKEND_ASSERT3(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR, effectList)
-
-    UInt32 size = 0;
-    // Get parameter count:
-    ComponentResult res = AudioUnitGetProperty(audioUnit, 
-        kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, 0, &size);
-    BACKEND_ASSERT3(res == noErr, "Could not get parameter count from audio effect.", NORMAL_ERROR, effectList)
-    int paramCount = size / sizeof(AudioUnitParameterID);
-
-    // Get parameters:
-    AudioUnitParameterID parameters[paramCount];
-    res = AudioUnitGetProperty(audioUnit, 
-        kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, &parameters, &size);
-    BACKEND_ASSERT3(res == noErr, "Could not get parameter list from audio effect.", NORMAL_ERROR, effectList)
-
-    for (int i=0; i<paramCount; ++i)
-        effectList << createParameter(audioUnit, parameters[i]);
-    
-    CloseComponent(audioUnit);
-    return effectList;
-}
-
-QString AudioEffect::name()
-{
-    ComponentDescription description = m_audioNode->getAudioNodeDescription();
-    Component component = FindNextComponent(0, &description);
-    BACKEND_ASSERT3(component, "Could not get audio effect name.", NORMAL_ERROR, QLatin1String("<unknown effect>"))
-
-    ComponentDescription cDesc;
-    Handle nameH = NewHandle(0);
-    GetComponentInfo(component, &cDesc, nameH, 0, 0); 
-    HLock(nameH);
-    char *namePtr = *nameH;
-    int len = *namePtr++;
-    namePtr[len] = 0;
-    QString qsName = QString::fromUtf8(namePtr);
-    DisposeHandle(nameH);
-    return qsName;
-}
-
-QString AudioEffect::description()
-{
-    ComponentDescription description = m_audioNode->getAudioNodeDescription();
-    Component component = FindNextComponent(0, &description);
-    BACKEND_ASSERT3(component, "Could not get audio effect description.", NORMAL_ERROR, QLatin1String("<unknown effect>"))
-
-    ComponentDescription cDesc;
-    Handle descH = NewHandle(0);
-    GetComponentInfo(component, &cDesc, 0, descH, 0); 
-    HLock(descH);
-    char *descPtr = *descH;
-    int len = *descPtr++;
-    descPtr[len] = 0;
-    QString qsDesc = QString::fromUtf8(descPtr);
-    DisposeHandle(descH);
-    return qsDesc;
-}
-
-QList<int> AudioEffect::effectList()
-{
-    QList<int> effects;
-
-	ComponentDescription d;
-	d.componentType = kAudioUnitType_Effect;
-	d.componentSubType = 0;
-	d.componentManufacturer = 0;
-	d.componentFlags = 0;
-	d.componentFlagsMask = 0;
-    Component component = FindNextComponent(0, &d);
-    
-    while (component) {
-        ComponentDescription cDesc;
-        GetComponentInfo(component, &cDesc, 0, 0, 0); 
-        effects << cDesc.componentSubType;
-        component = FindNextComponent(component, &d);
-    }
-    return effects;
-}
-
-Phonon::EffectParameter AudioEffect::createParameter(const AudioUnit &audioUnit, const AudioUnitParameterID &id) const
-{
-    AudioUnitParameterInfo info;
-    UInt32 size = sizeof(info);
-    ComponentResult res = AudioUnitGetProperty(audioUnit,
-        kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, id, &info, &size);
-    BACKEND_ASSERT3(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR, Phonon::EffectParameter())
-    
-    QString name = info.flags & kAudioUnitParameterFlag_HasCFNameString
-        ? QCFString::toQString(info.cfNameString) : QLatin1String("<unknown parameter>");
-        
-    Phonon::EffectParameter::Hint hint;
-    switch(info.unit){
-    case (kAudioUnitParameterUnit_Indexed):
-    case (kAudioUnitParameterUnit_Seconds):
-    case (kAudioUnitParameterUnit_SampleFrames):
-    case (kAudioUnitParameterUnit_Milliseconds):
-        hint = Phonon::EffectParameter::IntegerHint;
-        break;
-    case (kAudioUnitParameterUnit_Boolean):
-        hint = Phonon::EffectParameter::ToggledHint;
-        break;
-    default:
-        hint = Phonon::EffectParameter::LogarithmicHint;
-        break;
-    }
-    
-    QVariant def(info.defaultValue);    
-    QVariant min(info.minValue);
-    QVariant max(info.maxValue);
-    return Phonon::EffectParameter(id, name, hint, def, min, max, QVariantList(), name);
-}
-
-QVariant AudioEffect::parameterValue(const Phonon::EffectParameter &value) const
-{
-    return m_audioNode->parameterValue(value);
-}
-
-void AudioEffect::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
-{
-    m_audioNode->setParameterValue(parameter, newValue);
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_audioeffects.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audioeffects.h phonon-4.3.0/qt7/audioeffects.h
--- phonon-4.3.0/qt7/audioeffects.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audioeffects.h	2009-03-03 08:46:45.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,6 @@
 #define Phonon_QT7_AUDIOEFFECTS_H
 
-#include <QtCore>
+#include <QtCore/QVariant>
+#include <QtCore/QHash>
 #include <phonon/effectinterface.h>
 #include <phonon/effectparameter.h>
diff -r -U2 -N phonon-4.3.0/qt7/audioeffects.mm phonon-4.3.0/qt7/audioeffects.mm
--- phonon-4.3.0/qt7/audioeffects.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audioeffects.mm	2009-03-02 04:16:07.000000000 -0700
@@ -0,0 +1,254 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audioeffects.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioEffectAudioNode::AudioEffectAudioNode(int effectType)
+    : AudioNode(1, 1), m_effectType(effectType)
+{
+}
+
+ComponentDescription AudioEffectAudioNode::getAudioNodeDescription() const
+{
+	ComponentDescription d;
+	d.componentType = kAudioUnitType_Effect;
+	d.componentSubType = m_effectType;
+	d.componentManufacturer = kAudioUnitManufacturer_Apple;
+	d.componentFlags = 0;
+	d.componentFlagsMask = 0;
+    return d;
+}
+
+void AudioEffectAudioNode::initializeAudioUnit()
+{
+    if (!m_audioUnit)
+        return;
+    foreach(int id, m_alteredParameters.keys()){
+        Float32 value = m_alteredParameters.value(id);
+        ComponentResult res = AudioUnitSetParameter(m_audioUnit, id, kAudioUnitScope_Global, 0, value, 0);
+        BACKEND_ASSERT2(res == noErr, "Could not initialize audio effect.", NORMAL_ERROR)
+    }
+}
+
+QVariant AudioEffectAudioNode::parameterValue(const Phonon::EffectParameter &parameter) const
+{
+    if (m_audioUnit){
+        Float32 value = 0;
+        AudioUnitGetParameter(m_audioUnit, parameter.id(), kAudioUnitScope_Global, 0, &value);
+        return QVariant(value);
+    } else if (m_alteredParameters.contains(parameter.id())){
+        return QVariant(m_alteredParameters.value(parameter.id()));
+    } else {
+        // Use default value:
+        AudioUnit tmpAudioUnit;
+        ComponentDescription description = getAudioNodeDescription();
+        Component component = FindNextComponent(0, &description);
+        BACKEND_ASSERT3(component, "Could not get parameters of audio effect.", NORMAL_ERROR, QVariant())
+        OSErr err = OpenAComponent(component, &tmpAudioUnit);
+        BACKEND_ASSERT3(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR, QVariant())
+        AudioUnitParameterInfo info;
+        UInt32 size = sizeof(info);
+        ComponentResult res = AudioUnitGetProperty(tmpAudioUnit,
+            kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, parameter.id(), &info, &size);
+        BACKEND_ASSERT3(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR, QVariant())
+        return QVariant(info.defaultValue);
+    }
+}
+
+void AudioEffectAudioNode::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
+{
+    Float32 value = 0;
+    if (newValue.isValid()){
+        value = newValue.toDouble();
+        m_alteredParameters.insert(parameter.id(), value);
+    } else {
+        // Use default value:
+        m_alteredParameters.remove(parameter.id());
+        if (m_audioUnit){
+            AudioUnit tmpAudioUnit;
+            ComponentDescription description = getAudioNodeDescription();
+            Component component = FindNextComponent(0, &description);
+            BACKEND_ASSERT2(component, "Could not get parameters of audio effect.", NORMAL_ERROR)
+            OSErr err = OpenAComponent(component, &tmpAudioUnit);
+            BACKEND_ASSERT2(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR)
+            AudioUnitParameterInfo info;
+            UInt32 size = sizeof(info);
+            ComponentResult res = AudioUnitGetProperty(tmpAudioUnit,
+                kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, parameter.id(), &info, &size);
+            BACKEND_ASSERT2(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR)
+            value = info.defaultValue;
+        }
+    }
+
+    if (m_audioUnit){
+        ComponentResult res = AudioUnitSetParameter(m_audioUnit, parameter.id(), kAudioUnitScope_Global, 0, value, 0);
+        BACKEND_ASSERT2(res == noErr, "Could not set effect parameter value.", NORMAL_ERROR)
+    }
+}
+
+///////////////////////////////////////////////////////////////////////
+
+AudioEffect::AudioEffect(int effectType, QObject *parent)
+    : MediaNode(AudioSink | AudioSource, 0, parent)
+{
+    m_audioNode = new AudioEffectAudioNode(effectType);
+    setAudioNode(m_audioNode);
+}
+
+QList<Phonon::EffectParameter> AudioEffect::parameters() const
+{
+    QList<Phonon::EffectParameter> effectList;
+    // Create a temporary audio unit:
+    AudioUnit audioUnit;
+    ComponentDescription description = m_audioNode->getAudioNodeDescription();
+    Component component = FindNextComponent(0, &description);
+    BACKEND_ASSERT3(component, "Could not get parameters of audio effect.", NORMAL_ERROR, effectList)
+    OSErr err = OpenAComponent(component, &audioUnit);
+    BACKEND_ASSERT3(err == noErr, "Could not get parameters of audio effect.", NORMAL_ERROR, effectList)
+
+    UInt32 size = 0;
+    // Get parameter count:
+    ComponentResult res = AudioUnitGetProperty(audioUnit, 
+        kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, 0, &size);
+    BACKEND_ASSERT3(res == noErr, "Could not get parameter count from audio effect.", NORMAL_ERROR, effectList)
+    int paramCount = size / sizeof(AudioUnitParameterID);
+
+    // Get parameters:
+    AudioUnitParameterID parameters[paramCount];
+    res = AudioUnitGetProperty(audioUnit, 
+        kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, &parameters, &size);
+    BACKEND_ASSERT3(res == noErr, "Could not get parameter list from audio effect.", NORMAL_ERROR, effectList)
+
+    for (int i=0; i<paramCount; ++i)
+        effectList << createParameter(audioUnit, parameters[i]);
+    
+    CloseComponent(audioUnit);
+    return effectList;
+}
+
+QString AudioEffect::name()
+{
+    ComponentDescription description = m_audioNode->getAudioNodeDescription();
+    Component component = FindNextComponent(0, &description);
+    BACKEND_ASSERT3(component, "Could not get audio effect name.", NORMAL_ERROR, QLatin1String("<unknown effect>"))
+
+    ComponentDescription cDesc;
+    Handle nameH = NewHandle(0);
+    GetComponentInfo(component, &cDesc, nameH, 0, 0); 
+    HLock(nameH);
+    char *namePtr = *nameH;
+    int len = *namePtr++;
+    namePtr[len] = 0;
+    QString qsName = QString::fromUtf8(namePtr);
+    DisposeHandle(nameH);
+    return qsName;
+}
+
+QString AudioEffect::description()
+{
+    ComponentDescription description = m_audioNode->getAudioNodeDescription();
+    Component component = FindNextComponent(0, &description);
+    BACKEND_ASSERT3(component, "Could not get audio effect description.", NORMAL_ERROR, QLatin1String("<unknown effect>"))
+
+    ComponentDescription cDesc;
+    Handle descH = NewHandle(0);
+    GetComponentInfo(component, &cDesc, 0, descH, 0); 
+    HLock(descH);
+    char *descPtr = *descH;
+    int len = *descPtr++;
+    descPtr[len] = 0;
+    QString qsDesc = QString::fromUtf8(descPtr);
+    DisposeHandle(descH);
+    return qsDesc;
+}
+
+QList<int> AudioEffect::effectList()
+{
+    QList<int> effects;
+
+	ComponentDescription d;
+	d.componentType = kAudioUnitType_Effect;
+	d.componentSubType = 0;
+	d.componentManufacturer = 0;
+	d.componentFlags = 0;
+	d.componentFlagsMask = 0;
+    Component component = FindNextComponent(0, &d);
+    
+    while (component) {
+        ComponentDescription cDesc;
+        GetComponentInfo(component, &cDesc, 0, 0, 0); 
+        effects << cDesc.componentSubType;
+        component = FindNextComponent(component, &d);
+    }
+    return effects;
+}
+
+Phonon::EffectParameter AudioEffect::createParameter(const AudioUnit &audioUnit, const AudioUnitParameterID &id) const
+{
+    AudioUnitParameterInfo info;
+    UInt32 size = sizeof(info);
+    ComponentResult res = AudioUnitGetProperty(audioUnit,
+        kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, id, &info, &size);
+    BACKEND_ASSERT3(res == noErr, "Could not get parameter info from audio effect.", NORMAL_ERROR, Phonon::EffectParameter())
+    
+    QString name = info.flags & kAudioUnitParameterFlag_HasCFNameString
+        ? PhononCFString::toQString(info.cfNameString) : QLatin1String("<unknown parameter>");
+        
+    Phonon::EffectParameter::Hint hint;
+    switch(info.unit){
+    case (kAudioUnitParameterUnit_Indexed):
+    case (kAudioUnitParameterUnit_Seconds):
+    case (kAudioUnitParameterUnit_SampleFrames):
+    case (kAudioUnitParameterUnit_Milliseconds):
+        hint = Phonon::EffectParameter::IntegerHint;
+        break;
+    case (kAudioUnitParameterUnit_Boolean):
+        hint = Phonon::EffectParameter::ToggledHint;
+        break;
+    default:
+        hint = Phonon::EffectParameter::LogarithmicHint;
+        break;
+    }
+    
+    QVariant def(info.defaultValue);    
+    QVariant min(info.minValue);
+    QVariant max(info.maxValue);
+    return Phonon::EffectParameter(id, name, hint, def, min, max, QVariantList(), name);
+}
+
+QVariant AudioEffect::parameterValue(const Phonon::EffectParameter &value) const
+{
+    return m_audioNode->parameterValue(value);
+}
+
+void AudioEffect::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
+{
+    m_audioNode->setParameterValue(parameter, newValue);
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_audioeffects.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audiograph.cpp phonon-4.3.0/qt7/audiograph.cpp
--- phonon-4.3.0/qt7/audiograph.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiograph.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,320 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiograph.h"
-#include "quicktimeaudioplayer.h"
-#include "medianode.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioGraph::AudioGraph(MediaNode *root) : MediaNode(AudioGraphNode, 0, root), m_root(root)
-{
-    m_audioGraphRef = 0;
-    m_initialized = false;
-    m_startedLogically = false;
-    m_graphCannotPlay = false;
-    m_paused = false;
-}
-
-AudioGraph::~AudioGraph()
-{
-    deleteGraph();
-}
-
-void AudioGraph::startAllOverFromScratch()
-{
-    MediaNodeEvent event(MediaNodeEvent::AudioGraphAboutToBeDeleted, this);
-    m_root->notify(&event);
-    deleteGraph();
-}
-
-void AudioGraph::deleteGraph()
-{
-    if (m_audioGraphRef){
-    	AUGraphStop(m_audioGraphRef);
-	    AUGraphUninitialize(m_audioGraphRef);
-        AUGraphClose(m_audioGraphRef);
-        DisposeAUGraph(m_audioGraphRef);
-        m_initialized = false;
-        m_graphCannotPlay = false;
-        DEBUG_AUDIO_GRAPH("Graph ref in" << int(this) << "is deleted")
-    }
-}
-
-MediaNode *AudioGraph::root()
-{
-    return m_root;
-}
-
-AUGraph AudioGraph::audioGraphRef()
-{
-    return m_audioGraphRef;
-}
-
-void AudioGraph::setStatusCannotPlay()
-{
-    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "received 'cannot play' request")
-    if (!m_graphCannotPlay){
-        stop();
-        m_graphCannotPlay = true;
-        MediaNodeEvent e(MediaNodeEvent::AudioGraphCannotPlay, this);
-        m_root->notify(&e);
-    }
-}
-
-void AudioGraph::rebuildGraph()
-{
-    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "is rebuilding")
-    startAllOverFromScratch();
-    if (!openAndInit()){
-        setStatusCannotPlay();
-    } else { 
-        tryStartGraph();
-        m_graphCannotPlay = false;
-    }   
-}
-
-bool AudioGraph::graphCannotPlay()
-{
-    return m_graphCannotPlay;
-}
-
-void AudioGraph::updateStreamSpecifications()
-{
-    if (!m_initialized){
-        if (m_graphCannotPlay)
-            rebuildGraph();
-        return;
-    }
-
-    AudioConnection rootConnection(m_root);
-    bool updateOk = updateStreamSpecificationRecursive(&rootConnection);
-    if (!updateOk){
-        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not update stream specification. Rebuild.")
-        rebuildGraph();
-    }
-}
-
-bool AudioGraph::updateStreamSpecificationRecursive(AudioConnection *connection)
-{
-    bool updateOk = connection->updateStreamSpecification();
-    if (!updateOk)
-        return false;
-
-    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
-        if (!updateStreamSpecificationRecursive(connection->m_sink->m_audioSinkList[i]))
-            return false;
-    }
-    return true;
-}
-
-bool AudioGraph::openAndInit()
-{
-	OSStatus err;
-	err = NewAUGraph(&m_audioGraphRef);
-    BACKEND_ASSERT3(err == noErr, "Could not create audio graph.", NORMAL_ERROR, false)
-
-    MediaNodeEvent eventNew(MediaNodeEvent::NewAudioGraph, this);
-    m_root->notify(&eventNew);
-
-    AudioConnection rootConnection(m_root);
-    createAndConnectAuNodesRecursive(&rootConnection);
-	err = AUGraphOpen(m_audioGraphRef);
-    BACKEND_ASSERT3(err == noErr, "Could not create audio graph.", NORMAL_ERROR, false)
-
-    if (!createAudioUnitsRecursive(&rootConnection))
-        return false;
-
-	err = AUGraphInitialize(m_audioGraphRef);
-    BACKEND_ASSERT3(err == noErr, "Could not initialize audio graph.", NORMAL_ERROR, false)
-
-    m_initialized = true;
-    MediaNodeEvent eventInit(MediaNodeEvent::AudioGraphInitialized, this);
-    m_root->notify(&eventInit);
-    return true;
-}
-
-void AudioGraph::createAndConnectAuNodesRecursive(AudioConnection *connection)
-{
-    connection->m_sink->m_audioNode->createAndConnectAUNodes();
-    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
-        AudioConnection *c = connection->m_sink->m_audioSinkList[i];
-        createAndConnectAuNodesRecursive(c);
-        bool ok = c->connect(this);
-        BACKEND_ASSERT2(ok, "Could not connect an audio nodes pair in the audio graph.", NORMAL_ERROR)
-    }
-}
-
-bool AudioGraph::createAudioUnitsRecursive(AudioConnection *connection)
-{
-    connection->m_sink->m_audioNode->createAudioUnits();
-    bool ok = connection->updateStreamSpecification();
-    if (!ok)
-        return false;
-    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
-        if (!createAudioUnitsRecursive(connection->m_sink->m_audioSinkList[i]))
-            return false;
-    }
-    return true;
-}
-
-void AudioGraph::tryStartGraph()
-{
-    // The graph will only start if the background AUGraph
-    // is valid. Therefore we just try. If it fails, user
-    // actions like connect etc. migh make the graph valid
-    // at a later point.
-    if (m_startedLogically && !isRunning()){
-        OSStatus err = AUGraphStart(m_audioGraphRef);
-        if (err == noErr)
-            DEBUG_AUDIO_GRAPH("Graph" << int(this) << "started")
-        else
-            DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not start")
-    }
-}
-
-bool AudioGraph::isRunning()
-{
-    Boolean running = false;
-    AUGraphIsRunning(m_audioGraphRef, &running);
-    return running;
-}
-
-void AudioGraph::setPaused(bool pause)
-{
-    // This function should only make
-    // a difference if the graph is
-    // running before pausing.
-    if (pause){
-        if (isRunning()){
-            stop();
-            m_paused = true;
-        }
-    } else if (m_paused){
-        start();
-        m_paused = false;
-    }
-}
-
-void AudioGraph::connectLate(AudioConnection *connection)
-{
-    MediaNodeEvent event(MediaNodeEvent::NewAudioGraph, this);
-    connection->m_sink->notify(&event);
-
-    if (!m_initialized)
-        return;
-
-    DEBUG_AUDIO_GRAPH("Graph:" << int(this) << "create and connect audio sink after init:" << int(connection->m_sink->m_audioNode))
-    AudioConnection startConnection(connection->m_source);
-    createAndConnectAuNodesRecursive(&startConnection);
-    
-    if (!createAudioUnitsRecursive(&startConnection)){
-        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not update stream specification. Rebuild.")
-        rebuildGraph();
-    }  
-}
-
-void AudioGraph::disconnectLate(AudioConnection *connection)
-{
-    if (!m_initialized)
-        return;
-
-    DEBUG_AUDIO_GRAPH("Graph:" << int(this) << "disconnect audio sink after init:" << int(connection->m_sink->m_audioNode))
-
-    if (!connection->disconnect(this)){
-        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not disconnect audio sink. Rebuild.")
-        rebuildGraph();
-    }
-}
-
-void AudioGraph::update()
-{
-    if (m_startedLogically){
-        if (m_initialized){
-            // Quick solution:
-            AUGraphUpdate(m_audioGraphRef, 0);
-            tryStartGraph();            
-        } else
-            rebuildGraph();
-    }
-}
-
-int AudioGraph::nodeCount()
-{
-    if (!m_audioGraphRef)
-        return 0;
-    UInt32 count;
-    AUGraphGetNodeCount(m_audioGraphRef, &count);
-    return int(count);
-}
-
-void AudioGraph::prepare()
-{
-    if (!m_initialized)
-        rebuildGraph();
-}
-
-void AudioGraph::start()
-{
-    // Start does not mean 'start to play
-    // music'. It means 'prepare to receive
-    // audio from the player units'.
-    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "asked to start (cannot play:" << m_graphCannotPlay << ")")
-    m_startedLogically = true;
-    
-    if (m_graphCannotPlay)
-        return;
-        
-    if (!m_initialized)
-        rebuildGraph();
-
-    if (!m_graphCannotPlay)
-        tryStartGraph();
-}
-
-void AudioGraph::stop()
-{
-    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "asked to stop")
-    if (m_audioGraphRef)
-	    AUGraphStop(m_audioGraphRef);
-    m_startedLogically = false;
-}
-
-void AudioGraph::notify(const MediaNodeEvent *event, bool propagate)
-{
-    switch (event->type()){
-        case MediaNodeEvent::StartConnectionChange:
-            if (m_graphCannotPlay)
-                startAllOverFromScratch();
-            break;
-        case MediaNodeEvent::EndConnectionChange:
-            update();
-            break;
-       default:
-            break;
-    }
-    m_root->notify(event, propagate);
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiograph.h phonon-4.3.0/qt7/audiograph.h
--- phonon-4.3.0/qt7/audiograph.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiograph.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -22,5 +22,5 @@
 #include <AudioUnit/AudioUnit.h>
 
-#include <QtCore>
+#include <QtCore/qnamespace.h>
 #include "audioconnection.h"
 #include "medianode.h"
@@ -64,5 +64,5 @@
             void createAndConnectAuNodesRecursive(AudioConnection *connection);
             bool createAudioUnitsRecursive(AudioConnection *connection);
- 
+
             void connectLate(AudioConnection *connection);
             void disconnectLate(AudioConnection *connection);
diff -r -U2 -N phonon-4.3.0/qt7/audiograph.mm phonon-4.3.0/qt7/audiograph.mm
--- phonon-4.3.0/qt7/audiograph.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiograph.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,320 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiograph.h"
+#include "quicktimeaudioplayer.h"
+#include "medianode.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioGraph::AudioGraph(MediaNode *root) : MediaNode(AudioGraphNode, 0, root), m_root(root)
+{
+    m_audioGraphRef = 0;
+    m_initialized = false;
+    m_startedLogically = false;
+    m_graphCannotPlay = false;
+    m_paused = false;
+}
+
+AudioGraph::~AudioGraph()
+{
+    deleteGraph();
+}
+
+void AudioGraph::startAllOverFromScratch()
+{
+    MediaNodeEvent event(MediaNodeEvent::AudioGraphAboutToBeDeleted, this);
+    m_root->notify(&event);
+    deleteGraph();
+}
+
+void AudioGraph::deleteGraph()
+{
+    if (m_audioGraphRef){
+    	AUGraphStop(m_audioGraphRef);
+	    AUGraphUninitialize(m_audioGraphRef);
+        AUGraphClose(m_audioGraphRef);
+        DisposeAUGraph(m_audioGraphRef);
+        m_initialized = false;
+        m_graphCannotPlay = false;
+        DEBUG_AUDIO_GRAPH("Graph ref in" << int(this) << "is deleted")
+    }
+}
+
+MediaNode *AudioGraph::root()
+{
+    return m_root;
+}
+
+AUGraph AudioGraph::audioGraphRef()
+{
+    return m_audioGraphRef;
+}
+
+void AudioGraph::setStatusCannotPlay()
+{
+    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "received 'cannot play' request")
+    if (!m_graphCannotPlay){
+        stop();
+        m_graphCannotPlay = true;
+        MediaNodeEvent e(MediaNodeEvent::AudioGraphCannotPlay, this);
+        m_root->notify(&e);
+    }
+}
+
+void AudioGraph::rebuildGraph()
+{
+    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "is rebuilding")
+    startAllOverFromScratch();
+    if (!openAndInit()){
+        setStatusCannotPlay();
+    } else { 
+        tryStartGraph();
+        m_graphCannotPlay = false;
+    }   
+}
+
+bool AudioGraph::graphCannotPlay()
+{
+    return m_graphCannotPlay;
+}
+
+void AudioGraph::updateStreamSpecifications()
+{
+    if (!m_initialized){
+        if (m_graphCannotPlay)
+            rebuildGraph();
+        return;
+    }
+
+    AudioConnection rootConnection(m_root);
+    bool updateOk = updateStreamSpecificationRecursive(&rootConnection);
+    if (!updateOk){
+        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not update stream specification. Rebuild.")
+        rebuildGraph();
+    }
+}
+
+bool AudioGraph::updateStreamSpecificationRecursive(AudioConnection *connection)
+{
+    bool updateOk = connection->updateStreamSpecification();
+    if (!updateOk)
+        return false;
+
+    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
+        if (!updateStreamSpecificationRecursive(connection->m_sink->m_audioSinkList[i]))
+            return false;
+    }
+    return true;
+}
+
+bool AudioGraph::openAndInit()
+{
+	OSStatus err;
+	err = NewAUGraph(&m_audioGraphRef);
+    BACKEND_ASSERT3(err == noErr, "Could not create audio graph.", NORMAL_ERROR, false)
+
+    MediaNodeEvent eventNew(MediaNodeEvent::NewAudioGraph, this);
+    m_root->notify(&eventNew);
+
+    AudioConnection rootConnection(m_root);
+    createAndConnectAuNodesRecursive(&rootConnection);
+	err = AUGraphOpen(m_audioGraphRef);
+    BACKEND_ASSERT3(err == noErr, "Could not create audio graph.", NORMAL_ERROR, false)
+
+    if (!createAudioUnitsRecursive(&rootConnection))
+        return false;
+
+	err = AUGraphInitialize(m_audioGraphRef);
+    BACKEND_ASSERT3(err == noErr, "Could not initialize audio graph.", NORMAL_ERROR, false)
+
+    m_initialized = true;
+    MediaNodeEvent eventInit(MediaNodeEvent::AudioGraphInitialized, this);
+    m_root->notify(&eventInit);
+    return true;
+}
+
+void AudioGraph::createAndConnectAuNodesRecursive(AudioConnection *connection)
+{
+    connection->m_sink->m_audioNode->createAndConnectAUNodes();
+    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
+        AudioConnection *c = connection->m_sink->m_audioSinkList[i];
+        createAndConnectAuNodesRecursive(c);
+        bool ok = c->connect(this);
+        BACKEND_ASSERT2(ok, "Could not connect an audio nodes pair in the audio graph.", NORMAL_ERROR)
+    }
+}
+
+bool AudioGraph::createAudioUnitsRecursive(AudioConnection *connection)
+{
+    connection->m_sink->m_audioNode->createAudioUnits();
+    bool ok = connection->updateStreamSpecification();
+    if (!ok)
+        return false;
+    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
+        if (!createAudioUnitsRecursive(connection->m_sink->m_audioSinkList[i]))
+            return false;
+    }
+    return true;
+}
+
+void AudioGraph::tryStartGraph()
+{
+    // The graph will only start if the background AUGraph
+    // is valid. Therefore we just try. If it fails, user
+    // actions like connect etc. migh make the graph valid
+    // at a later point.
+    if (m_startedLogically && !isRunning()){
+        OSStatus err = AUGraphStart(m_audioGraphRef);
+        if (err == noErr)
+            DEBUG_AUDIO_GRAPH("Graph" << int(this) << "started")
+        else
+            DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not start")
+    }
+}
+
+bool AudioGraph::isRunning()
+{
+    Boolean running = false;
+    AUGraphIsRunning(m_audioGraphRef, &running);
+    return running;
+}
+
+void AudioGraph::setPaused(bool pause)
+{
+    // This function should only make
+    // a difference if the graph is
+    // running before pausing.
+    if (pause){
+        if (isRunning()){
+            stop();
+            m_paused = true;
+        }
+    } else if (m_paused){
+        start();
+        m_paused = false;
+    }
+}
+
+void AudioGraph::connectLate(AudioConnection *connection)
+{
+    MediaNodeEvent event(MediaNodeEvent::NewAudioGraph, this);
+    connection->m_sink->notify(&event);
+
+    if (!m_initialized)
+        return;
+
+    DEBUG_AUDIO_GRAPH("Graph:" << int(this) << "create and connect audio sink after init:" << int(connection->m_sink->m_audioNode))
+    AudioConnection startConnection(connection->m_source);
+    createAndConnectAuNodesRecursive(&startConnection);
+    
+    if (!createAudioUnitsRecursive(&startConnection)){
+        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not update stream specification. Rebuild.")
+        rebuildGraph();
+    }  
+}
+
+void AudioGraph::disconnectLate(AudioConnection *connection)
+{
+    if (!m_initialized)
+        return;
+
+    DEBUG_AUDIO_GRAPH("Graph:" << int(this) << "disconnect audio sink after init:" << int(connection->m_sink->m_audioNode))
+
+    if (!connection->disconnect(this)){
+        DEBUG_AUDIO_GRAPH("Graph" << int(this) << "could not disconnect audio sink. Rebuild.")
+        rebuildGraph();
+    }
+}
+
+void AudioGraph::update()
+{
+    if (m_startedLogically){
+        if (m_initialized){
+            // Quick solution:
+            AUGraphUpdate(m_audioGraphRef, 0);
+            tryStartGraph();            
+        } else
+            rebuildGraph();
+    }
+}
+
+int AudioGraph::nodeCount()
+{
+    if (!m_audioGraphRef)
+        return 0;
+    UInt32 count;
+    AUGraphGetNodeCount(m_audioGraphRef, &count);
+    return int(count);
+}
+
+void AudioGraph::prepare()
+{
+    if (!m_initialized)
+        rebuildGraph();
+}
+
+void AudioGraph::start()
+{
+    // Start does not mean 'start to play
+    // music'. It means 'prepare to receive
+    // audio from the player units'.
+    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "asked to start (cannot play:" << m_graphCannotPlay << ")")
+    m_startedLogically = true;
+    
+    if (m_graphCannotPlay)
+        return;
+        
+    if (!m_initialized)
+        rebuildGraph();
+
+    if (!m_graphCannotPlay)
+        tryStartGraph();
+}
+
+void AudioGraph::stop()
+{
+    DEBUG_AUDIO_GRAPH("Graph" << int(this) << "asked to stop")
+    if (m_audioGraphRef)
+	    AUGraphStop(m_audioGraphRef);
+    m_startedLogically = false;
+}
+
+void AudioGraph::notify(const MediaNodeEvent *event, bool propagate)
+{
+    switch (event->type()){
+        case MediaNodeEvent::StartConnectionChange:
+            if (m_graphCannotPlay)
+                startAllOverFromScratch();
+            break;
+        case MediaNodeEvent::EndConnectionChange:
+            update();
+            break;
+       default:
+            break;
+    }
+    m_root->notify(event, propagate);
+}
+
+}} // namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiomixer.cpp phonon-4.3.0/qt7/audiomixer.cpp
--- phonon-4.3.0/qt7/audiomixer.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiomixer.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,182 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiomixer.h"
-#include <QtCore>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioMixerAudioNode::AudioMixerAudioNode() : AudioNode(30, 1)
-{
-    m_numberOfBusses = 2;
-    m_volume = 1.0f;
-}
-
-ComponentDescription AudioMixerAudioNode::getAudioNodeDescription() const
-{
-	ComponentDescription description;
-	description.componentType = kAudioUnitType_Mixer;
-	description.componentSubType = kAudioUnitSubType_StereoMixer;
-	description.componentManufacturer = kAudioUnitManufacturer_Apple;
-	description.componentFlags = 0;
-	description.componentFlagsMask = 0;
-    return description;
-}
-
-void AudioMixerAudioNode::initializeAudioUnit()
-{
-    // Set bus count:
-    OSStatus err = AudioUnitSetProperty(m_audioUnit,
-        kAudioUnitProperty_BusCount, kAudioUnitScope_Input, 0, &m_numberOfBusses, sizeof(int));
-    BACKEND_ASSERT2(err == noErr, "Could not set number of busses on audio mixer node.", FATAL_ERROR)
-}
-
-void AudioMixerAudioNode::setVolume(float volume, int bus)
-{
-    if (volume < 0)
-        m_volume = 0;
-    else if (volume > 1)
-        m_volume = 1;
-    else
-        m_volume = volume;
-
-    if (m_audioUnit){
-//        Float32 db = Float32(volume);//Float32(20.0 * log10(volume)); // convert to db
-        Float32 db = Float32(volume);
-        OSStatus err = AudioUnitSetParameter(m_audioUnit, kStereoMixerParam_Volume, kAudioUnitScope_Input, bus, db, 0);
-        BACKEND_ASSERT2(err == noErr, "Could not set volume on audio mixer node.", NORMAL_ERROR)
-    }
-}
-
-float AudioMixerAudioNode::volume(int bus)
-{
-    if (!m_audioUnit)
-        return 0;
-
-    Float32 db;
-    OSStatus err = AudioUnitGetParameter(m_audioUnit, kStereoMixerParam_Volume, kAudioUnitScope_Input, bus, &db);
-    BACKEND_ASSERT3(err == noErr, "Could not get volume on audio mixer node.", NORMAL_ERROR, 0)
-    return float(db);
-}
-
-///////////////////////////////////////////////////////////////////////
-
-AudioMixer::AudioMixer(QObject *parent) : MediaNode(AudioSink | AudioSource, 0, parent)
-{
-    m_audioNode = new AudioMixerAudioNode();
-    setAudioNode(m_audioNode);
-    m_fadeCurve = Phonon::VolumeFaderEffect::Fade3Decibel;
-    m_fadeTimer = 0;
-    m_fadeDuration = 0;
-    m_fadeFromVolume = 0;
-    m_fadeToVolume = 0;
-}
-
-AudioMixer::~AudioMixer()
-{
-    if (m_fadeTimer)
-        killTimer(m_fadeTimer);
-}
-
-QList<Phonon::EffectParameter> AudioMixer::parameters() const
-{
-    QList<Phonon::EffectParameter> ret;
-    return ret;
-}
-
-QVariant AudioMixer::parameterValue(const Phonon::EffectParameter &value) const
-{
-    NOT_IMPLEMENTED;
-    Q_UNUSED(value);
-    return QVariant();
-}
-
-void AudioMixer::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
-{
-    NOT_IMPLEMENTED;
-    Q_UNUSED(parameter);
-    Q_UNUSED(newValue);
-}
-
-float AudioMixer::volume() const
-{
-    return m_audioNode->volume(0);
-}
-
-void AudioMixer::setVolume(float volume)
-{
-    m_audioNode->setVolume(volume, 0);
-}
-
-Phonon::VolumeFaderEffect::FadeCurve AudioMixer::fadeCurve() const
-{
-    return m_fadeCurve;
-}
-
-void AudioMixer::setFadeCurve(Phonon::VolumeFaderEffect::FadeCurve fadeCurve)
-{
-    m_fadeCurve = fadeCurve;
-}
-
-void AudioMixer::fadeTo(float volume, int fadeTime)
-{
-    m_fadeToVolume = volume;
-    m_fadeDuration = fadeTime;
-    m_fadeFromVolume = m_audioNode->volume(0);
-    
-    m_fadeStartTime.start();
-    if (m_fadeTimer)
-        killTimer(m_fadeTimer);
-    m_fadeTimer = startTimer(100);
-}
-
-void AudioMixer::updateFade()
-{
-    float step = float(m_fadeStartTime.elapsed()) / float(m_fadeDuration);
-    if (step > 1){
-        step = 1;
-        if (m_fadeTimer)
-            killTimer(m_fadeTimer);
-    }
-    float volume = m_fadeFromVolume + ((m_fadeToVolume - m_fadeFromVolume) * step);
-    m_audioNode->setVolume(volume, 0);
-}
-
-bool AudioMixer::event(QEvent *event)
-{
-    switch (event->type()){
-        case QEvent::Timer:{
-            QTimerEvent *timerEvent = static_cast<QTimerEvent *>(event);
-            if (timerEvent->timerId() == m_fadeTimer)
-                updateFade();
-            break; }
-        default:
-            break;
-    }
-    return MediaNode::event(event);
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_audiomixer.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audiomixer.h phonon-4.3.0/qt7/audiomixer.h
--- phonon-4.3.0/qt7/audiomixer.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiomixer.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,7 @@
 #define Phonon_QT7_AUDIOMIXER_H
 
-#include <QtCore>
+#include <QtCore/QObject>
+#include <QtCore/QTime>
+#include <QtCore/QEvent>
 #include <phonon/effectinterface.h>
 #include <phonon/effectparameter.h>
@@ -65,5 +67,5 @@
             float m_fadeFromVolume;
             QTime m_fadeStartTime;
-            
+
             // EffectInterface:
             QList<Phonon::EffectParameter> parameters() const;
diff -r -U2 -N phonon-4.3.0/qt7/audiomixer.mm phonon-4.3.0/qt7/audiomixer.mm
--- phonon-4.3.0/qt7/audiomixer.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiomixer.mm	2009-03-02 04:16:07.000000000 -0700
@@ -0,0 +1,181 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiomixer.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioMixerAudioNode::AudioMixerAudioNode() : AudioNode(30, 1)
+{
+    m_numberOfBusses = 2;
+    m_volume = 1.0f;
+}
+
+ComponentDescription AudioMixerAudioNode::getAudioNodeDescription() const
+{
+	ComponentDescription description;
+	description.componentType = kAudioUnitType_Mixer;
+	description.componentSubType = kAudioUnitSubType_StereoMixer;
+	description.componentManufacturer = kAudioUnitManufacturer_Apple;
+	description.componentFlags = 0;
+	description.componentFlagsMask = 0;
+    return description;
+}
+
+void AudioMixerAudioNode::initializeAudioUnit()
+{
+    // Set bus count:
+    OSStatus err = AudioUnitSetProperty(m_audioUnit,
+        kAudioUnitProperty_BusCount, kAudioUnitScope_Input, 0, &m_numberOfBusses, sizeof(int));
+    BACKEND_ASSERT2(err == noErr, "Could not set number of busses on audio mixer node.", FATAL_ERROR)
+}
+
+void AudioMixerAudioNode::setVolume(float volume, int bus)
+{
+    if (volume < 0)
+        m_volume = 0;
+    else if (volume > 1)
+        m_volume = 1;
+    else
+        m_volume = volume;
+
+    if (m_audioUnit){
+//        Float32 db = Float32(volume);//Float32(20.0 * log10(volume)); // convert to db
+        Float32 db = Float32(volume);
+        OSStatus err = AudioUnitSetParameter(m_audioUnit, kStereoMixerParam_Volume, kAudioUnitScope_Input, bus, db, 0);
+        BACKEND_ASSERT2(err == noErr, "Could not set volume on audio mixer node.", NORMAL_ERROR)
+    }
+}
+
+float AudioMixerAudioNode::volume(int bus)
+{
+    if (!m_audioUnit)
+        return 0;
+
+    Float32 db;
+    OSStatus err = AudioUnitGetParameter(m_audioUnit, kStereoMixerParam_Volume, kAudioUnitScope_Input, bus, &db);
+    BACKEND_ASSERT3(err == noErr, "Could not get volume on audio mixer node.", NORMAL_ERROR, 0)
+    return float(db);
+}
+
+///////////////////////////////////////////////////////////////////////
+
+AudioMixer::AudioMixer(QObject *parent) : MediaNode(AudioSink | AudioSource, 0, parent)
+{
+    m_audioNode = new AudioMixerAudioNode();
+    setAudioNode(m_audioNode);
+    m_fadeCurve = Phonon::VolumeFaderEffect::Fade3Decibel;
+    m_fadeTimer = 0;
+    m_fadeDuration = 0;
+    m_fadeFromVolume = 0;
+    m_fadeToVolume = 0;
+}
+
+AudioMixer::~AudioMixer()
+{
+    if (m_fadeTimer)
+        killTimer(m_fadeTimer);
+}
+
+QList<Phonon::EffectParameter> AudioMixer::parameters() const
+{
+    QList<Phonon::EffectParameter> ret;
+    return ret;
+}
+
+QVariant AudioMixer::parameterValue(const Phonon::EffectParameter &value) const
+{
+    NOT_IMPLEMENTED;
+    Q_UNUSED(value);
+    return QVariant();
+}
+
+void AudioMixer::setParameterValue(const Phonon::EffectParameter &parameter, const QVariant &newValue)
+{
+    NOT_IMPLEMENTED;
+    Q_UNUSED(parameter);
+    Q_UNUSED(newValue);
+}
+
+float AudioMixer::volume() const
+{
+    return m_audioNode->volume(0);
+}
+
+void AudioMixer::setVolume(float volume)
+{
+    m_audioNode->setVolume(volume, 0);
+}
+
+Phonon::VolumeFaderEffect::FadeCurve AudioMixer::fadeCurve() const
+{
+    return m_fadeCurve;
+}
+
+void AudioMixer::setFadeCurve(Phonon::VolumeFaderEffect::FadeCurve fadeCurve)
+{
+    m_fadeCurve = fadeCurve;
+}
+
+void AudioMixer::fadeTo(float volume, int fadeTime)
+{
+    m_fadeToVolume = volume;
+    m_fadeDuration = fadeTime;
+    m_fadeFromVolume = m_audioNode->volume(0);
+    
+    m_fadeStartTime.start();
+    if (m_fadeTimer)
+        killTimer(m_fadeTimer);
+    m_fadeTimer = startTimer(100);
+}
+
+void AudioMixer::updateFade()
+{
+    float step = float(m_fadeStartTime.elapsed()) / float(m_fadeDuration);
+    if (step > 1){
+        step = 1;
+        if (m_fadeTimer)
+            killTimer(m_fadeTimer);
+    }
+    float volume = m_fadeFromVolume + ((m_fadeToVolume - m_fadeFromVolume) * step);
+    m_audioNode->setVolume(volume, 0);
+}
+
+bool AudioMixer::event(QEvent *event)
+{
+    switch (event->type()){
+        case QEvent::Timer:{
+            QTimerEvent *timerEvent = static_cast<QTimerEvent *>(event);
+            if (timerEvent->timerId() == m_fadeTimer)
+                updateFade();
+            break; }
+        default:
+            break;
+    }
+    return MediaNode::event(event);
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_audiomixer.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audionode.cpp phonon-4.3.0/qt7/audionode.cpp
--- phonon-4.3.0/qt7/audionode.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audionode.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,240 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audionode.h"
-#include "audiograph.h"
-#include "audioconnection.h"
-#include "medianode.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioNode::AudioNode(int maxInputBusses, int maxOutputBusses)
-{
-    m_auNode = 0;
-    m_audioUnit = 0;
-    m_audioGraph = 0;
-    m_maxInputBusses = maxInputBusses;
-    m_maxOutputBusses = maxOutputBusses;
-    m_lastConnectionIn = 0;
-}
-
-AudioNode::~AudioNode()
-{
-    setGraph(0);
-}
-
-void AudioNode::setGraph(AudioGraph *audioGraph)
-{
-    if (m_audioGraph == audioGraph)
-        return;
-
-    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "is setting graph:" << int(audioGraph))    
-    if (m_auNode){
-        AUGraphRemoveNode(m_audioGraph->audioGraphRef(), m_auNode);
-        m_auNode = 0;
-    }
-    
-    m_audioUnit = 0;
-    m_lastConnectionIn = 0;
-    m_audioGraph = audioGraph;
-}
-
-void AudioNode::createAndConnectAUNodes()
-{
-    if (m_auNode)
-        return;
-
-    ComponentDescription description = getAudioNodeDescription();
-    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "creates AUNode" 
-        << QString(!FindNextComponent(0, &description) ? "ERROR: COMPONENT NOT FOUND!" : "OK!"))
-
-    OSStatus err = noErr;
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-    if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_5)
-        err = AUGraphAddNode(m_audioGraph->audioGraphRef(), &description, &m_auNode);
-    else
-#endif
-        err = AUGraphNewNode(m_audioGraph->audioGraphRef(), &description, 0, 0, &m_auNode);
-        
-    BACKEND_ASSERT2(err != kAUGraphErr_OutputNodeErr, "A MediaObject can only be connected to one audio output device.", FATAL_ERROR)
-    BACKEND_ASSERT2(err == noErr, "Could not create new AUNode.", FATAL_ERROR)
-}
-
-AUNode AudioNode::getInputAUNode()
-{
-    return m_auNode;
-}
-
-AUNode AudioNode::getOutputAUNode()
-{
-    return m_auNode;
-}
-
-void AudioNode::createAudioUnits()
-{
-    if (m_audioUnit)
-        return;
-
-    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "creates AudioUnit")
-    OSStatus err = AUGraphGetNodeInfo(m_audioGraph->audioGraphRef(), m_auNode, 0, 0, 0, &m_audioUnit);
-    BACKEND_ASSERT2(err == noErr, "Could not get audio unit from audio node.", FATAL_ERROR)
-    initializeAudioUnit();
-}
-
-ComponentDescription AudioNode::getAudioNodeDescription() const
-{
-    // Override if needed.
-    ComponentDescription cd;
-    Q_UNUSED(cd);
-    return cd;
-}
-
-bool AudioNode::setStreamHelp(AudioConnection *c, int bus, OSType scope, bool fromSource)
-{
-    if (fromSource){
-	    OSStatus err = AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_StreamFormat, scope,
-	        bus, &c->m_sourceStreamDescription, sizeof(AudioStreamBasicDescription));
-        if (err != noErr){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " - failed setting stream format")
-            return false;
-        }
-	    AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_AudioChannelLayout, scope,
-	    bus, c->m_sourceChannelLayout, c->m_sourceChannelLayoutSize);
-    } else {
-	    OSStatus err = AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_StreamFormat, scope,
-	        bus, &c->m_sinkStreamDescription, sizeof(AudioStreamBasicDescription));
-        if (err != noErr){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " - failed setting stream format")
-            return false;
-        }
-	    AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_AudioChannelLayout, scope,
-	    bus, c->m_sinkChannelLayout, c->m_sourceChannelLayoutSize);
-    }
-    return true;
-}
-
-bool AudioNode::setStreamSpecification(AudioConnection *connection, ConnectionSide side)
-{
-    if (side == Source){
-        // This object am source of connection:
-        if (connection->m_hasSourceSpecification){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification out"
-                << connection->m_sourceOutputBus << "from connection source")
-            return setStreamHelp(connection, connection->m_sourceOutputBus, kAudioUnitScope_Output, true);
-        } else {
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "did not set stream specification out")
-        }
-    } else {
-        if (connection->m_hasSinkSpecification){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification"
-                << connection->m_sinkInputBus << "from connection sink")
-            return setStreamHelp(connection, connection->m_sinkInputBus, kAudioUnitScope_Input, false);
-        } else if (connection->m_hasSourceSpecification){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification"
-            << connection->m_sinkInputBus << "from connection source")
-            return setStreamHelp(connection, connection->m_sinkInputBus, kAudioUnitScope_Input, true);
-        } else {
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "did not set stream specification in")
-        }
-    }
-    return true;
-}
-
-bool AudioNode::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
-{
-    if (side == Source){
-        // As default, use the last description to describe the source:
-        if (m_lastConnectionIn->m_hasSinkSpecification){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is source, and fills in stream spec using last connection sink.")
-            connection->m_sourceStreamDescription = m_lastConnectionIn->m_sinkStreamDescription;
-            connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_lastConnectionIn->m_sinkChannelLayoutSize);
-            memcpy(connection->m_sourceChannelLayout, m_lastConnectionIn->m_sinkChannelLayout, m_lastConnectionIn->m_sinkChannelLayoutSize);
-            connection->m_sourceChannelLayoutSize = m_lastConnectionIn->m_sinkChannelLayoutSize;
-            connection->m_hasSourceSpecification = true;
-        } else if (m_lastConnectionIn->m_hasSourceSpecification){
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is source, and fills in stream spec using last connection source.")
-            connection->m_sourceStreamDescription = m_lastConnectionIn->m_sourceStreamDescription;
-            connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_lastConnectionIn->m_sourceChannelLayoutSize);
-            memcpy(connection->m_sourceChannelLayout, m_lastConnectionIn->m_sourceChannelLayout, m_lastConnectionIn->m_sourceChannelLayoutSize);
-            connection->m_sourceChannelLayoutSize = m_lastConnectionIn->m_sourceChannelLayoutSize;
-            connection->m_hasSourceSpecification = true;
-        } else {
-            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " __WARNING__: could not get stream specification...")
-        }
-    } else {
-        DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is sink, skips filling in stream.")
-        if (!connection->isSinkOnly())
-            m_lastConnectionIn = connection;
-    }
-    return true;
-}
-
-/**
-    Let timeProperty be one of e.g
-    {kAudioUnitProperty_Latency, kAudioUnitProperty_TailTime,
-    kAudioOutputUnitProperty_StartTime, kAudioUnitProperty_CurrentPlayTime}
-*/
-Float64 AudioNode::getTimeInSamples(int timeProperty)
-{
-    if (!m_audioUnit)
-        return 0;
-
-    AudioTimeStamp timeStamp;
-    UInt32 size = sizeof(timeStamp);
-    memset(&timeStamp, 0, sizeof(timeStamp));
-	OSStatus err = AudioUnitGetProperty(m_audioUnit,
-        timeProperty, kAudioUnitScope_Global,
-        0, &timeStamp, &size);
-    if (err != noErr)
-        return 0;
-    return timeStamp.mSampleTime;
-}
-
-void AudioNode::notify(const MediaNodeEvent *event)
-{
-    switch(event->type()){
-    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
-        setGraph(0);
-        break;
-    case MediaNodeEvent::NewAudioGraph:
-        setGraph(static_cast<AudioGraph *>(event->data()));
-        break;
-    default:
-        break;
-    }
-
-    mediaNodeEvent(event);
-}
-
-void AudioNode::mediaNodeEvent(const MediaNodeEvent */*event*/)
-{
-    // Override if needed
-}
-
-void AudioNode::initializeAudioUnit()
-{
-    // Override if needed.
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audionode.h phonon-4.3.0/qt7/audionode.h
--- phonon-4.3.0/qt7/audionode.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audionode.h	2009-12-27 09:57:19.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_AudioNode_H
 
-#include <QObject>
+#include <QtCore/QObject>
 #include "backendheader.h"
 #include "audioconnection.h"
@@ -73,5 +73,5 @@
 
             // Only the following methods needs to
-            // be overidden by only_one-audio-unit nodes:
+            // be overridden by only_one-audio-unit nodes:
             virtual ComponentDescription getAudioNodeDescription() const;
             virtual void initializeAudioUnit();
diff -r -U2 -N phonon-4.3.0/qt7/audionode.mm phonon-4.3.0/qt7/audionode.mm
--- phonon-4.3.0/qt7/audionode.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audionode.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,240 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audionode.h"
+#include "audiograph.h"
+#include "audioconnection.h"
+#include "medianode.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioNode::AudioNode(int maxInputBusses, int maxOutputBusses)
+{
+    m_auNode = 0;
+    m_audioUnit = 0;
+    m_audioGraph = 0;
+    m_maxInputBusses = maxInputBusses;
+    m_maxOutputBusses = maxOutputBusses;
+    m_lastConnectionIn = 0;
+}
+
+AudioNode::~AudioNode()
+{
+    setGraph(0);
+}
+
+void AudioNode::setGraph(AudioGraph *audioGraph)
+{
+    if (m_audioGraph == audioGraph)
+        return;
+
+    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "is setting graph:" << int(audioGraph))    
+    if (m_auNode){
+        AUGraphRemoveNode(m_audioGraph->audioGraphRef(), m_auNode);
+        m_auNode = 0;
+    }
+    
+    m_audioUnit = 0;
+    m_lastConnectionIn = 0;
+    m_audioGraph = audioGraph;
+}
+
+void AudioNode::createAndConnectAUNodes()
+{
+    if (m_auNode)
+        return;
+
+    ComponentDescription description = getAudioNodeDescription();
+    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "creates AUNode" 
+        << QString(!FindNextComponent(0, &description) ? "ERROR: COMPONENT NOT FOUND!" : "OK!"))
+
+    OSStatus err = noErr;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
+    if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_5)
+        err = AUGraphAddNode(m_audioGraph->audioGraphRef(), &description, &m_auNode);
+    else
+#endif
+        err = AUGraphNewNode(m_audioGraph->audioGraphRef(), &description, 0, 0, &m_auNode);
+        
+    BACKEND_ASSERT2(err != kAUGraphErr_OutputNodeErr, "A MediaObject can only be connected to one audio output device.", FATAL_ERROR)
+    BACKEND_ASSERT2(err == noErr, "Could not create new AUNode.", FATAL_ERROR)
+}
+
+AUNode AudioNode::getInputAUNode()
+{
+    return m_auNode;
+}
+
+AUNode AudioNode::getOutputAUNode()
+{
+    return m_auNode;
+}
+
+void AudioNode::createAudioUnits()
+{
+    if (m_audioUnit)
+        return;
+
+    DEBUG_AUDIO_GRAPH("AudioNode" << int(this) << "creates AudioUnit")
+    OSStatus err = AUGraphGetNodeInfo(m_audioGraph->audioGraphRef(), m_auNode, 0, 0, 0, &m_audioUnit);
+    BACKEND_ASSERT2(err == noErr, "Could not get audio unit from audio node.", FATAL_ERROR)
+    initializeAudioUnit();
+}
+
+ComponentDescription AudioNode::getAudioNodeDescription() const
+{
+    // Override if needed.
+    ComponentDescription cd;
+    Q_UNUSED(cd);
+    return cd;
+}
+
+bool AudioNode::setStreamHelp(AudioConnection *c, int bus, OSType scope, bool fromSource)
+{
+    if (fromSource){
+	    OSStatus err = AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_StreamFormat, scope,
+	        bus, &c->m_sourceStreamDescription, sizeof(AudioStreamBasicDescription));
+        if (err != noErr){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " - failed setting stream format")
+            return false;
+        }
+	    AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_AudioChannelLayout, scope,
+	    bus, c->m_sourceChannelLayout, c->m_sourceChannelLayoutSize);
+    } else {
+	    OSStatus err = AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_StreamFormat, scope,
+	        bus, &c->m_sinkStreamDescription, sizeof(AudioStreamBasicDescription));
+        if (err != noErr){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " - failed setting stream format")
+            return false;
+        }
+	    AudioUnitSetProperty(m_audioUnit, kAudioUnitProperty_AudioChannelLayout, scope,
+	    bus, c->m_sinkChannelLayout, c->m_sourceChannelLayoutSize);
+    }
+    return true;
+}
+
+bool AudioNode::setStreamSpecification(AudioConnection *connection, ConnectionSide side)
+{
+    if (side == Source){
+        // This object am source of connection:
+        if (connection->m_hasSourceSpecification){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification out"
+                << connection->m_sourceOutputBus << "from connection source")
+            return setStreamHelp(connection, connection->m_sourceOutputBus, kAudioUnitScope_Output, true);
+        } else {
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "did not set stream specification out")
+        }
+    } else {
+        if (connection->m_hasSinkSpecification){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification"
+                << connection->m_sinkInputBus << "from connection sink")
+            return setStreamHelp(connection, connection->m_sinkInputBus, kAudioUnitScope_Input, false);
+        } else if (connection->m_hasSourceSpecification){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "sets stream specification"
+            << connection->m_sinkInputBus << "from connection source")
+            return setStreamHelp(connection, connection->m_sinkInputBus, kAudioUnitScope_Input, true);
+        } else {
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "did not set stream specification in")
+        }
+    }
+    return true;
+}
+
+bool AudioNode::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
+{
+    if (side == Source){
+        // As default, use the last description to describe the source:
+        if (m_lastConnectionIn->m_hasSinkSpecification){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is source, and fills in stream spec using last connection sink.")
+            connection->m_sourceStreamDescription = m_lastConnectionIn->m_sinkStreamDescription;
+            connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_lastConnectionIn->m_sinkChannelLayoutSize);
+            memcpy(connection->m_sourceChannelLayout, m_lastConnectionIn->m_sinkChannelLayout, m_lastConnectionIn->m_sinkChannelLayoutSize);
+            connection->m_sourceChannelLayoutSize = m_lastConnectionIn->m_sinkChannelLayoutSize;
+            connection->m_hasSourceSpecification = true;
+        } else if (m_lastConnectionIn->m_hasSourceSpecification){
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is source, and fills in stream spec using last connection source.")
+            connection->m_sourceStreamDescription = m_lastConnectionIn->m_sourceStreamDescription;
+            connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_lastConnectionIn->m_sourceChannelLayoutSize);
+            memcpy(connection->m_sourceChannelLayout, m_lastConnectionIn->m_sourceChannelLayout, m_lastConnectionIn->m_sourceChannelLayoutSize);
+            connection->m_sourceChannelLayoutSize = m_lastConnectionIn->m_sourceChannelLayoutSize;
+            connection->m_hasSourceSpecification = true;
+        } else {
+            DEBUG_AUDIO_STREAM("AudioNode" << int(this) << " __WARNING__: could not get stream specification...")
+        }
+    } else {
+        DEBUG_AUDIO_STREAM("AudioNode" << int(this) << "is sink, skips filling in stream.")
+        if (!connection->isSinkOnly())
+            m_lastConnectionIn = connection;
+    }
+    return true;
+}
+
+/**
+    Let timeProperty be one of e.g
+    {kAudioUnitProperty_Latency, kAudioUnitProperty_TailTime,
+    kAudioOutputUnitProperty_StartTime, kAudioUnitProperty_CurrentPlayTime}
+*/
+Float64 AudioNode::getTimeInSamples(int timeProperty)
+{
+    if (!m_audioUnit)
+        return 0;
+
+    AudioTimeStamp timeStamp;
+    UInt32 size = sizeof(timeStamp);
+    memset(&timeStamp, 0, sizeof(timeStamp));
+	OSStatus err = AudioUnitGetProperty(m_audioUnit,
+        timeProperty, kAudioUnitScope_Global,
+        0, &timeStamp, &size);
+    if (err != noErr)
+        return 0;
+    return timeStamp.mSampleTime;
+}
+
+void AudioNode::notify(const MediaNodeEvent *event)
+{
+    switch(event->type()){
+    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
+        setGraph(0);
+        break;
+    case MediaNodeEvent::NewAudioGraph:
+        setGraph(static_cast<AudioGraph *>(event->data()));
+        break;
+    default:
+        break;
+    }
+
+    mediaNodeEvent(event);
+}
+
+void AudioNode::mediaNodeEvent(const MediaNodeEvent */*event*/)
+{
+    // Override if needed
+}
+
+void AudioNode::initializeAudioUnit()
+{
+    // Override if needed.
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiooutput.cpp phonon-4.3.0/qt7/audiooutput.cpp
--- phonon-4.3.0/qt7/audiooutput.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiooutput.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,169 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiooutput.h"
-#include "audiograph.h"
-#include "audiodevice.h"
-#include "mediaobject.h"
-#include <private/qcore_mac_p.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioOutputAudioPart::AudioOutputAudioPart() : AudioNode(1, 0)
-{
-    m_audioDevice = AudioDevice::defaultDevice(AudioDevice::Out);
-    m_volume = 1;
-}
-
-ComponentDescription AudioOutputAudioPart::getAudioNodeDescription() const
-{
-	ComponentDescription description;
-	description.componentType = kAudioUnitType_Output;
-	description.componentSubType = kAudioUnitSubType_DefaultOutput;
-	description.componentManufacturer = kAudioUnitManufacturer_Apple;
-	description.componentFlags = 0;
-	description.componentFlagsMask = 0;
-    return description;
-}
-
-void AudioOutputAudioPart::initializeAudioUnit()
-{
-    setAudioDevice(m_audioDevice);
-    setVolume(m_volume);
-}
-
-void AudioOutputAudioPart::setAudioDevice(AudioDeviceID device)
-{
-    m_audioDevice = device;
-    if (!m_audioDevice)
-        return;
-    if (!m_audioUnit)
-        return;
-    bool ok = AudioDevice::setDevice(m_audioUnit, m_audioDevice, AudioDevice::Out);
-    if (!ok)
-        emit audioDeviceFailed();
-}
-
-void AudioOutputAudioPart::setVolume(float volume)
-{
-    if (volume < 0)
-        m_volume = 0;
-    if (volume > 1)
-        m_volume = 1;
-    else
-        m_volume = volume;
-
-    if (m_audioUnit){
-        float db = volume;//20.0 * log10(volume); // convert to db
-        OSStatus err = AudioUnitSetParameter(m_audioUnit, kHALOutputParam_Volume, kAudioUnitScope_Input, 0, db, 0);
-        BACKEND_ASSERT2(err == noErr, "Could not set volume on output audio unit.", FATAL_ERROR)
-        emit volumeChanged(qreal(db));
-    }
-}
-
-float AudioOutputAudioPart::volume()
-{
-    return m_volume;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////
-
-AudioOutput::AudioOutput(QObject *parent) : MediaNode(AudioSink, parent)
-{
-    m_audioOutput = new AudioOutputAudioPart();
-    setAudioNode(m_audioOutput);
-    connect(m_audioOutput, SIGNAL(volumeChanged(qreal)), this, SIGNAL(volumeChanged(qreal)));
-    connect(m_audioOutput, SIGNAL(audioDeviceFailed()), this, SIGNAL(audioDeviceFailed()));
-    m_redirectToMovie = false;
-}
-
-AudioOutput::~AudioOutput()
-{
-}
-
-void AudioOutput::setVolume(qreal volume)
-{
-    IMPLEMENTED;
-    m_audioOutput->setVolume(float(volume));
-    if (m_owningMediaObject)
-       m_owningMediaObject->setVolumeOnMovie(volume);
-        
-    emit volumeChanged(m_audioOutput->volume());
-}
-
-qreal AudioOutput::volume() const
-{
-    IMPLEMENTED;
-    return qreal(m_audioOutput->volume());
-}
-
-bool AudioOutput::setOutputDevice(int device)
-{
-    IMPLEMENTED;
-    if (device == -1)
-        return false;
-
-    if (m_owningMediaObject){
-        bool ok = m_owningMediaObject->setAudioDeviceOnMovie(device);
-        if (!ok)
-            return false;
-    }
-    
-    if (m_audioGraph){
-        MediaNodeEvent event1(MediaNodeEvent::AboutToRestartAudioStream, this);
-        m_audioGraph->notify(&event1);
-    }
-    
-    m_audioOutput->setAudioDevice(device);
-    
-    if (m_audioGraph){
-        MediaNodeEvent event2(MediaNodeEvent::RestartAudioStreamRequest, this);
-        m_audioGraph->notify(&event2);
-    }
-    return true;
-}
-
-int AudioOutput::outputDevice() const
-{
-    IMPLEMENTED;
-    return m_audioOutput->m_audioDevice;
-}
-
-void AudioOutput::mediaNodeEvent(const MediaNodeEvent *event)
-{
-    switch (event->type()){
-        case MediaNodeEvent::SetMediaObject:
-            if (static_cast<MediaObject *>(event->data())){
-                setVolume(volume());
-                setOutputDevice(outputDevice());
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_audiooutput.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audiooutput.h phonon-4.3.0/qt7/audiooutput.h
--- phonon-4.3.0/qt7/audiooutput.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiooutput.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_AUDIOOUTPUT_H
 
-#include <QtCore>
+#include <QtCore/QObject>
 #include <phonon/audiooutputinterface.h>
 #include <phonon/abstractaudiooutput.h>
@@ -76,5 +76,5 @@
         protected:
             void mediaNodeEvent(const MediaNodeEvent *event);
-            
+
         private:
             AudioOutputAudioPart *m_audioOutput;
diff -r -U2 -N phonon-4.3.0/qt7/audiooutput.mm phonon-4.3.0/qt7/audiooutput.mm
--- phonon-4.3.0/qt7/audiooutput.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiooutput.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,168 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiooutput.h"
+#include "audiograph.h"
+#include "audiodevice.h"
+#include "mediaobject.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioOutputAudioPart::AudioOutputAudioPart() : AudioNode(1, 0)
+{
+    m_audioDevice = AudioDevice::defaultDevice(AudioDevice::Out);
+    m_volume = 1;
+}
+
+ComponentDescription AudioOutputAudioPart::getAudioNodeDescription() const
+{
+	ComponentDescription description;
+	description.componentType = kAudioUnitType_Output;
+	description.componentSubType = kAudioUnitSubType_DefaultOutput;
+	description.componentManufacturer = kAudioUnitManufacturer_Apple;
+	description.componentFlags = 0;
+	description.componentFlagsMask = 0;
+    return description;
+}
+
+void AudioOutputAudioPart::initializeAudioUnit()
+{
+    setAudioDevice(m_audioDevice);
+    setVolume(m_volume);
+}
+
+void AudioOutputAudioPart::setAudioDevice(AudioDeviceID device)
+{
+    m_audioDevice = device;
+    if (!m_audioDevice)
+        return;
+    if (!m_audioUnit)
+        return;
+    bool ok = AudioDevice::setDevice(m_audioUnit, m_audioDevice, AudioDevice::Out);
+    if (!ok)
+        emit audioDeviceFailed();
+}
+
+void AudioOutputAudioPart::setVolume(float volume)
+{
+    if (volume < 0)
+        m_volume = 0;
+    if (volume > 1)
+        m_volume = 1;
+    else
+        m_volume = volume;
+
+    if (m_audioUnit){
+        float db = volume;//20.0 * log10(volume); // convert to db
+        OSStatus err = AudioUnitSetParameter(m_audioUnit, kHALOutputParam_Volume, kAudioUnitScope_Input, 0, db, 0);
+        BACKEND_ASSERT2(err == noErr, "Could not set volume on output audio unit.", FATAL_ERROR)
+        emit volumeChanged(qreal(db));
+    }
+}
+
+float AudioOutputAudioPart::volume()
+{
+    return m_volume;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////
+
+AudioOutput::AudioOutput(QObject *parent) : MediaNode(AudioSink, parent)
+{
+    m_audioOutput = new AudioOutputAudioPart();
+    setAudioNode(m_audioOutput);
+    connect(m_audioOutput, SIGNAL(volumeChanged(qreal)), this, SIGNAL(volumeChanged(qreal)));
+    connect(m_audioOutput, SIGNAL(audioDeviceFailed()), this, SIGNAL(audioDeviceFailed()));
+    m_redirectToMovie = false;
+}
+
+AudioOutput::~AudioOutput()
+{
+}
+
+void AudioOutput::setVolume(qreal volume)
+{
+    IMPLEMENTED;
+    m_audioOutput->setVolume(float(volume));
+    if (m_owningMediaObject)
+       m_owningMediaObject->setVolumeOnMovie(volume);
+        
+    emit volumeChanged(m_audioOutput->volume());
+}
+
+qreal AudioOutput::volume() const
+{
+    IMPLEMENTED;
+    return qreal(m_audioOutput->volume());
+}
+
+bool AudioOutput::setOutputDevice(int device)
+{
+    IMPLEMENTED;
+    if (device == -1)
+        return false;
+
+    if (m_owningMediaObject){
+        bool ok = m_owningMediaObject->setAudioDeviceOnMovie(device);
+        if (!ok)
+            return false;
+    }
+    
+    if (m_audioGraph){
+        MediaNodeEvent event1(MediaNodeEvent::AboutToRestartAudioStream, this);
+        m_audioGraph->notify(&event1);
+    }
+    
+    m_audioOutput->setAudioDevice(device);
+    
+    if (m_audioGraph){
+        MediaNodeEvent event2(MediaNodeEvent::RestartAudioStreamRequest, this);
+        m_audioGraph->notify(&event2);
+    }
+    return true;
+}
+
+int AudioOutput::outputDevice() const
+{
+    IMPLEMENTED;
+    return m_audioOutput->m_audioDevice;
+}
+
+void AudioOutput::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    switch (event->type()){
+        case MediaNodeEvent::SetMediaObject:
+            if (static_cast<MediaObject *>(event->data())){
+                setVolume(volume());
+                setOutputDevice(outputDevice());
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_audiooutput.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/audiopartoutput.cpp phonon-4.3.0/qt7/audiopartoutput.cpp
--- phonon-4.3.0/qt7/audiopartoutput.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiopartoutput.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,69 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiopartoutput.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioPartOutput::AudioPartOutput()
-    : AudioNode()
-{
-}
-
-AudioPartOutput::~AudioPartOutput()
-{
-}
-
-ComponentDescription AudioPartOutput::getAudioNodeDescription() const
-{
-	ComponentDescription description;
-	description.componentType = kAudioUnitType_Output;
-	description.componentSubType = kAudioUnitSubType_DefaultOutput;
-	description.componentManufacturer = kAudioUnitManufacturer_Apple;
-	description.componentFlags = 0;
-	description.componentFlagsMask = 0;
-    return description;
-}
-
-void AudioPartOutput::initializeAudioUnit(AudioNode *source)
-{
-    m_audioStreamDescription = source->outputStreamDescription();
-    m_audioChannelLayout = source->outputChannelLayout();
-    m_audioChannelLayoutSize = source->outputChannelLayoutSize();
-
-    // Specify the stream format:
-    OSStatus err;
-	err = AudioUnitSetProperty(m_audioUnit,
-	    kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input,
-	    0, m_audioStreamDescription, sizeof(AudioStreamBasicDescription));
-    BACKEND_ASSERT2(err == noErr, "Could not set stream format on audio output unit.", FATAL_ERROR)
-
-    // Set the channel layout:
-	err = AudioUnitSetProperty(m_audioUnit,
-	    kAudioUnitProperty_AudioChannelLayout, kAudioUnitScope_Input,
-	    0, m_audioChannelLayout, m_audioChannelLayoutSize);
-    BACKEND_ASSERT2(err == noErr, "Could not set channel layout on audio output unit.", FATAL_ERROR)
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiopartoutput.h phonon-4.3.0/qt7/audiopartoutput.h
--- phonon-4.3.0/qt7/audiopartoutput.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiopartoutput.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -22,6 +22,5 @@
 #include <AudioUnit/AudioUnit.h>
 #include "audionode.h"
-
-#include <QtCore>
+#include <QtCore/qnamespace.h>
 
 QT_BEGIN_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiopartoutput.mm phonon-4.3.0/qt7/audiopartoutput.mm
--- phonon-4.3.0/qt7/audiopartoutput.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiopartoutput.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,69 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiopartoutput.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioPartOutput::AudioPartOutput()
+    : AudioNode()
+{
+}
+
+AudioPartOutput::~AudioPartOutput()
+{
+}
+
+ComponentDescription AudioPartOutput::getAudioNodeDescription() const
+{
+	ComponentDescription description;
+	description.componentType = kAudioUnitType_Output;
+	description.componentSubType = kAudioUnitSubType_DefaultOutput;
+	description.componentManufacturer = kAudioUnitManufacturer_Apple;
+	description.componentFlags = 0;
+	description.componentFlagsMask = 0;
+    return description;
+}
+
+void AudioPartOutput::initializeAudioUnit(AudioNode *source)
+{
+    m_audioStreamDescription = source->outputStreamDescription();
+    m_audioChannelLayout = source->outputChannelLayout();
+    m_audioChannelLayoutSize = source->outputChannelLayoutSize();
+
+    // Specify the stream format:
+    OSStatus err;
+	err = AudioUnitSetProperty(m_audioUnit,
+	    kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input,
+	    0, m_audioStreamDescription, sizeof(AudioStreamBasicDescription));
+    BACKEND_ASSERT2(err == noErr, "Could not set stream format on audio output unit.", FATAL_ERROR)
+
+    // Set the channel layout:
+	err = AudioUnitSetProperty(m_audioUnit,
+	    kAudioUnitProperty_AudioChannelLayout, kAudioUnitScope_Input,
+	    0, m_audioChannelLayout, m_audioChannelLayoutSize);
+    BACKEND_ASSERT2(err == noErr, "Could not set channel layout on audio output unit.", FATAL_ERROR)
+}
+
+}} // namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiosplitter.cpp phonon-4.3.0/qt7/audiosplitter.cpp
--- phonon-4.3.0/qt7/audiosplitter.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiosplitter.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,52 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "audiosplitter.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-AudioNodeSplitter::AudioNodeSplitter() : AudioNode(1, 2)
-{
-}
-
-ComponentDescription AudioNodeSplitter::getAudioNodeDescription() const
-{
-	ComponentDescription description;
-	description.componentType = kAudioUnitType_FormatConverter;
-	description.componentSubType = kAudioUnitSubType_Splitter;
-	description.componentManufacturer = kAudioUnitManufacturer_Apple;
-	description.componentFlags = 0;
-	description.componentFlagsMask = 0;
-    return description;
-}
-
-AudioSplitter::AudioSplitter(QObject *parent) : MediaNode(AudioSink | AudioSource, new AudioNodeSplitter(), parent)
-{
-}
-
-AudioSplitter::~AudioSplitter()
-{
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/audiosplitter.h phonon-4.3.0/qt7/audiosplitter.h
--- phonon-4.3.0/qt7/audiosplitter.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/audiosplitter.h	2009-02-26 05:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/qt7/audiosplitter.mm phonon-4.3.0/qt7/audiosplitter.mm
--- phonon-4.3.0/qt7/audiosplitter.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/audiosplitter.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,52 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiosplitter.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+AudioNodeSplitter::AudioNodeSplitter() : AudioNode(1, 2)
+{
+}
+
+ComponentDescription AudioNodeSplitter::getAudioNodeDescription() const
+{
+	ComponentDescription description;
+	description.componentType = kAudioUnitType_FormatConverter;
+	description.componentSubType = kAudioUnitSubType_Splitter;
+	description.componentManufacturer = kAudioUnitManufacturer_Apple;
+	description.componentFlags = 0;
+	description.componentFlagsMask = 0;
+    return description;
+}
+
+AudioSplitter::AudioSplitter(QObject *parent) : MediaNode(AudioSink | AudioSource, new AudioNodeSplitter(), parent)
+{
+}
+
+AudioSplitter::~AudioSplitter()
+{
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/backend.cpp phonon-4.3.0/qt7/backend.cpp
--- phonon-4.3.0/qt7/backend.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/backend.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,275 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "backend.h"
-#include <QtCore/QDebug>
-#include <QtCore/QSet>
-#include <QtCore/QVariant>
-#include <QtPlugin>
-
-#include "backendheader.h"
-
-#include "videowidget.h"
-#include "audiooutput.h"
-#include "mediaobject.h"
-#include "videoeffect.h"
-#include "medianode.h"
-#include "audiodevice.h"
-#include "audiomixer.h"
-#include "backendinfo.h"
-#include "quicktimeaudioplayer.h"
-
-#include "audiograph.h"
-#include "audiomixer.h"
-#include "audiooutput.h"
-#include "audiosplitter.h"
-#include "audioeffects.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-Backend::Backend()
-{
-    IMPLEMENTED << "Creating backend QT7";
-}
-
-Backend::Backend(QObject *parent, const QStringList &) : QObject(parent)
-{
-    IMPLEMENTED << "Creating backend QT7";
-    setProperty("identifier",     QLatin1String("Mac OS X/QuickTime7"));
-    setProperty("backendName",    QLatin1String("Mac OS X/QuickTime7"));
-    setProperty("backendComment", QLatin1String("Developed by Trolltech"));
-    setProperty("backendVersion", QLatin1String("0.1"));
-    setProperty("backendIcon",    QLatin1String(""));
-    setProperty("backendWebsite", QLatin1String("http://www.trolltech.com/"));
-}
-
-Backend::~Backend()
-{
-}
-
-bool Backend::quickTime7Available()
-{
-    static bool ok = BackendInfo::isQuickTimeVersionAvailable(0x0700);
-    if (!ok){
-        static bool messageWritten = false;
-        if (!messageWritten && qgetenv("PHONON_DEBUG") == "1"){
-            messageWritten = true;
-            QString str("WARNING: Phonon backend plugin need QuickTime 7 or newer to work.");
-            str += " This computer has version "
-                + BackendInfo::quickTimeVersionString()
-                + " installed.";
-            qWarning(str.toAscii().data());
-        }
-        return false;
-    }
-    return true;
-}
-
-QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
-{
-    if (!quickTime7Available())
-        return 0;
-        
-    switch (c) {
-    case MediaObjectClass:
-        IMPLEMENTED << "Creating new MediaObjectClass.";
-        return new MediaObject(parent);
-        break;
-    case VolumeFaderEffectClass:
-        IMPLEMENTED << "Creating new VolumeFaderEffectClass.";
-        return new AudioMixer(parent);
-        break;
-    case AudioOutputClass:
-        IMPLEMENTED << "Creating new AudioOutputClass.";
-        return new AudioOutput(parent);
-        break;
-    case AudioDataOutputClass:
-        NOT_IMPLEMENTED << "Creating new AudioDataOutputClass.";
-        break;
-    case VisualizationClass:
-        NOT_IMPLEMENTED << "Creating new VisualizationClass.";
-        break;
-    case VideoDataOutputClass:
-        NOT_IMPLEMENTED << "Creating new VideoDataOutputClass.";
-        break;
-    case EffectClass:
-        IMPLEMENTED << "Creating new EffectClass.";
-        return new AudioEffect(args[0].toInt());
-        break;
-    case VideoWidgetClass:
-        IMPLEMENTED << "Creating new VideoWidget.";
-        return new VideoWidget(parent);
-        break;
-    default:
-        return 0;
-    }
-    return 0;
-}
-
-bool Backend::startConnectionChange(QSet<QObject *> objects)
-{
-    IMPLEMENTED;
-    for (int i=0; i<objects.size(); i++){
-        MediaNode *node = qobject_cast<MediaNode*>(objects.values()[i]);
-        if (node && node->m_audioGraph){
-            MediaNodeEvent event(MediaNodeEvent::StartConnectionChange);
-            node->m_audioGraph->notify(&event);
-            break;        
-        }
-    }        
-    return true;
-}
-
-bool Backend::endConnectionChange(QSet<QObject *> objects)
-{
-    IMPLEMENTED;
-    for (int i=0; i<objects.size(); i++){
-        MediaNode *node = qobject_cast<MediaNode*>(objects.values()[i]);
-        if (node && node->m_audioGraph){
-            MediaNodeEvent event(MediaNodeEvent::EndConnectionChange);
-            node->m_audioGraph->notify(&event);
-            break;
-        }
-    }
-    
-    return true;
-}
-
-bool Backend::connectNodes(QObject *aSource, QObject *aSink)
-{
-    IMPLEMENTED;
-    MediaNode *source = qobject_cast<MediaNode*>(aSource);
-    if (!source) return false;
-    MediaNode *sink = qobject_cast<MediaNode*>(aSink);
-    if (!sink) return false;
-
-    return source->connectToSink(sink);
-}
-
-
-bool Backend::disconnectNodes(QObject *aSource, QObject *aSink)
-{
-    IMPLEMENTED;
-    MediaNode *source = qobject_cast<MediaNode*>(aSource);
-    if (!source) return false;
-    MediaNode *sink = qobject_cast<MediaNode*>(aSink);
-    if (!sink) return false;
-
-    return source->disconnectToSink(sink);
-}
-
-
-QStringList Backend::availableMimeTypes() const
-{
-    IMPLEMENTED;
-    return BackendInfo::quickTimeMimeTypes(BackendInfo::In).keys();
-}
-
-/**
-* Returns a set of indexes that acts as identifiers for the various properties
-* this backend supports for the given ObjectDescriptionType.
-* More information for a given property/index can be
-* looked up in Backend::objectDescriptionProperties(...).
-*/
-QList<int> Backend::objectDescriptionIndexes(ObjectDescriptionType type) const
-{
-    QList<int> ret;
-
-    switch (type){
-    case AudioOutputDeviceType:{
-        IMPLEMENTED_SILENT << "Creating index set for type: AudioOutputDeviceType";
-        QList<AudioDeviceID> devices = AudioDevice::devices(AudioDevice::Out);
-        for (int i=0; i<devices.size(); i++)
-            ret << int(devices[i]);
-        break; }
-    case EffectType:{
-        IMPLEMENTED_SILENT << "Creating index set for type: EffectType";
-        if (QuickTimeAudioPlayer::soundPlayerIsAwailable())
-            ret = AudioEffect::effectList();
-        break; }
-        
-#if 0 // will be awailable in a later version of phonon.
-    case AudioCaptureDeviceType:{
-        IMPLEMENTED_SILENT << "Creating index set for type: AudioCaptureDeviceType";
-        QList<AudioDeviceID> devices = AudioDevice::devices(AudioDevice::In).keys();
-        for (int i=0; i<devices.size(); i++)
-            ret <<int(devices[i]);
-        break; }
-    case VideoEffectType:{
-        // Just count the number of filters awailable (c), and
-        // add return a set with the numbers 1..c inserted:
-        IMPLEMENTED_SILENT << "Creating index set for type: VideoEffectType";
-        QList<QString> filters = objc_getCiFilterInfo()->filterDisplayNames;
-        for (int i=0; i<filters.size(); i++)
-            ret << insert(i);
-        break; }
-#endif
-    default:
-        NOT_IMPLEMENTED;
-        break;
-    }
-    return ret;
-}
-
-QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(ObjectDescriptionType type, int index) const
-{
-    QHash<QByteArray, QVariant> ret;
-
-    switch (type){
-    case AudioOutputDeviceType:{
-        IMPLEMENTED_SILENT << "Creating description hash for type: AudioOutputDeviceType";
-        ret.insert("name", AudioDevice::deviceSourceNameElseDeviceName(index));
-        ret.insert("description", AudioDevice::deviceNameElseDeviceSourceName(index));
-        break; }
-    case EffectType:{
-        AudioEffect e(index);
-        ret.insert("name", e.name());
-        ret.insert("description", e.description());
-        break; }
-        
-#if 0 // will be awailable in a later version of phonon.
-    case VideoEffectType:{
-        // Get list of effects, pick out filter at index, and return its name:
-        IMPLEMENTED_SILENT << "Creating description hash for type: VideoEffectType";
-        QList<QString> filters = objc_getCiFilterInfo()->filterDisplayNames;
-        ret.insert("name", filters[index]);
-    case AudioCaptureDeviceType:{
-        IMPLEMENTED_SILENT << "Creating description hash for type: AudioCaptureDeviceType";
-        QMap<AudioDeviceID, QString> devices = AudioDevice::devices(AudioDevice::In);
-        ret.insert("name", devices.value(index));
-        break; }
-#endif
-    default:
-        NOT_IMPLEMENTED;
-        break;
-    }
-
-    return ret;
-}
-
-Q_EXPORT_PLUGIN2(phonon_qt7, Backend)
-}}
-
-QT_END_NAMESPACE
-
-#include "moc_backend.cpp"
-
diff -r -U2 -N phonon-4.3.0/qt7/backend.h phonon-4.3.0/qt7/backend.h
--- phonon-4.3.0/qt7/backend.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/backend.h	2009-02-26 05:48:10.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/qt7/backendheader.h phonon-4.3.0/qt7/backendheader.h
--- phonon-4.3.0/qt7/backendheader.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/backendheader.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,6 +19,12 @@
 #define Phonon_QT7_BACKENDHEADER_H
 
-#include <QString>
- 
+#include <QtCore/QString>
+#import <Foundation/NSAutoreleasePool.h>
+#include <CoreFoundation/CFBase.h>
+
+#ifndef Q_WS_MAC64
+#define QUICKTIME_C_API_AVAILABLE
+#endif
+
 QT_BEGIN_NAMESPACE
 
@@ -46,5 +52,5 @@
 
 #define SET_ERROR(string, type){                                \
-        Phonon::QT7::gSetErrorString(QLatin1String(string));    \
+        Phonon::QT7::gSetErrorString(string);    \
         Phonon::QT7::gSetErrorType(type);                       \
         Phonon::QT7::gSetErrorLocation(ERROR_LOCATION); }
@@ -76,5 +82,5 @@
 #define CASE_UNSUPPORTED(string, type) SET_ERROR(string, type)
 
-#if SET_DEBUG_IMPLEMENTED
+#ifdef SET_DEBUG_IMPLEMENTED
 #define IMPLEMENTED qDebug() << "QT7:" << __FUNCTION__ << "(" << __FILE__ << "):"
 #else
@@ -82,5 +88,5 @@
 #endif
 
-#if SET_DEBUG_HALF_IMPLEMENTED
+#ifdef SET_DEBUG_HALF_IMPLEMENTED
 #define HALF_IMPLEMENTED qDebug() << "QT7: --- HALF IMPLEMENTED:" << __FUNCTION__ << "(" << __FILE__ << "," << __LINE__ << "):"
 #else
@@ -112,4 +118,60 @@
 #endif
 
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class PhononAutoReleasePool
+{
+private:
+    void *pool;
+public:
+    PhononAutoReleasePool();
+    ~PhononAutoReleasePool();
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+template <typename T>
+class PhononCFType
+{
+public:
+    inline PhononCFType(const T &t = 0) : type(t) {}
+    inline PhononCFType(const PhononCFType &helper) : type(helper.type) { if (type) CFRetain(type); }
+    inline ~PhononCFType() { if (type) CFRelease(type); }
+    inline operator T() { return type; }
+    inline PhononCFType operator =(const PhononCFType &helper)
+    {
+	if (helper.type)
+	    CFRetain(helper.type);
+	CFTypeRef type2 = type;
+	type = helper.type;
+	if (type2)
+	    CFRelease(type2);
+	return *this;
+    }
+    inline T *operator&() { return &type; }
+    static PhononCFType constructFromGet(const T &t)
+    {
+        CFRetain(t);
+        return PhononCFType<T>(t);
+    }
+protected:
+    T type;
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class PhononCFString : public PhononCFType<CFStringRef>
+{
+public:
+    inline PhononCFString(const QString &str) : PhononCFType<CFStringRef>(0), string(str) {}
+    inline PhononCFString(const CFStringRef cfstr = 0) : PhononCFType<CFStringRef>(cfstr) {}
+    inline PhononCFString(const PhononCFType<CFStringRef> &other) : PhononCFType<CFStringRef>(other) {}
+    operator QString() const;
+    operator CFStringRef() const;
+    static QString toQString(CFStringRef cfstr);
+    static CFStringRef toCFStringRef(const QString &str);
+private:
+    QString string;
+};
 }} //namespace Phonon::QT7
 
diff -r -U2 -N phonon-4.3.0/qt7/backendheader.mm phonon-4.3.0/qt7/backendheader.mm
--- phonon-4.3.0/qt7/backendheader.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/backendheader.mm	2009-03-02 04:16:07.000000000 -0700
@@ -0,0 +1,127 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "backendheader.h"
+#include <QtCore/QString>
+#include <QtCore/QDebug>
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <QVarLengthArray>
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+Q_GLOBAL_STATIC(QString, gErrorString)
+int gErrorType = NO_ERROR;
+
+void gSetErrorString(const QString &errorString)
+{
+    if (qgetenv("PHONON_DEBUG") == "1"){
+        qDebug() << "Error:" << errorString;
+    }
+
+    if (!gErrorString()->isEmpty())
+        return; // not yet caught.
+        
+    *gErrorString() = errorString;   
+}
+
+QString gGetErrorString()
+{
+    return *gErrorString();
+}
+
+void gSetErrorLocation(const QString &errorLocation)
+{
+    if (qgetenv("PHONON_DEBUG") == "1"){
+        qDebug() << "Location:" << errorLocation;
+    }
+}
+
+void gSetErrorType(int errorType)
+{
+    if (gErrorType != NO_ERROR)
+        return; // not yet caught.
+    gErrorType = errorType;
+}
+
+int gGetErrorType()
+{
+    return gErrorType;
+}
+
+void gClearError()
+{
+    gErrorString()->clear();
+    gErrorType = NO_ERROR;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+PhononAutoReleasePool::PhononAutoReleasePool()
+{
+    pool = (void*)[[NSAutoreleasePool alloc] init];
+}
+
+PhononAutoReleasePool::~PhononAutoReleasePool()
+{
+    [(NSAutoreleasePool*)pool release];
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+QString PhononCFString::toQString(CFStringRef str)
+{
+    if(!str)
+        return QString();
+    CFIndex length = CFStringGetLength(str);
+    const UniChar *chars = CFStringGetCharactersPtr(str);
+    if (chars)
+        return QString(reinterpret_cast<const QChar *>(chars), length);
+
+    QVarLengthArray<UniChar> buffer(length);
+    CFStringGetCharacters(str, CFRangeMake(0, length), buffer.data());
+    return QString(reinterpret_cast<const QChar *>(buffer.constData()), length);
+}
+
+PhononCFString::operator QString() const
+{
+    if (string.isEmpty() && type)
+        const_cast<PhononCFString*>(this)->string = toQString(type);
+    return string;
+}
+
+CFStringRef PhononCFString::toCFStringRef(const QString &string)
+{
+    return CFStringCreateWithCharacters(0, reinterpret_cast<const UniChar *>(string.unicode()),
+                                        string.length());
+}
+
+PhononCFString::operator CFStringRef() const
+{
+    if (!type)
+        const_cast<PhononCFString*>(this)->type = toCFStringRef(string);
+    return type;
+}
+
+}}
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/backendinfo.cpp phonon-4.3.0/qt7/backendinfo.cpp
--- phonon-4.3.0/qt7/backendinfo.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/backendinfo.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,197 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "backendinfo.h"
-#include "backendheader.h"
-#include <private/qcore_mac_p.h>
-
-#include <AudioToolbox/AudioToolbox.h>
-#include <AudioUnit/AudioUnit.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-QString BackendInfo::quickTimeVersionString()
-{
-	long version;
-    OSStatus err = Gestalt(gestaltQuickTimeVersion, &version);
-    if (err != noErr)
-        return QString("00.0.0.0000");
-    QString versionString = QString("%1%2.%3.%4.%5%6%7%8")
-        .arg((version >> (7*4)) & 0xF)
-        .arg((version >> (6*4)) & 0xF)
-        .arg((version >> (5*4)) & 0xF)
-        .arg((version >> (4*4)) & 0xF)
-        .arg((version >> (3*4)) & 0xF)
-        .arg((version >> (2*4)) & 0xF)
-        .arg((version >> (1*4)) & 0xF)
-        .arg((version >> (0*4)) & 0xF);
-    return versionString;
-}
-
-bool BackendInfo::isQuickTimeVersionAvailable(int minHexVersion)
-{
-    // minHexVersion == 0x0741 means version 7.4.1
-	long qtHexVersion;
-    OSStatus err = Gestalt(gestaltQuickTimeVersion, &qtHexVersion);
-    return (err == noErr) ? ((qtHexVersion >> 16) >= minHexVersion) : 0;
-}
-
-QMap<QString, QString> BackendInfo::quickTimeMimeTypes(Scope scope)
-{
-    QMap<QString, QString> mimeTypes;
-    ARGUMENT_UNSUPPORTED(scope, Out, NORMAL_ERROR, mimeTypes)
-
-    ComponentDescription description;
-    description.componentType = MovieImportType;
-    description.componentSubType = 0;
-    description.componentManufacturer = 0;
-    description.componentFlags = hasMovieImportMIMEList | canMovieImportFiles;
-    description.componentFlagsMask = canMovieImportFiles | movieImportSubTypeIsFileExtension | hasMovieImportMIMEList;
-    Component component = FindNextComponent(0, &description);
-
-    while (component) {
-        QTAtomContainer mimeList = 0;
-        OSStatus err = MovieImportGetMIMETypeList((MovieImportComponent)component, &mimeList);
-        if (err == noErr){
-            int count = QTCountChildrenOfType(mimeList, kParentAtomIsContainer, 0);
-            for (int i=1; i<=count; ++i){
-                QString mimeType = getMimeTypeTag(mimeList, i, kMimeInfoMimeTypeTag);
-                if (mimeType.startsWith(QLatin1String("audio")) || mimeType.startsWith(QLatin1String("video"))){
-                    QString mimeDescription = getMimeTypeTag(mimeList, i, kMimeInfoDescriptionTag);
-                    if (err == noErr && !mimeType.isEmpty())
-                        mimeTypes.insert(mimeType, mimeDescription);
-                }
-            }
-         }
-         QTDisposeAtomContainer(mimeList);
-         component = FindNextComponent(component, &description);
-    }
-
-    return mimeTypes;
-}
-
-QString BackendInfo::getMimeTypeTag(QTAtomContainer mimeList, int index, OSType type)
-{
-    QTAtom mimeAtom = QTFindChildByIndex(mimeList, kParentAtomIsContainer, type, index, 0);
-    char mimeCharArray[256];
-    long length;
-    OSStatus err = QTCopyAtomDataToPtr(mimeList, mimeAtom, true, sizeof(mimeCharArray)-1, mimeCharArray, &length);
-    if (err == noErr)
-        return QString::fromAscii(mimeCharArray, length);
-    return QString();
-}
-
-QStringList BackendInfo::quickTimeCompressionFormats()
-{
-    QStringList result;
-
-    ComponentInstance component = 0;
-    OSStatus err = OpenADefaultComponent(StandardCompressionType, StandardCompressionSubTypeAudio, &component);
-    BACKEND_ASSERT3(err == noErr, "Could not open component for retrieving awailable compression formats", NORMAL_ERROR, result)
-
-    UInt32 size;
-    err = QTGetComponentPropertyInfo(component, kQTPropertyClass_SCAudio, kQTSCAudioPropertyID_AvailableCompressionFormatNamesList, 0, &size,0);
-    BACKEND_ASSERT3(err == noErr, "Could not get awailable compression formats", NORMAL_ERROR, result)
-
-    CFArrayRef formats[size];
-    err = QTGetComponentProperty(component, kQTPropertyClass_SCAudio, kQTSCAudioPropertyID_AvailableCompressionFormatNamesList, size, &formats, &size);
-    BACKEND_ASSERT3(err == noErr, "Could not get awailable compression formats", NORMAL_ERROR, result)
-
-    CFIndex count = CFArrayGetCount(*formats);
-    for (CFIndex i=0; i<count; ++i){
-        const CFStringRef name = (const struct __CFString *) CFArrayGetValueAtIndex(*formats, i);
-        result << QCFString::toQString(name);
-    }
-    return result;
-}
-
-
-QStringList BackendInfo::coreAudioCodecs(Scope scope)
-{
-    QStringList result;
-    UInt32 size;
-    OSStatus err;
-    OSType *formatIDs;
-
-    OSType encodersOrDecoders = (scope == In)
-        ? kAudioFormatProperty_EncodeFormatIDs : kAudioFormatProperty_DecodeFormatIDs;
-
-    err = AudioFormatGetPropertyInfo(encodersOrDecoders, 0, NULL,  &size);
-    BACKEND_ASSERT3(err == noErr, "Could not get awailable decoders/encoders", NORMAL_ERROR, result)
-
-    formatIDs = (OSType*)malloc(size);
-    UInt32 numFormats = size / sizeof(OSType);
-    err = AudioFormatGetProperty(encodersOrDecoders, 0, NULL, &size,  formatIDs);
-    BACKEND_ASSERT(err == noErr, "Could not get awailable decoders/encoders", NORMAL_ERROR){
-        free(formatIDs);
-        return result;
-    }
-
-    for (UInt32 i=0; i<numFormats; ++i){
-        AudioStreamBasicDescription absd;
-        memset(&absd, 0, sizeof(absd));
-        absd.mFormatID = formatIDs[i];
-
-        CFStringRef name;
-        size = sizeof(CFStringRef);
-        err = AudioFormatGetProperty(kAudioFormatProperty_FormatName, sizeof(absd), &absd,  &size, &name);
-        BACKEND_ASSERT(err == noErr, "Could not get awailable decoder/encoder names", NORMAL_ERROR){
-            free(formatIDs);
-            return result;
-        }
-        result << QCFString::toQString(name);
-    }
-    free(formatIDs);
-    return result;
-}
-
-QStringList BackendInfo::coreAudioFileTypes(Scope scope)
-{
-    QStringList result;
-    OSStatus err;
-    UInt32 propertySize;
-
-    OSType readOrwrite = (scope == In)
-        ? kAudioFileGlobalInfo_ReadableTypes : kAudioFileGlobalInfo_WritableTypes;
-
-    err = AudioFileGetGlobalInfoSize(readOrwrite, 0, NULL, &propertySize);
-    BACKEND_ASSERT3(err == noErr, "Could not get core audio file types", NORMAL_ERROR, result)
-
-    OSType *types = (OSType*)malloc(propertySize);
-    err = AudioFileGetGlobalInfo(readOrwrite, 0, NULL, &propertySize,  types);
-    BACKEND_ASSERT3(err == noErr, "Could not get core audio file types", NORMAL_ERROR, result)
-
-    UInt32 numTypes = propertySize / sizeof(OSType);
-    for (UInt32 i=0; i<numTypes; ++i){
-        CFStringRef name;
-        UInt32 outSize = sizeof(name);
-        err = AudioFileGetGlobalInfo(kAudioFileGlobalInfo_FileTypeName, sizeof(OSType), types+i, &outSize, &name);
-        BACKEND_ASSERT3(err == noErr, "Could not get core audio file type names", NORMAL_ERROR, result)
-        result << QCFString::toQString(name);
-    }
-    return result;
-}
-
-}}
-
-QT_END_NAMESPACE
-
diff -r -U2 -N phonon-4.3.0/qt7/backendinfo.h phonon-4.3.0/qt7/backendinfo.h
--- phonon-4.3.0/qt7/backendinfo.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/backendinfo.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,10 +19,7 @@
 #define Phonon_QT7_BACKENDINFO_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
 #include <phonon/mediasource.h>
 #include <Carbon/Carbon.h>
-#include <QtCore>
+#include <QtCore/QStringList>
 
 QT_BEGIN_NAMESPACE
@@ -39,13 +36,8 @@
             static QString quickTimeVersionString();
             static bool isQuickTimeVersionAvailable(int minHexVersion);
-            
-            static QMap<QString, QString> quickTimeMimeTypes(Scope scope);
+            static QStringList quickTimeMimeTypes(Scope scope);
             static QStringList quickTimeCompressionFormats();
             static QStringList coreAudioCodecs(Scope scope);
             static QStringList coreAudioFileTypes(Scope scope);
-
-        private:
-            static QString getMimeTypeTag(QTAtomContainer mimeList, int index, OSType type);
-
     };
 
diff -r -U2 -N phonon-4.3.0/qt7/backendinfo.mm phonon-4.3.0/qt7/backendinfo.mm
--- phonon-4.3.0/qt7/backendinfo.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/backendinfo.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,311 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "backendinfo.h"
+#include "backendheader.h"
+
+#include <AudioToolbox/AudioToolbox.h>
+#include <AudioUnit/AudioUnit.h>
+#include <CoreServices/CoreServices.h>
+
+#import <QTKit/QTMovie.h>
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    #include <QuickTime/QuickTime.h>
+    #undef check // avoid name clash;
+#endif
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+QString BackendInfo::quickTimeVersionString()
+{
+	SInt32 version;
+    OSStatus err = Gestalt(gestaltQuickTimeVersion, &version);
+    if (err != noErr)
+        return QString("00.0.0.0000");
+    QString versionString = QString("%1%2.%3.%4.%5%6%7%8")
+        .arg((version >> (7*4)) & 0xF)
+        .arg((version >> (6*4)) & 0xF)
+        .arg((version >> (5*4)) & 0xF)
+        .arg((version >> (4*4)) & 0xF)
+        .arg((version >> (3*4)) & 0xF)
+        .arg((version >> (2*4)) & 0xF)
+        .arg((version >> (1*4)) & 0xF)
+        .arg((version >> (0*4)) & 0xF);
+    return versionString;
+}
+
+bool BackendInfo::isQuickTimeVersionAvailable(int minHexVersion)
+{
+    // minHexVersion == 0x0741 means version 7.4.1
+	SInt32 qtHexVersion;
+    OSStatus err = Gestalt(gestaltQuickTimeVersion, &qtHexVersion);
+    return (err == noErr) ? ((qtHexVersion >> 16) >= minHexVersion) : 0;
+}
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+static QString getMimeTypeTag(QTAtomContainer mimeList, int index, OSType type)
+{
+    QTAtom mimeAtom = QTFindChildByIndex(mimeList, kParentAtomIsContainer, type, index, 0);
+    char mimeCharArray[256];
+    long length;
+    OSStatus err = QTCopyAtomDataToPtr(mimeList, mimeAtom, true, sizeof(mimeCharArray)-1, mimeCharArray, &length);
+    if (err == noErr)
+        return QString::fromAscii(mimeCharArray, length);
+    return QString();
+}
+#endif // QUICKTIME_C_API_AVAILABLE
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+QStringList BackendInfo::quickTimeMimeTypes(Scope scope)
+{
+    QStringList mimeTypes;
+    ARGUMENT_UNSUPPORTED(scope, Out, NORMAL_ERROR, mimeTypes)
+
+    ComponentDescription description;
+    description.componentType = MovieImportType;
+    description.componentSubType = 0;
+    description.componentManufacturer = 0;
+    description.componentFlags = hasMovieImportMIMEList | canMovieImportFiles;
+    description.componentFlagsMask = canMovieImportFiles | movieImportSubTypeIsFileExtension | hasMovieImportMIMEList;
+    Component component = FindNextComponent(0, &description);
+
+    while (component) {
+        QTAtomContainer mimeList = 0;
+        OSStatus err = MovieImportGetMIMETypeList((MovieImportComponent)component, &mimeList);
+        if (err == noErr){
+            int count = QTCountChildrenOfType(mimeList, kParentAtomIsContainer, 0);
+            for (int i=1; i<=count; ++i){
+                QString mimeType = getMimeTypeTag(mimeList, i, kMimeInfoMimeTypeTag);
+                if (mimeType.startsWith(QLatin1String("audio")) || mimeType.startsWith(QLatin1String("video"))){
+                    if (err == noErr && !mimeType.isEmpty())
+                        mimeTypes << mimeType;
+                }
+            }
+         }
+         QTDisposeAtomContainer(mimeList);
+         component = FindNextComponent(component, &description);
+    }
+	mimeTypes.sort();
+    return mimeTypes;
+}
+
+#else // QUICKTIME_C_API_AVAILABLE == false
+
+QString mimeForExtensionAudio(const QString &ext)
+{
+	if (ext == "3g2") return QLatin1String("audio/3g2"); 
+	if (ext == "3gp") return QLatin1String("audio/3gp"); 
+	if (ext == "aac") return QLatin1String("audio/aac"); 
+	if (ext == "ac3") return QLatin1String("audio/ac3"); 
+	if (ext == "aif") return QLatin1String("audio/aif"); 
+	if (ext == "aifc") return QLatin1String("audio/aifc"); 
+	if (ext == "aiff") return QLatin1String("audio/aiff"); 
+	if (ext == "amr") return QLatin1String("audio/amr"); 
+	if (ext == "au") return QLatin1String("audio/au");
+	if (ext == "bwf") return QLatin1String("audio/bwf");
+	if (ext == "caf") return QLatin1String("audio/caf");
+	if (ext == "cdda") return QLatin1String("audio/cdda");
+	if (ext == "gsm") return QLatin1String("audio/gsm");
+	if (ext == "kar") return QLatin1String("audio/kar");
+	if (ext == "m1a") return QLatin1String("audio/m1a");
+	if (ext == "m1s") return QLatin1String("audio/m1s");
+	if (ext == "m3u") return QLatin1String("audio/m3u");
+	if (ext == "m3url") return QLatin1String("audio/m3url"); 
+	if (ext == "mid") return QLatin1String("audio/mid");
+	if (ext == "midi") return QLatin1String("audio/midi");
+	if (ext == "mka") return QLatin1String("audio/mka");
+	if (ext == "mp3") return QLatin1String("audio/mp3");
+	if (ext == "mp4") return QLatin1String("audio/mp4");
+	if (ext == "mpa") return QLatin1String("audio/mpa");
+	if (ext == "mpeg") return QLatin1String("audio/mpeg");
+	if (ext == "mpg") return QLatin1String("audio/mpg");
+	if (ext == "mpg4") return QLatin1String("audio/mpg4");
+	if (ext == "mpm") return QLatin1String("audio/mpm"); 
+	if (ext == "qcp") return QLatin1String("audio/qcp"); 
+	if (ext == "sd2") return QLatin1String("audio/sd2"); 
+	if (ext == "smf") return QLatin1String("audio/smf"); 
+	if (ext == "snd") return QLatin1String("audio/snd"); 
+	if (ext == "ulw") return QLatin1String("audio/ulw"); 
+	if (ext == "wav") return QLatin1String("audio/wav"); 
+	if (ext == "wax") return QLatin1String("audio/wax"); 
+	if (ext == "wma") return QLatin1String("audio/wma"); 
+	return QString();
+}
+
+QString mimeForExtensionVideo(const QString &ext)
+{
+	if (ext == "3g2") return QLatin1String("video/3g2"); 
+	if (ext == "3gp") return QLatin1String("video/3gp"); 
+	if (ext == "asf") return QLatin1String("video/asf"); 
+	if (ext == "asx") return QLatin1String("video/asx"); 
+	if (ext == "avi") return QLatin1String("video/avi"); 
+	if (ext == "dif") return QLatin1String("video/dif"); 
+	if (ext == "dv") return QLatin1String("video/dv"); 
+	if (ext == "flc") return QLatin1String("video/flc"); 
+	if (ext == "fli") return QLatin1String("video/fli"); 
+	if (ext == "m15") return QLatin1String("video/m15"); 
+	if (ext == "m1a") return QLatin1String("video/m1a"); 
+	if (ext == "m1s") return QLatin1String("video/m1s"); 
+	if (ext == "m1v") return QLatin1String("video/m1v"); 
+	if (ext == "m75") return QLatin1String("video/m75"); 
+	if (ext == "mkv") return QLatin1String("video/mkv"); 
+	if (ext == "mp4") return QLatin1String("video/mp4"); 
+	if (ext == "mpa") return QLatin1String("video/mpa"); 
+	if (ext == "mpeg") return QLatin1String("video/mpeg"); 
+	if (ext == "mpg") return QLatin1String("video/mpg"); 
+	if (ext == "mpg4") return QLatin1String("video/mpg4"); 
+	if (ext == "mpm") return QLatin1String("video/mpm"); 
+	if (ext == "mpv") return QLatin1String("video/mpv"); 
+	if (ext == "vfw") return QLatin1String("video/vfw"); 
+	if (ext == "wm") return QLatin1String("video/wm"); 
+	if (ext == "wmv") return QLatin1String("video/wmv"); 
+	if (ext == "wmx") return QLatin1String("video/wmx"); 
+	if (ext == "wvx") return QLatin1String("video/wvx");
+	return QString();
+}
+
+QStringList BackendInfo::quickTimeMimeTypes(Scope scope)
+{
+    QStringList mimeTypes;
+    QStringList fileExtensions;
+    ARGUMENT_UNSUPPORTED(scope, Out, NORMAL_ERROR, mimeTypes)
+
+	PhononAutoReleasePool pool;
+	NSArray *fileTypes = [QTMovie movieFileTypes:QTIncludeAllTypes];
+	for (NSString *type in fileTypes){
+		QString formattedType = QString::fromUtf8([type UTF8String]);
+		formattedType = formattedType.remove('\'').remove('.').toLower();
+		QString audioMime = mimeForExtensionAudio(formattedType);
+		QString videoMime = mimeForExtensionVideo(formattedType);
+		if (!audioMime.isEmpty())
+			mimeTypes << audioMime;
+		if (!videoMime.isEmpty())
+			mimeTypes << videoMime;
+		if (audioMime.isEmpty() && videoMime.isEmpty())
+			fileExtensions << QLatin1String("application/x-qt-") + formattedType;
+	}
+	mimeTypes.sort();
+	fileExtensions.sort();
+    return mimeTypes + fileExtensions;
+}
+#endif // QUICKTIME_C_API_AVAILABLE
+
+QStringList BackendInfo::quickTimeCompressionFormats()
+{
+    QStringList result;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+
+    ComponentInstance component = 0;
+    OSStatus err = OpenADefaultComponent(StandardCompressionType, StandardCompressionSubTypeAudio, &component);
+    BACKEND_ASSERT3(err == noErr, "Could not open component for retrieving awailable compression formats", NORMAL_ERROR, result)
+
+    UInt32 size;
+    err = QTGetComponentPropertyInfo(component, kQTPropertyClass_SCAudio, kQTSCAudioPropertyID_AvailableCompressionFormatNamesList, 0, &size,0);
+    BACKEND_ASSERT3(err == noErr, "Could not get awailable compression formats", NORMAL_ERROR, result)
+
+    CFArrayRef formats[size];
+    err = QTGetComponentProperty(component, kQTPropertyClass_SCAudio, kQTSCAudioPropertyID_AvailableCompressionFormatNamesList, size, &formats, &size);
+    BACKEND_ASSERT3(err == noErr, "Could not get awailable compression formats", NORMAL_ERROR, result)
+
+    CFIndex count = CFArrayGetCount(*formats);
+    for (CFIndex i=0; i<count; ++i){
+        const CFStringRef name = (const struct __CFString *) CFArrayGetValueAtIndex(*formats, i);
+        result << PhononCFString::toQString(name);
+    }
+    
+#endif // QUICKTIME_C_API_AVAILABLE
+    return result;
+}
+
+
+QStringList BackendInfo::coreAudioCodecs(Scope scope)
+{
+    QStringList result;
+    UInt32 size;
+    OSStatus err;
+    OSType *formatIDs;
+
+    OSType encodersOrDecoders = (scope == In)
+        ? kAudioFormatProperty_EncodeFormatIDs : kAudioFormatProperty_DecodeFormatIDs;
+
+    err = AudioFormatGetPropertyInfo(encodersOrDecoders, 0, NULL,  &size);
+    BACKEND_ASSERT3(err == noErr, "Could not get awailable decoders/encoders", NORMAL_ERROR, result)
+
+    formatIDs = (OSType*)malloc(size);
+    UInt32 numFormats = size / sizeof(OSType);
+    err = AudioFormatGetProperty(encodersOrDecoders, 0, NULL, &size,  formatIDs);
+    BACKEND_ASSERT(err == noErr, "Could not get awailable decoders/encoders", NORMAL_ERROR){
+        free(formatIDs);
+        return result;
+    }
+
+    for (UInt32 i=0; i<numFormats; ++i){
+        AudioStreamBasicDescription absd;
+        memset(&absd, 0, sizeof(absd));
+        absd.mFormatID = formatIDs[i];
+
+        CFStringRef name;
+        size = sizeof(CFStringRef);
+        err = AudioFormatGetProperty(kAudioFormatProperty_FormatName, sizeof(absd), &absd,  &size, &name);
+        BACKEND_ASSERT(err == noErr, "Could not get awailable decoder/encoder names", NORMAL_ERROR){
+            free(formatIDs);
+            return result;
+        }
+        result << PhononCFString::toQString(name);
+    }
+    free(formatIDs);
+    return result;
+}
+
+QStringList BackendInfo::coreAudioFileTypes(Scope scope)
+{
+    QStringList result;
+    OSStatus err;
+    UInt32 propertySize;
+
+    OSType readOrwrite = (scope == In)
+        ? kAudioFileGlobalInfo_ReadableTypes : kAudioFileGlobalInfo_WritableTypes;
+
+    err = AudioFileGetGlobalInfoSize(readOrwrite, 0, NULL, &propertySize);
+    BACKEND_ASSERT3(err == noErr, "Could not get core audio file types", NORMAL_ERROR, result)
+
+    OSType *types = (OSType*)malloc(propertySize);
+    err = AudioFileGetGlobalInfo(readOrwrite, 0, NULL, &propertySize,  types);
+    BACKEND_ASSERT3(err == noErr, "Could not get core audio file types", NORMAL_ERROR, result)
+
+    UInt32 numTypes = propertySize / sizeof(OSType);
+    for (UInt32 i=0; i<numTypes; ++i){
+        CFStringRef name;
+        UInt32 outSize = sizeof(name);
+        err = AudioFileGetGlobalInfo(kAudioFileGlobalInfo_FileTypeName, sizeof(OSType), types+i, &outSize, &name);
+        BACKEND_ASSERT3(err == noErr, "Could not get core audio file type names", NORMAL_ERROR, result)
+        result << PhononCFString::toQString(name);
+    }
+    return result;
+}
+
+}}
+
+QT_END_NAMESPACE
+
diff -r -U2 -N phonon-4.3.0/qt7/backend.mm phonon-4.3.0/qt7/backend.mm
--- phonon-4.3.0/qt7/backend.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/backend.mm	2009-03-02 04:16:07.000000000 -0700
@@ -0,0 +1,276 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "backend.h"
+#include <QtCore/QDebug>
+#include <QtCore/QSet>
+#include <QtCore/QVariant>
+#include <QtCore/QtPlugin>
+
+#include "backendheader.h"
+
+#include "videowidget.h"
+#include "audiooutput.h"
+#include "mediaobject.h"
+#include "videoeffect.h"
+#include "medianode.h"
+#include "audiodevice.h"
+#include "audiomixer.h"
+#include "backendinfo.h"
+#include "quicktimeaudioplayer.h"
+
+#include "audiograph.h"
+#include "audiomixer.h"
+#include "audiooutput.h"
+#include "audiosplitter.h"
+#include "audioeffects.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+Backend::Backend()
+{
+    IMPLEMENTED << "Creating backend QT7";
+}
+
+Backend::Backend(QObject *parent, const QStringList &) : QObject(parent)
+{
+    IMPLEMENTED << "Creating backend QT7";
+    setProperty("identifier",     QLatin1String("Mac OS X/QuickTime7"));
+    setProperty("backendName",    QLatin1String("Mac OS X/QuickTime7"));
+    setProperty("backendComment", QLatin1String("Developed by Trolltech"));
+    setProperty("backendVersion", QLatin1String("0.1"));
+    setProperty("backendIcon",    QLatin1String(""));
+    setProperty("backendWebsite", QLatin1String("http://qtsoftware.com/"));
+}
+
+Backend::~Backend()
+{
+}
+
+bool Backend::quickTime7Available()
+{
+    static bool ok = BackendInfo::isQuickTimeVersionAvailable(0x0700);
+    if (!ok){
+        static bool messageWritten = false;
+        if (!messageWritten && qgetenv("PHONON_DEBUG") == "1"){
+            messageWritten = true;
+            QString str("WARNING: Phonon backend plugin need QuickTime 7 or newer to work.");
+            str += " This computer has version "
+                + BackendInfo::quickTimeVersionString()
+                + " installed.";
+            qWarning(str.toAscii().data());
+        }
+        return false;
+    }
+    return true;
+}
+
+QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
+{
+    if (!quickTime7Available())
+        return 0;
+        
+    switch (c) {
+    case MediaObjectClass:
+        IMPLEMENTED << "Creating new MediaObjectClass.";
+        return new MediaObject(parent);
+        break;
+    case VolumeFaderEffectClass:
+        IMPLEMENTED << "Creating new VolumeFaderEffectClass.";
+        return new AudioMixer(parent);
+        break;
+    case AudioOutputClass:
+        IMPLEMENTED << "Creating new AudioOutputClass.";
+        return new AudioOutput(parent);
+        break;
+    case AudioDataOutputClass:
+        NOT_IMPLEMENTED << "Creating new AudioDataOutputClass.";
+        break;
+    case VisualizationClass:
+        NOT_IMPLEMENTED << "Creating new VisualizationClass.";
+        break;
+    case VideoDataOutputClass:
+        NOT_IMPLEMENTED << "Creating new VideoDataOutputClass.";
+        break;
+    case EffectClass:
+        IMPLEMENTED << "Creating new EffectClass.";
+        return new AudioEffect(args[0].toInt());
+        break;
+    case VideoWidgetClass:
+        IMPLEMENTED << "Creating new VideoWidget.";
+        return new VideoWidget(parent);
+        break;
+    default:
+        return 0;
+    }
+    return 0;
+}
+
+bool Backend::startConnectionChange(QSet<QObject *> objects)
+{
+    IMPLEMENTED;
+    QList<AudioGraph *> notifiedGraphs;
+    for (int i=0; i<objects.size(); i++){
+        MediaNode *node = qobject_cast<MediaNode*>(objects.values()[i]);
+        if (node && node->m_audioGraph && !notifiedGraphs.contains(node->m_audioGraph)){
+            MediaNodeEvent event(MediaNodeEvent::StartConnectionChange);
+            node->m_audioGraph->notify(&event);
+            notifiedGraphs << node->m_audioGraph;
+        }
+    }        
+    return true;
+}
+
+bool Backend::endConnectionChange(QSet<QObject *> objects)
+{
+    IMPLEMENTED;
+    QList<AudioGraph *> notifiedGraphs;
+    for (int i=0; i<objects.size(); i++){
+        MediaNode *node = qobject_cast<MediaNode*>(objects.values()[i]);
+        if (node && node->m_audioGraph && !notifiedGraphs.contains(node->m_audioGraph)){
+            MediaNodeEvent event(MediaNodeEvent::EndConnectionChange);
+            node->m_audioGraph->notify(&event);
+            notifiedGraphs << node->m_audioGraph;
+        }
+    }
+    return true;
+}
+
+bool Backend::connectNodes(QObject *aSource, QObject *aSink)
+{
+    IMPLEMENTED;
+    MediaNode *source = qobject_cast<MediaNode*>(aSource);
+    if (!source) return false;
+    MediaNode *sink = qobject_cast<MediaNode*>(aSink);
+    if (!sink) return false;
+
+    return source->connectToSink(sink);
+}
+
+
+bool Backend::disconnectNodes(QObject *aSource, QObject *aSink)
+{
+    IMPLEMENTED;
+    MediaNode *source = qobject_cast<MediaNode*>(aSource);
+    if (!source) return false;
+    MediaNode *sink = qobject_cast<MediaNode*>(aSink);
+    if (!sink) return false;
+
+    return source->disconnectToSink(sink);
+}
+
+
+QStringList Backend::availableMimeTypes() const
+{
+    IMPLEMENTED;
+    return BackendInfo::quickTimeMimeTypes(BackendInfo::In);
+}
+
+/**
+* Returns a set of indexes that acts as identifiers for the various properties
+* this backend supports for the given ObjectDescriptionType.
+* More information for a given property/index can be
+* looked up in Backend::objectDescriptionProperties(...).
+*/
+QList<int> Backend::objectDescriptionIndexes(ObjectDescriptionType type) const
+{
+    QList<int> ret;
+
+    switch (type){
+    case AudioOutputDeviceType:{
+        IMPLEMENTED_SILENT << "Creating index set for type: AudioOutputDeviceType";
+        QList<AudioDeviceID> devices = AudioDevice::devices(AudioDevice::Out);
+        for (int i=0; i<devices.size(); i++)
+            ret << int(devices[i]);
+        break; }
+    case EffectType:{
+        IMPLEMENTED_SILENT << "Creating index set for type: EffectType";
+        if (QuickTimeAudioPlayer::soundPlayerIsAwailable())
+            ret = AudioEffect::effectList();
+        break; }
+        
+#if 0 // will be awailable in a later version of phonon.
+    case AudioCaptureDeviceType:{
+        IMPLEMENTED_SILENT << "Creating index set for type: AudioCaptureDeviceType";
+        QList<AudioDeviceID> devices = AudioDevice::devices(AudioDevice::In).keys();
+        for (int i=0; i<devices.size(); i++)
+            ret <<int(devices[i]);
+        break; }
+    case VideoEffectType:{
+        // Just count the number of filters awailable (c), and
+        // add return a set with the numbers 1..c inserted:
+        IMPLEMENTED_SILENT << "Creating index set for type: VideoEffectType";
+        QList<QtCore/QString> filters = objc_getCiFilterInfo()->filterDisplayNames;
+        for (int i=0; i<filters.size(); i++)
+            ret << insert(i);
+        break; }
+#endif
+    default:
+        NOT_IMPLEMENTED;
+        break;
+    }
+    return ret;
+}
+
+QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(ObjectDescriptionType type, int index) const
+{
+    QHash<QByteArray, QVariant> ret;
+
+    switch (type){
+    case AudioOutputDeviceType:{
+        IMPLEMENTED_SILENT << "Creating description hash for type: AudioOutputDeviceType";
+        ret.insert("name", AudioDevice::deviceSourceNameElseDeviceName(index));
+        ret.insert("description", AudioDevice::deviceNameElseDeviceSourceName(index));
+        break; }
+    case EffectType:{
+        AudioEffect e(index);
+        ret.insert("name", e.name());
+        ret.insert("description", e.description());
+        break; }
+        
+#if 0 // will be awailable in a later version of phonon.
+    case VideoEffectType:{
+        // Get list of effects, pick out filter at index, and return its name:
+        IMPLEMENTED_SILENT << "Creating description hash for type: VideoEffectType";
+        QList<QtCore/QString> filters = objc_getCiFilterInfo()->filterDisplayNames;
+        ret.insert("name", filters[index]);
+    case AudioCaptureDeviceType:{
+        IMPLEMENTED_SILENT << "Creating description hash for type: AudioCaptureDeviceType";
+        QMap<AudioDeviceID, QString> devices = AudioDevice::devices(AudioDevice::In);
+        ret.insert("name", devices.value(index));
+        break; }
+#endif
+    default:
+        NOT_IMPLEMENTED;
+        break;
+    }
+
+    return ret;
+}
+
+Q_EXPORT_PLUGIN2(phonon_qt7, Backend)
+}}
+
+QT_END_NAMESPACE
+
+#include "moc_backend.cpp"
+
diff -r -U2 -N phonon-4.3.0/qt7/CMakeLists.txt phonon-4.3.0/qt7/CMakeLists.txt
--- phonon-4.3.0/qt7/CMakeLists.txt	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/CMakeLists.txt	2009-03-03 08:50:22.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2007 Trolltech ASA. All rights reserved.
+# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 #
 # This library is free software: you can redistribute it and/or modify
@@ -15,27 +15,30 @@
 include(ConfigureChecks.cmake)
 
+include_directories(${OPENGL_INCLUDE_DIR})
+
 if (BUILD_PHONON_QT7)
     set(phonon_qt7_SRCS
-        medianode.cpp
-        backend.cpp
-        videowidget.cpp
-        mediaobject.cpp
-        quicktimevideoplayer.cpp
-	displaylinkcallback.cpp
-        error.cpp
-	medianodevideopart.cpp
-        medianodeevent.cpp
-        quicktimeaudioplayer.cpp
-	audionode.cpp
-        audiograph.cpp
-        audiooutput.cpp
-        quicktimemetadata.cpp
-   	audiomixer.cpp
-        audiodevice.cpp
-        backendinfo.cpp
-        audioconnection.cpp
-   	videoframe.cpp
-        audiosplitter.cpp
-        mediaobjectaudionode.cpp
+        quicktimevideoplayer.mm
+        backendheader.mm 
+        medianodevideopart.mm 
+        medianodeevent.mm 
+        audiooutput.mm 
+        backendinfo.mm 
+        audiosplitter.mm 
+        audioeffects.mm 
+        quicktimestreamreader.mm 
+        medianode.mm 
+        backend.mm 
+        mediaobject.mm 
+        mediaobjectaudionode.mm 
+        audiomixer.mm  
+        quicktimeaudioplayer.mm 
+        videoframe.mm 
+        quicktimemetadata.mm 
+        audiodevice.mm 
+        audioconnection.mm 
+        audiograph.mm 
+        audionode.mm 
+        videowidget.mm
        )
 
@@ -43,15 +46,13 @@
    target_link_libraries(phonon_qt7
        ${QT_QTGUI_LIBRARY} ${QT_QTOPENGL_LIBRARY}
-       "-framework phonon"
+       ${PHONON_LIBS}
        "-framework QuickTime"
-       "-framework OpenGL"
        "-framework AudioUnit"
        "-framework AudioToolbox"
        "-framework CoreAudio"
-       "-framework Quartz"
-#      "-framework AGL"
+       "-framework QuartzCore"
+       "-framework QTKit"
        )
     install(TARGETS phonon_qt7 DESTINATION ${PLUGIN_INSTALL_DIR})
-    #install(FILES qt7.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
 
 endif (BUILD_PHONON_QT7)
diff -r -U2 -N phonon-4.3.0/qt7/ConfigureChecks.cmake phonon-4.3.0/qt7/ConfigureChecks.cmake
--- phonon-4.3.0/qt7/ConfigureChecks.cmake	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/ConfigureChecks.cmake	2009-02-26 05:48:10.000000000 -0700
@@ -1,3 +1,3 @@
-# Copyright (C) 2007 Trolltech ASA. All rights reserved.
+# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 #
 # This library is free software: you can redistribute it and/or modify
diff -r -U2 -N phonon-4.3.0/qt7/displaylinkcallback.cpp phonon-4.3.0/qt7/displaylinkcallback.cpp
--- phonon-4.3.0/qt7/displaylinkcallback.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/displaylinkcallback.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,97 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "displaylinkcallback.h"
-#include "backendheader.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-CVDisplayLinkRef DisplayLinkCallback::m_displayLink = 0;
-int DisplayLinkCallback::m_refCount = 0;
-CVTimeStamp DisplayLinkCallback::m_timeStamp;
-bool DisplayLinkCallback::m_initialized = false;
-
-static CVReturn displayLinkCallback(CVDisplayLinkRef /*displayLink*/,
-								 const CVTimeStamp */*inNow*/,
-								 const CVTimeStamp */*inOutputTime*/,
-								 CVOptionFlags /*flagsIn*/,
-								 CVOptionFlags */*flagsOut*/,
-                                 void */*displayLinkContext*/)
-{
-    return kCVReturnSuccess;
-}
-
-CVTimeStamp LinkTimeProxy::getCVTimeStamp() const
-{
-    return m_timeStamp;
-}
-
-void LinkTimeProxy::setCVTimeStamp(const CVTimeStamp &timeStamp)
-{
-    m_timeStamp = timeStamp;
-}
-
-LinkTimeProxy DisplayLinkCallback::currentTime()
-{
-    LinkTimeProxy proxy;
-    CVDisplayLinkGetCurrentTime(m_displayLink, &m_timeStamp);
-    proxy.setCVTimeStamp(m_timeStamp);
-    return proxy;
-}
-
-void DisplayLinkCallback::retain()
-{
-    ++m_refCount;
-    if (m_initialized)
-        return;
-
-    // First subscriber. Initialize:
-    m_initialized = true;
-    memset(&m_timeStamp, 0, sizeof(m_timeStamp));
-    OSStatus err = EnterMovies();
-    BACKEND_ASSERT2(err == noErr, "Could not initialize QuickTime", FATAL_ERROR)
-    err = CVDisplayLinkCreateWithCGDisplay(kCGDirectMainDisplay, &m_displayLink);
-	BACKEND_ASSERT2(err == noErr, "Could not create display link", FATAL_ERROR)
-    err = CVDisplayLinkSetCurrentCGDisplay(m_displayLink, kCGDirectMainDisplay);
-	BACKEND_ASSERT2(err == noErr, "Could not set the current display for the display link", FATAL_ERROR)
-        err = CVDisplayLinkSetOutputCallback(m_displayLink, displayLinkCallback, 0);
-    BACKEND_ASSERT2(err == noErr, "Could not set the callback for the display link", FATAL_ERROR)
-    err = CVDisplayLinkStart(m_displayLink);
-	BACKEND_ASSERT2(err == noErr, "Could not start the display link", FATAL_ERROR)
-}
-
-void DisplayLinkCallback::release()
-{
-    BACKEND_ASSERT2(m_refCount > 0, "Release called for display link with refcount < 1", NORMAL_ERROR)
-    --m_refCount;
-    if (m_refCount == 0){
-        CVDisplayLinkStop(m_displayLink);
-        CFRelease(m_displayLink);
-        m_displayLink = 0;
-        ExitMovies();
-        m_initialized = false;
-    }
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/displaylinkcallback.h phonon-4.3.0/qt7/displaylinkcallback.h
--- phonon-4.3.0/qt7/displaylinkcallback.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/displaylinkcallback.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,62 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef Phonon_QT7_DISPLAYLINKCALLBACK_H
-#define Phonon_QT7_DISPLAYLINKCALLBACK_H
-
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
-#include <QObject>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-    // Hide the fact that CoreVideo is beeing
-    // used to support panther:
-    class LinkTimeProxy
-    {
-        public:
-            CVTimeStamp getCVTimeStamp() const;
-            void setCVTimeStamp(const CVTimeStamp &timeStamp);
-            
-        private:
-            CVTimeStamp m_timeStamp;
-    };
-
-    class DisplayLinkCallback
-    {
-        public:
-            static void retain();
-            static void release();
-            static LinkTimeProxy currentTime();
-
-        private:
-            static CVDisplayLinkRef m_displayLink;
-            static int m_refCount;
-            static CVTimeStamp m_timeStamp;
-            static bool m_initialized;
-    };
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#endif // Phonon_QT7_DISPLAYLINKCALLBACK_H
diff -r -U2 -N phonon-4.3.0/qt7/error.cpp phonon-4.3.0/qt7/error.cpp
--- phonon-4.3.0/qt7/error.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/error.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,76 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "backendheader.h"
-#include <QString>
-#include <QDebug>
- 
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-Q_GLOBAL_STATIC(QString, gErrorString)
-int gErrorType = NO_ERROR;
-
-void gSetErrorString(const QString &errorString)
-{
-    if (qgetenv("PHONON_DEBUG") == "1"){
-        qDebug() << "Error:" << errorString;
-    }
-
-    if (!gErrorString()->isEmpty())
-        return; // not yet caught.
-        
-    *gErrorString() = errorString;   
-}
-
-QString gGetErrorString()
-{
-    return *gErrorString();
-}
-
-void gSetErrorLocation(const QString &errorLocation)
-{
-    if (qgetenv("PHONON_DEBUG") == "1"){
-        qDebug() << "Location:" << errorLocation;
-    }
-}
-
-void gSetErrorType(int errorType)
-{
-    if (gErrorType != NO_ERROR)
-        return; // not yet caught.
-    gErrorType = errorType;
-}
-
-int gGetErrorType()
-{
-    return gErrorType;
-}
-
-void gClearError()
-{
-    gErrorString()->clear();
-    gErrorType = NO_ERROR;
-}
-
-}}
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/medianode.cpp phonon-4.3.0/qt7/medianode.cpp
--- phonon-4.3.0/qt7/medianode.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianode.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,261 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "medianode.h"
-#include "audiograph.h"
-#include "audionode.h"
-#include "backendheader.h"
-
-#include "mediaobject.h"
-#include "audiooutput.h"
-#include "quicktimevideoplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-MediaNode::MediaNode(NodeDescription description, QObject *parent)
-    : QObject(parent), m_audioGraph(0), m_audioNode(0), m_description(description), m_owningMediaObject(0)
-{
-}
-
-MediaNode::MediaNode(NodeDescription description, AudioNode *audioPart, QObject *parent)
-    : QObject(parent), m_audioGraph(0), m_audioNode(audioPart), m_description(description)
-{
-}
-
-void MediaNode::setAudioNode(AudioNode *audioPart)
-{
-    if (m_audioNode)
-        delete m_audioNode;
-    m_audioNode = audioPart;
-}
-
-MediaNode::~MediaNode()
-{
-   delete m_audioNode;
-   qDeleteAll(m_audioSinkList);
-}
-
-AudioConnection *MediaNode::getAudioConnectionToSink(MediaNode *sink)
-{
-    AudioConnection *connection = 0;
-    for (int i=0; i<m_audioSinkList.size(); ++i){
-        if (m_audioSinkList[i]->isBetween(this, sink)){
-            connection = m_audioSinkList[i];
-            break;
-        }
-    }
-    return connection;
-}
-
-bool MediaNode::connectToSink(MediaNode *sink)
-{
-    if ((m_description & AudioSource) && (sink->m_description & AudioSink)){
-        // Check that they don't belong to different graphs. If they do, but
-        // sink is not connected to any source, accept it:
-        if (m_owningMediaObject && sink->m_owningMediaObject
-            && m_owningMediaObject != sink->m_owningMediaObject
-            && !sink->m_audioSourceList.isEmpty()){
-            return false;
-        }
-
-        // Check that the connection doesn't already exists:
-        AudioConnection *connection = getAudioConnectionToSink(sink);
-        if (connection)
-            return true;
-
-        // Check that there are awailable input/output busses:
-        int inputBus = sink->availableAudioInputBus();
-        int outputBus = availableAudioOutputBus();
-        if (inputBus >= sink->m_audioNode->m_maxInputBusses || outputBus >= m_audioNode->m_maxOutputBusses)
-            return false;
-
-        // All OK. Create connection:
-        connection = new AudioConnection(this, outputBus, sink, inputBus);
-        m_audioSinkList << connection;
-        sink->m_audioSourceList << connection;
-
-        if (m_audioNode->m_audioGraph)
-            m_audioNode->m_audioGraph->connectLate(connection);
-
-        MediaNodeEvent event1(MediaNodeEvent::AudioSinkAdded, connection);
-        notify(&event1, false);
-        MediaNodeEvent event2(MediaNodeEvent::AudioSourceAdded, connection);
-        sink->notify(&event2, false);
-        return true;
-    }
-
-    if ((m_description & VideoSource) && (sink->m_description & VideoSink)){
-        // Check that the connection doesn't already exists:
-        if (m_videoSinkList.contains(sink))
-            return true;
-
-        m_videoSinkList << sink;
-        MediaNodeEvent event1(MediaNodeEvent::VideoSinkAdded, sink);
-        notify(&event1, false);
-        MediaNodeEvent event2(MediaNodeEvent::VideoSourceAdded, this);
-        sink->notify(&event2, false);
-        return true;
-    }
-
-    return false;
-}
-
-bool MediaNode::disconnectToSink(MediaNode *sink)
-{
-    if ((m_description & AudioSource) && (sink->m_description & AudioSink)){
-        AudioConnection *connection = getAudioConnectionToSink(sink);
-        if (!connection)
-            return false;
-
-        m_audioSinkList.removeOne(connection);
-        sink->m_audioSourceList.removeOne(connection);
-
-        if (m_audioNode->m_audioGraph)
-            m_audioNode->m_audioGraph->disconnectLate(connection);
-
-        MediaNodeEvent event1(MediaNodeEvent::AudioSinkRemoved, connection);
-        notify(&event1, false);
-        MediaNodeEvent event2(MediaNodeEvent::AudioSourceRemoved, connection);
-        sink->notify(&event2, false);
-        
-        delete connection;
-        return true;
-    }
-
-    if ((m_description & VideoSource) && (sink->m_description & VideoSink)){
-        m_videoSinkList.removeOne(sink);
-
-        MediaNodeEvent event1(MediaNodeEvent::VideoSinkRemoved, sink);
-        notify(&event1, false);
-        MediaNodeEvent event2(MediaNodeEvent::VideoSourceRemoved, this);
-        sink->notify(&event2, false);
-        return true;
-    }
-
-    return false;
-}
-
-int MediaNode::availableAudioInputBus()
-{
-    // Scan through all the connection <u>in</u> to this
-    // node, and find an awailable index:
-    int index = -1;
-    bool available = false;
-
-    while (!available){
-        ++index;
-        available = true;
-        for (int i=0; i<m_audioSourceList.size(); ++i){
-            if (m_audioSourceList[i]->m_sinkInputBus == index){
-                available = false;
-                break;
-            }
-        }
-    }
-    return index;
-}
-
-int MediaNode::availableAudioOutputBus()
-{
-    // Scan through all the connection <u>out</u> from this
-    // node, and find an awailable index:
-    int bus = -1;
-    bool available = false;
-
-    while (!available){
-        ++bus;
-        available = true;
-        for (int i=0; i<m_audioSinkList.size(); ++i){
-            if (m_audioSinkList[i]->m_sourceOutputBus == bus){
-                available = false;
-                break;
-            }
-        }
-    }
-    return bus;
-}
-
-void MediaNode::notify(const MediaNodeEvent *event, bool propagate)
-{
-    // Let subclass handle the event first:
-    mediaNodeEvent(event);
-
-    switch(event->type()){
-    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
-        if (m_audioNode){
-            foreach(AudioConnection *connection, m_audioSinkList)
-                connection->invalidate();
-        }
-        break;
-    case MediaNodeEvent::NewAudioGraph:
-        m_audioGraph = static_cast<AudioGraph *>(event->data());
-        break;
-    case MediaNodeEvent::AudioSinkAdded:
-    case MediaNodeEvent::VideoSinkAdded:
-        if (m_owningMediaObject){
-            MediaNodeEvent e1(MediaNodeEvent::SetMediaObject, m_owningMediaObject);
-            sendEventToSinks(&e1);
-            QRect videoRect = m_owningMediaObject->videoPlayer()->videoRect();
-            MediaNodeEvent e2(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
-            sendEventToSinks(&e2);
-        }
-        break;
-    case MediaNodeEvent::SetMediaObject:
-        m_owningMediaObject = static_cast<MediaObject *>(event->data());
-        break;
-    default:
-        break;
-    }
-
-    // Inform the audio node as well:
-    if (m_audioNode)
-        m_audioNode->notify(event);
-
-    // And perhaps the sinks:
-    if (propagate)
-        sendEventToSinks(event);
-}
-
-void MediaNode::sendEventToSinks(const MediaNodeEvent *event)
-{
-    for (int i=0; i<m_audioSinkList.size(); ++i)
-        m_audioSinkList[i]->m_sink->notify(event);
-    for (int i=0; i<m_videoSinkList.size(); ++i)
-        m_videoSinkList[i]->notify(event);
-}
-
-void MediaNode::updateVideo(VideoFrame &frame){
-    for (int i=0; i<m_videoSinkList.size(); ++i)
-        m_videoSinkList[i]->updateVideo(frame);
-}
-
-void MediaNode::mediaNodeEvent(const MediaNodeEvent */*event*/)
-{
-   // Override if needed.
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_medianode.cpp"
-
diff -r -U2 -N phonon-4.3.0/qt7/medianodeevent.cpp phonon-4.3.0/qt7/medianodeevent.cpp
--- phonon-4.3.0/qt7/medianodeevent.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianodeevent.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,37 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "medianodeevent.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-MediaNodeEvent::MediaNodeEvent(Type type, void *data) : eventType(type), eventData(data)
-{
-}
-
-MediaNodeEvent::~MediaNodeEvent()
-{
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/medianodeevent.h phonon-4.3.0/qt7/medianodeevent.h
--- phonon-4.3.0/qt7/medianodeevent.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianodeevent.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_MEDIANODEEVENT_H
 
-#include <QtCore>
+#include <QtCore/qnamespace.h>
 
 QT_BEGIN_NAMESPACE
@@ -47,8 +47,10 @@
                 AudioSourceAdded,
                 AudioSourceRemoved,
+				VideoOutputCountChanged,
                 VideoFrameSizeChanged,
                 SetMediaObject,
                 StartConnectionChange,
-                EndConnectionChange
+                EndConnectionChange,
+				MediaPlaying
             };
 
diff -r -U2 -N phonon-4.3.0/qt7/medianodeevent.mm phonon-4.3.0/qt7/medianodeevent.mm
--- phonon-4.3.0/qt7/medianodeevent.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/medianodeevent.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,37 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "medianodeevent.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+MediaNodeEvent::MediaNodeEvent(Type type, void *data) : eventType(type), eventData(data)
+{
+}
+
+MediaNodeEvent::~MediaNodeEvent()
+{
+}
+
+}} // namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/medianode.h phonon-4.3.0/qt7/medianode.h
--- phonon-4.3.0/qt7/medianode.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianode.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_MediaNode_H
 
-#include <QObject>
+#include <QtCore/QObject>
 #include "backendheader.h"
 #include "medianodeevent.h"
diff -r -U2 -N phonon-4.3.0/qt7/medianode.mm phonon-4.3.0/qt7/medianode.mm
--- phonon-4.3.0/qt7/medianode.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/medianode.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,261 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "medianode.h"
+#include "audiograph.h"
+#include "audionode.h"
+#include "backendheader.h"
+
+#include "mediaobject.h"
+#include "audiooutput.h"
+#include "quicktimevideoplayer.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+MediaNode::MediaNode(NodeDescription description, QObject *parent)
+    : QObject(parent), m_audioGraph(0), m_audioNode(0), m_description(description), m_owningMediaObject(0)
+{
+}
+
+MediaNode::MediaNode(NodeDescription description, AudioNode *audioPart, QObject *parent)
+    : QObject(parent), m_audioGraph(0), m_audioNode(audioPart), m_description(description)
+{
+}
+
+void MediaNode::setAudioNode(AudioNode *audioPart)
+{
+    if (m_audioNode)
+        delete m_audioNode;
+    m_audioNode = audioPart;
+}
+
+MediaNode::~MediaNode()
+{
+   delete m_audioNode;
+   qDeleteAll(m_audioSinkList);
+}
+
+AudioConnection *MediaNode::getAudioConnectionToSink(MediaNode *sink)
+{
+    AudioConnection *connection = 0;
+    for (int i=0; i<m_audioSinkList.size(); ++i){
+        if (m_audioSinkList[i]->isBetween(this, sink)){
+            connection = m_audioSinkList[i];
+            break;
+        }
+    }
+    return connection;
+}
+
+bool MediaNode::connectToSink(MediaNode *sink)
+{
+    if ((m_description & AudioSource) && (sink->m_description & AudioSink)){
+        // Check that they don't belong to different graphs. If they do, but
+        // sink is not connected to any source, accept it:
+        if (m_owningMediaObject && sink->m_owningMediaObject
+            && m_owningMediaObject != sink->m_owningMediaObject
+            && !sink->m_audioSourceList.isEmpty()){
+            return false;
+        }
+
+        // Check that the connection doesn't already exists:
+        AudioConnection *connection = getAudioConnectionToSink(sink);
+        if (connection)
+            return true;
+
+        // Check that there are awailable input/output busses:
+        int inputBus = sink->availableAudioInputBus();
+        int outputBus = availableAudioOutputBus();
+        if (inputBus >= sink->m_audioNode->m_maxInputBusses || outputBus >= m_audioNode->m_maxOutputBusses)
+            return false;
+
+        // All OK. Create connection:
+        connection = new AudioConnection(this, outputBus, sink, inputBus);
+        m_audioSinkList << connection;
+        sink->m_audioSourceList << connection;
+
+        if (m_audioNode->m_audioGraph)
+            m_audioNode->m_audioGraph->connectLate(connection);
+
+        MediaNodeEvent event1(MediaNodeEvent::AudioSinkAdded, connection);
+        notify(&event1, false);
+        MediaNodeEvent event2(MediaNodeEvent::AudioSourceAdded, connection);
+        sink->notify(&event2, false);
+        return true;
+    }
+
+    if ((m_description & VideoSource) && (sink->m_description & VideoSink)){
+        // Check that the connection doesn't already exists:
+        if (m_videoSinkList.contains(sink))
+            return true;
+
+        m_videoSinkList << sink;
+        MediaNodeEvent event1(MediaNodeEvent::VideoSinkAdded, sink);
+        notify(&event1, false);
+        MediaNodeEvent event2(MediaNodeEvent::VideoSourceAdded, this);
+        sink->notify(&event2, false);
+        return true;
+    }
+
+    return false;
+}
+
+bool MediaNode::disconnectToSink(MediaNode *sink)
+{
+    if ((m_description & AudioSource) && (sink->m_description & AudioSink)){
+        AudioConnection *connection = getAudioConnectionToSink(sink);
+        if (!connection)
+            return false;
+
+        m_audioSinkList.removeOne(connection);
+        sink->m_audioSourceList.removeOne(connection);
+
+        if (m_audioNode->m_audioGraph)
+            m_audioNode->m_audioGraph->disconnectLate(connection);
+
+        MediaNodeEvent event1(MediaNodeEvent::AudioSinkRemoved, connection);
+        notify(&event1, false);
+        MediaNodeEvent event2(MediaNodeEvent::AudioSourceRemoved, connection);
+        sink->notify(&event2, false);
+        
+        delete connection;
+        return true;
+    }
+
+    if ((m_description & VideoSource) && (sink->m_description & VideoSink)){
+        m_videoSinkList.removeOne(sink);
+
+        MediaNodeEvent event1(MediaNodeEvent::VideoSinkRemoved, sink);
+        notify(&event1, false);
+        MediaNodeEvent event2(MediaNodeEvent::VideoSourceRemoved, this);
+        sink->notify(&event2, false);
+        return true;
+    }
+
+    return false;
+}
+
+int MediaNode::availableAudioInputBus()
+{
+    // Scan through all the connection <u>in</u> to this
+    // node, and find an awailable index:
+    int index = -1;
+    bool available = false;
+
+    while (!available){
+        ++index;
+        available = true;
+        for (int i=0; i<m_audioSourceList.size(); ++i){
+            if (m_audioSourceList[i]->m_sinkInputBus == index){
+                available = false;
+                break;
+            }
+        }
+    }
+    return index;
+}
+
+int MediaNode::availableAudioOutputBus()
+{
+    // Scan through all the connection <u>out</u> from this
+    // node, and find an awailable index:
+    int bus = -1;
+    bool available = false;
+
+    while (!available){
+        ++bus;
+        available = true;
+        for (int i=0; i<m_audioSinkList.size(); ++i){
+            if (m_audioSinkList[i]->m_sourceOutputBus == bus){
+                available = false;
+                break;
+            }
+        }
+    }
+    return bus;
+}
+
+void MediaNode::notify(const MediaNodeEvent *event, bool propagate)
+{
+    // Let subclass handle the event first:
+    mediaNodeEvent(event);
+
+    switch(event->type()){
+    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
+        if (m_audioNode){
+            foreach(AudioConnection *connection, m_audioSinkList)
+                connection->invalidate();
+        }
+        break;
+    case MediaNodeEvent::NewAudioGraph:
+        m_audioGraph = static_cast<AudioGraph *>(event->data());
+        break;
+    case MediaNodeEvent::AudioSinkAdded:
+    case MediaNodeEvent::VideoSinkAdded:
+        if (m_owningMediaObject){
+            MediaNodeEvent e1(MediaNodeEvent::SetMediaObject, m_owningMediaObject);
+            sendEventToSinks(&e1);
+            QRect videoRect = m_owningMediaObject->videoPlayer()->videoRect();
+            MediaNodeEvent e2(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
+            sendEventToSinks(&e2);
+        }
+        break;
+    case MediaNodeEvent::SetMediaObject:
+        m_owningMediaObject = static_cast<MediaObject *>(event->data());
+        break;
+    default:
+        break;
+    }
+
+    // Inform the audio node as well:
+    if (m_audioNode)
+        m_audioNode->notify(event);
+
+    // And perhaps the sinks:
+    if (propagate)
+        sendEventToSinks(event);
+}
+
+void MediaNode::sendEventToSinks(const MediaNodeEvent *event)
+{
+    for (int i=0; i<m_audioSinkList.size(); ++i)
+        m_audioSinkList[i]->m_sink->notify(event);
+    for (int i=0; i<m_videoSinkList.size(); ++i)
+        m_videoSinkList[i]->notify(event);
+}
+
+void MediaNode::updateVideo(VideoFrame &frame){
+    for (int i=0; i<m_videoSinkList.size(); ++i)
+        m_videoSinkList[i]->updateVideo(frame);
+}
+
+void MediaNode::mediaNodeEvent(const MediaNodeEvent */*event*/)
+{
+   // Override if needed.
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_medianode.cpp"
+
diff -r -U2 -N phonon-4.3.0/qt7/medianodevideopart.cpp phonon-4.3.0/qt7/medianodevideopart.cpp
--- phonon-4.3.0/qt7/medianodevideopart.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianodevideopart.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,37 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "medianodevideopart.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-MediaNodeVideoPart::MediaNodeVideoPart()
-{
-}
-
-MediaNodeVideoPart::~MediaNodeVideoPart()
-{
-}
-
-}}
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/medianodevideopart.h phonon-4.3.0/qt7/medianodevideopart.h
--- phonon-4.3.0/qt7/medianodevideopart.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/medianodevideopart.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_MEDIANODEVIDEOPART_H
 
-#include <QtCore>
+#include <QtCore/qnamespace.h>
 #include "backendheader.h"
 
@@ -33,5 +33,4 @@
         MediaNodeVideoPart();
         virtual ~MediaNodeVideoPart();
-
         virtual void updateVideo(void *ciImage) = 0;
     };
diff -r -U2 -N phonon-4.3.0/qt7/medianodevideopart.mm phonon-4.3.0/qt7/medianodevideopart.mm
--- phonon-4.3.0/qt7/medianodevideopart.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/medianodevideopart.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,37 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "medianodevideopart.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+MediaNodeVideoPart::MediaNodeVideoPart()
+{
+}
+
+MediaNodeVideoPart::~MediaNodeVideoPart()
+{
+}
+
+}}
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/mediaobjectaudionode.cpp phonon-4.3.0/qt7/mediaobjectaudionode.cpp
--- phonon-4.3.0/qt7/mediaobjectaudionode.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobjectaudionode.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,207 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "mediaobjectaudionode.h"
-#include "quicktimeaudioplayer.h"
-#include "quicktimevideoplayer.h"
-#include "audiomixer.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-MediaObjectAudioNode::MediaObjectAudioNode(QuickTimeAudioPlayer *player1, QuickTimeAudioPlayer *player2) : AudioNode(0, 1)
-{
-    m_mute = false;
-    m_player1 = player1;
-    m_player2 = player2;
-    m_mixer = new AudioMixerAudioNode();
-
-    m_connection1 = new AudioConnection(m_player1, 0, m_mixer, 0);
-    m_connection2 = new AudioConnection(m_player2, 0, m_mixer, 1);
-
-    m_fadeDuration = 0;
-}
-
-MediaObjectAudioNode::~MediaObjectAudioNode()
-{
-    setGraph(0);
-    delete m_player1;
-    delete m_player2;
-    delete m_mixer;
-    delete m_connection1;
-    delete m_connection2;
-}
-
-void MediaObjectAudioNode::createAndConnectAUNodes()
-{
-    DEBUG_AUDIO_GRAPH("(MediaObjectAudioNode" << int(this) << "createAndConnectAUNodes called)" )
-    m_player1->createAndConnectAUNodes();
-    m_player2->createAndConnectAUNodes();
-    m_mixer->createAndConnectAUNodes();
-
-    m_connection1->connect(m_audioGraph);
-    m_connection2->connect(m_audioGraph);
-}
-
-void MediaObjectAudioNode::createAudioUnits()
-{
-    DEBUG_AUDIO_GRAPH("(MediaObjectAudioNode" << int(this) << "createAudioUnits called)" )
-    m_player1->createAudioUnits();
-    m_player2->createAudioUnits();
-    m_mixer->createAudioUnits();
-}
-
-void MediaObjectAudioNode::setGraph(AudioGraph *audioGraph)
-{
-    DEBUG_AUDIO_GRAPH("MediaObjectAudioNode" << int(this) << "is setting graph:" << int(audioGraph))
-    m_audioGraph = audioGraph;
-    m_player1->setGraph(audioGraph);
-    m_player2->setGraph(audioGraph);
-    m_mixer->setGraph(audioGraph);
-}
-
-AUNode MediaObjectAudioNode::getOutputAUNode()
-{
-    return m_mixer->getOutputAUNode();
-}
-
-bool MediaObjectAudioNode::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
-{
-    if (side == Source){
-        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "fillInStreamSpecification called, role = source)")
-        return m_mixer->fillInStreamSpecification(connection, side);
-    } else {
-        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "fillInStreamSpecification called, role = sink)")
-        return (m_connection2->updateStreamSpecification() && m_connection1->updateStreamSpecification());
-    }
-}
-
-bool MediaObjectAudioNode::setStreamSpecification(AudioConnection *connection, ConnectionSide side)
-{
-    if (side == Source){
-        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "setStreamSpecification called, role = source)")
-        return m_mixer->setStreamSpecification(connection, side);
-    }
-    return true;
-}
-
-void MediaObjectAudioNode::setMute(bool mute)
-{
-    m_mute = mute;
-    m_mixer->setVolume(m_mute ? 0 : m_volume1, m_connection1->m_sinkInputBus);
-    m_mixer->setVolume(m_mute ? 0 : m_volume2, m_connection2->m_sinkInputBus);
-}
-
-void MediaObjectAudioNode::updateVolume()
-{
-    if (m_mute)
-        return;
-        
-    QuickTimeVideoPlayer *player1 = static_cast<QuickTimeAudioPlayer *>(m_connection1->m_sourceAudioNode)->videoPlayer();
-    QuickTimeVideoPlayer *player2 = static_cast<QuickTimeAudioPlayer *>(m_connection2->m_sourceAudioNode)->videoPlayer();
-    if (player1)
-        player1->setRelativeVolume(m_volume1);
-    if (player2)
-        player2->setRelativeVolume(m_volume2);
-
-    m_mixer->setVolume(m_volume1, m_connection1->m_sinkInputBus);
-    m_mixer->setVolume(m_volume2, m_connection2->m_sinkInputBus);
-}
-
-void MediaObjectAudioNode::startCrossFade(qint64 duration)
-{
-    m_fadeDuration = duration;
-
-    // Swap:
-    AudioConnection *tmp = m_connection1;
-    m_connection1 = m_connection2;
-    m_connection2 = tmp;
-
-    // Init volume:
-    if (m_fadeDuration > 0){
-        m_volume1 = 0;
-        m_volume2 = 1;
-    } else {
-        m_volume1 = 1;
-        m_volume2 = 0;
-    }
-    updateVolume();
-}
-
-float MediaObjectAudioNode::applyCurve(float volume)
-{
-    float newValue = 0;
-    if (volume > 0)
-        newValue = float(0.5f * (2 + log10(volume)));
-    return newValue;
-}
-
-void MediaObjectAudioNode::updateCrossFade(qint64 currentTime)
-{
-    // Assume that currentTime starts at 0 and progress.
-    if (m_fadeDuration > 0){
-        float volume = float(currentTime) / float(m_fadeDuration);
-        if (volume >= 1){
-            volume = 1;
-            m_fadeDuration = 0;
-        }
-        m_volume1 = applyCurve(volume);
-        m_volume2 = 1 - volume;
-        updateVolume();
-    }
-}
-
-bool MediaObjectAudioNode::isCrossFading()
-{
-    return (m_fadeDuration > 0);
-}
-
-void MediaObjectAudioNode::cancelCrossFade()
-{
-    m_fadeDuration = 0;
-    m_volume1 = 1;
-    m_volume2 = 0;
-    updateVolume();
-}
-
-void MediaObjectAudioNode::mediaNodeEvent(const MediaNodeEvent *event)
-{
-    switch (event->type()){
-    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
-        m_connection1->invalidate();
-        m_connection2->invalidate();
-        break;
-    case MediaNodeEvent::AudioGraphCannotPlay:
-    case MediaNodeEvent::AudioGraphInitialized:
-        updateVolume();
-        break;
-    default:
-        break;
-    }
-
-    m_player1->mediaNodeEvent(event);
-    m_player2->mediaNodeEvent(event);
-    m_mixer->mediaNodeEvent(event);
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/mediaobjectaudionode.h phonon-4.3.0/qt7/mediaobjectaudionode.h
--- phonon-4.3.0/qt7/mediaobjectaudionode.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobjectaudionode.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,5 @@
 #define Phonon_QT7_MEDIAOBJECTAUDIONODE_H
 
-#include <QtCore>
+#include <QtCore/qnamespace.h>
 #include "audionode.h"
 
@@ -51,5 +51,5 @@
             void setMute(bool mute);
             bool isCrossFading();
-            
+
             QuickTimeAudioPlayer *m_player1;
             QuickTimeAudioPlayer *m_player2;
@@ -63,5 +63,5 @@
             float m_volume2;
             float m_mute;
-            
+
             float applyCurve(float volume);
             void updateVolume();
diff -r -U2 -N phonon-4.3.0/qt7/mediaobjectaudionode.mm phonon-4.3.0/qt7/mediaobjectaudionode.mm
--- phonon-4.3.0/qt7/mediaobjectaudionode.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobjectaudionode.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,207 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "mediaobjectaudionode.h"
+#include "quicktimeaudioplayer.h"
+#include "quicktimevideoplayer.h"
+#include "audiomixer.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+MediaObjectAudioNode::MediaObjectAudioNode(QuickTimeAudioPlayer *player1, QuickTimeAudioPlayer *player2) : AudioNode(0, 1)
+{
+    m_mute = false;
+    m_player1 = player1;
+    m_player2 = player2;
+    m_mixer = new AudioMixerAudioNode();
+
+    m_connection1 = new AudioConnection(m_player1, 0, m_mixer, 0);
+    m_connection2 = new AudioConnection(m_player2, 0, m_mixer, 1);
+
+    m_fadeDuration = 0;
+}
+
+MediaObjectAudioNode::~MediaObjectAudioNode()
+{
+    setGraph(0);
+    delete m_player1;
+    delete m_player2;
+    delete m_mixer;
+    delete m_connection1;
+    delete m_connection2;
+}
+
+void MediaObjectAudioNode::createAndConnectAUNodes()
+{
+    DEBUG_AUDIO_GRAPH("(MediaObjectAudioNode" << int(this) << "createAndConnectAUNodes called)" )
+    m_player1->createAndConnectAUNodes();
+    m_player2->createAndConnectAUNodes();
+    m_mixer->createAndConnectAUNodes();
+
+    m_connection1->connect(m_audioGraph);
+    m_connection2->connect(m_audioGraph);
+}
+
+void MediaObjectAudioNode::createAudioUnits()
+{
+    DEBUG_AUDIO_GRAPH("(MediaObjectAudioNode" << int(this) << "createAudioUnits called)" )
+    m_player1->createAudioUnits();
+    m_player2->createAudioUnits();
+    m_mixer->createAudioUnits();
+}
+
+void MediaObjectAudioNode::setGraph(AudioGraph *audioGraph)
+{
+    DEBUG_AUDIO_GRAPH("MediaObjectAudioNode" << int(this) << "is setting graph:" << int(audioGraph))
+    m_audioGraph = audioGraph;
+    m_player1->setGraph(audioGraph);
+    m_player2->setGraph(audioGraph);
+    m_mixer->setGraph(audioGraph);
+}
+
+AUNode MediaObjectAudioNode::getOutputAUNode()
+{
+    return m_mixer->getOutputAUNode();
+}
+
+bool MediaObjectAudioNode::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
+{
+    if (side == Source){
+        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "fillInStreamSpecification called, role = source)")
+        return m_mixer->fillInStreamSpecification(connection, side);
+    } else {
+        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "fillInStreamSpecification called, role = sink)")
+        return (m_connection2->updateStreamSpecification() && m_connection1->updateStreamSpecification());
+    }
+}
+
+bool MediaObjectAudioNode::setStreamSpecification(AudioConnection *connection, ConnectionSide side)
+{
+    if (side == Source){
+        DEBUG_AUDIO_STREAM("(MediaObjectAudioNode" << int(this) << "setStreamSpecification called, role = source)")
+        return m_mixer->setStreamSpecification(connection, side);
+    }
+    return true;
+}
+
+void MediaObjectAudioNode::setMute(bool mute)
+{
+    m_mute = mute;
+    m_mixer->setVolume(m_mute ? 0 : m_volume1, m_connection1->m_sinkInputBus);
+    m_mixer->setVolume(m_mute ? 0 : m_volume2, m_connection2->m_sinkInputBus);
+}
+
+void MediaObjectAudioNode::updateVolume()
+{
+    if (m_mute)
+        return;
+        
+    QuickTimeVideoPlayer *player1 = static_cast<QuickTimeAudioPlayer *>(m_connection1->m_sourceAudioNode)->videoPlayer();
+    QuickTimeVideoPlayer *player2 = static_cast<QuickTimeAudioPlayer *>(m_connection2->m_sourceAudioNode)->videoPlayer();
+    if (player1)
+        player1->setRelativeVolume(m_volume1);
+    if (player2)
+        player2->setRelativeVolume(m_volume2);
+
+    m_mixer->setVolume(m_volume1, m_connection1->m_sinkInputBus);
+    m_mixer->setVolume(m_volume2, m_connection2->m_sinkInputBus);
+}
+
+void MediaObjectAudioNode::startCrossFade(qint64 duration)
+{
+    m_fadeDuration = duration;
+
+    // Swap:
+    AudioConnection *tmp = m_connection1;
+    m_connection1 = m_connection2;
+    m_connection2 = tmp;
+
+    // Init volume:
+    if (m_fadeDuration > 0){
+        m_volume1 = 0;
+        m_volume2 = 1;
+    } else {
+        m_volume1 = 1;
+        m_volume2 = 0;
+    }
+    updateVolume();
+}
+
+float MediaObjectAudioNode::applyCurve(float volume)
+{
+    float newValue = 0;
+    if (volume > 0)
+        newValue = float(0.5f * (2 + log10(volume)));
+    return newValue;
+}
+
+void MediaObjectAudioNode::updateCrossFade(qint64 currentTime)
+{
+    // Assume that currentTime starts at 0 and progress.
+    if (m_fadeDuration > 0){
+        float volume = float(currentTime) / float(m_fadeDuration);
+        if (volume >= 1){
+            volume = 1;
+            m_fadeDuration = 0;
+        }
+        m_volume1 = applyCurve(volume);
+        m_volume2 = 1 - volume;
+        updateVolume();
+    }
+}
+
+bool MediaObjectAudioNode::isCrossFading()
+{
+    return (m_fadeDuration > 0);
+}
+
+void MediaObjectAudioNode::cancelCrossFade()
+{
+    m_fadeDuration = 0;
+    m_volume1 = 1;
+    m_volume2 = 0;
+    updateVolume();
+}
+
+void MediaObjectAudioNode::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    switch (event->type()){
+    case MediaNodeEvent::AudioGraphAboutToBeDeleted:
+        m_connection1->invalidate();
+        m_connection2->invalidate();
+        break;
+    case MediaNodeEvent::AudioGraphCannotPlay:
+    case MediaNodeEvent::AudioGraphInitialized:
+        updateVolume();
+        break;
+    default:
+        break;
+    }
+
+    m_player1->mediaNodeEvent(event);
+    m_player2->mediaNodeEvent(event);
+    m_mixer->mediaNodeEvent(event);
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/mediaobject.cpp phonon-4.3.0/qt7/mediaobject.cpp
--- phonon-4.3.0/qt7/mediaobject.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobject.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,825 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
-#include "mediaobject.h"
-#include "backendheader.h"
-#include "videowidget.h"
-#include "videoframe.h"
-#include "audiooutput.h"
-#include "quicktimeaudioplayer.h"
-#include "quicktimevideoplayer.h"
-#include "quicktimemetadata.h"
-#include "displaylinkcallback.h"
-#include "audiograph.h"
-#include "mediaobjectaudionode.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-MediaObject::MediaObject(QObject *parent) : MediaNode(AudioSource | VideoSource, parent)
-{
-    DisplayLinkCallback::retain();
-    m_owningMediaObject = this;
-    m_state = Phonon::LoadingState;
-
-    m_videoPlayer = new QuickTimeVideoPlayer();
-    m_audioPlayer = new QuickTimeAudioPlayer();
-    m_nextVideoPlayer = new QuickTimeVideoPlayer();
-    m_nextAudioPlayer = new QuickTimeAudioPlayer();
-    m_mediaObjectAudioNode = new MediaObjectAudioNode(m_audioPlayer, m_nextAudioPlayer);
-    setAudioNode(m_mediaObjectAudioNode);
-
-    m_metaData = new QuickTimeMetaData();
-    m_audioGraph = new AudioGraph(this);
-
-    m_tickInterval = 0;
-    m_prefinishMark = 0;
-    m_currentTime = 0;
-    m_transitionTime = 0;
-    m_percentageLoaded = 0;
-    m_waitNextSwap = false;
-    m_hasAudioEffects = false;
-    m_hasAudioOutputs = false;
-    m_audioSystem = AS_Unset;
-    m_errorType = Phonon::NoError;
-
-    m_tickTimer = 0;
-    m_bufferTimer = 0;
-    m_rapidTimer = 0;
-
-    checkForError();
-}
-
-MediaObject::~MediaObject()
-{   
-    // m_mediaObjectAudioNode is owned by super class.    
-    m_audioPlayer->unsetVideoPlayer();
-    m_nextAudioPlayer->unsetVideoPlayer();
-    delete m_videoPlayer;
-    delete m_nextVideoPlayer;
-    delete m_metaData;
-    DisplayLinkCallback::release();
-    checkForError();
-}
-
-bool MediaObject::setState(Phonon::State state)
-{
-    Phonon::State prevState = m_state;
-    m_state = state;
-    if (prevState != m_state){
-        emit stateChanged(m_state, prevState);
-        if (m_state != state){
-            // End-application did something
-            // upon  receiving the signal. 
-            return false;
-        }
-    }
-    return true;
-}
-
-void MediaObject::inspectGraphRecursive(AudioConnection *connection, bool &hasEffects, bool &hasOutputs)
-{
-    if ((connection->m_sink->m_description & (AudioSource | AudioSink)) == (AudioSource | AudioSink))
-        hasEffects = true;
-    else if (connection->m_sink->m_description & AudioSink)
-        hasOutputs = true;
-
-    if (hasEffects && hasOutputs)
-        return;
-        
-    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i){
-        inspectGraphRecursive(connection->m_sink->m_audioSinkList[i], hasEffects, hasOutputs);
-        if (hasEffects && hasOutputs)
-            return;
-    }
-}
-
-void MediaObject::inspectGraph()
-{
-    // Inspect the graph to check wether there are any
-    // effects or outputs connected. This will have
-    // influence on the audio system that gets used:
-    m_hasAudioEffects = false;
-    m_hasAudioOutputs = false;
-    AudioConnection rootConnection(this);
-    inspectGraphRecursive(&rootConnection, m_hasAudioEffects, m_hasAudioOutputs);
-}
-
-void MediaObject::setupAudioSystem()
-{
-    // Select which audio system to use:
-    AudioSystem newAudioSystem = AS_Unset;
-    if (!m_hasAudioOutputs || !m_videoPlayer->canPlayMedia()){
-        newAudioSystem = AS_Silent;
-    } else if (!m_hasAudioEffects){
-        newAudioSystem = AS_Video;
-    } else if (QSysInfo::MacintoshVersion < QSysInfo::MV_10_4){
-        newAudioSystem = AS_Video;
-        SET_ERROR("Audio effects are not supported for Mac OS 10.3 and below", NORMAL_ERROR);
-    } else if (m_videoPlayer->isDrmProtected()){
-        newAudioSystem = AS_Video;
-        SET_ERROR("Audio effects are not supported for DRM protected media", NORMAL_ERROR);
-    } else if (m_audioGraph->graphCannotPlay()){
-        newAudioSystem = AS_Video;
-        SET_ERROR("Audio effects are not supported for the current codec", NORMAL_ERROR);
-    } else
-        newAudioSystem = AS_Graph;
-
-    if (newAudioSystem == m_audioSystem)
-        return;
-  
-    // Enable selected audio system:
-    m_audioSystem = newAudioSystem; 
-    switch (newAudioSystem){
-        case AS_Silent:
-            m_audioGraph->stop();
-            m_videoPlayer->enableAudio(false);
-            m_nextVideoPlayer->enableAudio(false);    
-            m_audioPlayer->enableAudio(false);
-            m_nextAudioPlayer->enableAudio(false);
-        break;
-        case AS_Graph:
-            if (m_state == Phonon::PausedState)
-                m_audioGraph->prepare();
-            else
-                m_audioGraph->start();
-            // Starting the graph can lead to a recursive call
-            // telling us that we must direct audio through
-            // video. If that has happened, we must not proceed:
-            if (m_audioSystem != AS_Graph)
-                return;
-            m_videoPlayer->enableAudio(false);
-            m_nextVideoPlayer->enableAudio(false);
-            m_audioPlayer->enableAudio(true);
-            m_audioPlayer->seek(m_videoPlayer->currentTime());
-            m_nextAudioPlayer->enableAudio(true);
-            m_audioPlayer->seek(m_videoPlayer->currentTime());
-            m_nextAudioPlayer->seek(m_nextVideoPlayer->currentTime());
-        break;
-        case AS_Video:
-        case AS_Unset:
-            m_audioGraph->stop();
-            m_videoPlayer->enableAudio(true);
-            m_nextVideoPlayer->enableAudio(true);
-            m_audioPlayer->enableAudio(false);
-            m_nextAudioPlayer->enableAudio(false);
-            m_videoPlayer->seek(m_audioPlayer->currentTime());
-            m_nextVideoPlayer->seek(m_nextAudioPlayer->currentTime());
-        break;
-    }
-}
-
-void MediaObject::setSource(const MediaSource &source)
-{
-    IMPLEMENTED;
-    setState(Phonon::LoadingState);
-    
-    // Save current state for event/signal handling below:
-    bool prevHasVideo = m_videoPlayer->hasVideo();
-    qint64 prevTotalTime = totalTime();
-    m_waitNextSwap = false;
-        
-    // Cancel cross-fade if any:
-    m_nextVideoPlayer->pause();
-    m_nextAudioPlayer->pause();
-    m_mediaObjectAudioNode->cancelCrossFade();
-    
-    // Set new source:
-    m_audioPlayer->unsetVideoPlayer();
-    m_videoPlayer->setMediaSource(source);
-    m_audioPlayer->setVideoPlayer(m_videoPlayer);
-    m_metaData->setVideo(m_videoPlayer->movieRef());        
-    m_audioGraph->updateStreamSpecifications();        
-    m_nextAudioPlayer->unsetVideoPlayer();
-    m_nextVideoPlayer->unsetVideo();
-    m_currentTime = 0;
-        
-    // Emit/notify information about the new source:
-    QRect videoRect = m_videoPlayer->videoRect();
-    MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
-    notify(&e1);
-
-    // Clear video widgets:
-    VideoFrame emptyFrame;
-    updateVideo(emptyFrame);
-
-    emit currentSourceChanged(source);
-    emit metaDataChanged(m_metaData->metaData());
-
-    if (prevHasVideo != m_videoPlayer->hasVideo())
-        emit hasVideoChanged(m_videoPlayer->hasVideo());        
-    if (prevTotalTime != totalTime())
-        emit totalTimeChanged(totalTime());        
-    if (checkForError())
-        return;
-    if (!m_videoPlayer->isDrmAuthorized())
-        SET_ERROR("This computer is not authorized to play media (DRM protected).", FATAL_ERROR)
-    if (checkForError())
-        return;
-    if (!m_videoPlayer->canPlayMedia())
-        SET_ERROR("Cannot play media.", FATAL_ERROR)
-        
-    // The state might have changed from LoadingState
-    // as a response to an error state change. So we
-    // need to check it before stopping: 
-    if (m_state == Phonon::LoadingState)
-        stop();
-
-    setupAudioSystem();
-    checkForError();
-}
-
-void MediaObject::setNextSource(const MediaSource &source)
-{
-    IMPLEMENTED;
-    m_nextAudioPlayer->unsetVideoPlayer();
-    m_nextVideoPlayer->setMediaSource(source);
-    m_nextAudioPlayer->setVideoPlayer(m_nextVideoPlayer);
-    checkForError();
-}
-
-void MediaObject::swapCurrentWithNext(qint32 transitionTime)
-{
-    setState(Phonon::LoadingState);
-    // Save current state for event/signal handling below:
-    bool prevHasVideo = m_videoPlayer->hasVideo();
-    qint64 prevTotalTime = totalTime();
-
-    qSwap(m_audioPlayer, m_nextAudioPlayer);
-    qSwap(m_videoPlayer, m_nextVideoPlayer);
-    m_mediaObjectAudioNode->startCrossFade(transitionTime);
-    m_audioGraph->updateStreamSpecifications();
-    m_metaData->setVideo(m_videoPlayer->movieRef());
-    m_waitNextSwap = false;
-    m_currentTime = 0;
-        
-    // Emit/notify information about the new source:
-    QRect videoRect = m_videoPlayer->videoRect();
-    MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
-    notify(&e1);
-
-    emit currentSourceChanged(m_videoPlayer->mediaSource());
-    emit metaDataChanged(m_metaData->metaData());
-
-    if (prevHasVideo != m_videoPlayer->hasVideo())
-        emit hasVideoChanged(m_videoPlayer->hasVideo());        
-    if (prevTotalTime != totalTime())
-        emit totalTimeChanged(totalTime());
-    if (checkForError())
-        return;
-    if (!m_videoPlayer->isDrmAuthorized())
-        SET_ERROR("This computer is not authorized to play media (DRM protected).", FATAL_ERROR)
-    if (checkForError())
-        return;
-    if (!m_videoPlayer->canPlayMedia())
-        SET_ERROR("Cannot play next media.", FATAL_ERROR)
-
-    setupAudioSystem();
-    checkForError();
-    if (m_state == Phonon::LoadingState){
-        if (setState(Phonon::PlayingState))
-            play_internal();
-        checkForError();
-    }
-}
-
-void MediaObject::updateTimer(int &timer, int interval)
-{
-    if (timer)
-        killTimer(timer);
-    timer = 0;
-    if (interval >= 0)    
-        timer = startTimer(interval); 
-}
-
-void MediaObject::play_internal()
-{
-    // Play main audio/video:
-    m_videoPlayer->play();
-    m_audioPlayer->play();     
-    updateLipSynch(0);
-    // Play old audio/video to finish cross-fade:
-    if (m_nextVideoPlayer->currentTime() > 0){
-        m_nextVideoPlayer->play();
-        m_nextAudioPlayer->play();
-    }
-    bufferAudioVideo();
-    updateTimer(m_rapidTimer, 100);
-}
-
-void MediaObject::pause_internal()
-{
-    m_audioGraph->stop();
-    m_audioPlayer->pause();
-    m_nextAudioPlayer->pause();
-    m_videoPlayer->pause();
-    m_nextVideoPlayer->pause();
-    updateTimer(m_rapidTimer, -1);
-    updateTimer(m_bufferTimer, -1);
-
-    if (m_waitNextSwap)
-        m_swapTimeLeft = m_swapTime.msecsTo(QTime::currentTime());
-}
-
-void MediaObject::play()
-{
-    IMPLEMENTED;
-    if (m_state == Phonon::PlayingState)
-        return;
-    if (m_waitNextSwap){
-        // update swap time after pause:
-        m_swapTime = QTime::currentTime();
-        m_swapTime.addMSecs(m_swapTimeLeft);
-        setState(Phonon::PlayingState);
-        return;
-    }
-    if (m_currentTime == m_videoPlayer->duration())
-        return;
-    if (!m_videoPlayer->canPlayMedia())
-        return;
-    if (!setState(Phonon::PlayingState))
-        return;        
-    if (m_audioSystem == AS_Graph){
-        m_audioGraph->start();
-        m_mediaObjectAudioNode->setMute(true);
-    }
-    play_internal();
-    m_mediaObjectAudioNode->setMute(false);
-    checkForError();
-}
-
-void MediaObject::pause()
-{
-    IMPLEMENTED;
-    if (m_state == Phonon::PausedState)
-        return;
-    if (!setState(Phonon::PausedState))
-        return;
-    pause_internal();
-    if (m_audioSystem == AS_Graph)
-        m_audioGraph->prepare();
-    checkForError();
-}
-
-void MediaObject::stop()
-{
-    IMPLEMENTED;
-    if (m_state == Phonon::StoppedState)
-        return;
-    if (!setState(Phonon::StoppedState))
-        return;
-    m_waitNextSwap = false;
-    pause_internal();
-    seek(0);
-    checkForError();
-}
-
-void MediaObject::seek(qint64 milliseconds)
-{
-    IMPLEMENTED;
-    if (m_state == Phonon::ErrorState)
-        return;
-        
-    // Stop cross-fade if any:
-    m_nextVideoPlayer->pause();
-    m_nextAudioPlayer->pause();
-    m_mediaObjectAudioNode->cancelCrossFade();
-
-    // Seek to new position:
-    m_mediaObjectAudioNode->setMute(true);
-    m_videoPlayer->seek(milliseconds);
-    m_audioPlayer->seek(m_videoPlayer->currentTime());
-    m_mediaObjectAudioNode->setMute(false);
-    
-    // Update time and cancel pending swap:
-    if (m_currentTime < m_videoPlayer->duration())
-        m_waitNextSwap = false;
-
-    updateCurrentTime();
-    checkForError();
-}
-
-QStringList MediaObject::availableAudioStreams() const
-{
-    NOT_IMPLEMENTED;
-    return QStringList();
-}
-
-QStringList MediaObject::availableVideoStreams() const
-{
-    NOT_IMPLEMENTED;
-    return QStringList();
-}
-
-QStringList MediaObject::availableSubtitleStreams() const
-{
-    NOT_IMPLEMENTED;
-    return QStringList();
-}
-
-QString MediaObject::currentAudioStream(const QObject */*audioPath*/) const
-{
-    NOT_IMPLEMENTED;
-    return QString();
-}
-
-QString MediaObject::currentVideoStream(const QObject */*videoPath*/) const
-{
-    NOT_IMPLEMENTED;
-    return QString();
-}
-
-QString MediaObject::currentSubtitleStream(const QObject */*videoPath*/) const
-{
-    NOT_IMPLEMENTED;
-    return QString();
-}
-
-void MediaObject::setCurrentAudioStream(const QString &/*streamName*/,const QObject */*audioPath*/)
-{
-    NOT_IMPLEMENTED;
-}
-
-void MediaObject::setCurrentVideoStream(const QString &/*streamName*/,const QObject */*videoPath*/)
-{
-    NOT_IMPLEMENTED;
-}
-
-void MediaObject::setCurrentSubtitleStream(const QString &/*streamName*/,const QObject */*videoPath*/)
-{
-    NOT_IMPLEMENTED;
-}
-
-void MediaObject::synchAudioVideo()
-{
-    if (m_state != Phonon::PlayingState)
-        return;
-    if (m_videoSinkList.isEmpty() || m_audioSinkList.isEmpty())
-        return;
-
-    seek(m_currentTime);
-    checkForError();
-}
-
-qint32 MediaObject::tickInterval() const
-{
-    IMPLEMENTED;
-    return m_tickInterval;
-}
-
-void MediaObject::setTickInterval(qint32 interval)
-{
-    IMPLEMENTED;
-    m_tickInterval = interval;
-    if (m_tickInterval > 0)
-        m_tickTimer = startTimer(m_tickInterval);
-    else{
-        killTimer(m_tickTimer);
-        m_tickTimer = 0;
-    }
-}
-
-bool MediaObject::hasVideo() const
-{
-    IMPLEMENTED;
-    return m_videoPlayer ? m_videoPlayer->hasVideo() : false;
-}
-
-bool MediaObject::isSeekable() const
-{
-    IMPLEMENTED;
-    return m_videoPlayer ? m_videoPlayer->isSeekable() : false;
-}
-
-qint64 MediaObject::currentTime() const
-{
-    IMPLEMENTED_SILENT;
-    const_cast<MediaObject *>(this)->updateCurrentTime(); 
-    return m_currentTime;
-}
-
-void MediaObject::updateCurrentTime()
-{
-    quint64 lastUpdateTime = m_currentTime;
-    m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
-    quint64 total = m_videoPlayer->duration();
-
-    // Check if it's time to emit aboutToFinish:
-    quint32 mark = qMax(quint64(0), qMin(total, total + m_transitionTime - 2000));
-    if (lastUpdateTime < mark && mark <= m_currentTime)
-        emit aboutToFinish();
-
-    // Check if it's time to emit prefinishMarkReached:
-    mark = qMax(quint64(0), total - m_prefinishMark);
-    if (lastUpdateTime < mark && mark <= m_currentTime)
-        emit prefinishMarkReached(total - m_currentTime);
-
-    if (m_nextVideoPlayer->state() == QuickTimeVideoPlayer::NoMedia){
-        // There is no next source in que.
-        // Check if it's time to emit finished:
-        if (lastUpdateTime < m_currentTime && m_currentTime == total){
-            emit finished();
-            m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
-            if (m_state == Phonon::PlayingState && m_currentTime == total)
-                pause();
-        }
-    } else {
-        // We have a next source.
-        // Check if it's time to swap to next source:
-        mark = qMax(quint64(0), total + m_transitionTime);
-        if (m_waitNextSwap && m_state == Phonon::PlayingState &&
-            m_transitionTime < m_swapTime.msecsTo(QTime::currentTime())){
-            swapCurrentWithNext(0);
-        } else if (mark >= total){
-            if (lastUpdateTime < total && total == m_currentTime){
-                m_swapTime = QTime::currentTime();
-                m_swapTime.addMSecs(mark - total);
-                m_waitNextSwap = true;
-            }
-        } else if (lastUpdateTime < mark && mark <= m_currentTime){
-            swapCurrentWithNext(total - m_currentTime);
-        }
-    }
-}
-
-qint64 MediaObject::totalTime() const
-{
-    IMPLEMENTED_SILENT;
-    return m_videoPlayer->duration();
-}
-
-Phonon::State MediaObject::state() const
-{
-    IMPLEMENTED;
-    return m_state;
-}
-
-QString MediaObject::errorString() const
-{
-    IMPLEMENTED;
-    return m_errorString;
-}
-
-Phonon::ErrorType MediaObject::errorType() const
-{
-    IMPLEMENTED;
-    return m_errorType;
-}
-
-bool MediaObject::checkForError()
-{
-    int type = gGetErrorType();
-    if (type == NO_ERROR)
-        return false;
-
-    m_errorType = (type == NORMAL_ERROR) ? Phonon::NormalError : Phonon::FatalError;
-    m_errorString = gGetErrorString();
-    pause_internal();
-    gClearError();
-    setState(Phonon::ErrorState);
-    return true;
-}
-
-QuickTimeVideoPlayer* MediaObject::videoPlayer() const
-{
-    return m_videoPlayer;
-}
-
-MediaSource MediaObject::source() const
-{
-    IMPLEMENTED;
-    return m_videoPlayer->mediaSource();
-}
-
-qint32 MediaObject::prefinishMark() const
-{
-    IMPLEMENTED;
-    return m_prefinishMark;
-}
-
-void MediaObject::setPrefinishMark(qint32 mark)
-{
-    IMPLEMENTED;
-    m_prefinishMark = mark;
-}
-
-qint32 MediaObject::transitionTime() const
-{
-    IMPLEMENTED;
-    return m_transitionTime;
-}
-
-void MediaObject::setTransitionTime(qint32 transitionTime)
-{
-    IMPLEMENTED;
-    m_transitionTime = transitionTime;
-}
-
-void MediaObject::setVolumeOnMovie(float volume)
-{
-    m_videoPlayer->setMasterVolume(volume);
-    m_nextVideoPlayer->setMasterVolume(volume);
-}
-
-bool MediaObject::setAudioDeviceOnMovie(int id)
-{
-    m_nextVideoPlayer->setAudioDevice(id);
-    return m_videoPlayer->setAudioDevice(id);
-}
-
-void MediaObject::updateCrossFade()
-{
-    m_mediaObjectAudioNode->updateCrossFade(m_currentTime);   
-    // Clean-up previous movie if done fading:
-    if (m_mediaObjectAudioNode->m_fadeDuration == 0){
-        if (m_nextVideoPlayer->isPlaying() || m_nextAudioPlayer->isPlaying()){
-            m_nextVideoPlayer->unsetVideo();
-            m_nextAudioPlayer->unsetVideoPlayer();
-        }
-    }        
-}
-
-void MediaObject::updateBufferStatus()
-{
-    float percent = m_videoPlayer->percentageLoaded();
-    if (percent != m_percentageLoaded){
-        m_percentageLoaded = percent;
-        emit bufferStatus(m_percentageLoaded * 100);
-    }
-}
-
-void MediaObject::updateAudioBuffers()
-{
-    // Schedule audio slices:
-    m_audioPlayer->scheduleAudioToGraph();
-    m_nextAudioPlayer->scheduleAudioToGraph();
-}
-
-bool MediaObject::isCrossFading()
-{
-    return m_mediaObjectAudioNode->isCrossFading();
-}
-
-void MediaObject::updateVideoFrames()
-{
-    // Draw next frame if awailable:
-    LinkTimeProxy displayLinkTime = DisplayLinkCallback::currentTime();
-    if (m_videoPlayer->videoFrameChanged(displayLinkTime)){
-        updateLipSynch(50);
-        VideoFrame frame(m_videoPlayer, displayLinkTime);           
-        if (m_nextVideoPlayer->isPlaying()
-            && m_nextVideoPlayer->hasVideo()
-            && isCrossFading()){
-            VideoFrame bgFrame(m_nextVideoPlayer, displayLinkTime);
-            frame.setBackgroundFrame(bgFrame);
-            frame.setBaseOpacity(m_mediaObjectAudioNode->m_volume1);
-        }
-        
-        // Send the frame through the graph:
-        updateVideo(frame);    
-    }
-}
-
-void MediaObject::updateLipSynch(int allowedOffset)
-{
-    if (m_audioSystem != AS_Graph || !m_audioGraph->isRunning())
-        return;
-    if (m_videoSinkList.isEmpty() || m_audioSinkList.isEmpty())
-        return;
-        
-    if (m_videoPlayer->hasVideo()){
-        qint64 diff = m_audioPlayer->currentTime() - m_videoPlayer->currentTime();
-        if (-allowedOffset > diff || diff > allowedOffset)
-            m_audioPlayer->seek(m_videoPlayer->currentTime());
-    }
-
-    if (isCrossFading() && m_nextVideoPlayer->hasVideo()){
-        qint64 diff = m_nextAudioPlayer->currentTime() - m_nextVideoPlayer->currentTime();
-        if (-(allowedOffset*2) > diff || diff > (allowedOffset*2))
-            m_nextAudioPlayer->seek(m_nextVideoPlayer->currentTime());
-    }
-}
-
-long MediaObject::updateQuickTime()
-{
-    long nextUpdateTime = 1000;
-    // QTGetTimeUntilNextTask does'nt really work, it
-    // returns zero all the time. Thats the reason for
-    // the nextUpdateTime guessing:
-    long ms = 0;
-    QTGetTimeUntilNextTask(&ms, 1000);
-    if (m_videoPlayer->hasVideo())
-        nextUpdateTime = qMax(ms, 30l);
-    else if (!m_videoPlayer->audioEnabled())
-        nextUpdateTime = qMax(ms, 100l);
-    return nextUpdateTime;
-}
-
-void MediaObject::bufferAudioVideo()
-{
-    MoviesTask(0, 0);
-    long nextVideoUpdate = updateQuickTime();
-    long nextAudioUpdate = m_audioPlayer->regularTaskFrequency();
-    updateAudioBuffers();
-    updateVideoFrames();
-    if (m_state == Phonon::PlayingState)
-        updateTimer(m_bufferTimer, qMin(nextVideoUpdate, nextAudioUpdate));
-}
-
-void MediaObject::updateRapidly()
-{
-    updateCurrentTime();
-    updateCrossFade();
-    updateBufferStatus();
-}
-
-void MediaObject::setMute(bool mute)
-{
-    m_mediaObjectAudioNode->setMute(mute);
-    m_videoPlayer->setMute(mute);
-    m_nextVideoPlayer->setMute(mute);
-}
-
-void MediaObject::mediaNodeEvent(const MediaNodeEvent *event)
-{
-    switch (event->type()){
-        case MediaNodeEvent::EndConnectionChange:
-            m_mediaObjectAudioNode->setMute(true);
-            inspectGraph();
-            setupAudioSystem();
-            synchAudioVideo();
-            checkForError();
-            m_mediaObjectAudioNode->setMute(false);
-             if (m_state == Phonon::PlayingState)
-                bufferAudioVideo();
-            break;
-        case MediaNodeEvent::AudioGraphCannotPlay:
-        case MediaNodeEvent::AudioGraphInitialized:
-            if (m_state != Phonon::LoadingState){
-                m_mediaObjectAudioNode->setMute(true);
-                setupAudioSystem();
-                updateLipSynch(0);
-                checkForError();
-                m_mediaObjectAudioNode->setMute(false);
-            }
-            break; 
-        default:
-            break;
-    }
-}
-
-bool MediaObject::event(QEvent *event)
-{
-    switch (event->type()){
-        case QEvent::Timer:
-            QTimerEvent *timerEvent = static_cast<QTimerEvent *>(event);
-            if (timerEvent->timerId() == m_rapidTimer)
-                updateRapidly();
-            else if (timerEvent->timerId() == m_tickTimer)
-                emit tick(currentTime());
-            else if (timerEvent->timerId() == m_bufferTimer)
-                bufferAudioVideo();
-            break;
-        default:
-            break;
-    }
-    return QObject::event(event);
-}
-
-bool MediaObject::hasInterface(Interface /*interface*/) const
-{
-    return false;
-}
-
-QVariant MediaObject::interfaceCall(Interface /*interface*/, int /*command*/, const QList<QVariant> &/*arguments*/)
-{
-    return QVariant();
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_mediaobject.cpp"
-
diff -r -U2 -N phonon-4.3.0/qt7/mediaobject.h phonon-4.3.0/qt7/mediaobject.h
--- phonon-4.3.0/qt7/mediaobject.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobject.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,9 +19,6 @@
 #define Phonon_QT7_MEDIAOBJECT_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
-#include <QtCore>
-
+#include <QtCore/QStringList>
+#include <QtCore/QTime>
 #include <phonon/mediaobjectinterface.h>
 #include <phonon/addoninterface.h>
@@ -93,5 +90,7 @@
         void setVolumeOnMovie(float volume);
         bool setAudioDeviceOnMovie(int id);
-        
+
+		int videoOutputCount();
+
     signals:
         void stateChanged(Phonon::State,Phonon::State);
@@ -127,5 +126,5 @@
         quint32 m_currentTime;
         float m_percentageLoaded;
-        
+
         int m_tickTimer;
         int m_bufferTimer;
@@ -150,17 +149,19 @@
         void updateLipSynch(int allowedOffset);
         void updateVideoFrames();
-        long updateQuickTime();
         void updateBufferStatus();
         void setMute(bool mute);
-        void inspectGraphRecursive(AudioConnection *connection, bool &hasEffects, bool &hasOutputs);
+		void inspectAudioGraphRecursive(AudioConnection *connection, int &effectCount, int &outputCount);
+		void inspectVideoGraphRecursive(MediaNode *node, int &effectCount, int &outputCount);
         void inspectGraph();
         bool isCrossFading();
-        
+
         QString m_errorString;
         Phonon::ErrorType m_errorType;
         bool checkForError();
 
-        bool m_hasAudioEffects;
-        bool m_hasAudioOutputs;
+	    int m_audioEffectCount;
+	    int m_audioOutputCount;
+	    int m_videoEffectCount;
+	    int m_videoOutputCount;
     };
 
diff -r -U2 -N phonon-4.3.0/qt7/mediaobject.mm phonon-4.3.0/qt7/mediaobject.mm
--- phonon-4.3.0/qt7/mediaobject.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/mediaobject.mm	2009-03-02 04:16:07.000000000 -0700
@@ -0,0 +1,852 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <QtCore/QEvent>
+#include "mediaobject.h"
+#include "backendheader.h"
+#include "videowidget.h"
+#include "videoframe.h"
+#include "audiooutput.h"
+#include "quicktimevideoplayer.h"
+#include "quicktimemetadata.h"
+#include "audiograph.h"
+#include "mediaobjectaudionode.h"
+#include "quicktimeaudioplayer.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+MediaObject::MediaObject(QObject *parent) : MediaNode(AudioSource | VideoSource, parent)
+{
+    m_owningMediaObject = this;
+    m_state = Phonon::LoadingState;
+
+    m_videoPlayer = new QuickTimeVideoPlayer();
+    m_audioPlayer = new QuickTimeAudioPlayer();
+    m_nextVideoPlayer = new QuickTimeVideoPlayer();
+    m_nextAudioPlayer = new QuickTimeAudioPlayer();
+    m_mediaObjectAudioNode = new MediaObjectAudioNode(m_audioPlayer, m_nextAudioPlayer);
+    setAudioNode(m_mediaObjectAudioNode);
+
+    m_metaData = new QuickTimeMetaData();
+    m_audioGraph = new AudioGraph(this);
+
+    m_tickInterval = 0;
+    m_prefinishMark = 0;
+    m_currentTime = 0;
+    m_transitionTime = 0;
+    m_percentageLoaded = 0;
+    m_waitNextSwap = false;
+    m_audioEffectCount = 0;
+    m_audioOutputCount = 0;
+    m_videoEffectCount = 0;
+    m_videoOutputCount = 0;
+    m_audioSystem = AS_Unset;
+    m_errorType = Phonon::NoError;
+
+    m_tickTimer = 0;
+    m_bufferTimer = 0;
+    m_rapidTimer = 0;
+
+    checkForError();
+}
+
+MediaObject::~MediaObject()
+{   
+    // m_mediaObjectAudioNode is owned by super class.    
+    m_audioPlayer->unsetVideoPlayer();
+    m_nextAudioPlayer->unsetVideoPlayer();
+    delete m_videoPlayer;
+    delete m_nextVideoPlayer;
+    delete m_metaData;
+    checkForError();
+}
+
+bool MediaObject::setState(Phonon::State state)
+{
+    Phonon::State prevState = m_state;
+    m_state = state;
+    if (prevState != m_state){
+        emit stateChanged(m_state, prevState);
+        if (m_state != state){
+            // End-application did something
+            // upon  receiving the signal. 
+            return false;
+        }
+    }
+    return true;
+}
+
+void MediaObject::inspectAudioGraphRecursive(AudioConnection *connection, int &effectCount, int &outputCount)
+{
+    if ((connection->m_sink->m_description & (AudioSource | AudioSink)) == (AudioSource | AudioSink))
+        ++effectCount;
+	else if (connection->m_sink->m_description & AudioSink)
+    	++outputCount;
+
+    for (int i=0; i<connection->m_sink->m_audioSinkList.size(); ++i)
+        inspectAudioGraphRecursive(connection->m_sink->m_audioSinkList[i], effectCount, outputCount);
+}
+
+void MediaObject::inspectVideoGraphRecursive(MediaNode *node, int &effectCount, int &outputCount)
+{
+    if ((node->m_description & (VideoSource | VideoSink)) == (VideoSource | VideoSink))
+        ++effectCount;
+	else if (node->m_description & VideoSink)
+    	++outputCount;
+
+    for (int i=0; i<node->m_videoSinkList.size(); ++i)
+        inspectVideoGraphRecursive(node->m_videoSinkList[i], effectCount, outputCount);
+}
+
+void MediaObject::inspectGraph()
+{
+    // Inspect the graph to check wether there are any
+    // effects or outputs connected. This will have
+    // influence on the audio system and video system that ends up beeing used:
+    int prevVideoOutputCount = m_videoOutputCount;	
+    m_audioEffectCount = 0;
+    m_audioOutputCount = 0;
+    m_videoEffectCount = 0;
+    m_videoOutputCount = 0;
+    AudioConnection rootConnection(this);
+    inspectAudioGraphRecursive(&rootConnection, m_audioEffectCount, m_audioOutputCount);
+    inspectVideoGraphRecursive(this, m_videoEffectCount, m_videoOutputCount);
+
+	if (m_videoOutputCount != prevVideoOutputCount){
+	    MediaNodeEvent e1(MediaNodeEvent::VideoOutputCountChanged, &m_videoOutputCount);
+	    notify(&e1);
+	}	
+}
+
+void MediaObject::setupAudioSystem()
+{
+    // Select which audio system to use:
+    AudioSystem newAudioSystem = AS_Unset;
+    if (!m_audioOutputCount || !m_videoPlayer->canPlayMedia()){
+        newAudioSystem = AS_Silent;
+    } else if (m_audioEffectCount == 0){
+        newAudioSystem = AS_Video;
+    } else if (QSysInfo::MacintoshVersion < QSysInfo::MV_10_4){
+        newAudioSystem = AS_Video;
+        SET_ERROR("Audio effects are not supported for Mac OS 10.3 and below", NORMAL_ERROR);
+    } else if (m_videoPlayer->isDrmProtected()){
+        newAudioSystem = AS_Video;
+        SET_ERROR("Audio effects are not supported for DRM protected media", NORMAL_ERROR);
+    } else if (m_audioGraph->graphCannotPlay()){
+        newAudioSystem = AS_Video;
+        SET_ERROR("Audio effects are not supported for the current codec", NORMAL_ERROR);
+#ifdef QUICKTIME_C_API_AVAILABLE
+    } else {
+        newAudioSystem = AS_Graph;
+    }
+#else
+    } else {
+        newAudioSystem = AS_Video;
+        SET_ERROR("Audio effects are not supported for the 64-bit version of the Phonon QT7 backend", NORMAL_ERROR);
+    }
+#endif
+
+    if (newAudioSystem == m_audioSystem)
+        return;
+  
+    // Enable selected audio system:
+    m_audioSystem = newAudioSystem; 
+    switch (newAudioSystem){
+        case AS_Silent:
+            m_audioGraph->stop();
+            m_videoPlayer->enableAudio(false);
+            m_nextVideoPlayer->enableAudio(false);    
+            m_audioPlayer->enableAudio(false);
+            m_nextAudioPlayer->enableAudio(false);
+        break;
+        case AS_Graph:
+            if (m_state == Phonon::PausedState)
+                m_audioGraph->prepare();
+            else
+                m_audioGraph->start();
+            // Starting the graph can lead to a recursive call
+            // telling us that we must direct audio through
+            // video. If that has happened, we must not proceed:
+            if (m_audioSystem != AS_Graph)
+                return;
+            m_videoPlayer->enableAudio(false);
+            m_nextVideoPlayer->enableAudio(false);
+            m_audioPlayer->enableAudio(true);
+            m_audioPlayer->seek(m_videoPlayer->currentTime());
+            m_nextAudioPlayer->enableAudio(true);
+            m_audioPlayer->seek(m_videoPlayer->currentTime());
+            m_nextAudioPlayer->seek(m_nextVideoPlayer->currentTime());
+        break;
+        case AS_Video:
+        case AS_Unset:
+            m_audioGraph->stop();
+            m_videoPlayer->enableAudio(true);
+            m_nextVideoPlayer->enableAudio(true);
+            m_audioPlayer->enableAudio(false);
+            m_nextAudioPlayer->enableAudio(false);
+            m_videoPlayer->seek(m_audioPlayer->currentTime());
+            m_nextVideoPlayer->seek(m_nextAudioPlayer->currentTime());
+        break;
+    }
+}
+
+void MediaObject::setSource(const MediaSource &source)
+{
+    IMPLEMENTED;
+	PhononAutoReleasePool pool;
+    setState(Phonon::LoadingState);
+    
+    // Save current state for event/signal handling below:
+    bool prevHasVideo = m_videoPlayer->hasVideo();
+    qint64 prevTotalTime = totalTime();
+    m_waitNextSwap = false;
+        
+    // Cancel cross-fade if any:
+    m_nextVideoPlayer->pause();
+    m_nextAudioPlayer->pause();
+    m_mediaObjectAudioNode->cancelCrossFade();
+    
+    // Set new source:
+    m_audioPlayer->unsetVideoPlayer();
+    m_videoPlayer->setMediaSource(source);
+    m_audioPlayer->setVideoPlayer(m_videoPlayer);
+    m_metaData->setVideo(m_videoPlayer);        
+
+    m_audioGraph->updateStreamSpecifications();        
+    m_nextAudioPlayer->unsetVideoPlayer();
+    m_nextVideoPlayer->unsetVideo();
+    m_currentTime = 0;
+        
+    // Emit/notify information about the new source:
+    QRect videoRect = m_videoPlayer->videoRect();
+    MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
+    notify(&e1);
+
+    // Clear video widgets:
+    VideoFrame emptyFrame;
+    updateVideo(emptyFrame);
+
+    emit currentSourceChanged(source);
+    emit metaDataChanged(m_metaData->metaData());
+
+    if (prevHasVideo != m_videoPlayer->hasVideo())
+        emit hasVideoChanged(m_videoPlayer->hasVideo());        
+    if (prevTotalTime != totalTime())
+        emit totalTimeChanged(totalTime());        
+    if (checkForError())
+        return;
+    if (!m_videoPlayer->isDrmAuthorized())
+        SET_ERROR("This computer is not authorized to play current media (DRM protected).", FATAL_ERROR)
+    if (checkForError())
+        return;
+    if (!m_videoPlayer->canPlayMedia())
+        SET_ERROR("Cannot play media.", FATAL_ERROR)
+        
+    // The state might have changed from LoadingState
+    // as a response to an error state change. So we
+    // need to check it before stopping: 
+    if (m_state == Phonon::LoadingState)
+        stop();
+
+    setupAudioSystem();
+    checkForError();
+}
+
+void MediaObject::setNextSource(const MediaSource &source)
+{
+    IMPLEMENTED;
+    m_nextAudioPlayer->unsetVideoPlayer();
+    m_nextVideoPlayer->setMediaSource(source);
+    m_nextAudioPlayer->setVideoPlayer(m_nextVideoPlayer);
+    checkForError();
+}
+
+void MediaObject::swapCurrentWithNext(qint32 transitionTime)
+{
+	PhononAutoReleasePool pool;
+    setState(Phonon::LoadingState);
+    // Save current state for event/signal handling below:
+    bool prevHasVideo = m_videoPlayer->hasVideo();
+    qint64 prevTotalTime = totalTime();
+
+    qSwap(m_audioPlayer, m_nextAudioPlayer);
+    qSwap(m_videoPlayer, m_nextVideoPlayer);
+    m_mediaObjectAudioNode->startCrossFade(transitionTime);
+    m_audioGraph->updateStreamSpecifications();
+    m_metaData->setVideo(m_videoPlayer);
+
+    m_waitNextSwap = false;
+    m_currentTime = 0;
+        
+    // Emit/notify information about the new source:
+    QRect videoRect = m_videoPlayer->videoRect();
+    MediaNodeEvent e1(MediaNodeEvent::VideoFrameSizeChanged, &videoRect);
+    notify(&e1);
+
+    emit currentSourceChanged(m_videoPlayer->mediaSource());
+    emit metaDataChanged(m_metaData->metaData());
+
+    if (prevHasVideo != m_videoPlayer->hasVideo())
+        emit hasVideoChanged(m_videoPlayer->hasVideo());        
+    if (prevTotalTime != totalTime())
+        emit totalTimeChanged(totalTime());
+    if (checkForError())
+        return;
+    if (!m_videoPlayer->isDrmAuthorized())
+        SET_ERROR("This computer is not authorized to play current media (DRM protected).", FATAL_ERROR)
+    if (checkForError())
+        return;
+    if (!m_videoPlayer->canPlayMedia())
+        SET_ERROR("Cannot play next media.", FATAL_ERROR)
+
+    setupAudioSystem();
+    checkForError();
+    if (m_state == Phonon::LoadingState){
+        if (setState(Phonon::PlayingState))
+            play_internal();
+        checkForError();
+    }
+}
+
+void MediaObject::updateTimer(int &timer, int interval)
+{
+    if (timer)
+        killTimer(timer);
+    timer = 0;
+    if (interval >= 0)    
+        timer = startTimer(interval); 
+}
+
+void MediaObject::play_internal()
+{
+    // Play main audio/video:
+    m_videoPlayer->play();
+    m_audioPlayer->play();     
+    updateLipSynch(0);
+    // Play old audio/video to finish cross-fade:
+    if (m_nextVideoPlayer->currentTime() > 0){
+        m_nextVideoPlayer->play();
+        m_nextAudioPlayer->play();
+    }
+    bufferAudioVideo();
+    updateTimer(m_rapidTimer, 100);
+}
+
+void MediaObject::pause_internal()
+{
+    m_audioGraph->stop();
+    m_audioPlayer->pause();
+    m_nextAudioPlayer->pause();
+    m_videoPlayer->pause();
+    m_nextVideoPlayer->pause();
+    updateTimer(m_rapidTimer, -1);
+    updateTimer(m_bufferTimer, -1);
+
+    if (m_waitNextSwap)
+        m_swapTimeLeft = m_swapTime.msecsTo(QTime::currentTime());
+}
+
+void MediaObject::play()
+{
+    IMPLEMENTED;
+    if (m_state == Phonon::PlayingState)
+        return;
+    if (m_waitNextSwap){
+        // update swap time after pause:
+        m_swapTime = QTime::currentTime();
+        m_swapTime.addMSecs(m_swapTimeLeft);
+        setState(Phonon::PlayingState);
+        return;
+    }
+    if (m_currentTime == m_videoPlayer->duration())
+        return;
+    if (!m_videoPlayer->canPlayMedia())
+        return;
+    if (!setState(Phonon::PlayingState))
+        return;        
+    if (m_audioSystem == AS_Graph){
+        m_audioGraph->start();
+        m_mediaObjectAudioNode->setMute(true);
+    }
+	// Inform the graph that we are about to play:
+	bool playing = true;
+    MediaNodeEvent e1(MediaNodeEvent::MediaPlaying, &playing);
+    notify(&e1);
+	// Start to play:
+    play_internal();
+    m_mediaObjectAudioNode->setMute(false);
+    checkForError();
+}
+
+void MediaObject::pause()
+{
+    IMPLEMENTED;
+    if (m_state == Phonon::PausedState)
+        return;
+    if (!setState(Phonon::PausedState))
+        return;
+    pause_internal();
+	// Inform the graph that we are no longer playing:
+	bool playing = false;
+    MediaNodeEvent e1(MediaNodeEvent::MediaPlaying, &playing);
+    notify(&e1);
+	// But be prepared:
+    if (m_audioSystem == AS_Graph)
+        m_audioGraph->prepare();
+    checkForError();
+}
+
+void MediaObject::stop()
+{
+    IMPLEMENTED;
+    if (m_state == Phonon::StoppedState)
+        return;
+    if (!setState(Phonon::StoppedState))
+        return;
+    m_waitNextSwap = false;
+    m_nextVideoPlayer->unsetVideo();
+    m_nextAudioPlayer->unsetVideoPlayer();
+    pause_internal();
+    seek(0);
+    checkForError();
+}
+
+void MediaObject::seek(qint64 milliseconds)
+{
+    IMPLEMENTED;
+    if (m_state == Phonon::ErrorState)
+        return;
+        
+    // Stop cross-fade if any:
+    m_nextVideoPlayer->unsetVideo();
+    m_nextAudioPlayer->unsetVideoPlayer();
+    m_mediaObjectAudioNode->cancelCrossFade();
+
+    // Seek to new position:
+    m_mediaObjectAudioNode->setMute(true);
+    m_videoPlayer->seek(milliseconds);
+    m_audioPlayer->seek(m_videoPlayer->currentTime());
+    m_mediaObjectAudioNode->setMute(false);
+    
+    // Update time and cancel pending swap:
+    if (m_currentTime < m_videoPlayer->duration())
+        m_waitNextSwap = false;
+
+    updateCurrentTime();
+	if (m_state != Phonon::PlayingState)
+		updateVideoFrames();
+    checkForError();
+}
+
+QStringList MediaObject::availableAudioStreams() const
+{
+    NOT_IMPLEMENTED;
+    return QStringList();
+}
+
+QStringList MediaObject::availableVideoStreams() const
+{
+    NOT_IMPLEMENTED;
+    return QStringList();
+}
+
+QStringList MediaObject::availableSubtitleStreams() const
+{
+    NOT_IMPLEMENTED;
+    return QStringList();
+}
+
+QString MediaObject::currentAudioStream(const QObject */*audioPath*/) const
+{
+    NOT_IMPLEMENTED;
+    return QString();
+}
+
+QString MediaObject::currentVideoStream(const QObject */*videoPath*/) const
+{
+    NOT_IMPLEMENTED;
+    return QString();
+}
+
+QString MediaObject::currentSubtitleStream(const QObject */*videoPath*/) const
+{
+    NOT_IMPLEMENTED;
+    return QString();
+}
+
+void MediaObject::setCurrentAudioStream(const QString &/*streamName*/,const QObject */*audioPath*/)
+{
+    NOT_IMPLEMENTED;
+}
+
+void MediaObject::setCurrentVideoStream(const QString &/*streamName*/,const QObject */*videoPath*/)
+{
+    NOT_IMPLEMENTED;
+}
+
+void MediaObject::setCurrentSubtitleStream(const QString &/*streamName*/,const QObject */*videoPath*/)
+{
+    NOT_IMPLEMENTED;
+}
+
+int MediaObject::videoOutputCount()
+{
+	return m_videoOutputCount;
+}
+
+void MediaObject::synchAudioVideo()
+{
+    if (m_state != Phonon::PlayingState)
+        return;
+    if (m_videoSinkList.isEmpty() || m_audioSinkList.isEmpty())
+        return;
+
+    seek(m_currentTime);
+    checkForError();
+}
+
+qint32 MediaObject::tickInterval() const
+{
+    IMPLEMENTED;
+    return m_tickInterval;
+}
+
+void MediaObject::setTickInterval(qint32 interval)
+{
+    IMPLEMENTED;
+    m_tickInterval = interval;
+    if (m_tickInterval > 0)
+        m_tickTimer = startTimer(m_tickInterval);
+    else{
+        killTimer(m_tickTimer);
+        m_tickTimer = 0;
+    }
+}
+
+bool MediaObject::hasVideo() const
+{
+    IMPLEMENTED;
+    return m_videoPlayer ? m_videoPlayer->hasVideo() : false;
+}
+
+bool MediaObject::isSeekable() const
+{
+    IMPLEMENTED;
+    return m_videoPlayer ? m_videoPlayer->isSeekable() : false;
+}
+
+qint64 MediaObject::currentTime() const
+{
+    IMPLEMENTED_SILENT;
+    const_cast<MediaObject *>(this)->updateCurrentTime(); 
+    return m_currentTime;
+}
+
+void MediaObject::updateCurrentTime()
+{
+    quint64 lastUpdateTime = m_currentTime;
+    m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
+    quint64 total = m_videoPlayer->duration();
+
+    // Check if it's time to emit aboutToFinish:
+    quint32 mark = qMax(quint64(0), qMin(total, total + m_transitionTime - 2000));
+    if (lastUpdateTime < mark && mark <= m_currentTime)
+        emit aboutToFinish();
+
+    // Check if it's time to emit prefinishMarkReached:
+    mark = qMax(quint64(0), total - m_prefinishMark);
+    if (lastUpdateTime < mark && mark <= m_currentTime)
+        emit prefinishMarkReached(total - m_currentTime);
+
+    if (m_nextVideoPlayer->state() == QuickTimeVideoPlayer::NoMedia){
+        // There is no next source in que.
+        // Check if it's time to emit finished:
+        if (lastUpdateTime < m_currentTime && m_currentTime == total){
+            emit finished();
+            m_currentTime = (m_audioSystem == AS_Graph) ? m_audioPlayer->currentTime() : m_videoPlayer->currentTime();
+            if (m_state == Phonon::PlayingState && m_currentTime == total)
+                pause();
+        }
+    } else {
+        // We have a next source.
+        // Check if it's time to swap to next source:
+        mark = qMax(quint64(0), total + m_transitionTime);
+        if (m_waitNextSwap && m_state == Phonon::PlayingState &&
+            m_transitionTime < m_swapTime.msecsTo(QTime::currentTime())){
+            swapCurrentWithNext(0);
+        } else if (mark >= total){
+            if (lastUpdateTime < total && total == m_currentTime){
+                m_swapTime = QTime::currentTime();
+                m_swapTime.addMSecs(mark - total);
+                m_waitNextSwap = true;
+            }
+        } else if (lastUpdateTime < mark && mark <= m_currentTime){
+            swapCurrentWithNext(total - m_currentTime);
+        }
+    }
+}
+
+qint64 MediaObject::totalTime() const
+{
+    IMPLEMENTED_SILENT;
+    return m_videoPlayer->duration();
+}
+
+Phonon::State MediaObject::state() const
+{
+    IMPLEMENTED;
+    return m_state;
+}
+
+QString MediaObject::errorString() const
+{
+    IMPLEMENTED;
+    return m_errorString;
+}
+
+Phonon::ErrorType MediaObject::errorType() const
+{
+    IMPLEMENTED;
+    return m_errorType;
+}
+
+bool MediaObject::checkForError()
+{
+    int type = gGetErrorType();
+    if (type == NO_ERROR)
+        return false;
+
+    m_errorType = (type == NORMAL_ERROR) ? Phonon::NormalError : Phonon::FatalError;
+    m_errorString = gGetErrorString();
+    pause_internal();
+    gClearError();
+    setState(Phonon::ErrorState);
+    return true;
+}
+
+QuickTimeVideoPlayer* MediaObject::videoPlayer() const
+{
+    return m_videoPlayer;
+}
+
+MediaSource MediaObject::source() const
+{
+    IMPLEMENTED;
+    return m_videoPlayer->mediaSource();
+}
+
+qint32 MediaObject::prefinishMark() const
+{
+    IMPLEMENTED;
+    return m_prefinishMark;
+}
+
+void MediaObject::setPrefinishMark(qint32 mark)
+{
+    IMPLEMENTED;
+    m_prefinishMark = mark;
+}
+
+qint32 MediaObject::transitionTime() const
+{
+    IMPLEMENTED;
+    return m_transitionTime;
+}
+
+void MediaObject::setTransitionTime(qint32 transitionTime)
+{
+    IMPLEMENTED;
+    m_transitionTime = transitionTime;
+}
+
+void MediaObject::setVolumeOnMovie(float volume)
+{
+    m_videoPlayer->setMasterVolume(volume);
+    m_nextVideoPlayer->setMasterVolume(volume);
+}
+
+bool MediaObject::setAudioDeviceOnMovie(int id)
+{
+    m_nextVideoPlayer->setAudioDevice(id);
+    return m_videoPlayer->setAudioDevice(id);
+}
+
+void MediaObject::updateCrossFade()
+{
+    m_mediaObjectAudioNode->updateCrossFade(m_currentTime);   
+    // Clean-up previous movie if done fading:
+    if (m_mediaObjectAudioNode->m_fadeDuration == 0){
+        if (m_nextVideoPlayer->isPlaying() || m_nextAudioPlayer->isPlaying()){
+            m_nextVideoPlayer->unsetVideo();
+            m_nextAudioPlayer->unsetVideoPlayer();
+        }
+    }        
+}
+
+void MediaObject::updateBufferStatus()
+{
+    float percent = m_videoPlayer->percentageLoaded();
+    if (percent != m_percentageLoaded){
+        m_percentageLoaded = percent;
+        emit bufferStatus(m_percentageLoaded * 100);
+    }
+}
+
+void MediaObject::updateAudioBuffers()
+{
+    // Schedule audio slices:
+    m_audioPlayer->scheduleAudioToGraph();
+    m_nextAudioPlayer->scheduleAudioToGraph();
+}
+
+bool MediaObject::isCrossFading()
+{
+    return m_mediaObjectAudioNode->isCrossFading();
+}
+
+void MediaObject::updateVideoFrames()
+{
+    // Draw next frame if awailable:
+    if (m_videoPlayer->videoFrameChanged()){
+        updateLipSynch(50);
+        VideoFrame frame(m_videoPlayer);           
+        if (m_nextVideoPlayer->isPlaying()
+            && m_nextVideoPlayer->hasVideo()
+            && isCrossFading()){
+            VideoFrame bgFrame(m_nextVideoPlayer);
+            frame.setBackgroundFrame(bgFrame);
+            frame.setBaseOpacity(m_mediaObjectAudioNode->m_volume1);
+        }
+        
+        // Send the frame through the graph:
+        updateVideo(frame);    
+        checkForError();
+    }
+}
+
+void MediaObject::updateLipSynch(int allowedOffset)
+{
+    if (m_audioSystem != AS_Graph || !m_audioGraph->isRunning())
+        return;
+    if (m_videoSinkList.isEmpty() || m_audioSinkList.isEmpty())
+        return;
+        
+    if (m_videoPlayer->hasVideo()){
+        qint64 diff = m_audioPlayer->currentTime() - m_videoPlayer->currentTime();
+        if (-allowedOffset > diff || diff > allowedOffset)
+            m_audioPlayer->seek(m_videoPlayer->currentTime());
+    }
+
+    if (isCrossFading() && m_nextVideoPlayer->hasVideo()){
+        qint64 diff = m_nextAudioPlayer->currentTime() - m_nextVideoPlayer->currentTime();
+        if (-(allowedOffset*2) > diff || diff > (allowedOffset*2))
+            m_nextAudioPlayer->seek(m_nextVideoPlayer->currentTime());
+    }
+}
+
+void MediaObject::bufferAudioVideo()
+{
+    long nextVideoUpdate = m_videoPlayer->hasVideo() ? 30 : INT_MAX;
+    long nextAudioUpdate = m_audioPlayer->regularTaskFrequency();
+    updateAudioBuffers();
+    updateVideoFrames();
+    if (m_state == Phonon::PlayingState)
+        updateTimer(m_bufferTimer, qMin(nextVideoUpdate, nextAudioUpdate));
+}
+
+void MediaObject::updateRapidly()
+{
+    updateCurrentTime();
+    updateCrossFade();
+    updateBufferStatus();
+}
+
+void MediaObject::setMute(bool mute)
+{
+    m_mediaObjectAudioNode->setMute(mute);
+    m_videoPlayer->setMute(mute);
+    m_nextVideoPlayer->setMute(mute);
+}
+
+void MediaObject::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    switch (event->type()){
+        case MediaNodeEvent::EndConnectionChange:
+            m_mediaObjectAudioNode->setMute(true);
+            inspectGraph();
+            setupAudioSystem();
+            synchAudioVideo();
+            checkForError();
+            m_mediaObjectAudioNode->setMute(false);
+             if (m_state == Phonon::PlayingState)
+                bufferAudioVideo();
+            break;
+        case MediaNodeEvent::AudioGraphCannotPlay:
+        case MediaNodeEvent::AudioGraphInitialized:
+            if (m_state != Phonon::LoadingState){
+                m_mediaObjectAudioNode->setMute(true);
+                setupAudioSystem();
+                updateLipSynch(0);
+                checkForError();
+                m_mediaObjectAudioNode->setMute(false);
+            }
+            break; 
+        default:
+            break;
+    }
+}
+
+bool MediaObject::event(QEvent *event)
+{
+    switch (event->type()){
+        case QEvent::Timer: {
+            QTimerEvent *timerEvent = static_cast<QTimerEvent *>(event);
+            if (timerEvent->timerId() == m_rapidTimer)
+                updateRapidly();
+            else if (timerEvent->timerId() == m_tickTimer)
+                emit tick(currentTime());
+            else if (timerEvent->timerId() == m_bufferTimer)
+                bufferAudioVideo();
+            }
+            break;
+        default:
+            break;
+    }
+    return QObject::event(event);
+}
+
+bool MediaObject::hasInterface(Interface /*interface*/) const
+{
+    return false;
+}
+
+QVariant MediaObject::interfaceCall(Interface /*interface*/, int /*command*/, const QList<QVariant> &/*arguments*/)
+{
+    return QVariant();
+}
+
+}} // namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_mediaobject.cpp"
+
diff -r -U2 -N phonon-4.3.0/qt7/objc_help.h phonon-4.3.0/qt7/objc_help.h
--- phonon-4.3.0/qt7/objc_help.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/objc_help.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,63 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef Phonon_QT7_VIDEOWIDGET_OBJC_H
-#define Phonon_QT7_VIDEOWIDGET_OBJC_H
-
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
-#include <AGL/agl.h>
-#include <QtCore>
-#include <phonon/effectparameter.h>
-
-struct CiFilterInfo
-{
-    QList<QString> filterNames;
-    QList<QString> filterDisplayNames;
-};
-
-struct CiFilterParameterInfo
-{
-    QList<QString> parameterNames;
-    QList<Phonon::EffectParameter> parameters;
-};
-
-void *objc_createPool();
-void objc_releasePool(void *pool);
-int objc_getRetainCount(void *nsObject);
-
-void *objc_createCiContext(AGLContext aglContext, AGLPixelFormat aglPixelFormat);
-void objc_releaseCiContext(void *ciContext);
-
-void objc_retainCiImage(void *ciImage);
-void objc_releaseCiImage(void *ciImage);
-void *objc_ciImageFromCvImageBuffer(void *cvImageBufferRef);
-QSize objc_ciImageSize(void *ciImage);
-void objc_drawCiImage(void *ciImage, QRect rect, void *ciContext);
-void objc_drawCiImageInv(void *ciImage, QRect rect, void *ciContext);
-
-void *objc_createCiFilter(int filterId);
-void objc_releaseCiFilter(void *ciFilter);
-void *objc_applyCiFilter(void *ciImage, void *ciFilter);
-void objc_setCiFilterParameter(void *ciFilter, int parameterId, QVariant value);
-QVariant objc_getCiFilterParameter(void *ciFilter, int parameterId);
-
-CiFilterInfo *objc_getCiFilterInfo();
-CiFilterParameterInfo objc_getCiFilterParameterInfo(void *ciFilter);
-
-#endif // Phonon_QT7_VIDEOWIDGET_OBJC_H
diff -r -U2 -N phonon-4.3.0/qt7/objc_help.mm phonon-4.3.0/qt7/objc_help.mm
--- phonon-4.3.0/qt7/objc_help.mm	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/objc_help.mm	1969-12-31 17:00:00.000000000 -0700
@@ -1,254 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "objc_help.h"
-#include "backendheader.h"
-#import <QuartzCore/QuartzCore.h>
-#include "quicktimevideoplayer.h"
-#include <private/qcore_mac_p.h>
-
-void *objc_createPool()
-{
-    return [[NSAutoreleasePool alloc] init];
-}
-
-void objc_releasePool(void *pool)
-{
-    [(NSAutoreleasePool *) pool release];
-}
-
-int objc_getRetainCount(void *nsObject)
-{
-    return (int)[(NSObject *) nsObject retainCount];
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////
-
-void *objc_createCiContext(AGLContext aglContext, AGLPixelFormat aglPixelFormat)
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    CGLContextObj cglContext = 0;
-    BACKEND_ASSERT3(aglGetCGLContext(aglContext, (void **)&cglContext),
-        "Could not get cgl context from agl context", FATAL_ERROR, 0)
-        
-    CGLPixelFormatObj cglPixelFormat = 0;
-    BACKEND_ASSERT3(aglGetCGLPixelFormat(aglPixelFormat, (void **)&cglPixelFormat),
-        "Could not get cgl pixel format from agl pixel format", FATAL_ERROR, 0)
-
-    CIContext *ciContext = [[CIContext contextWithCGLContext:cglContext pixelFormat:cglPixelFormat options:nil] retain];
-    [pool release];
-    return ciContext;
-}
-
-void objc_releaseCiContext(void *ciContext)
-{
-    [(CIContext *)ciContext release];
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////
-
-void objc_retainCiImage(void *ciImage)
-{
-    [(CIImage *) ciImage retain];
-}
-
-void objc_releaseCiImage(void *ciImage)
-{
-    [(CIImage *) ciImage release];
-}
-
-QSize objc_imageSize(void *ciImage)
-{
-    CGRect r = [(CIImage *) ciImage extent];
-    return QSize(r.size.width, r.size.height);
-}        
-
-void *objc_ciImageFromCvImageBuffer(void *cvImageBufferRef)
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    void *image = (void *)[[CIImage imageWithCVImageBuffer:(CVImageBufferRef) cvImageBufferRef] retain];
-//    return [CIImage imageWithCVImageBuffer:(CVImageBufferRef) cvImageBufferRef];
-    [pool release];
-    return image;
-}
-
-void objc_drawCiImage(void *ciImage, QRect rect, void *ciContext)
-{        
-    [(CIContext *) ciContext drawImage:(CIImage *) ciImage
-        inRect:CGRectMake(rect.x(), rect.y(), rect.width(), rect.height())
-        fromRect:[(CIImage *) ciImage extent]];
-    glFlush();
-}
-
-void objc_drawCiImageInv(void *ciImage, QRect rect, void *ciContext)
-{        
-    [(CIContext *) ciContext drawImage:(CIImage *) ciImage
-        inRect:CGRectMake(rect.x(), rect.y() + rect.height(), rect.width(), -rect.height())
-        fromRect:[(CIImage *) ciImage extent]];
-    glFlush();
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////
-
-bool acceptCiFilter(CIFilter *filter)
-{
-    // For now, only accept filters that has not other attributes
-    // than NSNumbers.
-    bool accepted = true;
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; 
-    NSDictionary *filterDictionary = [filter attributes];
-    NSArray *parameters = [filterDictionary allKeys];
-    
-    // Iterate through all parameters of the filter:
-    for (uint parameterId=0; parameterId<[parameters count]; parameterId++){
-        NSString *parameterName = (NSString*) [parameters objectAtIndex:parameterId];
-        if ([parameterName isEqualToString:@"inputImage"]
-            || [parameterName isEqualToString:@"outputImage"])
-            continue;
-            
-        NSObject *parameterValue = [filterDictionary valueForKey:parameterName];
-        if (parameterValue){
-            if ([parameterValue isKindOfClass:[NSDictionary class]]){
-                NSDictionary *parameterDictionary = (NSDictionary *) parameterValue;
-                NSString *attributeClass = [parameterDictionary valueForKey:@"CIAttributeClass"];
-                if (attributeClass && ![attributeClass isEqualToString:@"NSNumber"]){
-                    accepted = false;
-                    break;
-                }   
-            }
-        }
-    }
-    
-    [pool release];
-    return accepted;
-}
-
-CiFilterInfo *ciFilterInfo = 0; // TODO: Find some way to delete this cache?
-CiFilterInfo *objc_getCiFilterInfo()
-{
-    if (!ciFilterInfo){
-        ciFilterInfo = new CiFilterInfo;
-        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];    
-        NSArray *nslist = [CIFilter filterNamesInCategories:nil];
-        for (uint i=0; i<[nslist count]; i++){
-            NSString *filterName = (NSString*) [nslist objectAtIndex:i];
-            CIFilter *filter = [CIFilter filterWithName:filterName];
-            if (acceptCiFilter(filter)){
-                NSDictionary *filterDictionary = [filter attributes];
-                NSString *filterDispName = [filterDictionary valueForKey:@"CIAttributeFilterDisplayName"];
-                if (!filterDispName)
-                    filterDispName = filterName;
-                ciFilterInfo->filterNames.append([filterName UTF8String]);
-                ciFilterInfo->filterDisplayNames.append([filterDispName UTF8String]);
-            }
-        }
-        [pool release];
-    }
-    return ciFilterInfo;
-}
-
-void *objc_createCiFilter(int filterId)
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];    
-    CiFilterInfo *info = objc_getCiFilterInfo();
-    NSString *filterName = (NSString *) QCFString::toCFStringRef(info->filterNames[filterId]);
-    CIFilter *filter = [CIFilter filterWithName:filterName];
-    if (filter){
-        [filter retain];
-        [filter setDefaults];
-    }
-    [pool release];
-    return filter;
-}
-
-void objc_releaseCiFilter(void *ciFilter)
-{
-    [(CIFilter *) ciFilter release];
-}
-
-void objc_setCiFilterParameter(void *ciFilter, int parameterId, QVariant value)
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    QString name = objc_getCiFilterParameterInfo(ciFilter).parameterNames[parameterId];
-    NSString *nsName = (NSString *) QCFString::toCFStringRef(name);
-    [(CIFilter *) ciFilter setValue:[NSNumber numberWithFloat:value.toDouble()] forKey:nsName];
-    [pool release];
-}
-
-QVariant objc_getCiFilterParameter(void *ciFilter, int parameterId)
-{
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    QString name = objc_getCiFilterParameterInfo(ciFilter).parameterNames[parameterId];
-    NSString *nsName = (NSString *) QCFString::toCFStringRef(name);
-    NSNumber *value = [(CIFilter *) ciFilter valueForKey:nsName];
-    QVariant ret([value doubleValue]);
-    [pool release];
-    return ret;
-}
-
-void *objc_applyCiFilter(void *ciImage, void* ciFilter)
-{
-    CIImage *inputImage = (CIImage *) ciImage;    
-    CIFilter *filter = (CIFilter *) ciFilter;
-    [filter setValue:inputImage forKey:@"inputImage"];
-    return [filter valueForKey:@"outputImage"];
-}
-
-CiFilterParameterInfo objc_getCiFilterParameterInfo(void *ciFilter)
-{
-    CiFilterParameterInfo info;
-    
-    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; 
-    CIFilter *filter = (CIFilter *) ciFilter;
-    NSDictionary *filterDictionary = [filter attributes];
-    NSArray *parameters = [filterDictionary allKeys];
-    
-    // Iterate through all parameters of the filter:
-    for (uint parameterId=0; parameterId<[parameters count]; parameterId++){
-        NSString *parameterName = (NSString*) [parameters objectAtIndex:parameterId];
-        NSObject *parameterValue = [filterDictionary valueForKey:parameterName];
-        if (parameterValue){
-            if ([parameterValue isKindOfClass:[NSDictionary class]]){
-                NSDictionary *parameterDictionary = (NSDictionary *) parameterValue;
-                NSString *attributeClass = [parameterDictionary valueForKey:@"CIAttributeClass"];
-                if (attributeClass && [attributeClass isEqualToString:@"NSNumber"]){
-                    // Only parameters that stores an NSNumber are interresting.
-                    NSString *parameterDispName = [parameterDictionary valueForKey:@"CIAttributeDisplayName"];
-                    NSNumber *min = [parameterDictionary valueForKey:@"CIAttributeSliderMin"];
-                    NSNumber *max = [parameterDictionary valueForKey:@"CIAttributeSliderMax"];
-                    NSNumber *def = [parameterDictionary valueForKey:@"CIAttributeDefault"];
-                    if (!parameterDispName)
-                        parameterDispName = parameterName;
-                    
-                    // Add the parameter to the list:
-                    info.parameterNames.append([parameterName UTF8String]);
-                    info.parameters.append(Phonon::EffectParameter(parameterId, [parameterDispName UTF8String], 0,
-                            QVariant(def ? [def doubleValue] : 0),
-                            QVariant(min ? [min doubleValue] : 0),
-                            QVariant(max ? [max doubleValue] : 0)));
-                }   
-            }
-        }
-    }
-    
-    [pool release];    
-    return info;
-}
-
-
-
-
diff -r -U2 -N phonon-4.3.0/qt7/quicktimeaudioplayer.cpp phonon-4.3.0/qt7/quicktimeaudioplayer.cpp
--- phonon-4.3.0/qt7/quicktimeaudioplayer.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimeaudioplayer.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,495 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "quicktimeaudioplayer.h"
-#include "quicktimevideoplayer.h"
-#include "backendheader.h"
-#include "audiograph.h"
-#include "medianodeevent.h"
-#include "medianode.h"
-#include <private/qt_mac_p.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-QuickTimeAudioPlayer::QuickTimeAudioPlayer() : AudioNode(0, 1)
-{
-    m_state = NoMedia;
-    m_videoPlayer = 0;
-    m_audioExtractionRef = 0;
-    m_audioChannelLayout = 0;
-    m_sliceList = 0;
-    m_sliceCount = 30;
-    m_maxExtractionPacketCount = 4096;
-    m_audioExtractionComplete = false;
-    m_audioEnabled = true;
-    m_samplesRemaining = -1;
-    m_startTime = 0;
-    m_sampleTimeStamp = 0;
-    m_duration = 0;
-    m_audioUnitIsReset = true;
-}
-
-QuickTimeAudioPlayer::~QuickTimeAudioPlayer()
-{
-    unsetVideoPlayer();
-}
-
-void QuickTimeAudioPlayer::unsetVideoPlayer()
-{
-    if (m_audioUnit){
-        OSStatus err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
-        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit when unsetting movie", FATAL_ERROR)
-    }
-
-    // FIX: When streaming media, and the app quits, the follwing command
-    // makes the app crash. Cannot see why at the moment.
-    if (m_audioExtractionRef && m_videoPlayer && m_videoPlayer->movieRef())
-         MovieAudioExtractionEnd(m_audioExtractionRef);
-
-    if (m_audioChannelLayout){
-        free(m_audioChannelLayout);
-        m_audioChannelLayout = 0;
-    }
-    
-    if (m_sliceList){
-        for (int i=0; i<m_sliceCount; i++)
-	        free(m_sliceList[i].mBufferList);
-        free(m_sliceList);
-        m_sliceList = 0;
-    }
-    
-    m_videoPlayer = 0;
-    m_audioExtractionRef = 0;
-    m_audioExtractionComplete = false;
-    m_samplesRemaining = -1;
-    m_sampleTimeStamp = 0;
-    m_state = NoMedia;
-}
-
-void QuickTimeAudioPlayer::enableAudio(bool enable)
-{
-    // Remember to seek after enabling audio.
-    if (enable == m_audioEnabled)
-        return;
-        
-    m_audioEnabled = enable;
-    if (!enable)
-        flush();
-}
-
-bool QuickTimeAudioPlayer::audioEnabled()
-{
-    return m_audioEnabled;
-}
-
-void QuickTimeAudioPlayer::setVideoPlayer(QuickTimeVideoPlayer *videoPlayer)
-{
-    unsetVideoPlayer();
-    if (videoPlayer && videoPlayer->movieRef()){
-        m_videoPlayer = videoPlayer;
-        m_duration = getLongestSoundtrackDurationInMs();
-        initSoundExtraction();
-        allocateSoundSlices();
-        m_state = Paused;
-        seek(0);
-    }
-}
-
-QuickTimeVideoPlayer *QuickTimeAudioPlayer::videoPlayer()
-{
-    return m_videoPlayer;
-}
-
-void QuickTimeAudioPlayer::scheduleAudioToGraph()
-{
-    if (!m_videoPlayer || !m_audioEnabled || m_audioExtractionComplete || m_state != Playing)
-        return;
-
-    // Schedule audio slices, and detect if everything went OK.
-    // If not, flag the need for another audio system, but let
-    // the end app know about it:
-    gClearError();
-    scheduleSoundSlices();    
-    if (gGetErrorType() != NO_ERROR){
-        gClearError();
-        if (m_audioGraph)
-            m_audioGraph->setStatusCannotPlay();
-    }
-}
-
-void QuickTimeAudioPlayer::flush()
-{
-    // Empty scheduled audio data, so playback
-    // will stop. Call seek to refill data again.
-    if (m_audioUnit){
-        m_startTime = currentTime();
-        OSStatus err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
-        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit on pause", FATAL_ERROR)
-        m_audioUnitIsReset = true;
-    }
-}
-
-void QuickTimeAudioPlayer::pause()
-{
-    m_state = Paused;
-    flush();
-}
-
-void QuickTimeAudioPlayer::play()
-{
-    m_state = Playing;
-    if (!m_audioEnabled)
-        return;
-    if (m_audioUnitIsReset)
-        seek(m_startTime);
-    else
-        scheduleAudioToGraph();
-}
-
-bool QuickTimeAudioPlayer::isPlaying()
-{
-    return m_videoPlayer && m_state == Playing;
-}
-
-void QuickTimeAudioPlayer::seek(quint64 milliseconds)
-{
-    if (milliseconds > m_duration)
-        milliseconds = m_duration;
-    if (!m_audioUnitIsReset && milliseconds == currentTime())
-        return;
-        
-    m_startTime = milliseconds;
-    
-    // Since the graph may be running (advancing time), there is
-    // no point in seeking if were not going to play immidiatly:
-    if (m_state != Playing)
-        return;
-    if (!m_audioUnit)
-        return;
-    if (!m_videoPlayer || !m_audioEnabled || !m_videoPlayer->isSeekable())
-        return;    
-
-    // Reset (and stop playing):
-    OSStatus err;
-    if (!m_audioUnitIsReset){
-        err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
-        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit before seek", FATAL_ERROR)
-    }
-    m_sampleTimeStamp = 0;
-    for (int i = 0; i < m_sliceCount; i++)
-	    m_sliceList[i].mFlags = kScheduledAudioSliceFlag_Complete;
-
-    // Start to play again immidiatly:
-    AudioTimeStamp timeStamp;
-    memset(&timeStamp, 0, sizeof(timeStamp));
-	timeStamp.mFlags = kAudioTimeStampSampleTimeValid;
-    timeStamp.mSampleTime = -1;
-	err = AudioUnitSetProperty(m_audioUnit,
-        kAudioUnitProperty_ScheduleStartTimeStamp, kAudioUnitScope_Global,
-        0, &timeStamp, sizeof(timeStamp));
-    BACKEND_ASSERT2(err == noErr, "Could not set schedule start time stamp on audio player unit", FATAL_ERROR)
-
-    // Seek back to 'now' in the movie:
-    TimeRecord timeRec;
-	timeRec.scale = GetMovieTimeScale(m_videoPlayer->movieRef());
-    timeRec.base = 0;
-	timeRec.value.hi = 0;
-	timeRec.value.lo = (milliseconds / 1000.0f) * timeRec.scale;
-	err = MovieAudioExtractionSetProperty(m_audioExtractionRef,
-        kQTPropertyClass_MovieAudioExtraction_Movie,
-        kQTMovieAudioExtractionMoviePropertyID_CurrentTime,
-        sizeof(TimeRecord), &timeRec);
-    BACKEND_ASSERT2(err == noErr, "Could not set current time on audio player unit", FATAL_ERROR)
-
-    float durationLeftSec = float(m_duration - milliseconds) / 1000.0f;
-    m_samplesRemaining = (durationLeftSec > 0) ? (durationLeftSec * m_audioStreamDescription.mSampleRate) : -1;
-    m_audioExtractionComplete = false;
-    m_audioUnitIsReset = false;    
-    scheduleAudioToGraph();
-}
-
-quint64 QuickTimeAudioPlayer::currentTime()
-{
-    if (!m_audioUnit){
-        if (m_videoPlayer)
-            return m_videoPlayer->currentTime();
-        else
-            return m_startTime;
-    }
-
-    Float64 currentUnitTime = getTimeInSamples(kAudioUnitProperty_CurrentPlayTime);
-    if (currentUnitTime == -1)
-        currentUnitTime = 0;
-
-    quint64 cTime = quint64(m_startTime +
-        float(currentUnitTime / float(m_audioStreamDescription.mSampleRate)) * 1000.0f);
-    return (cTime < m_duration) ? cTime : m_duration;
-}
-
-QString QuickTimeAudioPlayer::currentTimeString()
-{
-    return QuickTimeVideoPlayer::timeToString(currentTime());
-}
-
-bool QuickTimeAudioPlayer::hasAudio()
-{
-    if (!m_videoPlayer)
-        return false;
-        
-    return m_videoPlayer->hasAudio();
-}
-
-bool QuickTimeAudioPlayer::soundPlayerIsAwailable()
-{
-    QuickTimeAudioPlayer player;
-    ComponentDescription d = player.getAudioNodeDescription();
-    return FindNextComponent(0, &d);
-}
-
-ComponentDescription QuickTimeAudioPlayer::getAudioNodeDescription() const
-{
-	ComponentDescription description;
-	description.componentType = kAudioUnitType_Generator;
-	description.componentSubType = kAudioUnitSubType_ScheduledSoundPlayer;
-	description.componentManufacturer = kAudioUnitManufacturer_Apple;
-	description.componentFlags = 0;
-	description.componentFlagsMask = 0;
-    return description;
-}
-
-void QuickTimeAudioPlayer::initializeAudioUnit()
-{
-}
-
-bool QuickTimeAudioPlayer::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
-{
-    if (!m_videoPlayer){
-        if (side == Source)
-            DEBUG_AUDIO_STREAM("QuickTimeAudioPlayer" << int(this) << "is source, but has no movie to use for stream spec fill.")
-        return true;
-    }
-
-    if (side == Source){
-        DEBUG_AUDIO_STREAM("QuickTimeAudioPlayer" << int(this) << "is source, and fills in stream spec from movie.")
-        connection->m_sourceStreamDescription = m_audioStreamDescription;
-        connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_audioChannelLayoutSize);
-        memcpy(connection->m_sourceChannelLayout, m_audioChannelLayout, m_audioChannelLayoutSize);
-        connection->m_sourceChannelLayoutSize = m_audioChannelLayoutSize;
-        connection->m_hasSourceSpecification = true;
-    }
-    return true;
-}
-
-qint64 QuickTimeAudioPlayer::getLongestSoundtrackDurationInMs()
-{
-    if (!m_videoPlayer)
-        return 0;
-
-    TimeValue maxDuration = 0;
-    int ntracks = GetMovieTrackCount(m_videoPlayer->movieRef());
-    if (ntracks){
-        for (int i=1; i<ntracks + 1; ++i) {
-            Track track = GetMovieIndTrackType(m_videoPlayer->movieRef(), i, SoundMediaType, movieTrackMediaType);
-            if (track){
-                TimeValue duration = GetTrackDuration(track);
-                if (duration > maxDuration) maxDuration = duration;
-            }
-        }
-        return 1000 * (float(maxDuration) / float(GetMovieTimeScale(m_videoPlayer->movieRef())));
-    }
-    return 0;
-}
-
-long QuickTimeAudioPlayer::regularTaskFrequency(){
-    if (!m_audioEnabled || !m_audioUnit || (m_audioGraph && m_audioGraph->graphCannotPlay()))
-        return INT_MAX;
-
-    // Calculate how much audio in
-    // milliseconds our slices can hold:
-    int packetNeedPerSecond = m_audioStreamDescription.mSampleRate / m_maxExtractionPacketCount;
-    long bufferTimeLengthSec = float(m_sliceCount) / float(packetNeedPerSecond);
-    // Make sure we also get some time to fill the
-    // buffer, so divide the time by two:
-    return (bufferTimeLengthSec * (1000 / 2));
-}
-
-void QuickTimeAudioPlayer::initSoundExtraction()
-{
-    // Initilize the extraction:
-	OSStatus err = noErr;
-	err = MovieAudioExtractionBegin(m_videoPlayer->movieRef(), 0, &m_audioExtractionRef);
-    BACKEND_ASSERT2(err == noErr, "Could not start audio extraction on audio player unit", FATAL_ERROR)
-	m_discrete = false;
-#if 0
-    // Extract all channels as descrete:
-    err = MovieAudioExtractionSetProperty(audioExtractionRef,
-        kQTPropertyClass_MovieAudioExtraction_Movie,
-        kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
-        sizeof (discrete),
-        &discrete);
-    BACKEND_ASSERT2(err == noErr, "Could not set channels discrete on audio player unit", FATAL_ERROR)
-#endif
-
-	// Get the size of the audio channel layout (may include offset):
-	err = MovieAudioExtractionGetPropertyInfo(m_audioExtractionRef,
-	    kQTPropertyClass_MovieAudioExtraction_Audio,
-        kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
-        0, &m_audioChannelLayoutSize, 0);
-    BACKEND_ASSERT2(err == noErr, "Could not get channel layout size from audio extraction", FATAL_ERROR)
-
-	// Allocate memory for the layout
-	m_audioChannelLayout = (AudioChannelLayout *) calloc(1, m_audioChannelLayoutSize);
-    BACKEND_ASSERT2(m_audioChannelLayout, "Could not allocate memory for channel layout on audio player unit", FATAL_ERROR)
-
-	// Get the layout:
-	err = MovieAudioExtractionGetProperty(m_audioExtractionRef,
-	    kQTPropertyClass_MovieAudioExtraction_Audio,
-		kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
-		m_audioChannelLayoutSize, m_audioChannelLayout, 0);
-    BACKEND_ASSERT2(err == noErr, "Could not get channel layout from audio extraction", FATAL_ERROR)
-
-	// Get audio stream description:
-	err = MovieAudioExtractionGetProperty(m_audioExtractionRef,
-        kQTPropertyClass_MovieAudioExtraction_Audio,
-        kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
-        sizeof(m_audioStreamDescription), &m_audioStreamDescription, 0);
-    BACKEND_ASSERT2(err == noErr, "Could not get audio stream description from audio extraction", FATAL_ERROR)
-}
-
-void QuickTimeAudioPlayer::allocateSoundSlices()
-{
-    // m_sliceList will contain a specified number of ScheduledAudioSlice-s that each can
-    // carry audio from extraction, and be scheduled for playback at an audio unit.
-    // Each ScheduledAudioSlice will contain several audio buffers, one for each sound channel.
-    // Each buffer will carry (at most) a specified number of sound packets, and each packet can
-    // contain one or more frames.
-
-    // Create a list of ScheduledAudioSlices:
-	m_sliceList = (ScheduledAudioSlice *) calloc(m_sliceCount, sizeof(ScheduledAudioSlice));
-    BACKEND_ASSERT2(m_sliceList, "Could not allocate memory for audio slices", FATAL_ERROR)
-	bzero(m_sliceList, m_sliceCount * sizeof(ScheduledAudioSlice));
-
-    // Calculate the size of the different structures needed:
-	int packetsBufferSize = m_maxExtractionPacketCount * m_audioStreamDescription.mBytesPerPacket;
-    int channels = m_audioStreamDescription.mChannelsPerFrame;
-	int audioBufferListSize = int(sizeof(AudioBufferList) + (channels-1) * sizeof(AudioBuffer));
-	int mallocSize = audioBufferListSize + (packetsBufferSize * m_audioStreamDescription.mChannelsPerFrame);
-
-    // Round off to Altivec sizes:
-    packetsBufferSize = int(((packetsBufferSize + 15) / 16) * 16);
-    audioBufferListSize = int(((audioBufferListSize + 15) / 16) * 16);
-
- 	for (int sliceIndex = 0; sliceIndex < m_sliceCount; ++sliceIndex){
-        // Create the memory chunk for this audio slice:
-		AudioBufferList	*audioBufferList = (AudioBufferList*) calloc(1, mallocSize);
-        BACKEND_ASSERT2(audioBufferList, "Could not allocate memory for audio buffer list", FATAL_ERROR)
-
-        // The AudioBufferList contains an AudioBuffer for each channel in the audio stream:
-		audioBufferList->mNumberBuffers = m_audioStreamDescription.mChannelsPerFrame;
-		for (uint i = 0; i < audioBufferList->mNumberBuffers; ++i){
-			audioBufferList->mBuffers[i].mNumberChannels = 1;
-			audioBufferList->mBuffers[i].mData = (char *) audioBufferList + audioBufferListSize + (i * packetsBufferSize);
-			audioBufferList->mBuffers[i].mDataByteSize = packetsBufferSize;
-		}
-
-		m_sliceList[sliceIndex].mBufferList = audioBufferList;
-		m_sliceList[sliceIndex].mNumberFrames = m_maxExtractionPacketCount;
-		m_sliceList[sliceIndex].mTimeStamp.mFlags = kAudioTimeStampSampleTimeValid;
-		m_sliceList[sliceIndex].mCompletionProcUserData = 0;
-		m_sliceList[sliceIndex].mCompletionProc = 0;
-		m_sliceList[sliceIndex].mFlags = kScheduledAudioSliceFlag_Complete;
-		m_sliceList[sliceIndex].mReserved = 0;
-	}
-}
-
-void QuickTimeAudioPlayer::scheduleSoundSlices()
-{
-    QMacCocoaAutoReleasePool pool;
-	// For each completed (or never used) slice, fill and schedule it.
-	for (int sliceIndex = 0; sliceIndex < m_sliceCount; ++sliceIndex){
-		if (m_sliceList[sliceIndex].mFlags & kScheduledAudioSliceFlag_Complete){
-			if (m_samplesRemaining == 0)
-				m_audioExtractionComplete = true;
-
-			if (!m_audioExtractionComplete){
-			    // Determine how many samples to read:
-				int samplesCount = m_samplesRemaining;
-				if ((samplesCount > m_maxExtractionPacketCount) || (samplesCount == -1))
-					samplesCount = m_maxExtractionPacketCount;
-				m_sliceList[sliceIndex].mTimeStamp.mSampleTime = m_sampleTimeStamp;
-
-	            // Reset buffer sizes:
-	            int byteSize = samplesCount * m_audioStreamDescription.mBytesPerPacket;
-	            for (uint i = 0; i < m_sliceList[sliceIndex].mBufferList->mNumberBuffers; ++i)
-                    m_sliceList[sliceIndex].mBufferList->mBuffers[i].mDataByteSize = byteSize;
-
-	            // Do the extraction:
-                UInt32 flags = 0;
-                UInt32 samplesRead = samplesCount;
-	            OSStatus err = MovieAudioExtractionFillBuffer(
-	                m_audioExtractionRef, &samplesRead, m_sliceList[sliceIndex].mBufferList, &flags);
-                BACKEND_ASSERT2(err == noErr, "Could not fill audio buffers from audio extraction", FATAL_ERROR)
-	            m_audioExtractionComplete = (flags & kQTMovieAudioExtractionComplete);
-
-	            // Play the slice:
-	            if (samplesRead != 0 && m_audioUnit != 0){
-                    m_sliceList[sliceIndex].mNumberFrames = samplesRead;
-                    err = AudioUnitSetProperty(m_audioUnit,
-                        kAudioUnitProperty_ScheduleAudioSlice, kAudioUnitScope_Global,
-                        0, &m_sliceList[sliceIndex], sizeof(ScheduledAudioSlice));
-                    BACKEND_ASSERT2(err == noErr, "Could not schedule audio buffers on audio unit", FATAL_ERROR)
- 	            } else
-					m_sliceList[sliceIndex].mFlags = kScheduledAudioSliceFlag_Complete;
-
-                // Move the window:
-				m_sampleTimeStamp += samplesRead;
-				if (m_samplesRemaining != -1)
-					m_samplesRemaining -= samplesRead;
-			}
-		}
-	}
-}
-
-void QuickTimeAudioPlayer::mediaNodeEvent(const MediaNodeEvent *event)
-{
-    switch (event->type()){
-        case MediaNodeEvent::AudioGraphAboutToBeDeleted:
-        case MediaNodeEvent::AboutToRestartAudioStream:
-        case MediaNodeEvent::StartConnectionChange:
-            m_startTime = currentTime();
-            break;
-        case MediaNodeEvent::AudioGraphInitialized:
-        case MediaNodeEvent::RestartAudioStreamRequest:
-        case MediaNodeEvent::EndConnectionChange:
-            if (m_state == Playing)
-                seek(m_startTime);
-            break;
-       default:
-            break;
-    }
-}
-
-}}
-
-QT_END_NAMESPACE
-
-
diff -r -U2 -N phonon-4.3.0/qt7/quicktimeaudioplayer.h phonon-4.3.0/qt7/quicktimeaudioplayer.h
--- phonon-4.3.0/qt7/quicktimeaudioplayer.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimeaudioplayer.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,13 +19,16 @@
 #define Phonon_QT7_QUICKTIMEAUDIOPLAYER_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
+#include "backendheader.h"
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    #include <QuickTime/QuickTime.h>
+    #undef check // avoid name clash;
+#endif
 
 #include <phonon/mediasource.h>
 #include <Carbon/Carbon.h>
+#include <QtCore/QString>
 #include "audionode.h"
 
-#include <QtCore>
-
 QT_BEGIN_NAMESPACE
 
@@ -37,5 +40,5 @@
     class MediaNodeEvent;
     class QuickTimeVideoPlayer;
-    
+
     class QuickTimeAudioPlayer : public AudioNode
     {
@@ -62,5 +65,4 @@
             quint64 currentTime();
             QString currentTimeString();
-            qint64 getLongestSoundtrackDurationInMs();
             QuickTimeVideoPlayer *videoPlayer();
 
@@ -80,9 +82,12 @@
             State m_state;
             QuickTimeVideoPlayer *m_videoPlayer;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
             MovieAudioExtractionRef m_audioExtractionRef;
-            ScheduledAudioSlice *m_sliceList;
+#endif
 
+            ScheduledAudioSlice *m_sliceList;
             AudioChannelLayout *m_audioChannelLayout;
-        	UInt32 m_audioChannelLayoutSize;
+            UInt32 m_audioChannelLayoutSize;
             AudioStreamBasicDescription m_audioStreamDescription;
 
@@ -99,5 +104,4 @@
             Float64 m_sampleTimeStamp;
             quint64 m_startTime;
-            quint64 m_duration;
     };
 
@@ -105,3 +109,4 @@
 
 QT_END_NAMESPACE
+
 #endif // Phonon_QT7_QUICKTIMEAUDIOPLAYER_H
diff -r -U2 -N phonon-4.3.0/qt7/quicktimeaudioplayer.mm phonon-4.3.0/qt7/quicktimeaudioplayer.mm
--- phonon-4.3.0/qt7/quicktimeaudioplayer.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimeaudioplayer.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,491 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "quicktimeaudioplayer.h"
+#include "quicktimevideoplayer.h"
+#include "audiograph.h"
+#include "medianodeevent.h"
+#include "medianode.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+QuickTimeAudioPlayer::QuickTimeAudioPlayer() : AudioNode(0, 1)
+{
+    m_state = NoMedia;
+    m_videoPlayer = 0;
+    m_audioChannelLayout = 0;
+    m_sliceList = 0;
+    m_sliceCount = 30;
+    m_maxExtractionPacketCount = 4096;
+    m_audioExtractionComplete = false;
+    m_audioEnabled = true;
+    m_samplesRemaining = -1;
+    m_startTime = 0;
+    m_sampleTimeStamp = 0;
+    m_audioUnitIsReset = true;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    m_audioExtractionRef = 0;
+#endif
+}
+
+QuickTimeAudioPlayer::~QuickTimeAudioPlayer()
+{
+    unsetVideoPlayer();
+}
+
+void QuickTimeAudioPlayer::unsetVideoPlayer()
+{
+    if (m_audioUnit){
+        OSStatus err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
+        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit when unsetting movie", FATAL_ERROR)
+    }
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    if (m_audioExtractionRef && m_videoPlayer && m_videoPlayer->hasMovie())
+         MovieAudioExtractionEnd(m_audioExtractionRef);
+    m_audioExtractionRef = 0;
+#endif
+
+    if (m_audioChannelLayout){
+        free(m_audioChannelLayout);
+        m_audioChannelLayout = 0;
+    }
+    
+    if (m_sliceList){
+        for (int i=0; i<m_sliceCount; i++)
+	        free(m_sliceList[i].mBufferList);
+        free(m_sliceList);
+        m_sliceList = 0;
+    }
+    
+    m_videoPlayer = 0;
+    m_audioExtractionComplete = false;
+    m_samplesRemaining = -1;
+    m_sampleTimeStamp = 0;
+    m_state = NoMedia;
+}
+
+void QuickTimeAudioPlayer::enableAudio(bool enable)
+{
+    // Remember to seek after enabling audio.
+    if (enable == m_audioEnabled)
+        return;
+        
+    m_audioEnabled = enable;
+    if (!enable)
+        flush();
+}
+
+bool QuickTimeAudioPlayer::audioEnabled()
+{
+    return m_audioEnabled;
+}
+
+void QuickTimeAudioPlayer::setVideoPlayer(QuickTimeVideoPlayer *videoPlayer)
+{
+    unsetVideoPlayer();
+    if (videoPlayer && videoPlayer->hasMovie()){
+        m_videoPlayer = videoPlayer;
+        initSoundExtraction();
+        allocateSoundSlices();
+        m_state = Paused;
+        seek(0);
+    }
+}
+
+QuickTimeVideoPlayer *QuickTimeAudioPlayer::videoPlayer()
+{
+    return m_videoPlayer;
+}
+
+void QuickTimeAudioPlayer::scheduleAudioToGraph()
+{
+    if (!m_videoPlayer || !m_audioEnabled || m_audioExtractionComplete || m_state != Playing)
+        return;
+
+    // Schedule audio slices, and detect if everything went OK.
+    // If not, flag the need for another audio system, but let
+    // the end app know about it:
+    gClearError();
+    scheduleSoundSlices();    
+    if (gGetErrorType() != NO_ERROR){
+        gClearError();
+        if (m_audioGraph)
+            m_audioGraph->setStatusCannotPlay();
+    }
+}
+
+void QuickTimeAudioPlayer::flush()
+{
+    // Empty scheduled audio data, so playback
+    // will stop. Call seek to refill data again.
+    if (m_audioUnit){
+        m_startTime = currentTime();
+        OSStatus err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
+        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit on pause", FATAL_ERROR)
+        m_audioUnitIsReset = true;
+    }
+}
+
+void QuickTimeAudioPlayer::pause()
+{
+    m_state = Paused;
+    flush();
+}
+
+void QuickTimeAudioPlayer::play()
+{
+    m_state = Playing;
+    if (!m_audioEnabled)
+        return;
+    if (m_audioUnitIsReset)
+        seek(m_startTime);
+    else
+        scheduleAudioToGraph();
+}
+
+bool QuickTimeAudioPlayer::isPlaying()
+{
+    return m_videoPlayer && m_state == Playing;
+}
+
+void QuickTimeAudioPlayer::seek(quint64 milliseconds)
+{
+    if (!m_videoPlayer || !m_videoPlayer->hasMovie())
+        return;    
+    if (milliseconds > m_videoPlayer->duration())
+        milliseconds = m_videoPlayer->duration();
+    if (!m_audioUnitIsReset && milliseconds == currentTime())
+        return;
+        
+    m_startTime = milliseconds;
+    
+    // Since the graph may be running (advancing time), there is
+    // no point in seeking if were not going to play immidiatly:
+    if (m_state != Playing)
+        return;
+    if (!m_audioUnit)
+        return;
+    if (!m_audioEnabled || !m_videoPlayer->isSeekable())
+        return;
+
+    // Reset (and stop playing):
+    OSStatus err;
+    if (!m_audioUnitIsReset){
+        err = AudioUnitReset(m_audioUnit, kAudioUnitScope_Global, 0);
+        BACKEND_ASSERT2(err == noErr, "Could not reset audio player unit before seek", FATAL_ERROR)
+    }
+    m_sampleTimeStamp = 0;
+    for (int i = 0; i < m_sliceCount; i++)
+	    m_sliceList[i].mFlags = kScheduledAudioSliceFlag_Complete;
+
+    // Start to play again immidiatly:
+    AudioTimeStamp timeStamp;
+    memset(&timeStamp, 0, sizeof(timeStamp));
+	timeStamp.mFlags = kAudioTimeStampSampleTimeValid;
+    timeStamp.mSampleTime = -1;
+	err = AudioUnitSetProperty(m_audioUnit,
+        kAudioUnitProperty_ScheduleStartTimeStamp, kAudioUnitScope_Global,
+        0, &timeStamp, sizeof(timeStamp));
+    BACKEND_ASSERT2(err == noErr, "Could not set schedule start time stamp on audio player unit", FATAL_ERROR)
+
+    // Seek back to 'now' in the movie:
+    TimeRecord timeRec;
+	timeRec.scale = m_videoPlayer->timeScale();
+    timeRec.base = 0;
+	timeRec.value.hi = 0;
+	timeRec.value.lo = (milliseconds / 1000.0f) * timeRec.scale;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+	err = MovieAudioExtractionSetProperty(m_audioExtractionRef,
+        kQTPropertyClass_MovieAudioExtraction_Movie,
+        kQTMovieAudioExtractionMoviePropertyID_CurrentTime,
+        sizeof(TimeRecord), &timeRec);
+    BACKEND_ASSERT2(err == noErr, "Could not set current time on audio player unit", FATAL_ERROR)
+#endif
+
+    float durationLeftSec = float(m_videoPlayer->duration() - milliseconds) / 1000.0f;
+    m_samplesRemaining = (durationLeftSec > 0) ? (durationLeftSec * m_audioStreamDescription.mSampleRate) : -1;
+    m_audioExtractionComplete = false;
+    m_audioUnitIsReset = false;    
+    scheduleAudioToGraph();
+
+}
+
+quint64 QuickTimeAudioPlayer::currentTime()
+{
+    if (!m_audioUnit){
+        if (m_videoPlayer)
+            return m_videoPlayer->currentTime();
+        else
+            return m_startTime;
+    }
+
+    Float64 currentUnitTime = getTimeInSamples(kAudioUnitProperty_CurrentPlayTime);
+    if (currentUnitTime == -1)
+        currentUnitTime = 0;
+
+    quint64 cTime = quint64(m_startTime +
+        float(currentUnitTime / float(m_audioStreamDescription.mSampleRate)) * 1000.0f);
+    return (m_videoPlayer && cTime > m_videoPlayer->duration()) ? m_videoPlayer->duration() : cTime;
+}
+
+QString QuickTimeAudioPlayer::currentTimeString()
+{
+    return QuickTimeVideoPlayer::timeToString(currentTime());
+}
+
+bool QuickTimeAudioPlayer::hasAudio()
+{
+    if (!m_videoPlayer)
+        return false;
+        
+    return m_videoPlayer->hasAudio();
+}
+
+bool QuickTimeAudioPlayer::soundPlayerIsAwailable()
+{
+    QuickTimeAudioPlayer player;
+    ComponentDescription d = player.getAudioNodeDescription();
+    return FindNextComponent(0, &d);
+}
+
+ComponentDescription QuickTimeAudioPlayer::getAudioNodeDescription() const
+{
+	ComponentDescription description;
+	description.componentType = kAudioUnitType_Generator;
+	description.componentSubType = kAudioUnitSubType_ScheduledSoundPlayer;
+	description.componentManufacturer = kAudioUnitManufacturer_Apple;
+	description.componentFlags = 0;
+	description.componentFlagsMask = 0;
+    return description;
+}
+
+void QuickTimeAudioPlayer::initializeAudioUnit()
+{
+}
+
+bool QuickTimeAudioPlayer::fillInStreamSpecification(AudioConnection *connection, ConnectionSide side)
+{
+    if (!m_videoPlayer){
+        if (side == Source)
+            DEBUG_AUDIO_STREAM("QuickTimeAudioPlayer" << int(this) << "is source, but has no movie to use for stream spec fill.")
+        return true;
+    }
+
+    if (side == Source){
+        DEBUG_AUDIO_STREAM("QuickTimeAudioPlayer" << int(this) << "is source, and fills in stream spec from movie.")
+        connection->m_sourceStreamDescription = m_audioStreamDescription;
+        connection->m_sourceChannelLayout = (AudioChannelLayout *) malloc(m_audioChannelLayoutSize);
+        memcpy(connection->m_sourceChannelLayout, m_audioChannelLayout, m_audioChannelLayoutSize);
+        connection->m_sourceChannelLayoutSize = m_audioChannelLayoutSize;
+        connection->m_hasSourceSpecification = true;
+    }
+    return true;
+}
+
+long QuickTimeAudioPlayer::regularTaskFrequency(){
+    if (!m_audioEnabled || !m_audioUnit || (m_audioGraph && m_audioGraph->graphCannotPlay()))
+        return INT_MAX;
+
+    // Calculate how much audio in
+    // milliseconds our slices can hold:
+    int packetNeedPerSecond = m_audioStreamDescription.mSampleRate / m_maxExtractionPacketCount;
+    long bufferTimeLengthSec = float(m_sliceCount) / float(packetNeedPerSecond);
+    // Make sure we also get some time to fill the
+    // buffer, so divide the time by two:
+    return (bufferTimeLengthSec * (1000 / 2));
+}
+
+void QuickTimeAudioPlayer::initSoundExtraction()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+
+    // Initilize the extraction:
+	OSStatus err = noErr;
+	err = MovieAudioExtractionBegin([m_videoPlayer->qtMovie() quickTimeMovie], 0, &m_audioExtractionRef);
+    BACKEND_ASSERT2(err == noErr, "Could not start audio extraction on audio player unit", FATAL_ERROR)
+	m_discrete = false;
+#if 0
+    // Extract all channels as descrete:
+    err = MovieAudioExtractionSetProperty(audioExtractionRef,
+        kQTPropertyClass_MovieAudioExtraction_Movie,
+        kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
+        sizeof (discrete),
+        &discrete);
+    BACKEND_ASSERT2(err == noErr, "Could not set channels discrete on audio player unit", FATAL_ERROR)
+#endif
+
+	// Get the size of the audio channel layout (may include offset):
+	err = MovieAudioExtractionGetPropertyInfo(m_audioExtractionRef,
+	    kQTPropertyClass_MovieAudioExtraction_Audio,
+        kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
+        0, &m_audioChannelLayoutSize, 0);
+    BACKEND_ASSERT2(err == noErr, "Could not get channel layout size from audio extraction", FATAL_ERROR)
+
+	// Allocate memory for the layout
+	m_audioChannelLayout = (AudioChannelLayout *) calloc(1, m_audioChannelLayoutSize);
+    BACKEND_ASSERT2(m_audioChannelLayout, "Could not allocate memory for channel layout on audio player unit", FATAL_ERROR)
+
+	// Get the layout:
+	err = MovieAudioExtractionGetProperty(m_audioExtractionRef,
+	    kQTPropertyClass_MovieAudioExtraction_Audio,
+		kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
+		m_audioChannelLayoutSize, m_audioChannelLayout, 0);
+    BACKEND_ASSERT2(err == noErr, "Could not get channel layout from audio extraction", FATAL_ERROR)
+
+	// Get audio stream description:
+	err = MovieAudioExtractionGetProperty(m_audioExtractionRef,
+        kQTPropertyClass_MovieAudioExtraction_Audio,
+        kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
+        sizeof(m_audioStreamDescription), &m_audioStreamDescription, 0);
+    BACKEND_ASSERT2(err == noErr, "Could not get audio stream description from audio extraction", FATAL_ERROR)
+    
+#endif // QUICKTIME_C_API_AVAILABLE
+}
+
+void QuickTimeAudioPlayer::allocateSoundSlices()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+
+    // m_sliceList will contain a specified number of ScheduledAudioSlice-s that each can
+    // carry audio from extraction, and be scheduled for playback at an audio unit.
+    // Each ScheduledAudioSlice will contain several audio buffers, one for each sound channel.
+    // Each buffer will carry (at most) a specified number of sound packets, and each packet can
+    // contain one or more frames.
+
+    // Create a list of ScheduledAudioSlices:
+	m_sliceList = (ScheduledAudioSlice *) calloc(m_sliceCount, sizeof(ScheduledAudioSlice));
+    BACKEND_ASSERT2(m_sliceList, "Could not allocate memory for audio slices", FATAL_ERROR)
+	bzero(m_sliceList, m_sliceCount * sizeof(ScheduledAudioSlice));
+
+    // Calculate the size of the different structures needed:
+	int packetsBufferSize = m_maxExtractionPacketCount * m_audioStreamDescription.mBytesPerPacket;
+    int channels = m_audioStreamDescription.mChannelsPerFrame;
+	int audioBufferListSize = int(sizeof(AudioBufferList) + (channels-1) * sizeof(AudioBuffer));
+	int mallocSize = audioBufferListSize + (packetsBufferSize * m_audioStreamDescription.mChannelsPerFrame);
+
+    // Round off to Altivec sizes:
+    packetsBufferSize = int(((packetsBufferSize + 15) / 16) * 16);
+    audioBufferListSize = int(((audioBufferListSize + 15) / 16) * 16);
+
+ 	for (int sliceIndex = 0; sliceIndex < m_sliceCount; ++sliceIndex){
+        // Create the memory chunk for this audio slice:
+		AudioBufferList	*audioBufferList = (AudioBufferList*) calloc(1, mallocSize);
+        BACKEND_ASSERT2(audioBufferList, "Could not allocate memory for audio buffer list", FATAL_ERROR)
+
+        // The AudioBufferList contains an AudioBuffer for each channel in the audio stream:
+		audioBufferList->mNumberBuffers = m_audioStreamDescription.mChannelsPerFrame;
+		for (uint i = 0; i < audioBufferList->mNumberBuffers; ++i){
+			audioBufferList->mBuffers[i].mNumberChannels = 1;
+			audioBufferList->mBuffers[i].mData = (char *) audioBufferList + audioBufferListSize + (i * packetsBufferSize);
+			audioBufferList->mBuffers[i].mDataByteSize = packetsBufferSize;
+		}
+
+		m_sliceList[sliceIndex].mBufferList = audioBufferList;
+		m_sliceList[sliceIndex].mNumberFrames = m_maxExtractionPacketCount;
+		m_sliceList[sliceIndex].mTimeStamp.mFlags = kAudioTimeStampSampleTimeValid;
+		m_sliceList[sliceIndex].mCompletionProcUserData = 0;
+		m_sliceList[sliceIndex].mCompletionProc = 0;
+		m_sliceList[sliceIndex].mFlags = kScheduledAudioSliceFlag_Complete;
+		m_sliceList[sliceIndex].mReserved = 0;
+	}
+	
+#endif // QUICKTIME_C_API_AVAILABLE
+}
+
+void QuickTimeAudioPlayer::scheduleSoundSlices()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+
+    PhononAutoReleasePool pool;
+	// For each completed (or never used) slice, fill and schedule it.
+	for (int sliceIndex = 0; sliceIndex < m_sliceCount; ++sliceIndex){
+		if (m_sliceList[sliceIndex].mFlags & kScheduledAudioSliceFlag_Complete){
+			if (m_samplesRemaining == 0)
+				m_audioExtractionComplete = true;
+
+			if (!m_audioExtractionComplete){
+			    // Determine how many samples to read:
+				int samplesCount = m_samplesRemaining;
+				if ((samplesCount > m_maxExtractionPacketCount) || (samplesCount == -1))
+					samplesCount = m_maxExtractionPacketCount;
+				m_sliceList[sliceIndex].mTimeStamp.mSampleTime = m_sampleTimeStamp;
+
+	            // Reset buffer sizes:
+	            int byteSize = samplesCount * m_audioStreamDescription.mBytesPerPacket;
+	            for (uint i = 0; i < m_sliceList[sliceIndex].mBufferList->mNumberBuffers; ++i)
+                    m_sliceList[sliceIndex].mBufferList->mBuffers[i].mDataByteSize = byteSize;
+
+	            // Do the extraction:
+                UInt32 flags = 0;
+                UInt32 samplesRead = samplesCount;
+	            OSStatus err = MovieAudioExtractionFillBuffer(
+	                m_audioExtractionRef, &samplesRead, m_sliceList[sliceIndex].mBufferList, &flags);
+                BACKEND_ASSERT2(err == noErr, "Could not fill audio buffers from audio extraction", FATAL_ERROR)
+	            m_audioExtractionComplete = (flags & kQTMovieAudioExtractionComplete);
+
+	            // Play the slice:
+	            if (samplesRead != 0 && m_audioUnit != 0){
+                    m_sliceList[sliceIndex].mNumberFrames = samplesRead;
+                    err = AudioUnitSetProperty(m_audioUnit,
+                        kAudioUnitProperty_ScheduleAudioSlice, kAudioUnitScope_Global,
+                        0, &m_sliceList[sliceIndex], sizeof(ScheduledAudioSlice));
+                    BACKEND_ASSERT2(err == noErr, "Could not schedule audio buffers on audio unit", FATAL_ERROR)
+ 	            } else
+					m_sliceList[sliceIndex].mFlags = kScheduledAudioSliceFlag_Complete;
+
+                // Move the window:
+				m_sampleTimeStamp += samplesRead;
+				if (m_samplesRemaining != -1)
+					m_samplesRemaining -= samplesRead;
+			}
+		}
+	}
+
+#endif // QUICKTIME_C_API_AVAILABLE
+}
+
+void QuickTimeAudioPlayer::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    switch (event->type()){
+        case MediaNodeEvent::AudioGraphAboutToBeDeleted:
+        case MediaNodeEvent::AboutToRestartAudioStream:
+        case MediaNodeEvent::StartConnectionChange:
+            m_startTime = currentTime();
+            break;
+        case MediaNodeEvent::AudioGraphInitialized:
+        case MediaNodeEvent::RestartAudioStreamRequest:
+        case MediaNodeEvent::EndConnectionChange:
+            if (m_state == Playing)
+                seek(m_startTime);
+            break;
+       default:
+            break;
+    }
+}
+
+}}
+
+QT_END_NAMESPACE
+
diff -r -U2 -N phonon-4.3.0/qt7/quicktimemetadata.cpp phonon-4.3.0/qt7/quicktimemetadata.cpp
--- phonon-4.3.0/qt7/quicktimemetadata.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimemetadata.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,177 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "quicktimemetadata.h"
-#include "backendheader.h"
-#include <private/qcore_mac_p.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-QuickTimeMetaData::QuickTimeMetaData()
-{
-    m_movieRef = 0;
-    m_movieChanged = false;
-}
-
-QuickTimeMetaData::~QuickTimeMetaData()
-{
-}
-
-void QuickTimeMetaData::setVideo(Movie movieRef)
-{
-    m_movieRef = movieRef;
-    m_movieChanged = true;
-    m_metaData.clear();
-}
-
-QString QuickTimeMetaData::stripCopyRightSymbol(const QString &key)
-{
-    return key.right(key.length()-1);
-}
-
-QString QuickTimeMetaData::convertQuickTimeKeyToUserKey(const QString &key)
-{
-    if (key == QLatin1String("com.apple.quicktime.displayname"))
-        return QLatin1String("nam");
-    else if (key == QLatin1String("com.apple.quicktime.album"))
-        return QLatin1String("alb");
-    else if (key == QLatin1String("com.apple.quicktime.artist"))
-        return QLatin1String("ART");
-    else
-        return QLatin1String("???");
-}
-
-OSStatus QuickTimeMetaData::readMetaValue(QTMetaDataRef metaDataRef, QTMetaDataItem item, QTPropertyClass propClass,
-    QTPropertyID id, QTPropertyValuePtr *value, ByteCount *size)
-{
-	QTPropertyValueType type;
-	ByteCount propSize;
-	UInt32 propFlags;
-	OSStatus err = QTMetaDataGetItemPropertyInfo(metaDataRef, item, propClass, id, &type, &propSize, &propFlags);
-    BACKEND_ASSERT3(err == noErr, "Could not read meta data value size", NORMAL_ERROR, err)
-
-    *value = malloc(propSize);
-
-	err = QTMetaDataGetItemProperty(metaDataRef, item, propClass, id, propSize, *value, size);
-    BACKEND_ASSERT3(err == noErr, "Could not read meta data value", NORMAL_ERROR, err)
-
-    if (type == 'code' || type == 'itsk' || type == 'itlk') {
-        // convert from native endian to big endian
-    	OSTypePtr pType = (OSTypePtr)*value;
-    	*pType = EndianU32_NtoB(*pType);
-    }
-
-	return err;
-}
-
-UInt32 QuickTimeMetaData::getMetaType(QTMetaDataRef metaDataRef, QTMetaDataItem item)
-{
-	QTPropertyValuePtr value = 0;
-	ByteCount ignore = 0;
-	OSStatus err = readMetaValue(
-	    metaDataRef, item, kPropertyClass_MetaDataItem, kQTMetaDataItemPropertyID_DataType, &value, &ignore);
-    BACKEND_ASSERT3(err == noErr, "Could not read meta data type", NORMAL_ERROR, 0)
-    UInt32 type = *((UInt32 *) value);
-    if (value)
-	    free(value);
-	return type;
-}
-
-QString QuickTimeMetaData::getMetaValue(QTMetaDataRef metaDataRef, QTMetaDataItem item, SInt32 id)
-{
-	QTPropertyValuePtr value = 0;
-	ByteCount size = 0;
-	OSStatus err = readMetaValue(metaDataRef, item, kPropertyClass_MetaDataItem, id, &value, &size);
-    BACKEND_ASSERT3(err == noErr, "Could not read meta data item", NORMAL_ERROR, QString())
-    BACKEND_ASSERT3(value != 0, "Could not read meta data item", NORMAL_ERROR, QString())
-
-    QString string;
-    UInt32 dataType = getMetaType(metaDataRef, item);
-    switch (dataType){
-    case kQTMetaDataTypeUTF8:
-    case kQTMetaDataTypeMacEncodedText:
-        string = QCFString::toQString(CFStringCreateWithBytes(0, (UInt8*)value, size, kCFStringEncodingUTF8, false));
-        break;
-    case kQTMetaDataTypeUTF16BE:
-        string = QCFString::toQString(CFStringCreateWithBytes(0, (UInt8*)value, size, kCFStringEncodingUTF16BE, false));
-        break;
-    default:
-        break;
-    }
-
-    if (value)
-	    free(value);
-    return string;
-}
-
-void QuickTimeMetaData::readFormattedData(QTMetaDataRef metaDataRef, OSType format, QMultiMap<QString, QString> &result)
-{
-	QTMetaDataItem item = kQTMetaDataItemUninitialized;
-    OSStatus err = QTMetaDataGetNextItem(metaDataRef, format, item, kQTMetaDataKeyFormatWildcard, 0, 0, &item);
-	while (err == noErr){
-        QString key = getMetaValue(metaDataRef, item, kQTMetaDataItemPropertyID_Key);
-        if (format == kQTMetaDataStorageFormatQuickTime)
-            key = convertQuickTimeKeyToUserKey(key);
-        else
-            key = stripCopyRightSymbol(key);
-
-	    if (!result.contains(key)){
-	        QString val = getMetaValue(metaDataRef, item, kQTMetaDataItemPropertyID_Value);
-            result.insert(key, val);
-        }
-        err = QTMetaDataGetNextItem(metaDataRef, format, item, kQTMetaDataKeyFormatWildcard, 0, 0, &item);
-	}
-}
-
-void QuickTimeMetaData::readMetaData()
-{
-	QTMetaDataRef metaDataRef;
-	if (!m_movieRef)
-        return;
-        
-	OSStatus err = QTCopyMovieMetaData(m_movieRef, &metaDataRef);
-    BACKEND_ASSERT2(err == noErr, "Could not read QuickTime meta data", NORMAL_ERROR)
-
-    QMultiMap<QString, QString> metaMap;
-    readFormattedData(metaDataRef, kQTMetaDataStorageFormatUserData, metaMap);
-    readFormattedData(metaDataRef, kQTMetaDataStorageFormatQuickTime, metaMap);
-    readFormattedData(metaDataRef, kQTMetaDataStorageFormatiTunes, metaMap);
-
-    m_metaData.insert(QLatin1String("ARTIST"), metaMap.value(QLatin1String("ART")));
-    m_metaData.insert(QLatin1String("ALBUM"), metaMap.value(QLatin1String("alb")));
-    m_metaData.insert(QLatin1String("TITLE"), metaMap.value(QLatin1String("nam")));
-    m_metaData.insert(QLatin1String("DATE"), metaMap.value(QLatin1String("day")));
-    m_metaData.insert(QLatin1String("GENRE"), metaMap.value(QLatin1String("gnre")));
-    m_metaData.insert(QLatin1String("TRACKNUMBER"), metaMap.value(QLatin1String("trk")));
-    m_metaData.insert(QLatin1String("DESCRIPTION"), metaMap.value(QLatin1String("des")));
-}
-
-QMultiMap<QString, QString> QuickTimeMetaData::metaData()
-{
-    if (m_movieRef && m_movieChanged)
-        readMetaData();
-    return m_metaData;
-}
-
-}}
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/quicktimemetadata.h phonon-4.3.0/qt7/quicktimemetadata.h
--- phonon-4.3.0/qt7/quicktimemetadata.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimemetadata.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,10 +19,13 @@
 #define Phonon_QT7_QUICKTIMEMETADATA_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
+#include "backendheader.h"
 #include <phonon/mediasource.h>
 #include <Carbon/Carbon.h>
-#include <QtCore>
+#include <QtCore/QString>
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    #include <QuickTime/QuickTime.h>
+    #undef check // avoid name clash;
+#endif
 
 QT_BEGIN_NAMESPACE
@@ -32,4 +35,5 @@
 namespace QT7
 {
+    class QuickTimeVideoPlayer;
     class QuickTimeMetaData
     {
@@ -38,13 +42,14 @@
             virtual ~QuickTimeMetaData();
 
-            void setVideo(Movie movieRef);
+            void setVideo(QuickTimeVideoPlayer *videoPlayer);
             QMultiMap<QString, QString> metaData();
-            Movie movieRef();
 
         private:
-            Movie m_movieRef;
             QMultiMap<QString, QString> m_metaData;
             bool m_movieChanged;
+            QuickTimeVideoPlayer *m_videoPlayer;
+            void readMetaData();
 
+#ifdef QUICKTIME_C_API_AVAILABLE
             QString stripCopyRightSymbol(const QString &key);
             QString convertQuickTimeKeyToUserKey(const QString &key);
@@ -53,5 +58,5 @@
             QString getMetaValue(QTMetaDataRef metaDataRef, QTMetaDataItem item, SInt32 id);
             void readFormattedData(QTMetaDataRef metaDataRef, OSType format, QMultiMap<QString, QString> &result);
-            void readMetaData();
+#endif // QUICKTIME_C_API_AVAILABLE
     };
 
diff -r -U2 -N phonon-4.3.0/qt7/quicktimemetadata.mm phonon-4.3.0/qt7/quicktimemetadata.mm
--- phonon-4.3.0/qt7/quicktimemetadata.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimemetadata.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,185 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "quicktimemetadata.h"
+#include "quicktimevideoplayer.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+QuickTimeMetaData::QuickTimeMetaData()
+{
+    m_videoPlayer = 0;
+    m_movieChanged = false;
+}
+
+QuickTimeMetaData::~QuickTimeMetaData()
+{
+}
+
+void QuickTimeMetaData::setVideo(QuickTimeVideoPlayer *videoPlayer)
+{
+    m_videoPlayer = videoPlayer;
+    m_movieChanged = true;
+    m_metaData.clear();
+}
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+
+QString QuickTimeMetaData::stripCopyRightSymbol(const QString &key)
+{
+    return key.right(key.length()-1);
+}
+
+QString QuickTimeMetaData::convertQuickTimeKeyToUserKey(const QString &key)
+{
+    if (key == QLatin1String("com.apple.quicktime.displayname"))
+        return QLatin1String("nam");
+    else if (key == QLatin1String("com.apple.quicktime.album"))
+        return QLatin1String("alb");
+    else if (key == QLatin1String("com.apple.quicktime.artist"))
+        return QLatin1String("ART");
+    else
+        return QLatin1String("???");
+}
+
+OSStatus QuickTimeMetaData::readMetaValue(QTMetaDataRef metaDataRef, QTMetaDataItem item, QTPropertyClass propClass,
+    QTPropertyID id, QTPropertyValuePtr *value, ByteCount *size)
+{
+	QTPropertyValueType type;
+	ByteCount propSize;
+	UInt32 propFlags;
+	OSStatus err = QTMetaDataGetItemPropertyInfo(metaDataRef, item, propClass, id, &type, &propSize, &propFlags);
+    BACKEND_ASSERT3(err == noErr, "Could not read meta data value size", NORMAL_ERROR, err)
+
+    *value = malloc(propSize);
+
+	err = QTMetaDataGetItemProperty(metaDataRef, item, propClass, id, propSize, *value, size);
+    BACKEND_ASSERT3(err == noErr, "Could not read meta data value", NORMAL_ERROR, err)
+
+    if (type == 'code' || type == 'itsk' || type == 'itlk') {
+        // convert from native endian to big endian
+    	OSTypePtr pType = (OSTypePtr)*value;
+    	*pType = EndianU32_NtoB(*pType);
+    }
+
+	return err;
+}
+
+UInt32 QuickTimeMetaData::getMetaType(QTMetaDataRef metaDataRef, QTMetaDataItem item)
+{
+	QTPropertyValuePtr value = 0;
+	ByteCount ignore = 0;
+	OSStatus err = readMetaValue(
+	    metaDataRef, item, kPropertyClass_MetaDataItem, kQTMetaDataItemPropertyID_DataType, &value, &ignore);
+    BACKEND_ASSERT3(err == noErr, "Could not read meta data type", NORMAL_ERROR, 0)
+    UInt32 type = *((UInt32 *) value);
+    if (value)
+	    free(value);
+	return type;
+}
+
+QString QuickTimeMetaData::getMetaValue(QTMetaDataRef metaDataRef, QTMetaDataItem item, SInt32 id)
+{
+	QTPropertyValuePtr value = 0;
+	ByteCount size = 0;
+	OSStatus err = readMetaValue(metaDataRef, item, kPropertyClass_MetaDataItem, id, &value, &size);
+    BACKEND_ASSERT3(err == noErr, "Could not read meta data item", NORMAL_ERROR, QString())
+    BACKEND_ASSERT3(value != 0, "Could not read meta data item", NORMAL_ERROR, QString())
+
+    QString string;
+    UInt32 dataType = getMetaType(metaDataRef, item);
+    switch (dataType){
+    case kQTMetaDataTypeUTF8:
+    case kQTMetaDataTypeMacEncodedText:
+        string = PhononCFString::toQString(CFStringCreateWithBytes(0, (UInt8*)value, size, kCFStringEncodingUTF8, false));
+        break;
+    case kQTMetaDataTypeUTF16BE:
+        string = PhononCFString::toQString(CFStringCreateWithBytes(0, (UInt8*)value, size, kCFStringEncodingUTF16BE, false));
+        break;
+    default:
+        break;
+    }
+
+    if (value)
+	    free(value);
+    return string;
+}
+
+void QuickTimeMetaData::readFormattedData(QTMetaDataRef metaDataRef, OSType format, QMultiMap<QString, QString> &result)
+{
+	QTMetaDataItem item = kQTMetaDataItemUninitialized;
+    OSStatus err = QTMetaDataGetNextItem(metaDataRef, format, item, kQTMetaDataKeyFormatWildcard, 0, 0, &item);
+	while (err == noErr){
+        QString key = getMetaValue(metaDataRef, item, kQTMetaDataItemPropertyID_Key);
+        if (format == kQTMetaDataStorageFormatQuickTime)
+            key = convertQuickTimeKeyToUserKey(key);
+        else
+            key = stripCopyRightSymbol(key);
+
+	    if (!result.contains(key)){
+	        QString val = getMetaValue(metaDataRef, item, kQTMetaDataItemPropertyID_Value);
+            result.insert(key, val);
+        }
+        err = QTMetaDataGetNextItem(metaDataRef, format, item, kQTMetaDataKeyFormatWildcard, 0, 0, &item);
+	}
+}
+
+#endif // QUICKTIME_C_API_AVAILABLE
+
+void QuickTimeMetaData::readMetaData()
+{
+	if (!m_videoPlayer)
+        return;
+    QMultiMap<QString, QString> metaMap;
+    
+#ifdef QUICKTIME_C_API_AVAILABLE
+	QTMetaDataRef metaDataRef;        
+	OSStatus err = QTCopyMovieMetaData([m_videoPlayer->qtMovie() quickTimeMovie], &metaDataRef);
+    BACKEND_ASSERT2(err == noErr, "Could not read QuickTime meta data", NORMAL_ERROR)
+
+    readFormattedData(metaDataRef, kQTMetaDataStorageFormatUserData, metaMap);
+    readFormattedData(metaDataRef, kQTMetaDataStorageFormatQuickTime, metaMap);
+    readFormattedData(metaDataRef, kQTMetaDataStorageFormatiTunes, metaMap);
+#else
+	NSString *name = [m_videoPlayer->qtMovie() attributeForKey:@"QTMovieDisplayNameAttribute"];
+	metaMap.insert(QLatin1String("nam"), QString::fromUtf8([name UTF8String]));
+#endif // QUICKTIME_C_API_AVAILABLE
+
+    m_metaData.insert(QLatin1String("ARTIST"), metaMap.value(QLatin1String("ART")));
+    m_metaData.insert(QLatin1String("ALBUM"), metaMap.value(QLatin1String("alb")));
+    m_metaData.insert(QLatin1String("TITLE"), metaMap.value(QLatin1String("nam")));
+    m_metaData.insert(QLatin1String("DATE"), metaMap.value(QLatin1String("day")));
+    m_metaData.insert(QLatin1String("GENRE"), metaMap.value(QLatin1String("gnre")));
+    m_metaData.insert(QLatin1String("TRACKNUMBER"), metaMap.value(QLatin1String("trk")));
+    m_metaData.insert(QLatin1String("DESCRIPTION"), metaMap.value(QLatin1String("des")));
+}
+
+QMultiMap<QString, QString> QuickTimeMetaData::metaData()
+{
+    if (m_videoPlayer && m_videoPlayer->hasMovie() && m_movieChanged)
+        readMetaData();
+    return m_metaData;
+}
+
+}}
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/quicktimestreamreader.cpp phonon-4.3.0/qt7/quicktimestreamreader.cpp
--- phonon-4.3.0/qt7/quicktimestreamreader.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimestreamreader.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,152 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "backendheader.h"
-#include "quicktimestreamreader.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-// Defined in quicktimestreamreader_objc.m:
-void *QuickTimeStreamReader_createMovieFromBufferGuessType(QByteArray &buffer);
-Movie QuickTimeStreamReader_convertToQuickTime(void *qtmovie);
-void QuickTimeStreamReader_release(void *movie);
-
-QuickTimeStreamReader::QuickTimeStreamReader(const Phonon::MediaSource &source)
-{
-    connectToSource(source);
-
-    // Regretfully, I need to load the whole movie into memory
-    // before I can tell QuickTime to play it. (whish 
-    // kQTDataLocationPropertyID_MovieUserProc worked...)    
-    if(!readAllDataIntoBuffer())
-        return;
-        
-    m_QTMovieRef = QuickTimeStreamReader_createMovieFromBufferGuessType(m_buffer);
-}
-
-QuickTimeStreamReader::~QuickTimeStreamReader()
-{
-    if (m_QTMovieRef)
-        QuickTimeStreamReader_release(m_QTMovieRef);
-}
-
-bool QuickTimeStreamReader::readAllDataIntoBuffer()
-{
-    int oldSize = m_buffer.size();
-    while (m_buffer.size() < m_size){
-        needData();
-        if (oldSize == currentBufferSize())
-            BACKEND_ASSERT3(oldSize != currentBufferSize(),
-                "Could not create new movie from IO stream. Not enough free memory to preload the whole movie.",
-                FATAL_ERROR, false)
-        oldSize = m_buffer.size();
-    }
-    return true;
-}
-
-Movie QuickTimeStreamReader::movieRef()
-{
-    return QuickTimeStreamReader_convertToQuickTime(m_QTMovieRef);
-}
-
-int QuickTimeStreamReader::readData(long offset, long size, void *data)
-{
-//    QReadLocker readLocker(&m_lock);
-    if (streamSize() != 1 && offset + size > streamSize()){
-        size = streamSize() - offset;
-    }
-
-    if (currentPos() - currentBufferSize() != offset)
-        setCurrentPos(offset);
-
-    int oldSize = currentBufferSize();
-    while (currentBufferSize() < int(size)) {
-        needData();
-        if (oldSize == currentBufferSize())
-            break;
-        oldSize = currentBufferSize();
-    }
-    
-    int bytesRead = qMin(currentBufferSize(), int(size));
-//    QWriteLocker writeLocker(&m_lock);
-    qMemCopy(data, m_buffer.data(), bytesRead);
-    m_buffer = m_buffer.mid(bytesRead);
-
-    return bytesRead;
-}
-    
-void QuickTimeStreamReader::writeData(const QByteArray &data)
-{
-    QWriteLocker locker(&m_lock);
-    m_pos += data.size();
-    m_buffer += data;
-}
-
-void QuickTimeStreamReader::endOfData()
-{
-}
-
-void QuickTimeStreamReader::setStreamSize(qint64 newSize)
-{
-    m_size = newSize;
-}
-
-qint64 QuickTimeStreamReader::streamSize() const
-{
-    return m_size;
-}
-
-void QuickTimeStreamReader::setStreamSeekable(bool s)
-{
-    m_seekable = s;
-}
-
-bool QuickTimeStreamReader::streamSeekable() const
-{
-    return m_seekable;
-}
-
-void QuickTimeStreamReader::setCurrentPos(qint64 pos)
-{
-    QWriteLocker locker(&m_lock);
-    m_pos = pos;
-    seekStream(pos);
-    m_buffer.clear();
-}
-
-qint64 QuickTimeStreamReader::currentPos() const
-{
-    return m_pos;
-}
-
-int QuickTimeStreamReader::currentBufferSize() const
-{
-    QReadLocker locker(&m_lock);
-    return m_buffer.size();
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_quicktimestreamreader.cpp"
-
diff -r -U2 -N phonon-4.3.0/qt7/quicktimestreamreader.h phonon-4.3.0/qt7/quicktimestreamreader.h
--- phonon-4.3.0/qt7/quicktimestreamreader.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimestreamreader.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,15 +19,15 @@
 #define Phonon_QT7_QUICKTIMESTREAMREADER_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
 #include <phonon/mediasource.h>
 #include <phonon/streaminterface.h>
-#include <QtCore>
-#include <QReadWriteLock>
+#include <QtCore/QReadWriteLock>
+
+#ifndef QT_MAC_USE_COCOA
+#include <QuickTime/Movies.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
-namespace Phonon 
+namespace Phonon
 {
 namespace QT7
@@ -37,5 +37,5 @@
         Q_OBJECT
         Q_INTERFACES(Phonon::StreamInterface)
-        
+
     public:
         QuickTimeStreamReader(const Phonon::MediaSource &source);
@@ -43,5 +43,6 @@
 
         int readData(long offset, long size, void *data);
-        bool readAllDataIntoBuffer();
+        bool readAllData();
+        QByteArray *pointerToData();
         void writeData(const QByteArray &data);
         void endOfData();
@@ -53,8 +54,9 @@
         qint64 currentPos() const;
         int currentBufferSize() const;
-        Movie QuickTimeStreamReader::movieRef();
+#ifndef QT_MAC_USE_COCOA
+        Movie movieRef();
+#endif
 
         QByteArray m_buffer;
-        void *m_QTMovieRef;
         mutable QReadWriteLock m_lock;
         bool m_seekable;
diff -r -U2 -N phonon-4.3.0/qt7/quicktimestreamreader.mm phonon-4.3.0/qt7/quicktimestreamreader.mm
--- phonon-4.3.0/qt7/quicktimestreamreader.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimestreamreader.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,137 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "backendheader.h"
+#include "quicktimestreamreader.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+QuickTimeStreamReader::QuickTimeStreamReader(const Phonon::MediaSource &source)
+{
+    connectToSource(source);
+}
+
+QuickTimeStreamReader::~QuickTimeStreamReader()
+{
+}
+
+bool QuickTimeStreamReader::readAllData()
+{
+    int oldSize = m_buffer.size();
+    while (m_buffer.size() < m_size){
+        needData();
+        if (oldSize == currentBufferSize())
+            BACKEND_ASSERT3(oldSize != currentBufferSize(),
+                "Could not create new movie from IO stream. Not enough free memory to preload the whole movie.",
+                FATAL_ERROR, false)
+        oldSize = m_buffer.size();
+    }
+    return true;
+}
+
+QByteArray *QuickTimeStreamReader::pointerToData()
+{
+    return &m_buffer;
+}
+
+int QuickTimeStreamReader::readData(long offset, long size, void *data)
+{
+//    QReadLocker readLocker(&m_lock);
+    if (streamSize() != 1 && offset + size > streamSize()){
+        size = streamSize() - offset;
+    }
+
+    if (currentPos() - currentBufferSize() != offset)
+        setCurrentPos(offset);
+
+    int oldSize = currentBufferSize();
+    while (currentBufferSize() < int(size)) {
+        needData();
+        if (oldSize == currentBufferSize())
+            break;
+        oldSize = currentBufferSize();
+    }
+    
+    int bytesRead = qMin(currentBufferSize(), int(size));
+//    QWriteLocker writeLocker(&m_lock);
+    qMemCopy(data, m_buffer.data(), bytesRead);
+    m_buffer = m_buffer.mid(bytesRead);
+
+    return bytesRead;
+}
+    
+void QuickTimeStreamReader::writeData(const QByteArray &data)
+{
+    QWriteLocker locker(&m_lock);
+    m_pos += data.size();
+    m_buffer += data;
+}
+
+void QuickTimeStreamReader::endOfData()
+{
+}
+
+void QuickTimeStreamReader::setStreamSize(qint64 newSize)
+{
+    m_size = newSize;
+}
+
+qint64 QuickTimeStreamReader::streamSize() const
+{
+    return m_size;
+}
+
+void QuickTimeStreamReader::setStreamSeekable(bool s)
+{
+    m_seekable = s;
+}
+
+bool QuickTimeStreamReader::streamSeekable() const
+{
+    return m_seekable;
+}
+
+void QuickTimeStreamReader::setCurrentPos(qint64 pos)
+{
+    QWriteLocker locker(&m_lock);
+    m_pos = pos;
+    seekStream(pos);
+    m_buffer.clear();
+}
+
+qint64 QuickTimeStreamReader::currentPos() const
+{
+    return m_pos;
+}
+
+int QuickTimeStreamReader::currentBufferSize() const
+{
+    QReadLocker locker(&m_lock);
+    return m_buffer.size();
+}
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_quicktimestreamreader.cpp"
+
diff -r -U2 -N phonon-4.3.0/qt7/quicktimestreamreader_objc.mm phonon-4.3.0/qt7/quicktimestreamreader_objc.mm
--- phonon-4.3.0/qt7/quicktimestreamreader_objc.mm	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimestreamreader_objc.mm	1969-12-31 17:00:00.000000000 -0700
@@ -1,101 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#import <QTKit/QTKit.h>
-
-#include <QByteArray>
-#include <private/qt_mac_p.h>
-#include <private/qcore_mac_p.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-#if 0
-static void dumpSupportedFileTypes()
-{
-    NSArray *fileTypes = [QTMovie movieFileTypes:QTIncludeCommonTypes];
-    NSString *prefix = @"."; 
-    for (unsigned int i=0; i<[fileTypes count]; ++i){
-        NSString *type = [fileTypes objectAtIndex:i];
-        type = [type stringByReplacingOccurrencesOfString:@"'" withString:@""];
-        type = [type stringByReplacingOccurrencesOfString:@"." withString:@""];
-        type = [prefix stringByAppendingString:type];
-        NSLog(type);
-    }    
-}
-#endif
-
-Movie QuickTimeStreamReader_convertToQuickTime(void *movie)
-{
-    return [(QTMovie *)movie quickTimeMovie];
-}
-
-void QuickTimeStreamReader_release(void *movie)
-{
-    [(QTMovie *)movie release];
-}
-
-void *QuickTimeStreamReader_createMovieFromBuffer(QByteArray &buffer, NSString *fileType)
-{    
-    QMacCocoaAutoReleasePool pool;    
-    NSData *data = [NSData dataWithBytesNoCopy:buffer.data() length:buffer.size() freeWhenDone:NO];
-    QTDataReference *dataRef = [QTDataReference dataReferenceWithReferenceToData:data name:fileType MIMEType:@""];
-    NSDictionary *props = [NSDictionary dictionaryWithObjectsAndKeys:
-                dataRef, QTMovieDataReferenceAttribute,
-                [NSNumber numberWithBool:YES], QTMovieOpenAsyncOKAttribute,
-                [NSNumber numberWithBool:YES], QTMovieIsActiveAttribute,
-                [NSNumber numberWithBool:YES], QTMovieResolveDataRefsAttribute,
-                nil];
-
-    QTMovie *movie = [QTMovie movieWithAttributes:props error:0];
-    if (movie)
-        [movie retain];
-    return movie;
-}
-
-void *QuickTimeStreamReader_createMovieFromBufferGuessType(QByteArray &buffer)
-{
-    QMacCocoaAutoReleasePool pool;    
-    void *movie = 0;
-
-    // It turns out to be better to just try the standard file types rather
-    // than using e.g [QTMovie movieFileTypes:QTIncludeCommonTypes]. Some
-    // codes thinks they can decode the stream, and crash...
-#define PhononTryType(type) ClearMoviesStickyError(); \
-        if ((movie = QuickTimeStreamReader_createMovieFromBuffer(buffer, @"."type))) return movie;
-    PhononTryType("avi");
-    PhononTryType("mp4");
-    PhononTryType("m4p");
-    PhononTryType("m1s");
-    PhononTryType("mp3");
-    PhononTryType("mpeg");
-    PhononTryType("mov");
-    PhononTryType("ogg");
-    PhononTryType("wav");
-    PhononTryType("wmv");
-#undef PhononTryType(type)
-    return 0;
-}
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
diff -r -U2 -N phonon-4.3.0/qt7/quicktimevideoplayer.cpp phonon-4.3.0/qt7/quicktimevideoplayer.cpp
--- phonon-4.3.0/qt7/quicktimevideoplayer.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimevideoplayer.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,714 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "quicktimevideoplayer.h"
-#include "backendheader.h"
-#include "mediaobject.h"
-#include "videowidget.h"
-#include "audiodevice.h"
-#include "quicktimestreamreader.h"
-
-#include <private/qcore_mac_p.h>
-
-#include <QGLContext>
-#include <QtOpenGL/private/qgl_p.h>
-
-QT_BEGIN_NAMESPACE
-
-extern QGLShareRegister* qgl_share_reg();
-
-QGLContextPrivate *qt_phonon_get_dptr(const QGLContext *context){
-    return context->d_ptr;
-}
-
-namespace Phonon
-{
-namespace QT7
-{
-
-// Defined in videowidget.cpp:
-QGLWidget *PhononSharedQGLWidget();
-    
-QuickTimeVideoPlayer::QuickTimeVideoPlayer() : QObject(0)
-{
-    m_state = NoMedia;
-    m_mediaSource = MediaSource();
-    m_visualContext = 0;
-    m_qGLContext = 0;
-    m_movieRef = 0;
-    m_streamReader = 0;
-    m_playbackRate = 1.0f;
-    m_masterVolume = 1.0f;
-    m_relativeVolume = 1.0f;
-    m_currentTime = 0;
-    m_mute = false;
-    m_audioEnabled = false;
-    m_hasVideo = false;
-    m_playbackRateSat = false;
-    m_isDrmProtected = false;
-    m_isDrmAuthorized = true;
-}
-
-QuickTimeVideoPlayer::~QuickTimeVideoPlayer()
-{
-    unsetVideo();
-    if (m_visualContext)
-        CFRelease(m_visualContext);
-}
-
-bool QuickTimeVideoPlayer::setGLContext(const QGLContext *qGLContext)
-{
-    if (qgl_share_reg()->checkSharing(m_qGLContext, qGLContext))
-        return false;
-
-    m_qGLContext = qGLContext;
-
-    AGLContext aglContext = static_cast<AGLContext>(qt_phonon_get_dptr(m_qGLContext)->cx);
-    AGLPixelFormat aglPixelFormat = static_cast<AGLPixelFormat>(qt_phonon_get_dptr(m_qGLContext)->vi);
-    return setGLContext(aglContext, aglPixelFormat);
-}
-
-bool QuickTimeVideoPlayer::setCurrentGLContext()
-{
-    return setGLContext(QGLContext::currentContext());
-}
-
-bool QuickTimeVideoPlayer::setGLContext(AGLContext aglContext, AGLPixelFormat aglPixelFormat)
-{
-    OSStatus err = noErr;
-    bool ok = true;
-    
-    if (m_visualContext){
-        CFRelease(m_visualContext);
-        m_visualContext = 0;
-    }
-
-    CGLContextObj cglContext = 0;
-    CGLPixelFormatObj cglPixelFormat = 0;
-
-    if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_4){
-        ok = aglGetCGLContext(aglContext, (void **)&cglContext);
-        BACKEND_ASSERT3(ok, "Could not get CoreVideo GL context (OpenGL)", FATAL_ERROR, false)
-        ok = aglGetCGLPixelFormat(aglPixelFormat, (void **)&cglPixelFormat);
-        BACKEND_ASSERT3(ok, "Could not get CoreVideo pixel format (OpenGL)", FATAL_ERROR, false)
-    } else {
-        ok = aglSetCurrentContext(aglContext);
-        BACKEND_ASSERT3(ok, "Could not set current GL context (OpenGL)", FATAL_ERROR, false)
-        cglContext = CGLGetCurrentContext();
-        BACKEND_ASSERT3(cglContext, "Could not get current CoreVideo GL context (OpenGL)", FATAL_ERROR, false)
-
-        Q_UNUSED(aglPixelFormat);
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-        GLint attributeCount = 2;
-#else
-        long attributeCount = 2;
-#endif
-        CGLPixelFormatAttribute pfa[attributeCount];
-        pfa[0] = kCGLPFAWindow;
-        pfa[1] = (CGLPixelFormatAttribute) 0;
-        err = CGLChoosePixelFormat(pfa, &cglPixelFormat, &attributeCount);
-        BACKEND_ASSERT3(err == noErr, "Could not create pixel format (OpenGL)", FATAL_ERROR, false)
-    }
-
-    CFTypeRef keys[] = { kQTVisualContextWorkingColorSpaceKey };
-    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
-    CFDictionaryRef textureContextAttributes = CFDictionaryCreate(kCFAllocatorDefault,
-        (const void **)keys,
-        (const void **)&colorSpace, 1,
-        &kCFTypeDictionaryKeyCallBacks,
-        &kCFTypeDictionaryValueCallBacks);
-        
-	err = QTOpenGLTextureContextCreate(kCFAllocatorDefault, cglContext,
-        cglPixelFormat, textureContextAttributes, &m_visualContext);
-    CFRelease(textureContextAttributes);
-    BACKEND_ASSERT3(err == noErr, "Could not create visual context (OpenGL)", FATAL_ERROR, false)
-
-    if (m_movieRef && m_visualContext)
-        SetMovieVisualContext(m_movieRef, m_visualContext);
-    return true;    
-}
-
-bool QuickTimeVideoPlayer::videoFrameChanged(const LinkTimeProxy &timeStamp)
-{
-    if (!m_movieRef || m_state != Playing || !m_hasVideo)
-        return false;
-
-    if (!m_visualContext)
-        setGLContext(PhononSharedQGLWidget()->context());
-    
-    QTVisualContextTask(m_visualContext);
-    CVTimeStamp cvStamp = timeStamp.getCVTimeStamp(); 
-    return QTVisualContextIsNewImageAvailable(m_visualContext, &cvStamp);
-}
-
-CVOpenGLTextureRef QuickTimeVideoPlayer::createCvTexture(const LinkTimeProxy &timeStamp)
-{
-    if (!m_visualContext)
-        return 0;
-    
-    CVOpenGLTextureRef texture = 0;
-    CVTimeStamp cvStamp = timeStamp.getCVTimeStamp(); 
-    OSStatus err = QTVisualContextCopyImageForTime(m_visualContext, 0, &cvStamp, &texture);
-    BACKEND_ASSERT3(err == noErr, "Could not copy image for time in QuickTime player", FATAL_ERROR, 0)
-    return texture;
-}
-
-void QuickTimeVideoPlayer::setMasterVolume(float volume)
-{
-    setVolume(volume, m_relativeVolume);
-}
-
-void QuickTimeVideoPlayer::setRelativeVolume(float volume)
-{
-    setVolume(m_masterVolume, volume);
-}
-
-void QuickTimeVideoPlayer::setVolume(float masterVolume, float relativeVolume)
-{
-    m_masterVolume = masterVolume;
-    m_relativeVolume = relativeVolume;
-    if (!m_movieRef || !m_audioEnabled || m_mute)
-        return;                
-    SetMovieAudioGain(m_movieRef, m_masterVolume * m_relativeVolume, 0);
-}
-
-void QuickTimeVideoPlayer::setMute(bool mute)
-{
-    m_mute = mute;
-    if (!m_movieRef || m_state != Playing || !m_audioEnabled)
-        return;
-
-    // Work-around bug that happends if you set/unset mute
-    // before movie is playing, and audio is not played 
-    // through graph. Then audio is delayed.
-    SetMovieAudioMute(m_movieRef, mute, 0);
-    SetMovieAudioGain(m_movieRef, mute ? 0 : m_masterVolume * m_relativeVolume, 0);
-}
-
-void QuickTimeVideoPlayer::enableAudio(bool enable)
-{
-    m_audioEnabled = enable;
-    if (!m_movieRef || m_state != Playing)
-        return;
-
-    // Work-around bug that happends if you set/unset mute
-    // before movie is playing, and audio is not played 
-    // through graph. Then audio is delayed.
-    SetMovieAudioMute(m_movieRef, (!enable || m_mute), 0);
-    SetMovieAudioGain(m_movieRef, (!enable || m_mute) ? 0 : m_masterVolume * m_relativeVolume, 0);
-}
-
-bool QuickTimeVideoPlayer::audioEnabled()
-{
-    return m_audioEnabled;
-}
-
-bool QuickTimeVideoPlayer::setAudioDevice(int id)
-{
-    if (!m_movieRef)
-        return false;
-
-    // The following code will not work for some media codecs that
-    // typically mingle audio/video frames (e.g mpeg).
-    CFStringRef idString = QCFString::toCFStringRef(AudioDevice::deviceUID(id));        
-    QTAudioContextRef context;
-    QTAudioContextCreateForAudioDevice(kCFAllocatorDefault, idString, 0, &context);
-    OSStatus err = SetMovieAudioContext(m_movieRef, context);
-    CFRelease(context);
-    if (err != noErr)
-        return false;
-    return true;
-}
-
-void QuickTimeVideoPlayer::setColors(qreal brightness, qreal contrast, qreal hue, qreal saturation)
-{
-    if (!m_movieRef)
-        return;
-
-    // 0 is default value for the colors
-    // in phonon, so adjust scale:
-    contrast += 1;
-    saturation += 1;
-
-    Float32 value;
-    value = brightness;
-    SetMovieVisualBrightness(m_movieRef, value, 0);
-    value = contrast;
-    SetMovieVisualContrast(m_movieRef, value, 0);
-    value = hue;
-    SetMovieVisualHue(m_movieRef, value, 0);
-    value = saturation;
-    SetMovieVisualSaturation(m_movieRef, value, 0);
-}
-
-QRect QuickTimeVideoPlayer::videoRect() const
-{
-    if (!m_movieRef)
-        return QRect();
-
-    Rect rect;
-    GetMovieBox(m_movieRef, &rect);
-    return QRect(rect.left, rect.top, rect.left + rect.right, rect.top + rect.bottom);
-}
-
-void QuickTimeVideoPlayer::unsetVideo()
-{
-    if (!m_movieRef)
-        return;
-
-    if (m_streamReader){
-        // Streamreader owns the movie.
-        delete m_streamReader;
-        m_streamReader = 0;
-    } else {
-        DisposeMovie(m_movieRef);
-    }
-
-	m_movieRef = 0;
-    m_currentTime = 0;
-    m_state = NoMedia;
-    m_mediaSource = MediaSource();
-    ClearMoviesStickyError();
-}
-
-QuickTimeVideoPlayer::State QuickTimeVideoPlayer::state() const
-{
-    return m_state;
-}
-
-quint64 QuickTimeVideoPlayer::timeLoaded()
-{
-    if (!m_movieRef)
-        return 0;
-    TimeValue value;
-    GetMaxLoadedTimeInMovie(m_movieRef, &value);
-    quint64 loaded = static_cast<quint64>(float(value) / float(GetMovieTimeScale(m_movieRef)) * 1000.0f);
-    return (loaded == INT_MAX) ? 0 : loaded;
-}
-
-float QuickTimeVideoPlayer::percentageLoaded()
-{
-    if (!m_movieRef || !isSeekable())
-        return 0;
-    TimeValue loaded;
-    GetMaxLoadedTimeInMovie(m_movieRef, &loaded);
-    float duration = GetMovieDuration(m_movieRef);
-    return duration ? float(loaded) / duration : 0;
-}
-
-void QuickTimeVideoPlayer::waitForState(long waitState)
-{
-    long state = GetMovieLoadState(m_movieRef);
-    while (state != kMovieLoadStateError && state < waitState){
-        MoviesTask(0, 0);
-        state = GetMovieLoadState(m_movieRef);
-    }
-}
-
-bool QuickTimeVideoPlayer::checkForError()
-{
-    // Only call this method if we're supposed
-    // to have a valid movie loaded.
-    if (gGetErrorType() != NO_ERROR)
-        return true;
-        
-    OSStatus err = GetMoviesStickyError();
-    if (err == noErr){
-        if (!m_movieRef){
-            SET_ERROR("Could not open media source.", FATAL_ERROR)
-            return true;
-        } else if (GetMovieLoadState(m_movieRef) == kMovieLoadStateError){
-            SET_ERROR("Could not open media source.", FATAL_ERROR)
-            return true;
-        }
-        return false; // No error occured!        
-    }
-
-    ClearMoviesStickyError();
-    
-    switch(err){
-    case noMovieFound:
-        SET_ERROR("Could not decode media source.", FATAL_ERROR)
-        break;
-    case 404:
-    case -19160:
-    case urlDataHFTPServerDisconnectedErr:
-        SET_ERROR("Could not locate media source.", FATAL_ERROR)
-        break;
-    case afpAccessDenied:
-        SET_ERROR("Could not open media source.", FATAL_ERROR)
-        break;
-    default:
-        return false; // Ignore unknown errors.
-    }
-    return true;
-}
-
-void QuickTimeVideoPlayer::setMediaSource(const MediaSource &mediaSource)
-{
-    unsetVideo();
-    m_mediaSource = mediaSource;
-    if (mediaSource.type() == MediaSource::Invalid){
-        m_state = NoMedia;
-        return;
-    }
-    openMovieFromCurrentMediaSource();
-    if (checkForError()){
-        unsetVideo();
-        return;
-    }
-
-    if (m_visualContext)
-        SetMovieVisualContext(m_movieRef, m_visualContext);
-    waitForState(kMovieLoadStatePlayable);
-    if (checkForError()){
-        unsetVideo();
-        return;
-    }
-
-    readProtection();
-    preRollMovie();
-    if (checkForError()){
-        unsetVideo();
-        return;
-    }
-
-    SetTimeBaseFlags(GetMovieTimeBase(m_movieRef), 0);
-    SetMoviePlayHints(m_movieRef, hintsLoop | hintsHighQuality, hintsLoop | hintsHighQuality);
-    if (!m_playbackRateSat)
-        m_playbackRate = prefferedPlaybackRate();
-    checkIfVideoAwailable();
-    enableAudio(m_audioEnabled);
-    setMute(m_mute);
-    setVolume(m_masterVolume, m_relativeVolume);
-    pause();
-    checkForError();
-
-    // Let the QuickTime work. Why I need to
-    // call MoviesTask twize is unknown, but if
-    // I don't do it, audio will sometimes not 
-    // play immidiatly for movies.
-    MoviesTask(m_movieRef, 0);
-    MoviesTask(m_movieRef, 0);
-}
-
-void QuickTimeVideoPlayer::openMovieFromCurrentMediaSource()
-{
-    switch (m_mediaSource.type()){
-    case MediaSource::LocalFile:
-        openMovieFromFile();
-        break;
-    case MediaSource::Url:
-        openMovieFromUrl();
-        break;
-    case MediaSource::Disc:
-        CASE_UNSUPPORTED("Could not open media source.", FATAL_ERROR)
-        break;
-    case MediaSource::Stream:
-        openMovieFromStream();
-        break;
-    case MediaSource::Invalid:
-        break;
-    }
-}
-
-void QuickTimeVideoPlayer::openMovieFromDataRef(DataReferenceRecord &dataRef)
-{
-	Boolean boolTrue = true;
-	QTNewMoviePropertyElement props[] = {
-		{kQTPropertyClass_DataLocation, kQTDataLocationPropertyID_DataReference, sizeof(dataRef), &dataRef, 0},
-		{kQTPropertyClass_NewMovieProperty, kQTNewMoviePropertyID_Active, sizeof(boolTrue), &boolTrue, 0},
-        {kQTPropertyClass_NewMovieProperty, kQTNewMoviePropertyID_DontInteractWithUser, sizeof(boolTrue), &boolTrue, 0},
-        {kQTPropertyClass_MovieInstantiation, kQTMovieInstantiationPropertyID_AsyncOK, sizeof(boolTrue), &boolTrue, 0},
-	};
-    int propCount = sizeof(props) / sizeof(props[0]);
-    NewMovieFromProperties(propCount, props, 0, 0, &m_movieRef);
-    DisposeHandle(dataRef.dataRef);
-}
-
-void QuickTimeVideoPlayer::openMovieFromFile()
-{
-    QFileInfo fileInfo(m_mediaSource.fileName());
-    QCFString filename = fileInfo.isSymLink() ? fileInfo.symLinkTarget() : fileInfo.canonicalFilePath();
-    DataReferenceRecord dataRef = {0, 0};
-    QTNewDataReferenceFromFullPathCFString(filename, kQTPOSIXPathStyle, 0, &dataRef.dataRef, &dataRef.dataRefType);
-    openMovieFromDataRef(dataRef);
-}
-
-void QuickTimeVideoPlayer::openMovieFromUrl()
-{
-    QCFString urlString = QCFString(m_mediaSource.url().toString());
-    CFURLRef url = CFURLCreateWithString(0, urlString, 0);
-    DataReferenceRecord dataRef = {0, 0};
-    QTNewDataReferenceFromCFURL(url, 0, &dataRef.dataRef, &dataRef.dataRefType);
-    openMovieFromDataRef(dataRef);
-}
-
-void QuickTimeVideoPlayer::openMovieFromStream()
-{
-    m_streamReader = new QuickTimeStreamReader(m_mediaSource);
-    m_movieRef = m_streamReader->movieRef();
-    if (m_movieRef){
-	    Boolean boolFalse = true;
-        QTSetMovieProperty(m_movieRef, kQTPropertyClass_DRM, kQTDRMPropertyID_InteractWithUser, sizeof(boolFalse), &boolFalse);
-    }
-}
-
-MediaSource QuickTimeVideoPlayer::mediaSource() const
-{
-    return m_mediaSource;
-}
-
-Movie QuickTimeVideoPlayer::movieRef() const
-{
-    return m_movieRef;
-}
-
-void QuickTimeVideoPlayer::setPlaybackRate(float rate)
-{
-    m_playbackRateSat = true;
-    m_playbackRate = rate;
-    if (m_movieRef)
-        SetMovieRate(m_movieRef, FloatToFixed(m_playbackRate));
-}
-
-float QuickTimeVideoPlayer::playbackRate() const
-{
-    return m_playbackRate;
-}
-
-quint64 QuickTimeVideoPlayer::currentTime() const
-{
-    if (!m_movieRef || m_state == Paused)
-        return m_currentTime;
-
-    TimeRecord timeRec;
-    GetMovieTime (m_movieRef, &timeRec);
-    quint64 t = static_cast<quint64>(float(timeRec.value.lo) / float(timeRec.scale) * 1000.0f);
-    const_cast<QuickTimeVideoPlayer *>(this)->m_currentTime = t;
-    return m_currentTime;
-}
-
-QString QuickTimeVideoPlayer::timeToString(quint64 ms)
-{
-    int sec = ms/1000;
-    int min = sec/60;
-    int hour = min/60;
-    return QString(QLatin1String("%1:%2:%3:%4")).arg(hour%60).arg(min%60).arg(sec%60).arg(ms%1000);
-}
-
-QString QuickTimeVideoPlayer::currentTimeString()
-{
-    return timeToString(currentTime());
-}
-
-quint64 QuickTimeVideoPlayer::duration() const
-{
-    if (!m_movieRef)
-        return 0;
-
-    return static_cast<quint64>(float(GetMovieDuration(m_movieRef)) / float(GetMovieTimeScale(m_movieRef)) * 1000.0f);
-}
-
-void QuickTimeVideoPlayer::play()
-{
-    if (!canPlayMedia())
-        return;
-
-    m_state = Playing;
-    enableAudio(m_audioEnabled);
-    setMute(m_mute);
-    
-    if (isSeekable()){
-        // The following lines is a work-around for
-        // audio-starting-late-bug when playing mpeg:
-        TimeRecord timeRec;
-        GetMovieTime(m_movieRef, &timeRec);
-        SetMovieTime(m_movieRef, &timeRec);
-    }
-    SetMovieRate(m_movieRef, FloatToFixed(m_playbackRate));    
-}
-
-void QuickTimeVideoPlayer::pause()
-{
-    if (!canPlayMedia())
-        return;
-
-    currentTime();
-    m_state = Paused;
-
-    if (isSeekable())
-        SetMovieRate(m_movieRef, FloatToFixed(0.0f));
-    else // pretend to be paused:
-        SetMovieAudioMute(m_movieRef, true, 0);
-}
-
-void QuickTimeVideoPlayer::seek(quint64 milliseconds)
-{
-    if (!canPlayMedia() || !isSeekable() || milliseconds == currentTime())
-        return;
-    if (milliseconds > duration())
-        milliseconds = duration();
-
-    m_currentTime = milliseconds;
-    TimeRecord timeRec;
-    GetMovieTime(m_movieRef, &timeRec);
-	timeRec.value.lo = (milliseconds / 1000.0f) * timeRec.scale;
-
-    if (milliseconds < timeLoaded()){
-        SetMovieTime(m_movieRef, &timeRec);
-    } else {
-        SetMovieRate(m_movieRef, FloatToFixed(0.0f));
-        preRollMovie(timeRec.value.lo);
-        SetMovieTime(m_movieRef, &timeRec);
-        if (m_state == Playing)
-            SetMovieRate(m_movieRef, FloatToFixed(m_playbackRate));
-    }  
-}
-
-bool QuickTimeVideoPlayer::canPlayMedia() const
-{
-    if (!m_movieRef)
-        return false;
-    return m_isDrmAuthorized;
-}
-
-bool QuickTimeVideoPlayer::isPlaying() const
-{
-    return m_state == Playing;
-}
-
-bool QuickTimeVideoPlayer::isSeekable() const
-{
-    return canPlayMedia() && (duration()-1) != INT_MAX;
-}
-
-float QuickTimeVideoPlayer::prefferedPlaybackRate() const
-{
-    if (!m_movieRef)
-        return -1;
-
-    return FixedToFloat(GetMoviePreferredRate(m_movieRef));
-}
-
-void MoviePrePrerollCompleteCallBack(Movie /*theMovie*/, OSErr /*thePrerollErr*/, void */*userData*/)
-{
-    // QuickTimeVideoPlayer *player = static_cast<QuickTimeVideoPlayer *>(userData);
-}
-
-bool QuickTimeVideoPlayer::preRollMovie(qint64 startTime)
-{
-    if (!canPlayMedia())
-        return false;
-
-    if (PrePrerollMovie(m_movieRef, startTime, FloatToFixed(m_playbackRate),
-        0 /*MoviePrePrerollCompleteCallBack*/, this) != noErr) // No callback means wait (synch)
-        return false;
-
-    if (PrerollMovie(m_movieRef, startTime, FloatToFixed(m_playbackRate)) != noErr)
-        return false;
-
-    return true;
-}
-
-bool QuickTimeVideoPlayer::hasAudio() const
-{
-    if (!m_movieRef)
-        return false;
-
-    Track track = GetMovieIndTrackType(
-        m_movieRef, 1, AudioMediaCharacteristic, movieTrackCharacteristic | movieTrackEnabledOnly);
-    return (track != 0);
-}
-
-bool QuickTimeVideoPlayer::hasVideo() const
-{
-    return m_hasVideo;
-}
-
-void QuickTimeVideoPlayer::checkIfVideoAwailable()
-{
-    Track track = GetMovieIndTrackType(
-        m_movieRef, 1, VisualMediaCharacteristic, movieTrackCharacteristic | movieTrackEnabledOnly);
-    m_hasVideo = bool(track != 0);
-}
-
-bool QuickTimeVideoPlayer::isDrmProtected() const
-{
-    return m_isDrmProtected;
-}
-
-bool QuickTimeVideoPlayer::isDrmAuthorized() const
-{
-    return m_isDrmAuthorized;
-}
-
-void QuickTimeVideoPlayer::readProtection()
-{
-    if (!m_movieRef){
-        m_isDrmProtected = false;
-        m_isDrmAuthorized = true;
-        return;
-    }
-        
-    Track track = GetMovieIndTrackType(m_movieRef, 1,
-        AudioMediaCharacteristic, movieTrackCharacteristic | movieTrackEnabledOnly);
-    if (track){
-        getTrackProtection(track, m_isDrmProtected, m_isDrmAuthorized);
-    } else {        
-        track = GetMovieIndTrackType(m_movieRef, 1,
-            VisualMediaCharacteristic, movieTrackCharacteristic | movieTrackEnabledOnly);
-        if (track){
-            getTrackProtection(track, m_isDrmProtected, m_isDrmAuthorized);
-        }
-    }    
-}
-
-void QuickTimeVideoPlayer::getTrackProtection(const Track &track, bool &isDrmProtected, bool &isDrmAuthorized) const
-{
-    isDrmProtected = false;
-    isDrmAuthorized = true;
-    
-    if (track){
-        Media media = GetTrackMedia(track);
-        if (media){
-            MediaHandler mediaHandler = GetMediaHandler(media);
-            if (mediaHandler){
-                // Regardless, skip message boxes pointing to iTunes regarding DRM:
-                Boolean boolFalse = false;
-                QTSetComponentProperty(mediaHandler, 
-                    kQTPropertyClass_DRM, kQTDRMPropertyID_InteractWithUser,
-                    sizeof(boolFalse), &boolFalse);
-
-                // Check track:
-                Boolean value;
-                OSStatus err = QTGetComponentProperty(mediaHandler,
-                    kQTPropertyClass_DRM, kQTDRMPropertyID_IsProtected,
-                    sizeof(value), &value, 0);
-                isDrmProtected = (err == noErr) ? bool(value) : false;
-                err = QTGetComponentProperty(mediaHandler,
-                    kQTPropertyClass_DRM, kQTDRMPropertyID_IsAuthorized,
-                    sizeof(value), &value, 0);
-                isDrmAuthorized = (err == noErr) ? bool(value) : true;
-            }
-        }
-    }
-}
-
-}}
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/quicktimevideoplayer.h phonon-4.3.0/qt7/quicktimevideoplayer.h
--- phonon-4.3.0/qt7/quicktimevideoplayer.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimevideoplayer.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,11 +19,13 @@
 #define Phonon_QT7_QUICKTIMEVIDEOPLAYER_H
 
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-#include <AGL/agl.h>
+#include "backendheader.h"
+
+#import <QTKit/QTDataReference.h>
+#import <QTKit/QTMovie.h>
 
 #include <phonon/mediasource.h>
 #include <Carbon/Carbon.h>
-#include <QtCore>
+#include <QtCore/QString>
+#include <QtOpenGL/QGLPixelBuffer>
 #include "videoframe.h"
 
@@ -37,5 +39,6 @@
 {
     class QuickTimeStreamReader;
-    
+	class VideoRenderWidgetQTMovieView;
+
     class QuickTimeVideoPlayer : QObject
     {
@@ -59,13 +62,14 @@
             void seek(quint64 milliseconds);
 
-            bool setGLContext(const QGLContext *qGLContext);
-            bool setCurrentGLContext();
-
-            bool videoFrameChanged(const LinkTimeProxy &timeStamp);
-            CVOpenGLTextureRef createCvTexture(const LinkTimeProxy &timeStamp);
+            bool videoFrameChanged();
+            CVOpenGLTextureRef currentFrameAsCVTexture();
+            GLuint currentFrameAsGLTexture();
+			void *currentFrameAsCIImage();
+            QImage currentFrameAsQImage();
             QRect videoRect() const;
 
             quint64 duration() const;
             quint64 currentTime() const;
+            long timeScale() const;
             QString currentTimeString();
 
@@ -79,13 +83,14 @@
             bool setAudioDevice(int id);
             void setPlaybackRate(float rate);
-            
+            QTMovie *qtMovie() const;
+
             float playbackRate() const;
             float prefferedPlaybackRate() const;
 
-            Movie movieRef() const;
             QuickTimeVideoPlayer::State state() const;
 
             bool hasAudio() const;
             bool hasVideo() const;
+            bool hasMovie() const;
             bool canPlayMedia() const;
             bool isPlaying() const;
@@ -100,7 +105,16 @@
             static QString timeToString(quint64 ms);
 
+			// Help functions when drawing to more that one widget in cocoa 64:
+			void *m_primaryRenderingTarget;
+            void setPrimaryRenderingTarget(NSObject *target);
+
+			void *primaryRenderingCIImage();
+			void setPrimaryRenderingCIImage(void *ciImage);
+
         private:
-            Movie m_movieRef;
+            QTMovie *m_QTMovie;
             State m_state;
+            QGLPixelBuffer *m_QImagePixelBuffer;
+
             bool m_playbackRateSat;
             bool m_isDrmProtected;
@@ -114,21 +128,33 @@
             quint64 m_currentTime;
             MediaSource m_mediaSource;
+			void *m_primaryRenderingCIImage;
+			qreal m_brightness;
+			qreal m_contrast;
+			qreal m_hue;
+			qreal m_saturation;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
             QTVisualContextRef m_visualContext;
+#endif
             VideoFrame m_currentFrame;
             QuickTimeStreamReader *m_streamReader;
-            const QGLContext *m_qGLContext;
 
+            void createVisualContext();
             void openMovieFromCurrentMediaSource();
-            void openMovieFromDataRef(DataReferenceRecord &dataRef);
+            void openMovieFromDataRef(QTDataReference *dataRef);
             void openMovieFromFile();
             void openMovieFromUrl();
             void openMovieFromStream();
-            
-            bool checkForError();
+            void openMovieFromData(QByteArray *data, char *fileType);
+            void openMovieFromDataGuessType(QByteArray *data);
+			QString mediaSourcePath();
+			bool codecExistsAccordingToSuffix(const QString &fileName);
+
+            void setError(NSError *error);
+            bool errorOccured();
             void readProtection();
-            void getTrackProtection(const Track &track, bool &isProtected, bool &isAuthorized) const;
-            bool setGLContext(AGLContext aglContext, AGLPixelFormat aglPixelFormat);
             void checkIfVideoAwailable();
-            void waitForState(long waitState);
+            bool movieNotLoaded();
+            void waitStatePlayable();
     };
 
diff -r -U2 -N phonon-4.3.0/qt7/quicktimevideoplayer.mm phonon-4.3.0/qt7/quicktimevideoplayer.mm
--- phonon-4.3.0/qt7/quicktimevideoplayer.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/quicktimevideoplayer.mm	2009-03-03 08:46:45.000000000 -0700
@@ -0,0 +1,955 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "quicktimevideoplayer.h"
+#include "mediaobject.h"
+#include "videowidget.h"
+#include "audiodevice.h"
+#include "quicktimestreamreader.h"
+
+#include <QtCore/QCoreApplication>
+#include <QtCore/QEventLoop>
+#include <QtCore/QFileInfo>
+#include <QtCore/QUrl>
+#include <QtOpenGL/QGLContext>
+
+#import <QTKit/QTTrack.h>
+#import <QTKit/QTMedia.h>
+#import <QuartzCore/CIContext.h>
+#import <QuartzCore/CIFilter.h>
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    #include <QuickTime/QuickTime.h>
+    #undef check // avoid name clash;
+    #include <AGL/agl.h>
+#endif
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+// Defined in videowidget.cpp:
+QGLWidget *PhononSharedQGLWidget();
+
+QuickTimeVideoPlayer::QuickTimeVideoPlayer() : QObject(0)
+{
+    m_state = NoMedia;
+    m_mediaSource = MediaSource();
+    m_QTMovie = 0;
+    m_streamReader = 0;
+    m_playbackRate = 1.0f;
+    m_masterVolume = 1.0f;
+    m_relativeVolume = 1.0f;
+    m_currentTime = 0;
+    m_mute = false;
+    m_audioEnabled = false;
+    m_hasVideo = false;
+    m_playbackRateSat = false;
+    m_isDrmProtected = false;
+    m_isDrmAuthorized = true;
+	m_primaryRenderingTarget = 0;
+	m_primaryRenderingCIImage = 0;
+    m_QImagePixelBuffer = 0;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    OSStatus err = EnterMovies();
+    BACKEND_ASSERT2(err == noErr, "Could not initialize QuickTime", FATAL_ERROR)
+	createVisualContext();
+#endif
+}
+
+QuickTimeVideoPlayer::~QuickTimeVideoPlayer()
+{
+    unsetVideo();
+    [(NSObject*)m_primaryRenderingTarget release];
+    m_primaryRenderingTarget = 0;
+#ifdef QUICKTIME_C_API_AVAILABLE
+    if (m_visualContext)
+        CFRelease(m_visualContext);
+#endif
+}
+
+void QuickTimeVideoPlayer::createVisualContext()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+	PhononSharedQGLWidget()->makeCurrent();
+
+	PhononAutoReleasePool pool;
+    CGLContextObj cglContext = CGLGetCurrentContext();
+	NSOpenGLPixelFormat *nsglPixelFormat = [NSOpenGLView defaultPixelFormat];
+    CGLPixelFormatObj cglPixelFormat = static_cast<CGLPixelFormatObj>([nsglPixelFormat CGLPixelFormatObj]);
+	BACKEND_ASSERT2(cglContext, "Could not get current CoreVideo GL context (OpenGL)", FATAL_ERROR)
+	BACKEND_ASSERT2(cglPixelFormat, "Could not get current CoreVideo pixel format (OpenGL)", FATAL_ERROR)
+
+    CFTypeRef keys[] = { kQTVisualContextWorkingColorSpaceKey };
+    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
+    CFDictionaryRef textureContextAttributes = CFDictionaryCreate(kCFAllocatorDefault,
+        (const void **)keys,
+        (const void **)&colorSpace, 1,
+        &kCFTypeDictionaryKeyCallBacks,
+        &kCFTypeDictionaryValueCallBacks);
+
+	OSStatus err = QTOpenGLTextureContextCreate(kCFAllocatorDefault, cglContext,
+        cglPixelFormat, textureContextAttributes, &m_visualContext);
+    CFRelease(textureContextAttributes);
+    BACKEND_ASSERT2(err == noErr, "Could not create visual context (OpenGL)", FATAL_ERROR)
+#endif // QUICKTIME_C_API_AVAILABLE
+}
+
+bool QuickTimeVideoPlayer::videoFrameChanged()
+{
+    if (!m_QTMovie || !m_hasVideo)
+        return false;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+	if (m_primaryRenderingTarget)
+		return true;
+    if (!m_visualContext)
+		return false;
+
+    QTVisualContextTask(m_visualContext);
+    return QTVisualContextIsNewImageAvailable(m_visualContext, 0);
+
+#elif defined(QT_MAC_USE_COCOA)
+    return true;
+
+#else
+    return false;
+#endif
+}
+
+CVOpenGLTextureRef QuickTimeVideoPlayer::currentFrameAsCVTexture()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+    if (!m_visualContext)
+        return 0;
+    CVOpenGLTextureRef texture = 0;
+    OSStatus err = QTVisualContextCopyImageForTime(m_visualContext, 0, 0, &texture);
+    BACKEND_ASSERT3(err == noErr, "Could not copy image for time in QuickTime player", FATAL_ERROR, 0)
+    return texture;
+
+#else
+    return 0;
+#endif
+}
+
+QImage QuickTimeVideoPlayer::currentFrameAsQImage()
+{
+#ifdef QUICKTIME_C_API_AVAILABLE
+    QGLContext *prevContext = const_cast<QGLContext *>(QGLContext::currentContext());
+    CVOpenGLTextureRef texture = currentFrameAsCVTexture();
+    GLenum target = CVOpenGLTextureGetTarget(texture);
+    GLfloat lowerLeft[2], lowerRight[2], upperRight[2], upperLeft[2];
+
+    if (!m_QImagePixelBuffer){
+        m_QImagePixelBuffer = new QGLPixelBuffer(videoRect().size(), QGLFormat::defaultFormat(), PhononSharedQGLWidget());
+        m_QImagePixelBuffer->makeCurrent();
+        glEnable(target);
+        glDisable(GL_BLEND);
+        glDisable(GL_CULL_FACE);
+    } else {
+        m_QImagePixelBuffer->makeCurrent();
+    }
+
+    CVOpenGLTextureGetCleanTexCoords(texture, upperLeft, upperRight, lowerRight, lowerLeft);
+    glBindTexture(target, CVOpenGLTextureGetName(texture));
+    glBegin(GL_QUADS);
+        glTexCoord2f(lowerLeft[0], lowerLeft[1]);
+        glVertex2i(-1, 1);
+        glTexCoord2f(lowerRight[0], lowerRight[1]);
+        glVertex2i(1, 1);
+        glTexCoord2f(upperRight[0], upperRight[1]);
+        glVertex2i(1, -1);
+        glTexCoord2f(upperLeft[0], upperLeft[1]);
+        glVertex2i(-1, -1);
+    glEnd();
+
+    QImage image = m_QImagePixelBuffer->toImage();
+    CVOpenGLTextureRelease(texture);
+    // Because of QuickTime, m_QImagePixelBuffer->doneCurrent() will fail.
+    // So we store, and restore, the context our selves:
+    prevContext->makeCurrent();
+    return image;
+#else
+	CIImage *img = (CIImage *)currentFrameAsCIImage();
+	if (!img)
+		return QImage();
+
+	NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc] initWithCIImage:img];
+	CGRect bounds = [img extent];
+	QImage qImg([bitmap bitmapData], bounds.size.width, bounds.size.height, QImage::Format_ARGB32);
+	QImage swapped = qImg.rgbSwapped();
+	[bitmap release];
+	[img release];
+	return swapped;
+#endif
+}
+
+void QuickTimeVideoPlayer::setPrimaryRenderingCIImage(void *ciImage)
+{
+	[(CIImage *)m_primaryRenderingCIImage release];
+	m_primaryRenderingCIImage = ciImage;
+	[(CIImage *)m_primaryRenderingCIImage retain];
+}
+
+void QuickTimeVideoPlayer::setPrimaryRenderingTarget(NSObject *target)
+{
+	[(NSObject*)m_primaryRenderingTarget release];
+	m_primaryRenderingTarget = target;
+	[(NSObject*)m_primaryRenderingTarget retain];
+}
+
+void *QuickTimeVideoPlayer::primaryRenderingCIImage()
+{
+	return m_primaryRenderingCIImage;
+}
+
+void *QuickTimeVideoPlayer::currentFrameAsCIImage()
+{
+    if (!m_QTMovie)
+        return 0;
+
+#if defined(QT_MAC_USE_COCOA)
+	if (m_primaryRenderingCIImage){
+		CIImage *img = (CIImage *)m_primaryRenderingCIImage;
+		if (m_brightness || m_contrast || m_saturation){
+			CIFilter *colorFilter = [CIFilter filterWithName:@"CIColorControls"];
+			[colorFilter setValue:[NSNumber numberWithFloat:m_brightness] forKey:@"inputBrightness"];
+			[colorFilter setValue:[NSNumber numberWithFloat:(m_contrast < 1) ? m_contrast : 1 + ((m_contrast-1)*3)] forKey:@"inputContrast"];
+			[colorFilter setValue:[NSNumber numberWithFloat:m_saturation] forKey:@"inputSaturation"];
+			[colorFilter setValue:img forKey:@"inputImage"];
+			img = [colorFilter valueForKey:@"outputImage"];
+		}
+		if (m_hue){
+			CIFilter *colorFilter = [CIFilter filterWithName:@"CIHueAdjust"];
+			[colorFilter setValue:[NSNumber numberWithFloat:(m_hue * 3.14)] forKey:@"inputAngle"];
+			[colorFilter setValue:img forKey:@"inputImage"];
+			img = [colorFilter valueForKey:@"outputImage"];
+		}
+		return [img retain];
+	}
+#endif
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+	CVOpenGLTextureRef cvImg = currentFrameAsCVTexture();
+	CIImage *img = [[CIImage alloc] initWithCVImageBuffer:cvImg];
+	CVOpenGLTextureRelease(cvImg);
+	return img;	
+#else
+	return 0;
+#endif
+}
+
+GLuint QuickTimeVideoPlayer::currentFrameAsGLTexture()
+{
+	CIImage *img = (CIImage *)currentFrameAsCIImage();
+	if (!img)
+		return 0;
+
+	NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc] initWithCIImage:img];
+    GLuint texName = 0;
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, [bitmap pixelsWide]);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    glGenTextures(1, &texName);
+    glBindTexture(GL_TEXTURE_RECTANGLE_EXT, texName);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER,  GL_LINEAR);
+
+    int samplesPerPixel = [bitmap samplesPerPixel];
+    if (![bitmap isPlanar] && (samplesPerPixel == 3 || samplesPerPixel == 4)){
+        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, 
+            samplesPerPixel == 4 ? GL_RGBA8 : GL_RGB8,
+            [bitmap pixelsWide], [bitmap pixelsHigh],
+            0, samplesPerPixel == 4 ? GL_RGBA : GL_RGB,
+            GL_UNSIGNED_BYTE, [bitmap bitmapData]);
+    } else {
+        // Handle other bitmap formats.
+    }
+
+    [bitmap release];
+	[img release];
+    return texName;
+}
+
+void QuickTimeVideoPlayer::setMasterVolume(float volume)
+{
+    setVolume(volume, m_relativeVolume);
+}
+
+void QuickTimeVideoPlayer::setRelativeVolume(float volume)
+{
+    setVolume(m_masterVolume, volume);
+}
+
+void QuickTimeVideoPlayer::setVolume(float masterVolume, float relativeVolume)
+{
+    m_masterVolume = masterVolume;
+    m_relativeVolume = relativeVolume;
+    if (!m_QTMovie || !m_audioEnabled || m_mute)
+        return;                
+    [m_QTMovie setVolume:(m_masterVolume * m_relativeVolume)];
+}
+
+void QuickTimeVideoPlayer::setMute(bool mute)
+{
+    m_mute = mute;
+    if (!m_QTMovie || m_state != Playing || !m_audioEnabled)
+        return;
+
+    // Work-around bug that happends if you set/unset mute
+    // before movie is playing, and audio is not played 
+    // through graph. Then audio is delayed.
+    [m_QTMovie setMuted:mute];
+    [m_QTMovie setVolume:(mute ? 0 : m_masterVolume * m_relativeVolume)];
+}
+
+void QuickTimeVideoPlayer::enableAudio(bool enable)
+{
+    m_audioEnabled = enable;
+    if (!m_QTMovie || m_state != Playing)
+        return;
+
+    // Work-around bug that happends if you set/unset mute
+    // before movie is playing, and audio is not played 
+    // through graph. Then audio is delayed.
+    [m_QTMovie setMuted:(!enable || m_mute)];
+    [m_QTMovie setVolume:((!enable || m_mute) ? 0 : m_masterVolume * m_relativeVolume)];
+}
+
+bool QuickTimeVideoPlayer::audioEnabled()
+{
+    return m_audioEnabled;
+}
+
+bool QuickTimeVideoPlayer::setAudioDevice(int id)
+{
+    if (!m_QTMovie)
+        return false;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    // The following code will not work for some media codecs that
+    // typically mingle audio/video frames (e.g mpeg).
+    CFStringRef idString = PhononCFString::toCFStringRef(AudioDevice::deviceUID(id));        
+    QTAudioContextRef context;
+    QTAudioContextCreateForAudioDevice(kCFAllocatorDefault, idString, 0, &context);
+    OSStatus err = SetMovieAudioContext([m_QTMovie quickTimeMovie], context);
+    CFRelease(context);
+    if (err != noErr)
+        return false;
+    return true;
+#else
+    Q_UNUSED(id);
+    return false;
+#endif
+}
+
+void QuickTimeVideoPlayer::setColors(qreal brightness, qreal contrast, qreal hue, qreal saturation)
+{
+    if (!m_QTMovie)
+        return;
+
+    // 0 is default value for the colors
+    // in phonon, so adjust scale:
+    contrast += 1;
+    saturation += 1;
+
+	m_brightness = brightness;
+	m_contrast = contrast;
+	m_hue = hue;
+	m_saturation = saturation;
+	
+#ifdef QUICKTIME_C_API_AVAILABLE
+    Float32 value;
+    value = brightness;
+    SetMovieVisualBrightness([m_QTMovie quickTimeMovie], value, 0);
+    value = contrast;
+    SetMovieVisualContrast([m_QTMovie quickTimeMovie], value, 0);
+    value = hue;
+    SetMovieVisualHue([m_QTMovie quickTimeMovie], value, 0);
+    value = saturation;
+    SetMovieVisualSaturation([m_QTMovie quickTimeMovie], value, 0);
+#endif
+}
+
+QRect QuickTimeVideoPlayer::videoRect() const
+{
+    if (!m_QTMovie)
+        return QRect();
+
+	PhononAutoReleasePool pool;
+    NSSize size = [[m_QTMovie attributeForKey:@"QTMovieCurrentSizeAttribute"] sizeValue];
+    return QRect(0, 0, size.width, size.height);
+}
+
+void QuickTimeVideoPlayer::unsetVideo()
+{
+    if (!m_QTMovie)
+        return;
+
+    [m_QTMovie release];
+	m_QTMovie = 0;
+    delete m_streamReader;
+    m_streamReader = 0;
+    m_currentTime = 0;
+    m_state = NoMedia;
+    m_isDrmProtected = false;
+    m_isDrmAuthorized = true;
+    m_mediaSource = MediaSource();
+	[(CIImage *)m_primaryRenderingCIImage release];
+	m_primaryRenderingCIImage = 0;
+    delete m_QImagePixelBuffer;
+    m_QImagePixelBuffer = 0;
+}
+
+QuickTimeVideoPlayer::State QuickTimeVideoPlayer::state() const
+{
+    return m_state;
+}
+
+quint64 QuickTimeVideoPlayer::timeLoaded()
+{
+    if (!m_QTMovie)
+        return 0;
+#ifdef QUICKTIME_C_API_AVAILABLE
+    TimeValue value;
+    GetMaxLoadedTimeInMovie([m_QTMovie quickTimeMovie], &value);
+    quint64 loaded = static_cast<quint64>(float(value) / float(GetMovieTimeScale([m_QTMovie quickTimeMovie])) * 1000.0f);
+    return (loaded == INT_MAX) ? 0 : loaded;
+#else
+    return 0;
+#endif
+}
+
+float QuickTimeVideoPlayer::percentageLoaded()
+{
+    if (!m_QTMovie || !isSeekable())
+        return 0;
+#ifdef QUICKTIME_C_API_AVAILABLE
+    TimeValue loaded;
+    GetMaxLoadedTimeInMovie([m_QTMovie quickTimeMovie], &loaded);
+    float duration = GetMovieDuration([m_QTMovie quickTimeMovie]);
+    return duration ? float(loaded) / duration : 0;
+#else
+    return 0;
+#endif
+}
+
+void QuickTimeVideoPlayer::waitStatePlayable()
+{
+#if defined(QT_MAC_USE_COCOA)
+    long state = [[m_QTMovie attributeForKey:@"QTMovieLoadStateAttribute"] longValue];
+    while (state != QTMovieLoadStateError && state < QTMovieLoadStatePlayable)
+        state = [[m_QTMovie attributeForKey:@"QTMovieLoadStateAttribute"] longValue];
+#elif defined(QUICKTIME_C_API_AVAILABLE)
+    long state = GetMovieLoadState([m_QTMovie quickTimeMovie]);
+    while (state != kMovieLoadStateError && state < kMovieLoadStatePlayable){
+        MoviesTask(0, 0);
+        state = GetMovieLoadState([m_QTMovie quickTimeMovie]);
+    }
+#endif
+}
+
+bool QuickTimeVideoPlayer::movieNotLoaded()
+{
+    if (!m_QTMovie)
+        return true;
+
+#if defined(QT_MAC_USE_COCOA)
+    long state = [[m_QTMovie attributeForKey:@"QTMovieLoadStateAttribute"] longValue];
+    return state == QTMovieLoadStateError;
+#elif defined(QUICKTIME_C_API_AVAILABLE)
+    long state = GetMovieLoadState([m_QTMovie quickTimeMovie]);
+    return state == kMovieLoadStateError;
+#endif
+}
+
+void QuickTimeVideoPlayer::setError(NSError *error)
+{
+    if (!error)
+        return;
+    QString desc = QString::fromUtf8([[error localizedDescription] UTF8String]);
+    if (desc == "The file is not a movie file.")
+        desc = QLatin1String("Could not decode media source.");
+    else if (desc == "A necessary data reference could not be resolved."){
+		if (codecExistsAccordingToSuffix(mediaSourcePath()))
+            desc = QLatin1String("Could not locate media source.");
+		else
+            desc = QLatin1String("Could not decode media source.");
+    } else if (desc == "You do not have sufficient permissions for this operation.")
+        desc = QLatin1String("Could not open media source.");
+    SET_ERROR(desc, FATAL_ERROR)
+}
+
+bool QuickTimeVideoPlayer::errorOccured()
+{
+    if (gGetErrorType() != NO_ERROR){
+        return true;
+    } else if (movieNotLoaded()){
+        SET_ERROR("Could not open media source.", FATAL_ERROR)
+        return true;
+    }
+	return false;
+}
+
+bool QuickTimeVideoPlayer::codecExistsAccordingToSuffix(const QString &fileName)
+{
+	PhononAutoReleasePool pool;
+	NSArray *fileTypes = [QTMovie movieFileTypes:QTIncludeAllTypes];
+	for (uint i=0; i<[fileTypes count]; ++i){
+		NSString *type = [fileTypes objectAtIndex:i];
+		QString formattedType = QString::fromUtf8([type UTF8String]);
+		formattedType.remove('\'').remove('.');
+		if (fileName.endsWith(QChar('.') + formattedType, Qt::CaseInsensitive))
+			return true;
+	}
+	return false;
+}
+
+void QuickTimeVideoPlayer::setMediaSource(const MediaSource &mediaSource)
+{
+    PhononAutoReleasePool pool;
+    unsetVideo();
+    m_mediaSource = mediaSource;
+    if (mediaSource.type() == MediaSource::Empty || mediaSource.type() == MediaSource::Invalid){
+        m_state = NoMedia;
+        return;
+    }
+    openMovieFromCurrentMediaSource();
+    if (errorOccured()){
+        unsetVideo();
+        return;
+    }
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    if (m_visualContext)
+        SetMovieVisualContext([m_QTMovie quickTimeMovie], m_visualContext);
+#endif
+
+    waitStatePlayable();
+    if (errorOccured()){
+        unsetVideo();
+        return;
+    }
+
+    readProtection();
+    preRollMovie();
+    if (errorOccured()){
+        unsetVideo();
+        return;
+    }
+
+    if (!m_playbackRateSat)
+        m_playbackRate = prefferedPlaybackRate();
+    checkIfVideoAwailable();
+    enableAudio(m_audioEnabled);
+    setMute(m_mute);
+    setVolume(m_masterVolume, m_relativeVolume);
+    pause();
+}
+
+void QuickTimeVideoPlayer::openMovieFromCurrentMediaSource()
+{
+    switch (m_mediaSource.type()){
+    case MediaSource::LocalFile:
+        openMovieFromFile();
+        break;
+    case MediaSource::Url:
+        openMovieFromUrl();
+        break;
+    case MediaSource::Disc:
+        CASE_UNSUPPORTED("Could not open media source.", FATAL_ERROR)
+        break;
+    case MediaSource::Stream:
+        openMovieFromStream();
+        break;
+    case MediaSource::Empty:
+    case MediaSource::Invalid:
+        break;
+    }
+}
+
+QString QuickTimeVideoPlayer::mediaSourcePath()
+{
+    switch (m_mediaSource.type()){
+    case MediaSource::LocalFile:{
+        QFileInfo fileInfo(m_mediaSource.fileName());
+        return fileInfo.isSymLink() ? fileInfo.symLinkTarget() : fileInfo.canonicalFilePath();
+        break;}
+    case MediaSource::Url:
+		return m_mediaSource.url().toEncoded();
+        break;
+    default:
+        break;
+    }
+	return QString();
+}
+
+void QuickTimeVideoPlayer::openMovieFromDataRef(QTDataReference *dataRef)
+{
+    PhononAutoReleasePool pool;
+    NSDictionary *attr = [NSDictionary dictionaryWithObjectsAndKeys:
+                dataRef, QTMovieDataReferenceAttribute,
+                [NSNumber numberWithBool:YES], QTMovieOpenAsyncOKAttribute,
+                [NSNumber numberWithBool:YES], QTMovieIsActiveAttribute,
+                [NSNumber numberWithBool:YES], QTMovieResolveDataRefsAttribute,
+                [NSNumber numberWithBool:YES], QTMovieDontInteractWithUserAttribute,
+                nil];
+
+    NSError *err = 0;
+    m_QTMovie = [[QTMovie movieWithAttributes:attr error:&err] retain];
+    if (err){
+        [m_QTMovie release];
+        m_QTMovie = 0;
+        setError(err);
+    }
+}
+
+void QuickTimeVideoPlayer::openMovieFromData(QByteArray *data, char *fileType)
+{
+    PhononAutoReleasePool pool;
+    NSString *type = [NSString stringWithUTF8String:fileType];
+    NSData *nsData = [NSData dataWithBytesNoCopy:data->data() length:data->size() freeWhenDone:NO];
+    QTDataReference *dataRef = [QTDataReference dataReferenceWithReferenceToData:nsData name:type MIMEType:@""];
+    openMovieFromDataRef(dataRef);
+}
+
+void QuickTimeVideoPlayer::openMovieFromDataGuessType(QByteArray *data)
+{
+    // It turns out to be better to just try the standard file types rather
+    // than using e.g [QTMovie movieFileTypes:QTIncludeCommonTypes]. Some
+    // codecs *think* they can decode the stream, and crash...
+#define TryOpenMovieWithCodec(type) gClearError(); \
+    openMovieFromData(data, "."type); \
+    if (m_QTMovie) return;
+
+    TryOpenMovieWithCodec("avi");
+    TryOpenMovieWithCodec("mp4");
+    TryOpenMovieWithCodec("m4p");
+    TryOpenMovieWithCodec("m1s");
+    TryOpenMovieWithCodec("mp3");
+    TryOpenMovieWithCodec("mpeg");
+    TryOpenMovieWithCodec("mov");
+    TryOpenMovieWithCodec("ogg");
+    TryOpenMovieWithCodec("wav");
+    TryOpenMovieWithCodec("wmv");
+#undef TryOpenMovieWithCodec(type)
+}
+
+void QuickTimeVideoPlayer::openMovieFromFile()
+{
+    NSString *nsFilename = (NSString *)PhononCFString::toCFStringRef(mediaSourcePath());
+    QTDataReference *dataRef = [QTDataReference dataReferenceWithReferenceToFile:nsFilename];
+    openMovieFromDataRef(dataRef);
+}
+
+void QuickTimeVideoPlayer::openMovieFromUrl()
+{
+    PhononAutoReleasePool pool;
+    NSString *urlString = (NSString *)PhononCFString::toCFStringRef(mediaSourcePath());
+    NSURL *url = [NSURL URLWithString: urlString];
+    QTDataReference *dataRef = [QTDataReference dataReferenceWithReferenceToURL:url];
+    openMovieFromDataRef(dataRef);
+}
+
+void QuickTimeVideoPlayer::openMovieFromStream()
+{
+    m_streamReader = new QuickTimeStreamReader(m_mediaSource);
+    if (!m_streamReader->readAllData())
+        return;
+    openMovieFromDataGuessType(m_streamReader->pointerToData());
+}
+
+MediaSource QuickTimeVideoPlayer::mediaSource() const
+{
+    return m_mediaSource;
+}
+
+QTMovie *QuickTimeVideoPlayer::qtMovie() const
+{
+    return m_QTMovie;
+}
+
+void QuickTimeVideoPlayer::setPlaybackRate(float rate)
+{
+	PhononAutoReleasePool pool;
+    m_playbackRateSat = true;
+    m_playbackRate = rate;
+    if (m_QTMovie)
+        [m_QTMovie setRate:m_playbackRate];
+}
+
+float QuickTimeVideoPlayer::playbackRate() const
+{
+    return m_playbackRate;
+}
+
+quint64 QuickTimeVideoPlayer::currentTime() const
+{
+    if (!m_QTMovie || m_state == Paused)
+        return m_currentTime;
+
+	PhononAutoReleasePool pool;
+    QTTime qtTime = [m_QTMovie currentTime];
+    quint64 t = static_cast<quint64>(float(qtTime.timeValue) / float(qtTime.timeScale) * 1000.0f);
+    const_cast<QuickTimeVideoPlayer *>(this)->m_currentTime = t;
+    return m_currentTime;
+}
+
+long QuickTimeVideoPlayer::timeScale() const
+{
+    if (!m_QTMovie)
+        return 0;
+
+	PhononAutoReleasePool pool;
+    return [[m_QTMovie attributeForKey:@"QTMovieTimeScaleAttribute"] longValue];
+}
+
+QString QuickTimeVideoPlayer::timeToString(quint64 ms)
+{
+    int sec = ms/1000;
+    int min = sec/60;
+    int hour = min/60;
+    return QString(QLatin1String("%1:%2:%3:%4")).arg(hour%60).arg(min%60).arg(sec%60).arg(ms%1000);
+}
+
+QString QuickTimeVideoPlayer::currentTimeString()
+{
+    return timeToString(currentTime());
+}
+
+quint64 QuickTimeVideoPlayer::duration() const
+{
+    if (!m_QTMovie)
+        return 0;
+
+	PhononAutoReleasePool pool;
+    QTTime qtTime = [m_QTMovie duration];
+    return static_cast<quint64>(float(qtTime.timeValue) / float(qtTime.timeScale) * 1000.0f);
+}
+
+void QuickTimeVideoPlayer::play()
+{
+    if (!canPlayMedia())
+        return;
+
+	PhononAutoReleasePool pool;
+    m_state = Playing;
+    enableAudio(m_audioEnabled);
+    setMute(m_mute);
+    [m_QTMovie setRate:m_playbackRate];
+}
+
+void QuickTimeVideoPlayer::pause()
+{
+    if (!canPlayMedia())
+        return;
+
+	PhononAutoReleasePool pool;
+    currentTime();
+    m_state = Paused;
+
+    if (isSeekable())
+        [m_QTMovie setRate:0];
+    else // pretend to be paused:
+        [m_QTMovie setMuted:0];
+}
+
+void QuickTimeVideoPlayer::seek(quint64 milliseconds)
+{
+    if (!canPlayMedia() || !isSeekable() || milliseconds == currentTime())
+        return;
+    if (milliseconds > duration())
+        milliseconds = duration();
+
+	PhononAutoReleasePool pool;
+    QTTime newQTTime = [m_QTMovie currentTime];
+    newQTTime.timeValue = (milliseconds / 1000.0f) * newQTTime.timeScale;
+    [m_QTMovie setCurrentTime:newQTTime];
+
+    // The movie might not have been able to seek
+    // to the exact point we told it to. So set
+    // the current time according to what the movie says:
+    newQTTime = [m_QTMovie currentTime];
+    m_currentTime = static_cast<quint64>
+        (float(newQTTime.timeValue) / float(newQTTime.timeScale) * 1000.0f);
+
+    if (m_state == Paused){
+        // We need (for reasons unknown) to task
+        // the movie twize to make sure that
+        // a subsequent call to frameAsCvTexture
+        // returns the correct frame:
+#ifdef QUICKTIME_C_API_AVAILABLE
+        MoviesTask(0, 0);
+        MoviesTask(0, 0);
+#elif defined(QT_MAC_USE_COCOA)
+        qApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers);
+#endif
+    }
+}
+
+bool QuickTimeVideoPlayer::canPlayMedia() const
+{
+    if (!m_QTMovie)
+        return false;
+    return m_isDrmAuthorized;
+}
+
+bool QuickTimeVideoPlayer::isPlaying() const
+{
+    return m_state == Playing;
+}
+
+bool QuickTimeVideoPlayer::isSeekable() const
+{
+    return canPlayMedia() && (duration()-1) != INT_MAX;
+}
+
+float QuickTimeVideoPlayer::prefferedPlaybackRate() const
+{
+    if (!m_QTMovie)
+        return 0;
+
+	PhononAutoReleasePool pool;
+    return [[m_QTMovie attributeForKey:@"QTMoviePreferredRateAttribute"] floatValue];
+}
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+void MoviePrePrerollCompleteCallBack(Movie /*theMovie*/, OSErr /*thePrerollErr*/, void * /*userData*/)
+{
+    // QuickTimeVideoPlayer *player = static_cast<QuickTimeVideoPlayer *>(userData);
+}
+#endif
+
+bool QuickTimeVideoPlayer::preRollMovie(qint64 startTime)
+{
+    if (!canPlayMedia())
+        return false;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    if (PrePrerollMovie([m_QTMovie quickTimeMovie], startTime, FloatToFixed(m_playbackRate),
+        0 /*MoviePrePrerollCompleteCallBack*/, this) != noErr) // No callback means wait (synch)
+        return false;
+
+    if (PrerollMovie([m_QTMovie quickTimeMovie], startTime, FloatToFixed(m_playbackRate)) != noErr)
+        return false;
+
+    return true;
+#else
+    Q_UNUSED(startTime);
+    return false;
+#endif
+}
+
+bool QuickTimeVideoPlayer::hasAudio() const
+{
+    if (!m_QTMovie)
+        return false;
+
+	PhononAutoReleasePool pool;
+    return [[m_QTMovie attributeForKey:@"QTMovieHasAudioAttribute"] boolValue] == YES;
+}
+
+bool QuickTimeVideoPlayer::hasVideo() const
+{
+    return m_hasVideo;
+}
+
+bool QuickTimeVideoPlayer::hasMovie() const
+{
+    return m_QTMovie != 0;
+}
+
+void QuickTimeVideoPlayer::checkIfVideoAwailable()
+{
+	PhononAutoReleasePool pool;
+    m_hasVideo = [[m_QTMovie attributeForKey:@"QTMovieHasVideoAttribute"] boolValue] == YES;
+}
+
+bool QuickTimeVideoPlayer::isDrmProtected() const
+{
+    return m_isDrmProtected;
+}
+
+bool QuickTimeVideoPlayer::isDrmAuthorized() const
+{
+    return m_isDrmAuthorized;
+}
+/*
+void QuickTimeVideoPlayer::movieCodecIsMPEG()
+{
+    NSArray *tracks = [m_QTMovie tracks];
+    for (QTTrack *track in tracks)
+        if ([[track media] hasCharacteristic:QTMediaTypeMPEG])
+            return true;
+    return false;
+}
+*/
+
+static void QtGetTrackProtection(QTTrack *track, bool &isDrmProtected, bool &isDrmAuthorized)
+{
+    isDrmProtected = false;
+    isDrmAuthorized = true;
+
+#ifdef QUICKTIME_C_API_AVAILABLE
+    QTMedia *media = [track media];
+    MediaHandler mediaHandler = GetMediaHandler([media quickTimeMedia]);
+    if (mediaHandler){
+        // Regardless, skip message boxes pointing to iTunes regarding DRM:
+        Boolean boolFalse = false;
+        QTSetComponentProperty(mediaHandler,
+            kQTPropertyClass_DRM, kQTDRMPropertyID_InteractWithUser,
+            sizeof(boolFalse), &boolFalse);
+
+        // Check track:
+        Boolean value;
+        OSStatus err = QTGetComponentProperty(mediaHandler,
+            kQTPropertyClass_DRM, kQTDRMPropertyID_IsProtected,
+            sizeof(value), &value, 0);
+        isDrmProtected = (err == noErr) ? bool(value) : false;
+        err = QTGetComponentProperty(mediaHandler,
+            kQTPropertyClass_DRM, kQTDRMPropertyID_IsAuthorized,
+            sizeof(value), &value, 0);
+        isDrmAuthorized = (err == noErr) ? bool(value) : true;
+    }
+#else
+    Q_UNUSED(track);
+#endif // QUICKTIME_C_API_AVAILABLE
+}
+
+void QuickTimeVideoPlayer::readProtection()
+{
+    m_isDrmProtected = false;
+    m_isDrmAuthorized = true;
+
+    NSArray *tracks = [m_QTMovie tracks];
+	for (uint i=0; i<[tracks count]; ++i){
+		QTTrack *track = [tracks objectAtIndex:i];
+        bool isDrmProtected = false;
+        bool isDrmAuthorized = true;
+        QtGetTrackProtection(track, isDrmProtected, isDrmAuthorized);
+        if (isDrmProtected)
+            m_isDrmProtected = true;
+        if (!isDrmAuthorized)
+            m_isDrmAuthorized = false;
+    }
+}
+
+}}
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/videoeffect.cpp phonon-4.3.0/qt7/videoeffect.cpp
--- phonon-4.3.0/qt7/videoeffect.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videoeffect.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,76 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "videoeffect.h"
-#include "backendheader.h"
-#include "objc_help.h"
-#include <phonon/effect.h>
-#include <phonon/effectparameter.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-VideoEffect::VideoEffect(int effectId, QObject *parent) : MediaNode(VideoSink | VideoSource, 0, parent), effectId(effectId)
-{
-    ciFilter = objc_createCiFilter(effectId);
-    if (ciFilter)
-        filterName = objc_getCiFilterInfo()->filterDisplayNames[effectId];
-}
-
-VideoEffect::~VideoEffect()
-{
-    if (ciFilter)
-        objc_releaseCiFilter(ciFilter);
-}
-
-QList<EffectParameter> VideoEffect::parameters() const
-{
-    IMPLEMENTED;
-    return objc_getCiFilterParameterInfo(ciFilter).parameters;
-}
-
-QVariant VideoEffect::parameterValue(const EffectParameter &parameter) const
-{
-    IMPLEMENTED;
-    return objc_getCiFilterParameter(ciFilter, parameter.id());
-}
-
-void VideoEffect::setParameterValue(const EffectParameter &parameter, const QVariant &newValue)
-{
-    IMPLEMENTED;
-    objc_setCiFilterParameter(ciFilter, parameter.id(), newValue);
-}
-
-void VideoEffect::mediaNodeEvent(const MediaNodeEvent */*event*/)
-{
-}
-
-void VideoEffect::updateVideo(VideoFrame &frame){
-    frame.applyCoreImageFilter(ciFilter);
-    MediaNode::updateVideo(frame);
-}
-
-}}
-
-QT_END_NAMESPACE
-
-#include "moc_videoeffect.cpp"
-
diff -r -U2 -N phonon-4.3.0/qt7/videoeffect.h phonon-4.3.0/qt7/videoeffect.h
--- phonon-4.3.0/qt7/videoeffect.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videoeffect.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,5 +19,6 @@
 #define Phonon_QT7_VIDEOEFFECT_H
 
-#include <QtCore>
+#include <QtCore/QList>
+#include <QtCore/QString>
 #include <phonon/effectinterface.h>
 #include "medianode.h"
diff -r -U2 -N phonon-4.3.0/qt7/videoeffect.mm phonon-4.3.0/qt7/videoeffect.mm
--- phonon-4.3.0/qt7/videoeffect.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/videoeffect.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,76 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "videoeffect.h"
+#include "backendheader.h"
+#include "objc_help.h"
+#include <phonon/effect.h>
+#include <phonon/effectparameter.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+VideoEffect::VideoEffect(int effectId, QObject *parent) : MediaNode(VideoSink | VideoSource, 0, parent), effectId(effectId)
+{
+    ciFilter = objc_createCiFilter(effectId);
+    if (ciFilter)
+        filterName = objc_getCiFilterInfo()->filterDisplayNames[effectId];
+}
+
+VideoEffect::~VideoEffect()
+{
+    if (ciFilter)
+        objc_releaseCiFilter(ciFilter);
+}
+
+QList<EffectParameter> VideoEffect::parameters() const
+{
+    IMPLEMENTED;
+    return objc_getCiFilterParameterInfo(ciFilter).parameters;
+}
+
+QVariant VideoEffect::parameterValue(const EffectParameter &parameter) const
+{
+    IMPLEMENTED;
+    return objc_getCiFilterParameter(ciFilter, parameter.id());
+}
+
+void VideoEffect::setParameterValue(const EffectParameter &parameter, const QVariant &newValue)
+{
+    IMPLEMENTED;
+    objc_setCiFilterParameter(ciFilter, parameter.id(), newValue);
+}
+
+void VideoEffect::mediaNodeEvent(const MediaNodeEvent */*event*/)
+{
+}
+
+void VideoEffect::updateVideo(VideoFrame &frame){
+    frame.applyCoreImageFilter(ciFilter);
+    MediaNode::updateVideo(frame);
+}
+
+}}
+
+QT_END_NAMESPACE
+
+#include "moc_videoeffect.cpp"
+
diff -r -U2 -N phonon-4.3.0/qt7/videoframe.cpp phonon-4.3.0/qt7/videoframe.cpp
--- phonon-4.3.0/qt7/videoframe.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videoframe.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,310 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "videoframe.h"
-#include "quicktimevideoplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-    VideoFrame::VideoFrame()
-    {
-        initMembers();
-    }
-
-    VideoFrame::VideoFrame(QuickTimeVideoPlayer *videoPlayer, const LinkTimeProxy &timeStamp)
-    {
-        initMembers();
-        m_videoPlayer = videoPlayer;
-        m_timeStamp = timeStamp;
-    }
-
-    VideoFrame::VideoFrame(const VideoFrame& frame)
-    {
-        copyMembers(frame);
-        retain();
-    }
-
-    void VideoFrame::operator=(const VideoFrame& frame)
-    {
-        if (this == &frame)
-            return;
-            
-        release();
-        copyMembers(frame);
-        retain();
-    }
-
-    void VideoFrame::initMembers()
-    {
-        m_cvTextureRef = 0;
-        m_videoPlayer = 0;
-        m_brightness = 0;
-        m_contrast = 0;
-        m_hue = 0;
-        m_saturation = 0;
-        m_opacity = 1;
-        m_backgroundFrame = 0;
-
-#if 0 // will be awailable in a later version of phonon.
-        m_ciFrameRef = 0;
-
-        // Move this stuff to a shared resource pool!
-        AGLContext aglContext = sharedOpenGLContext();
-        AGLPixelFormat aglPixelFormat = sharedOpenGLPixelFormat();
-
-        GLint swapInterval = 1;
-        GLint surfaceOpacity = 1;
-        aglSetInteger(aglContext, AGL_SURFACE_OPACITY, &surfaceOpacity);
-        aglSetInteger(aglContext, AGL_SWAP_INTERVAL, &swapInterval);
-
-        coreImageContext = objc_createCiContext(aglContext, aglPixelFormat);
-#endif
-    }
-
-    void VideoFrame::copyMembers(const VideoFrame& frame)
-    {
-        m_cvTextureRef = frame.m_cvTextureRef;
-        m_videoPlayer = frame.m_videoPlayer;
-        m_timeStamp = frame.m_timeStamp;
-        m_brightness = frame.m_brightness;
-        m_contrast = frame.m_contrast;
-        m_hue = frame.m_hue;
-        m_saturation = frame.m_saturation;
-        m_opacity = frame.m_opacity;
-        m_backgroundFrame = frame.m_backgroundFrame;
-
-#if 0 // will be awailable in a later version of phonon.
-        m_ciFrameRef = frame.m_ciFrameRef;
-#endif
-    }
-
-    VideoFrame::~VideoFrame()
-    {
-        release();
-#if 0 // will be awailable in a later version of phonon.
-        objc_releaseCiContext(coreImageContext);
-#endif
-    }
-
-    void VideoFrame::setBackgroundFrame(const VideoFrame &frame)
-    {
-        m_backgroundFrame = new VideoFrame(frame);
-    }
-
-    QRect VideoFrame::frameRect() const
-    {
-        return m_videoPlayer->videoRect();
-    }
-
-    CVOpenGLTextureRef VideoFrame::cvTextureRef() const
-    {
-        if (!m_cvTextureRef && m_videoPlayer){
-            m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
-            (const_cast<VideoFrame *>(this))->m_cvTextureRef = m_videoPlayer->createCvTexture(m_timeStamp);
-        }
-        return m_cvTextureRef;
-    }
-
-    GLuint VideoFrame::glTextureRef() const
-    {
-        return CVOpenGLTextureGetName(cvTextureRef());
-    }
-
-#if 0 // will be awailable in a later version of phonon.
-    void *VideoFrame::coreImageRef() const
-    {
-        if (!m_ciFrameRef)
-            (const_cast<VideoFrame *>(this))->m_ciFrameRef = objc_ciImageFromCvImageBuffer(cvTextureRef());
-        return m_ciFrameRef;
-    }
-
-    void VideoFrame::applyCoreImageFilter(void *filter)
-    {
-        objc_applyCiFilter(coreImageRef(), filter);
-    }
-
-    bool VideoFrame::hasCoreImage()
-    {
-        return m_ciFrameRef != 0;
-    }
-#endif
-
-    void VideoFrame::setColors(qreal brightness, qreal contrast, qreal hue, qreal saturation)
-    {
-        if (m_backgroundFrame)
-            m_backgroundFrame->setColors(brightness, contrast, hue, saturation);
-        if (m_brightness == brightness
-            && m_contrast == contrast
-            && m_hue == hue 
-            && m_saturation == saturation)
-            return;
-        
-        m_brightness = brightness;
-        m_contrast = contrast;
-        m_hue = hue;
-        m_saturation = saturation;
-        invalidateTexture();
-    }
-    
-    void VideoFrame::setBaseOpacity(qreal opacity)
-    {
-        m_opacity = opacity;
-    }
-
-    QImage VideoFrame::toQImage()
-    {
-        if (!m_videoPlayer)
-            return QImage();
-        if (m_videoPlayer->setCurrentGLContext())
-            invalidateTexture();
-        CVOpenGLTextureRef texRef = cvTextureRef();
-        if (!texRef)
-            return QImage();
-
-        GLenum target = CVOpenGLTextureGetTarget(texRef);
-        glEnable(target);
-        glBindTexture(target, CVOpenGLTextureGetName(texRef));
-        QImage image(frameRect().size(), QImage::Format_ARGB32);
-        glGetTexImage(target, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, image.bits());
-        return image;
-    }
-
-    void VideoFrame::drawFrame(const QRect &rect, float opacity, bool origoLowLeft) const
-    {
-        if (!m_videoPlayer)
-            return;            
-        if (m_videoPlayer->setCurrentGLContext())
-            invalidateTexture();
-            
-#if 0 // will be awailable in a later version of phonon.
-        objc_drawCiImage(m_currentFrame.coreImageRef(), m_drawFrameRect, coreImageContext);
-#endif
-        drawGLTexture(rect, origoLowLeft, opacity);
-    }
-
-    void VideoFrame::drawGLTexture(const QRect &rect, float opacity, bool origoLowLeft) const
-    {
-        if (m_backgroundFrame)
-            m_backgroundFrame->drawGLTexture(rect, opacity, origoLowLeft);
-            
-        CVOpenGLTextureRef texRef = cvTextureRef();
-        if (!texRef)
-            return;
-
-        glPushMatrix();
-            glDisable(GL_CULL_FACE);            
-            GLenum target = CVOpenGLTextureGetTarget(texRef);
-            glEnable(target);
-            
-            opacity *= m_opacity;
-            if (opacity < 1){
-                glEnable(GL_BLEND);
-                glColor4f(1, 1, 1, opacity);
-                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-            } else {
-                glColor3f(1, 1, 1);
-                glDisable(GL_BLEND);
-            }
-            
-            glBindTexture(target, CVOpenGLTextureGetName(texRef));
-            glTexParameterf(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-            glTexParameterf(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-            GLfloat lowerLeft[2], lowerRight[2], upperRight[2], upperLeft[2];
-            
-            // Work-around for CVOpenGLTextureGetCleanTexCoords. It 
-            // fails to catch movies with origo != (0, 0) 
-            if (origoLowLeft){
-                CVOpenGLTextureGetCleanTexCoords(texRef, lowerLeft, lowerRight, upperRight, upperLeft);
-                // Work-around for CVOpenGLTextureGetCleanTexCoords. It 
-                // fails to catch movies with origo != (0, 0) :
-                upperLeft[0] += m_videoPlayer->videoRect().x();
-                lowerLeft[0] += m_videoPlayer->videoRect().x();
-                upperLeft[1] += m_videoPlayer->videoRect().y();
-                upperRight[1] += m_videoPlayer->videoRect().y();
-            } else {
-                CVOpenGLTextureGetCleanTexCoords(texRef, upperLeft, upperRight, lowerRight, lowerLeft);
-                // upperLeft[0] += m_videoPlayer->videoRect().x();
-                // lowerLeft[0] += m_videoPlayer->videoRect().x();
-                // upperLeft[1] += m_videoPlayer->videoRect().y();
-                // upperRight[1] += m_videoPlayer->videoRect().y();
-            }
-                
-            // Draw the frame:
-            glBegin(GL_QUADS);
-                glTexCoord2f(lowerLeft[0], lowerLeft[1]);
-                glVertex2i(rect.topLeft().x(), rect.topLeft().y());
-                glTexCoord2f(lowerRight[0], lowerRight[1]);
-                glVertex2i(rect.topRight().x() + 1, rect.topRight().y());
-                glTexCoord2f(upperRight[0], upperRight[1]);
-                glVertex2i(rect.bottomRight().x() + 1, rect.bottomRight().y() + 1);
-                glTexCoord2f(upperLeft[0], upperLeft[1]);
-                glVertex2i(rect.bottomLeft().x(), rect.bottomLeft().y() + 1);
-            glEnd();
-        glPopMatrix();
-    }
-
-    bool VideoFrame::isEmpty()
-    {
-        return (m_videoPlayer == 0);
-    }
-
-    void VideoFrame::invalidateTexture() const
-    {
-        if (m_cvTextureRef){
-            CVOpenGLTextureRelease(m_cvTextureRef);
-            (const_cast<VideoFrame *>(this))->m_cvTextureRef = 0;
-        }
-    }
-
-    void VideoFrame::retain() const
-    {    
-        if (m_cvTextureRef)
-            CVOpenGLTextureRetain(m_cvTextureRef);
-        if (m_backgroundFrame)
-            m_backgroundFrame->retain();
-
-#if 0 // will be awailable in a later version of phonon.
-        if (m_ciFrameRef)
-            objc_retainCiImage(m_ciFrameRef);
-#endif
-    }
-
-    void VideoFrame::release() const
-    {
-        if (m_cvTextureRef)
-            CVOpenGLTextureRelease(m_cvTextureRef);
-        if (m_backgroundFrame)
-            m_backgroundFrame->release();
-
-        (const_cast<VideoFrame *>(this))->m_backgroundFrame = 0;
-        (const_cast<VideoFrame *>(this))->m_cvTextureRef = 0;
-
-#if 0 // will be awailable in a later version of phonon.
-        if (m_ciFrameRef)
-            objc_releaseCiImage(m_ciFrameRef);
-        (const_cast<VideoFrame *>(this))->m_ciFrameRef = 0;
-#endif
-
-    }
-
-}} //namespace Phonon::QT7
-
-QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/videoframe.h phonon-4.3.0/qt7/videoframe.h
--- phonon-4.3.0/qt7/videoframe.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videoframe.h	2009-03-02 04:16:07.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,10 +19,11 @@
 #define Phonon_QT7_VIDEOFRAME_H
 
-#include <QuickTime/QuickTime.h>
+#import <QuartzCore/CVOpenGLTexture.h>
+#import <AppKit/NSImage.h>
 #undef check // avoid name clash;
 
-#include <QtCore>
-#include <QImage>
-#include "displaylinkcallback.h"
+#include <QtCore/QRect>
+#include <QtGui/QPainter>
+#include <QtGui/QImage>
 
 QT_BEGIN_NAMESPACE
@@ -35,4 +36,5 @@
 {
     class QuickTimeVideoPlayer;
+	class QNSBitmapImage;
 
     class VideoFrame
@@ -40,38 +42,42 @@
         public:
             VideoFrame();
-            VideoFrame(QuickTimeVideoPlayer *videoPlayer, const LinkTimeProxy &timeStamp);
+            VideoFrame(QuickTimeVideoPlayer *videoPlayer);
             VideoFrame(const VideoFrame& frame);
             void operator=(const VideoFrame& frame);
             ~VideoFrame();
 
-            CVOpenGLTextureRef cvTextureRef() const;
+
+            CVOpenGLTextureRef cachedCVTexture() const;
+			void *cachedCIImage() const;
             GLuint glTextureRef() const;
-            bool isEmpty();
 
-            QRect frameRect() const;
-            void drawFrame(const QRect &rect, float opacity = 1.0f, bool origoLowLeft = true) const;
+			void drawQImage(QPainter *p, const QRect &rect) const;
+			void drawCIImage(const CGRect &rect, float opacity = 1.0f) const;
+			void drawCIImage(const QRect &rect, float opacity = 1.0f) const;
+            void drawCVTexture(const QRect &rect, float opacity = 1.0f) const;
+            void drawGLTexture(const QRect &rect, float opacity = 1.0f) const;
+
             void applyCoreImageFilter(void *filter);
             void setColors(qreal brightness, qreal contrast, qreal hue, qreal saturation);
+			bool hasColorAdjustments();
             void setBaseOpacity(qreal opacity);
             void setBackgroundFrame(const VideoFrame &frame);
-            QImage toQImage();
+
+            bool isEmpty();
+            QRect frameRect() const;
+            QuickTimeVideoPlayer *videoPlayer();
 
             void retain() const;
             void release() const;
 
-#if 0 // will be awailable in a later version of phonon.
-        private:
-            void *m_ciFrameRef;
-            void *coreImageContext;
-
-            void *coreImageRef() const;
-            void *createCoreImage();
-            bool hasCoreImage();
-#endif
+			static CGRect QRectToCGRect(const QRect & qrect);
 
         private:
-            CVOpenGLTextureRef m_cvTextureRef;
+            CVOpenGLTextureRef m_cachedCVTextureRef;
+            void *m_cachedCIImage;
+			QImage m_cachedQImage;
+            NSBitmapImageRep *m_cachedNSBitmap;
+
             QuickTimeVideoPlayer *m_videoPlayer;
-            LinkTimeProxy m_timeStamp;
             VideoFrame *m_backgroundFrame;
 
@@ -84,6 +90,5 @@
             void initMembers();
             void copyMembers(const VideoFrame& frame);
-            void drawGLTexture(const QRect &rect, float opacity, bool origoLowLeft) const;
-            void invalidateTexture() const;
+            void invalidateImage() const;
     };
 
diff -r -U2 -N phonon-4.3.0/qt7/videoframe.mm phonon-4.3.0/qt7/videoframe.mm
--- phonon-4.3.0/qt7/videoframe.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/videoframe.mm	2009-02-26 05:48:10.000000000 -0700
@@ -0,0 +1,378 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "videoframe.h"
+#include "quicktimevideoplayer.h"
+#import <QuartzCore/CIFilter.h>
+#import <QuartzCore/CIContext.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+    VideoFrame::VideoFrame()
+    {
+        initMembers();
+    }
+
+    VideoFrame::VideoFrame(QuickTimeVideoPlayer *videoPlayer)
+    {
+        initMembers();
+        m_videoPlayer = videoPlayer;
+    }
+
+    VideoFrame::VideoFrame(const VideoFrame& frame)
+    {
+        copyMembers(frame);
+        retain();
+    }
+
+    void VideoFrame::operator=(const VideoFrame& frame)
+    {
+        if (this == &frame)
+            return;
+
+        release();
+        copyMembers(frame);
+        retain();
+    }
+
+    void VideoFrame::initMembers()
+    {
+        m_cachedCVTextureRef = 0;
+		m_cachedCIImage = 0;
+        m_cachedNSBitmap = 0;
+        m_videoPlayer = 0;
+        m_brightness = 0;
+        m_contrast = 0;
+        m_hue = 0;
+        m_saturation = 0;
+        m_opacity = 1;
+        m_backgroundFrame = 0;
+    }
+
+    void VideoFrame::copyMembers(const VideoFrame& frame)
+    {
+        m_cachedCVTextureRef = frame.m_cachedCVTextureRef;
+		m_cachedCIImage = frame.m_cachedCIImage;
+		m_cachedQImage = frame.m_cachedQImage;
+        m_cachedNSBitmap = frame.m_cachedNSBitmap;
+        m_videoPlayer = frame.m_videoPlayer;
+        m_brightness = frame.m_brightness;
+        m_contrast = frame.m_contrast;
+        m_hue = frame.m_hue;
+        m_saturation = frame.m_saturation;
+        m_opacity = frame.m_opacity;
+        m_backgroundFrame = frame.m_backgroundFrame;
+    }
+
+    VideoFrame::~VideoFrame()
+    {
+        release();
+    }
+
+    QuickTimeVideoPlayer *VideoFrame::videoPlayer()
+    {
+        return m_videoPlayer;
+    }
+
+    void VideoFrame::setBackgroundFrame(const VideoFrame &frame)
+    {
+        m_backgroundFrame = new VideoFrame(frame);
+    }
+
+    QRect VideoFrame::frameRect() const
+    {
+        return m_videoPlayer->videoRect();
+    }
+
+    CVOpenGLTextureRef VideoFrame::cachedCVTexture() const
+    {
+        if (!m_cachedCVTextureRef && m_videoPlayer){
+            m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
+            (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = m_videoPlayer->currentFrameAsCVTexture();
+        }
+        return m_cachedCVTextureRef;
+    }
+
+    void *VideoFrame::cachedCIImage() const
+    {
+        if (!m_cachedCIImage && m_videoPlayer){
+            m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
+            (const_cast<VideoFrame *>(this))->m_cachedCIImage = m_videoPlayer->currentFrameAsCIImage();
+        }
+        return m_cachedCIImage;
+    }
+
+    GLuint VideoFrame::glTextureRef() const
+    {
+        return CVOpenGLTextureGetName(cachedCVTexture());
+    }
+
+    void VideoFrame::setColors(qreal brightness, qreal contrast, qreal hue, qreal saturation)
+    {
+        if (m_backgroundFrame)
+            m_backgroundFrame->setColors(brightness, contrast, hue, saturation);
+        if (m_brightness == brightness
+            && m_contrast == contrast
+            && m_hue == hue
+            && m_saturation == saturation)
+            return;
+
+        m_brightness = brightness;
+        m_contrast = contrast;
+        m_hue = hue;
+        m_saturation = saturation;
+
+        invalidateImage();
+    }
+
+	CGRect VideoFrame::QRectToCGRect(const QRect & qrect)
+	{
+        CGRect cgrect;
+        cgrect.origin.x = qrect.x();
+        cgrect.origin.y = qrect.y() + qrect.height();
+        cgrect.size.width = qrect.width();
+        cgrect.size.height = -qrect.height();
+		return cgrect;
+	}
+
+	bool VideoFrame::hasColorAdjustments()
+	{
+		return (m_brightness || m_contrast || m_saturation || m_hue);
+	}
+
+    void VideoFrame::setBaseOpacity(qreal opacity)
+    {
+        m_opacity = opacity;
+    }
+
+    void VideoFrame::drawQImage(QPainter *p, const QRect &rect) const
+	{
+        if (!m_videoPlayer)
+            return;
+#ifdef QUICKTIME_C_API_AVAILABLE
+        if (m_cachedQImage.isNull()){
+            m_videoPlayer->setColors(m_brightness, m_contrast, m_hue, m_saturation);
+            (const_cast<VideoFrame *>(this))->m_cachedQImage = m_videoPlayer->currentFrameAsQImage();
+        }
+#else
+        // Since cocoa-64 doesn't give us OpenGL textures directly, the process of converting
+        // CIImges into QImages takes time. We could still call m_videoPlayer->currentFrameAsQImage(),
+        // but because of bitmap memory management issues, and the fact that we need to swap red and
+        // blue, we can optimize the process a bit here since we are going to draw immidiatly:
+        CIImage *img = (CIImage*)cachedCIImage();
+        if (!img)
+            return;
+
+        if (!m_cachedNSBitmap){
+            (const_cast<VideoFrame *>(this))->m_cachedNSBitmap =
+                [[NSBitmapImageRep alloc] initWithCIImage:img];
+            CGRect bounds = [img extent];
+            int w = bounds.size.width;
+            int h = bounds.size.height;
+            (const_cast<VideoFrame *>(this))->m_cachedQImage =
+                QImage([m_cachedNSBitmap bitmapData], w, h, QImage::Format_ARGB32);
+			// Swap red and blue (same as QImage::rgbSwapped, but without copy)
+            for (int i=0; i<h; ++i) {
+                uint *p = (uint*) m_cachedQImage.scanLine(i);
+                uint *end = p + w;
+                while (p < end) {
+                    *p = ((*p << 16) & 0xff0000) | ((*p >> 16) & 0xff) | (*p & 0xff00ff00);
+                    p++;
+                }
+            }
+        }
+#endif
+        p->drawImage(rect, m_cachedQImage);
+	}
+
+    void VideoFrame::drawCIImage(const QRect &rect, float opacity) const
+	{
+		drawCIImage(QRectToCGRect(rect), opacity);
+	}
+
+    void VideoFrame::drawCIImage(const CGRect &rect, float opacity) const
+	{
+		Q_UNUSED(opacity);
+		CIImage *img = (CIImage *) cachedCIImage();
+		if (!img)
+			return;
+
+	    CIContext* ciContext = [[NSGraphicsContext currentContext] CIContext];
+	    [ciContext drawImage:img inRect:rect fromRect:[img extent]];
+	}
+
+    void VideoFrame::drawCVTexture(const QRect &rect, float opacity) const
+    {
+        if (!m_videoPlayer)
+            return;
+        if (m_backgroundFrame)
+            m_backgroundFrame->drawCVTexture(rect, opacity);
+
+        CVOpenGLTextureRef texRef = cachedCVTexture();
+        if (!texRef)
+            return;
+
+        glPushMatrix();
+            glDisable(GL_CULL_FACE);
+            GLenum target = CVOpenGLTextureGetTarget(texRef);
+            glEnable(target);
+
+            opacity *= m_opacity;
+            if (opacity < 1){
+                glEnable(GL_BLEND);
+                glColor4f(1, 1, 1, opacity);
+                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            } else {
+                glColor3f(1, 1, 1);
+                glDisable(GL_BLEND);
+            }
+
+            glBindTexture(target, CVOpenGLTextureGetName(texRef));
+            glTexParameterf(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameterf(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+            GLfloat lowerLeft[2], lowerRight[2], upperRight[2], upperLeft[2];
+            CVOpenGLTextureGetCleanTexCoords(texRef, lowerLeft, lowerRight, upperRight, upperLeft);
+
+            glBegin(GL_QUADS);
+                glTexCoord2f(lowerLeft[0], lowerLeft[1]);
+                glVertex2i(rect.topLeft().x(), rect.topLeft().y());
+                glTexCoord2f(lowerRight[0], lowerRight[1]);
+                glVertex2i(rect.topRight().x() + 1, rect.topRight().y());
+                glTexCoord2f(upperRight[0], upperRight[1]);
+                glVertex2i(rect.bottomRight().x() + 1, rect.bottomRight().y() + 1);
+                glTexCoord2f(upperLeft[0], upperLeft[1]);
+                glVertex2i(rect.bottomLeft().x(), rect.bottomLeft().y() + 1);
+            glEnd();
+        glPopMatrix();
+    }
+
+    void VideoFrame::drawGLTexture(const QRect &rect, float opacity) const
+    {
+        if (!m_videoPlayer)
+            return;
+        if (m_backgroundFrame)
+            m_backgroundFrame->drawGLTexture(rect, opacity);
+
+        GLuint texture = m_videoPlayer->currentFrameAsGLTexture();
+        if (!texture)
+            return;
+
+        glPushMatrix();
+            glDisable(GL_CULL_FACE);
+            glEnable(GL_TEXTURE_RECTANGLE_EXT);
+
+            opacity *= m_opacity;
+            if (opacity < 1){
+                glEnable(GL_BLEND);
+                glColor4f(1, 1, 1, opacity);
+                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            } else {
+                glColor3f(1, 1, 1);
+                glDisable(GL_BLEND);
+            }
+
+            glBindTexture(GL_TEXTURE_RECTANGLE_EXT, texture);
+            glTexParameterf(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameterf(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+            QRect videoRect = m_videoPlayer->videoRect();
+            GLfloat lowerLeft[2], lowerRight[2], upperRight[2], upperLeft[2];
+            lowerLeft[0] = 0;
+            lowerLeft[1] = videoRect.height();
+            lowerRight[0] = videoRect.width();
+            lowerRight[1] = videoRect.height();
+            upperRight[0] = videoRect.width();
+            upperRight[1] = 0;
+            upperLeft[0] = 0;
+            upperLeft[1] = 0;
+
+            glBegin(GL_QUADS);
+                glTexCoord2f(lowerLeft[0], lowerLeft[1]);
+                glVertex2i(rect.topLeft().x(), rect.topLeft().y());
+                glTexCoord2f(lowerRight[0], lowerRight[1]);
+                glVertex2i(rect.topRight().x() + 1, rect.topRight().y());
+                glTexCoord2f(upperRight[0], upperRight[1]);
+                glVertex2i(rect.bottomRight().x() + 1, rect.bottomRight().y() + 1);
+                glTexCoord2f(upperLeft[0], upperLeft[1]);
+                glVertex2i(rect.bottomLeft().x(), rect.bottomLeft().y() + 1);
+            glEnd();
+        glPopMatrix();
+
+
+        // FOR NOW. FREE THE TEXTURE:
+        glDeleteTextures(1, &texture);
+    }
+
+    bool VideoFrame::isEmpty()
+    {
+        return (m_videoPlayer == 0);
+    }
+
+    void VideoFrame::invalidateImage() const
+    {
+        if (m_cachedCVTextureRef){
+            CVOpenGLTextureRelease(m_cachedCVTextureRef);
+            (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = 0;
+        }
+        if (m_cachedCIImage){
+			[(CIImage *) m_cachedCIImage release];
+            (const_cast<VideoFrame *>(this))->m_cachedCIImage = 0;
+        }
+        if (m_cachedNSBitmap){
+            [m_cachedNSBitmap release];
+            (const_cast<VideoFrame *>(this))->m_cachedNSBitmap = 0;
+        }
+        (const_cast<VideoFrame *>(this))-> m_cachedQImage = QImage();
+    }
+
+    void VideoFrame::retain() const
+    {
+        if (m_cachedCVTextureRef)
+            CVOpenGLTextureRetain(m_cachedCVTextureRef);
+		if (m_cachedCIImage)
+			[(CIImage *) m_cachedCIImage retain];
+        if (m_backgroundFrame)
+            m_backgroundFrame->retain();
+        if (m_cachedNSBitmap)
+            [m_cachedNSBitmap retain];
+    }
+
+    void VideoFrame::release() const
+    {
+        if (m_cachedCVTextureRef)
+            CVOpenGLTextureRelease(m_cachedCVTextureRef);
+		if (m_cachedCIImage)
+			[(CIImage *) m_cachedCIImage release];
+        if (m_backgroundFrame)
+            m_backgroundFrame->release();
+        if (m_cachedNSBitmap)
+            [m_cachedNSBitmap release];
+
+        (const_cast<VideoFrame *>(this))->m_backgroundFrame = 0;
+        (const_cast<VideoFrame *>(this))->m_cachedCVTextureRef = 0;
+        (const_cast<VideoFrame *>(this))->m_cachedCIImage = 0;
+        (const_cast<VideoFrame *>(this))->m_cachedNSBitmap = 0;
+    }
+
+}} //namespace Phonon::QT7
+
+QT_END_NAMESPACE
diff -r -U2 -N phonon-4.3.0/qt7/videowidget.cpp phonon-4.3.0/qt7/videowidget.cpp
--- phonon-4.3.0/qt7/videowidget.cpp	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videowidget.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,414 +0,0 @@
-/*  This file is part of the KDE project.
-
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
-
-    This library is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 or 3 of the License.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this library.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "videowidget.h"
-#include "backendheader.h"
-#include "quicktimevideoplayer.h"
-#include "medianode.h"
-#include "medianodeevent.h"
-#include "mediaobject.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace Phonon
-{
-namespace QT7
-{
-
-QGLWidget *PhononSharedQGLWidget()
-{
-    static QGLWidget *sharedWidget = 0;
-    if (!sharedWidget)
-        sharedWidget = new QGLWidget();
-    return sharedWidget;    
-}
-
-class VideoRenderWidgetOpenGL : public QGLWidget
-{    
-public:
-    VideoFrame m_currentFrame;
-    QRect m_drawFrameRect;
-
-    VideoRenderWidgetOpenGL::VideoRenderWidgetOpenGL(QWidget *parent, const QGLFormat &format)
-        : QGLWidget(format, parent, PhononSharedQGLWidget())
-    {
-        setAutoFillBackground(false);        
-    }
-    
-    void VideoRenderWidgetOpenGL::initializeGL()
-    {
-        glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
-    }
-    
-    void VideoRenderWidgetOpenGL::resizeGL(int w, int h)
-    {
-        glMatrixMode(GL_MODELVIEW);
-        glLoadIdentity();
-        glMatrixMode(GL_PROJECTION);
-        glLoadIdentity();
-        glViewport(0, 0, GLsizei(w), GLsizei(h));
-        gluOrtho2D(0, GLsizei(w), 0, GLsizei(h));    
-        updateGL();
-    }
-
-    void VideoRenderWidgetOpenGL::paintGL()
-    {
-        glClear(GL_COLOR_BUFFER_BIT);
-        m_currentFrame.drawFrame(m_drawFrameRect);
-    }
-
-    void VideoRenderWidgetOpenGL::setVideoFrame(VideoFrame &frame)
-    {
-        m_currentFrame = frame;
-        if (isVisible()){
-            makeCurrent();
-            paintGL();
-            swapBuffers();
-        }
-    }
-    
-    void VideoRenderWidgetOpenGL::setDrawFrameRect(const QRect &rect)
-    {
-        m_drawFrameRect = rect;
-    }
-};
-
-/////////////////////////////////////////////////////////////////////////////////////////
-
-class VideoRenderWidget : public QWidget
-{    
-public:
-    enum RenderSystem {RS_GLWidget, RS_PaintEvent} m_renderSystem;
-    
-    VideoFrame m_currentFrame;
-    QRect m_movieFrameRect;
-    QRect m_drawFrameRect;
-    Phonon::VideoWidget::ScaleMode m_scaleMode;
-    Phonon::VideoWidget::AspectRatio m_aspect;
-    VideoRenderWidgetOpenGL *m_glWidget;
-    
-    qreal m_brightness;
-    qreal m_contrast;
-    qreal m_hue;
-    qreal m_saturation;
-    qreal m_opacity;
-
-    VideoRenderWidget::VideoRenderWidget() : QWidget(0),
-        m_scaleMode(Phonon::VideoWidget::FitInView), m_aspect(Phonon::VideoWidget::AspectRatioAuto)
-    {
-        m_brightness = 0;
-        m_contrast = 0;
-        m_hue = 0;
-        m_saturation = 0;
-        m_opacity = 1;
-
-        QGLFormat format = QGLFormat::defaultFormat();
-        format.setSwapInterval(1); // Vertical sync (avoid tearing)
-        m_glWidget = new VideoRenderWidgetOpenGL(this, format);
-        m_glWidget->setVisible(true);
-        m_renderSystem = RS_GLWidget;
-        setAutoFillBackground(false);        
-        updateDrawFrameRect();
-    }
-    
-    bool inGraphicsView() const
-    {
-        return parentWidget() && parentWidget()->testAttribute(Qt::WA_DontShowOnScreen);
-    }
-    
-    void setRenderSystem(RenderSystem renderSystem){
-        if (m_renderSystem == renderSystem)
-            return;
-            
-        m_renderSystem = renderSystem;
-        
-        switch (m_renderSystem){
-            case RS_GLWidget:
-                m_glWidget->setVisible(true);
-            	m_glWidget->setVideoFrame(m_currentFrame);
-                break;
-            case RS_PaintEvent:
-                m_glWidget->setVisible(false);
-                break;
-        }
-    }
-    
-    QSize VideoRenderWidget::sizeHint() const
-    {
-        return m_movieFrameRect.size();
-    }
-
-    void VideoRenderWidget::resizeEvent(QResizeEvent */*event*/)
-    {
-        updateDrawFrameRect();
-        m_glWidget->resize(size());
-    }     
-
-    bool VideoRenderWidget::event(QEvent *event)
-    {
-        switch (event->type()){
-            // Try to detect if one of this objects
-            // anchestors might have changed:
-            case QEvent::Resize:
-            case QEvent::Move:
-            case QEvent::ParentChange:
-                if (inGraphicsView())
-                    setRenderSystem(RS_PaintEvent);
-                else
-                    setRenderSystem(RS_GLWidget);
-                break;
-            case QEvent::Paint:
-                if (m_renderSystem == RS_PaintEvent){
-                    QPainter p(this);
-                    if (p.paintEngine()->type() == QPaintEngine::OpenGL){
-                        float opacity = parentWidget() ? parentWidget()->windowOpacity() : 1;
-                        m_currentFrame.drawFrame(m_drawFrameRect, opacity, false);
-                    } else
-                        p.drawImage(m_drawFrameRect, m_currentFrame.toQImage());
-                }
-                break;
-            default:
-                break;
-        }
-
-        return QWidget::event(event);
-    }
-
-    void VideoRenderWidget::setVideoFrame(VideoFrame &frame)
-    {
-        m_currentFrame = frame;
-        m_currentFrame.setColors(m_brightness, m_contrast, m_hue, m_saturation);
-
-        if (m_renderSystem == RS_GLWidget)          
-            m_glWidget->setVideoFrame(m_currentFrame);
-        else
-            update();
-    }
-    
-    void VideoRenderWidget::updateVideoFrame()
-    {
-        setVideoFrame(m_currentFrame);
-    }
-    
-    void VideoRenderWidget::setMovieRect(const QRect &mrect)
-    {
-        if (mrect == m_movieFrameRect)
-            return;
-        m_movieFrameRect = mrect;
-        updateDrawFrameRect();
-        updateGeometry();
-        qApp->processEvents();        
-    }
-    
-    void VideoRenderWidget::setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode)
-    {
-        m_scaleMode = scaleMode;
-        updateDrawFrameRect();
-        updateVideoFrame();
-        repaint();
-    }
-
-    void VideoRenderWidget::setAspectRatio(Phonon::VideoWidget::AspectRatio aspect)
-    {
-        m_aspect = aspect;
-        updateDrawFrameRect();
-        updateVideoFrame();
-        repaint();
-    }
-
-    void VideoRenderWidget::updateDrawFrameRect()
-    {
-        if (!m_movieFrameRect.isValid())
-            m_movieFrameRect = QRect(0, 0, 640, 480);
-    
-        // Set m_drawFrameRect to be the size of the smallest possible
-        // rect conforming to the aspect and containing the whole frame:
-        switch(m_aspect){
-        case Phonon::VideoWidget::AspectRatioWidget:
-            m_drawFrameRect = rect();
-            break;
-        case Phonon::VideoWidget::AspectRatio4_3:
-            m_drawFrameRect = scaleToAspect(m_movieFrameRect, 4, 3);
-            break;
-        case Phonon::VideoWidget::AspectRatio16_9:
-            m_drawFrameRect = scaleToAspect(m_movieFrameRect, 16, 9);
-            break;
-        case Phonon::VideoWidget::AspectRatioAuto:
-        default:
-            m_drawFrameRect = m_movieFrameRect;
-            break;
-        }
-    
-        // Scale m_drawFrameRect to fill the widget
-        // without breaking aspect:
-        int widgetWidth = rect().width();
-        int widgetHeight = rect().height();
-        int frameWidth = widgetWidth;
-        int frameHeight = m_drawFrameRect.height() * float(widgetWidth) / float(m_drawFrameRect.width());
-    
-        switch(m_scaleMode){
-        case Phonon::VideoWidget::ScaleAndCrop:
-            if (frameHeight < widgetHeight){
-                frameWidth *= float(widgetHeight) / float(frameHeight);
-                frameHeight = widgetHeight;
-            }
-            break;
-        case Phonon::VideoWidget::FitInView:
-        default:
-            if (frameHeight > widgetHeight){
-                frameWidth *= float(widgetHeight) / float(frameHeight);
-                frameHeight = widgetHeight;
-            }
-            break;
-        }
-    
-        m_drawFrameRect.setSize(QSize(frameWidth, frameHeight));
-        m_drawFrameRect.moveTo((widgetWidth - frameWidth) / 2.0f, (widgetHeight - frameHeight) / 2.0f);
-        m_glWidget->setDrawFrameRect(m_drawFrameRect);
-    }
-    
-    QRect VideoRenderWidget::scaleToAspect(QRect srcRect, int w, int h)
-    {
-        int width = srcRect.width();
-        int height = srcRect.width() * (float(h) / float(w));
-        if (height > srcRect.height()){
-            height = srcRect.height();
-            width = srcRect.height() * (float(w) / float(h));
-        }
-        return QRect(0, 0, width, height);
-    }    
-};
-
-/////////////////////////////////////////////////////////////////////////////////////////
-
-VideoWidget::VideoWidget(QObject *parent) : MediaNode(VideoSink, parent)
-{
-    m_videoRenderWidget = new VideoRenderWidget();    
-}
-
-VideoWidget::~VideoWidget()
-{
-    delete m_videoRenderWidget;
-}
-
-QWidget *VideoWidget::widget()
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget;
-}
-
-Phonon::VideoWidget::AspectRatio VideoWidget::aspectRatio() const
-{
-    IMPLEMENTED;
-    return  m_videoRenderWidget->m_aspect;
-}
-
-void VideoWidget::setAspectRatio(Phonon::VideoWidget::AspectRatio aspect)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->setAspectRatio(aspect);
-}
-
-Phonon::VideoWidget::ScaleMode VideoWidget::scaleMode() const
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget->m_scaleMode;
-}
-
-void VideoWidget::setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->setScaleMode(scaleMode);
-}
-
-qreal VideoWidget::brightness() const
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget->m_brightness;
-}
-
-void VideoWidget::setBrightness(qreal value)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->m_brightness = value;
-    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
-        m_videoRenderWidget->updateVideoFrame();
-}
-
-qreal VideoWidget::contrast() const
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget->m_contrast;
-}
-
-void VideoWidget::setContrast(qreal value)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->m_contrast = value;
-    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
-        m_videoRenderWidget->updateVideoFrame();
-}
-
-qreal VideoWidget::hue() const
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget->m_hue;
-}
-
-void VideoWidget::setHue(qreal value)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->m_hue = value;
-    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
-        m_videoRenderWidget->updateVideoFrame();
-}
-
-qreal VideoWidget::saturation() const
-{
-    IMPLEMENTED;
-    return m_videoRenderWidget->m_saturation;
-}
-
-void VideoWidget::setSaturation(qreal value)
-{
-    IMPLEMENTED;
-    m_videoRenderWidget->m_saturation = value;
-    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
-        m_videoRenderWidget->updateVideoFrame();
-}
-
-void VideoWidget::mediaNodeEvent(const MediaNodeEvent *event)
-{
-    switch (event->type()){
-    case MediaNodeEvent::VideoFrameSizeChanged:
-        m_videoRenderWidget->setMovieRect(*static_cast<QRect *>(event->data()));
-        break;
-    default:
-        break;
-    }
-}
-
-void VideoWidget::updateVideo(VideoFrame &frame){
-    m_videoRenderWidget->setVideoFrame(frame);
-    MediaNode::updateVideo(frame);
-}
-
-}} // namespace Phonon::QT7
-
-QT_END_NAMESPACE
-
-#include "moc_videowidget.cpp"
diff -r -U2 -N phonon-4.3.0/qt7/videowidget.h phonon-4.3.0/qt7/videowidget.h
--- phonon-4.3.0/qt7/videowidget.h	2008-11-24 10:12:03.000000000 -0700
+++ phonon-4.3.0/qt7/videowidget.h	2009-04-22 08:48:59.000000000 -0700
@@ -1,5 +1,5 @@
 /*  This file is part of the KDE project.
 
-    Copyright (C) 2007 Trolltech ASA. All rights reserved.
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
 
     This library is free software: you can redistribute it and/or modify
@@ -19,13 +19,5 @@
 #define Phonon_QT7_VIDEOWIDGET_H
 
-#include <QtGui>
-#include <QGLWidget>
-#include <QGLContext>
-#include <QtOpenGL/private/qgl_p.h>
-#include <QPointer>
-
-#include <QuickTime/QuickTime.h>
-#undef check // avoid name clash;
-
+#include <QtGui/QPaintEngine>
 #include <phonon/videowidgetinterface.h>
 #include "medianode.h"
@@ -61,5 +53,5 @@
         qreal saturation() const;
         void setSaturation(qreal);
-        
+
         QWidget *widget();
 
diff -r -U2 -N phonon-4.3.0/qt7/videowidget.mm phonon-4.3.0/qt7/videowidget.mm
--- phonon-4.3.0/qt7/videowidget.mm	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/qt7/videowidget.mm	2009-04-22 08:48:59.000000000 -0700
@@ -0,0 +1,883 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <QtCore/qglobal.h>
+#ifdef QT_MAC_USE_COCOA
+#import <QTKit/QTMovieLayer.h>
+#endif
+
+#include "videowidget.h"
+#include "backendheader.h"
+#include "quicktimevideoplayer.h"
+#include "medianode.h"
+#include "medianodeevent.h"
+#include "mediaobject.h"
+
+#include <QtOpenGL/QGLWidget>
+#include <QtCore/QTime>
+#include <QtCore/QEvent>
+#include <QtCore/QCoreApplication>
+
+#import <AppKit/NSImage.h>
+#import <QTKit/QTMovieView.h>
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+#ifdef QT_MAC_USE_COCOA // Rendering to a QTMovieView can only be done in Cocoa
+
+#define VIDEO_TRANSPARENT(m) -(void)m:(NSEvent *)e{[[self superview] m:e];}
+
+@interface SharedQTMovieView : QTMovieView
+{
+@private
+    Phonon::QT7::QuickTimeVideoPlayer *m_player;
+    QList<QWidget *> *m_parents;
+    QWidget *m_window;
+    QRect *m_drawRect;
+    bool m_newImageReady;
+    bool m_usingWindow;
+}
+
+- (SharedQTMovieView *) init;
+- (void) registerParent:(QWidget *)parent;
+- (void) unregisterParent:(QWidget *)parent;
+- (void) setDrawRect:(QRect &)rect;
+- (void) drawVideoFrame:(Phonon::QT7::VideoFrame &)frame forWidget:(QWidget *)widget shareImages:(bool)share;
+- (void) useOffscreenWindow:(bool)offscreen;
+- (void) applyDrawRectOnSelf;
+@end
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+@implementation SharedQTMovieView
+
+- (SharedQTMovieView *) init
+{
+    self = [super initWithFrame:NSZeroRect];
+	if (self){
+        [self setControllerVisible:NO];
+        m_parents = new QList<QWidget *>();
+        m_drawRect = new QRect(0, 0, 1, 1);
+        [self applyDrawRectOnSelf];
+        m_usingWindow = false;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    Phonon::QT7::PhononAutoReleasePool pool;
+    delete m_window;
+    delete m_drawRect;
+    delete m_parents;
+    [super dealloc];
+}
+
+- (void) applyDrawRectOnSelf
+{
+    NSRect nsrect;
+    nsrect.origin.x = m_drawRect->x();
+    nsrect.origin.y = m_drawRect->y();
+    nsrect.size.width = m_drawRect->width();
+    nsrect.size.height = m_drawRect->height();
+    [self setFrame:nsrect];
+}
+
+- (void) setDrawRect:(QRect &)rect
+{
+    *m_drawRect = rect;
+    if (!m_usingWindow)
+        [self applyDrawRectOnSelf];
+}
+
+- (void) waitForFrame
+{
+    if (m_usingWindow){
+        QTMovie *movie = [self movie];
+        if (movie){
+            // CIImages are expected, but not received.
+            // Try to wait a couple of seconds for them:
+            m_newImageReady = false;
+            float rate = [movie rate];
+            if (!rate)
+                [movie setRate:1];
+            QTime t; t.start();
+            while (!m_newImageReady && t.elapsed() < 2000)
+                ;
+            [movie setRate:rate];
+        }
+    }
+}
+
+- (void) useOffscreenWindow:(bool)offscreen
+{
+    if (offscreen == m_usingWindow)
+        return;
+    if (offscreen){
+        if (!m_window){
+            m_window = new QWidget;
+            m_window->setWindowOpacity(0.0);
+            m_window->show();
+            m_window->hide();
+        }
+        m_usingWindow = true;
+        [self setDelegate:self];
+        [self waitForFrame];
+        foreach(QWidget *w, *m_parents)
+            w->repaint();
+        qApp->processEvents();
+        [self removeFromSuperview];
+        [(NSView *)m_window->winId() addSubview:self];
+    } else if (!m_parents->isEmpty()){
+        m_usingWindow = false;
+        [self removeFromSuperview];
+        [(NSView*)m_parents->first()->winId() addSubview:self];
+        [self setDelegate:0];
+        [self setDrawRect:*m_drawRect];
+    }
+}
+
+- (void) drawVideoFrame:(Phonon::QT7::VideoFrame &)frame forWidget:(QWidget *)widget shareImages:(bool)share;
+{
+    // Detect if the video that produces the frame has changed:
+    Phonon::QT7::QuickTimeVideoPlayer *player = frame.videoPlayer();
+    if (player && player->qtMovie() != [self movie]){
+        m_player = player;
+        [self setMovie:player->qtMovie()];
+        [self waitForFrame];
+    }
+
+    [self useOffscreenWindow:(share || m_parents->size() > 1)];
+    if (m_usingWindow)
+        widget->update();
+}
+
+// Override this method so that the movie doesn't stop if
+// the window becomes invisible
+- (void)viewWillMoveToWindow:(NSWindow *)newWindow
+{
+    Q_UNUSED(newWindow);
+}
+
+- (CIImage *) view:(QTMovieView *)view willDisplayImage:(CIImage *)img
+{
+	// This method is called from QTMovieView just
+	// before the image will be drawn.
+    Q_UNUSED(view);
+    m_player->setPrimaryRenderingCIImage(img);
+    m_newImageReady = true;
+	return img;
+}
+
+- (void) registerParent:(QWidget *)parent
+{
+    if (m_parents->contains(parent))
+        return;
+    m_parents->append(parent);
+    if (m_parents->size() == 1){
+        Phonon::QT7::PhononAutoReleasePool pool;
+        m_usingWindow = true;
+        [self applyDrawRectOnSelf];
+        [self useOffscreenWindow:NO];
+    }
+}
+
+- (void) unregisterParent:(QWidget *)parent
+{
+    m_parents->removeAll(parent);
+    if (m_parents->size() == 1)
+        [self applyDrawRectOnSelf];
+}
+
+VIDEO_TRANSPARENT(mouseDown);
+VIDEO_TRANSPARENT(mouseDragged);
+VIDEO_TRANSPARENT(mouseUp);
+VIDEO_TRANSPARENT(mouseMoved);
+VIDEO_TRANSPARENT(mouseEntered);
+VIDEO_TRANSPARENT(mouseExited);
+VIDEO_TRANSPARENT(rightMouseDown);
+VIDEO_TRANSPARENT(rightMouseDragged);
+VIDEO_TRANSPARENT(rightMouseUp);
+VIDEO_TRANSPARENT(otherMouseDown);
+VIDEO_TRANSPARENT(otherMouseDragged);
+VIDEO_TRANSPARENT(otherMouseUp);
+VIDEO_TRANSPARENT(keyDown);
+VIDEO_TRANSPARENT(keyUp);
+VIDEO_TRANSPARENT(scrollWheel)
+
+@end
+
+#endif // QT_MAC_USE_COCOA
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace QT7
+{
+
+class IVideoRenderDrawWidget
+{
+public:
+	virtual ~IVideoRenderDrawWidget(){}
+	virtual void setVideoFrame(VideoFrame &) = 0;
+	virtual void setDrawFrameRect(const QRect &) = 0;
+	virtual void updateVideoOutputCount(int){}
+	virtual void setMovieIsPaused(bool){}
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+QGLWidget *PhononSharedQGLWidget(){
+	static QGLWidget *glWidget = 0;
+	if (!glWidget)
+		glWidget = new QGLWidget();
+	return glWidget;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class RenderOpenGL : public QGLWidget, public IVideoRenderDrawWidget
+{
+public:
+    VideoFrame m_currentFrame;
+    QRect m_drawFrameRect;
+
+    RenderOpenGL(QWidget *parent, const QGLFormat &format, const QSize &size) : QGLWidget(format, parent, PhononSharedQGLWidget())
+    {
+        resize(size);
+        setAutoFillBackground(false);
+        show();
+    }
+
+    void initializeGL()
+    {
+        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+    }
+
+    void resizeGL(int w, int h)
+    {
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+        glMatrixMode(GL_PROJECTION);
+        glLoadIdentity();
+        glViewport(0, 0, GLsizei(w), GLsizei(h));
+        gluOrtho2D(0, GLsizei(w), 0, GLsizei(h));
+        updateGL();
+    }
+
+    void paintGL()
+    {
+        glClear(GL_COLOR_BUFFER_BIT);
+        m_currentFrame.drawCVTexture(m_drawFrameRect);
+    }
+
+    void setVideoFrame(VideoFrame &frame)
+    {
+        m_currentFrame = frame;
+        makeCurrent();
+        paintGL();
+        swapBuffers();
+    }
+
+    void setDrawFrameRect(const QRect &rect)
+    {
+        m_drawFrameRect = rect;
+    }
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class RenderQTMovieView : public QWidget, public IVideoRenderDrawWidget
+{
+public:
+#if defined(QT_MAC_USE_COCOA)
+	QRect m_drawRect;
+	VideoFrame m_videoFrame;
+    SharedQTMovieView *m_currentView;
+    bool m_setDrawRectPending;
+    bool m_share;
+
+    RenderQTMovieView(bool share, QWidget *parent, const QSize &size=QSize()) : QWidget(parent), m_currentView(0)
+    {
+        m_setDrawRectPending = true;
+        m_share = share;
+        setAutoFillBackground(false);
+        if (share){
+            // In 'share' mode, this widget will only make sure
+            // that CIIImages are produced, and not actually
+            // draw anything:
+            hide();
+        } else {
+            resize(size);
+            show();
+        }
+    }
+
+    ~RenderQTMovieView()
+    {
+        [m_currentView unregisterParent:this];
+    }
+
+    void showEvent(QShowEvent *)
+    {
+        if (m_share)
+            return;
+        [m_currentView registerParent:this];
+    }
+
+    void hideEvent(QHideEvent *)
+    {
+        if (m_share)
+            return;
+        [m_currentView unregisterParent:this];
+    }
+
+    void paintEvent(QPaintEvent *)
+    {
+        if (m_share)
+            return;
+		QPainter p(this);
+		p.fillRect(rect(), Qt::black);
+        m_videoFrame.drawCIImage(m_drawRect);
+    }
+
+	void updateVideoOutputCount(int count)
+	{
+		Q_UNUSED(count);
+	}
+
+	void setMovieIsPaused(bool paused)
+	{
+        Q_UNUSED(paused);
+	}
+
+    void setVideoFrame(VideoFrame &frame)
+    {
+        m_videoFrame = frame;
+
+        if (!m_videoFrame.isEmpty()){
+            Phonon::QT7::QuickTimeVideoPlayer *player = m_videoFrame.videoPlayer();
+            if (!player->m_primaryRenderingTarget){
+                // First movie view. Create the shared resource:
+                SharedQTMovieView *view = [[[SharedQTMovieView alloc] init] autorelease];
+                player->setPrimaryRenderingTarget(view);
+            }
+
+            SharedQTMovieView *view = static_cast<SharedQTMovieView *>(player->m_primaryRenderingTarget);
+            if (!m_share && view != m_currentView){
+                [m_currentView unregisterParent:this];
+                m_currentView = view;
+                [m_currentView registerParent:this];
+            }
+
+            [view drawVideoFrame:m_videoFrame forWidget:this shareImages:m_share || m_videoFrame.hasColorAdjustments()];
+
+            if (m_setDrawRectPending){
+                m_setDrawRectPending = false;
+                [view setDrawRect:m_drawRect];
+            }
+        }
+    }
+
+    void setDrawFrameRect(const QRect &rect)
+    {
+        m_drawRect = rect;
+        Phonon::QT7::QuickTimeVideoPlayer *player = m_videoFrame.videoPlayer();
+        if (player && player->m_primaryRenderingTarget){
+            SharedQTMovieView *view = static_cast<SharedQTMovieView *>(player->m_primaryRenderingTarget);
+            [view setDrawRect:m_drawRect];
+        } else
+            m_setDrawRectPending = true;
+    }
+
+#else // QT_MAC_USE_COCOA == false
+	RenderQTMovieView(bool, QWidget *, const QSize& = QSize()){}
+	void setVideoFrame(VideoFrame &){}
+	void setDrawFrameRect(const QRect &){}
+#endif
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class RenderQTMovieLayer : public QWidget, public IVideoRenderDrawWidget
+{
+public:
+#ifdef QT_MAC_USE_COCOA
+    QTMovieLayer *m_movieLayer;
+
+    RenderQTMovieLayer(QWidget *parent, const QSize&) : QWidget(parent)
+    {
+		PhononAutoReleasePool pool;
+        setAutoFillBackground(false);
+        m_movieLayer = 0;
+        [(NSView *)winId() setWantsLayer:YES];
+    }
+
+    void setVideoFrame(VideoFrame &frame)
+    {
+        QuickTimeVideoPlayer *player = frame.videoPlayer();
+        if (!player || player->qtMovie() == [m_movieLayer movie])
+            return;
+
+        if (m_movieLayer)
+            [m_movieLayer setMovie:player->qtMovie()];
+        else {
+            m_movieLayer = [QTMovieLayer layerWithMovie:player->qtMovie()];
+            [(NSView *)winId() setLayer:m_movieLayer];
+        }
+    }
+
+    void setDrawFrameRect(const QRect &rect)
+    {
+        m_movieLayer.frame.origin.x = rect.x();
+        m_movieLayer.frame.origin.y = rect.y();
+        m_movieLayer.frame.size.width = rect.width();
+        m_movieLayer.frame.size.height = rect.height();
+    }
+
+#else // QT_MAC_USE_COCOA == false
+	RenderQTMovieLayer(QWidget *, const QSize&){}
+	void setVideoFrame(VideoFrame &){}
+	void setDrawFrameRect(const QRect &){}
+#endif
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+class VideoRenderWidget : public QWidget
+{
+public:
+    enum RenderSystem {	RS_NoRendering	= 0,
+						RS_QGLWidget	= 1,
+						RS_QPainter		= 2,
+						RS_CIImage		= 3,
+						RS_CVTexture	= 4,
+						RS_QImage		= 5,
+						RS_QTMovieView	= 6,
+						RS_QTMovieLayer = 7
+	} m_renderSystem;
+
+    VideoFrame m_currentFrame;
+    QRect m_movieFrameRect;
+    QRect m_drawFrameRect;
+    Phonon::VideoWidget::ScaleMode m_scaleMode;
+    Phonon::VideoWidget::AspectRatio m_aspect;
+	IVideoRenderDrawWidget *m_renderDrawWidget;
+
+    qreal m_brightness;
+    qreal m_contrast;
+    qreal m_hue;
+    qreal m_saturation;
+    qreal m_opacity;
+
+    VideoRenderWidget() : QWidget(0),
+        m_scaleMode(Phonon::VideoWidget::FitInView), m_aspect(Phonon::VideoWidget::AspectRatioAuto)
+    {
+		PhononAutoReleasePool pool;
+        m_brightness = 0;
+        m_contrast = 0;
+        m_hue = 0;
+        m_saturation = 0;
+        m_opacity = 1;
+		m_renderDrawWidget = 0;
+		m_renderSystem = RS_NoRendering;
+
+        setAutoFillBackground(false);
+        updateDrawFrameRect();
+    }
+
+    RenderSystem selectBestRenderSystem(){
+        if (!isVisible())
+            return RS_NoRendering;
+        else if (window() && window()->testAttribute(Qt::WA_DontShowOnScreen))
+            return RS_QPainter;
+        else {
+#ifdef QUICKTIME_C_API_AVAILABLE
+            return RS_QGLWidget;
+#else
+            return RS_QTMovieView;
+#endif
+        }
+    }
+
+    void setRenderSystem(RenderSystem renderSystem){
+		PhononAutoReleasePool pool;
+		static QString userSystem = qgetenv("PHONON_RENDER_SYSTEM");
+	    if (!userSystem.isEmpty())
+			renderSystem = RenderSystem(userSystem.toInt());
+
+        if (m_renderSystem == renderSystem)
+            return;
+
+        m_renderSystem = renderSystem;
+        if (m_renderDrawWidget){
+            delete m_renderDrawWidget;
+			m_renderDrawWidget = 0;
+		}
+
+        switch (m_renderSystem){
+            case RS_QGLWidget:{
+			    QGLFormat format = QGLFormat::defaultFormat();
+			    format.setSwapInterval(1); // Vertical sync (avoid tearing)
+			    m_renderDrawWidget = new RenderOpenGL(this, format, size());
+                break;}
+            case RS_QTMovieView:{
+			    m_renderDrawWidget = new RenderQTMovieView(false, this, size());
+                break;}
+            case RS_QTMovieLayer:{
+			    m_renderDrawWidget = new RenderQTMovieLayer(this, size());
+				break;}
+            case RS_QPainter:
+			case RS_CIImage:
+			case RS_CVTexture:
+			case RS_QImage:
+#ifndef QUICKTIME_C_API_AVAILABLE
+                // On cocoa-64, let QTMovieView produce
+                // video frames for us:
+				m_renderDrawWidget = new RenderQTMovieView(true, this);
+#endif
+				break;
+            case RS_NoRendering:
+                break;
+        }
+
+		if (m_renderDrawWidget){
+            m_renderDrawWidget->setVideoFrame(m_currentFrame);
+            m_renderDrawWidget->setDrawFrameRect(m_drawFrameRect);
+        }
+    }
+
+    QSize sizeHint() const
+    {
+        return m_movieFrameRect.size();
+    }
+
+    bool event(QEvent *event)
+    {
+        switch (event->type()){
+            // Try to detect if one of this objects
+            // anchestors might have changed:
+            case QEvent::Resize:{
+                PhononAutoReleasePool pool;
+                updateDrawFrameRect();
+                if (m_renderDrawWidget)
+                    dynamic_cast<QWidget *>(m_renderDrawWidget)->resize(size());
+                break; }
+            case QEvent::Paint:{
+                PhononAutoReleasePool pool;
+                float opacity = parentWidget() ? parentWidget()->windowOpacity() : 1;
+                switch (m_renderSystem){
+                    case RS_QPainter:{
+                        QPainter p(this);
+                        p.fillRect(rect(), Qt::black);
+                        if (p.paintEngine()->type() == QPaintEngine::OpenGL)
+                            m_currentFrame.drawCVTexture(m_drawFrameRect, opacity);
+                        else
+							m_currentFrame.drawQImage(&p, m_drawFrameRect);
+                        break; }
+					case RS_CIImage:
+                        m_currentFrame.drawCIImage(m_drawFrameRect, opacity);
+						break;
+                    case RS_CVTexture:
+	                   m_currentFrame.drawCVTexture(m_drawFrameRect, opacity);
+					   break;
+					case RS_QImage:{
+                        QPainter p(this);
+                        p.fillRect(rect(), Qt::black);
+						m_currentFrame.drawQImage(&p, m_drawFrameRect);
+                        break; }
+                    case RS_QGLWidget:
+                    case RS_QTMovieView:
+                    case RS_QTMovieLayer:
+                        // draw in separate widget
+                        break;
+                    case RS_NoRendering:
+                        QPainter p(this);
+                        p.fillRect(rect(), Qt::black);
+                        break;
+                }
+                break; }
+            default:
+                break;
+        }
+
+        return QWidget::event(event);
+    }
+
+    void setVideoFrame(VideoFrame &frame)
+    {
+		PhononAutoReleasePool pool;
+        m_currentFrame = frame;
+        m_currentFrame.setColors(m_brightness, m_contrast, m_hue, m_saturation);
+
+		if (m_renderDrawWidget)
+			m_renderDrawWidget->setVideoFrame(m_currentFrame);
+
+        setRenderSystem(selectBestRenderSystem());
+        switch (m_renderSystem){
+            case RS_QGLWidget:
+            case RS_QTMovieView:
+            case RS_QTMovieLayer:
+            case RS_NoRendering:
+                break;
+			case RS_CIImage:
+			case RS_CVTexture:
+			case RS_QImage:
+            case RS_QPainter:
+                repaint();
+                break;
+        }
+    }
+
+    void updateVideoFrame()
+    {
+        setVideoFrame(m_currentFrame);
+    }
+
+    void setMovieRect(const QRect &mrect)
+    {
+        if (mrect == m_movieFrameRect)
+            return;
+        m_movieFrameRect = mrect;
+        updateDrawFrameRect();
+        updateGeometry();
+        if (isVisible())
+            qApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers);
+    }
+
+    void setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode)
+    {
+        m_scaleMode = scaleMode;
+        updateDrawFrameRect();
+        updateVideoFrame();
+        repaint();
+    }
+
+    void setAspectRatio(Phonon::VideoWidget::AspectRatio aspect)
+    {
+        m_aspect = aspect;
+        updateDrawFrameRect();
+        updateVideoFrame();
+        repaint();
+    }
+
+	void updateVideoOutputCount(int count)
+	{
+		if (m_renderDrawWidget)
+			m_renderDrawWidget->updateVideoOutputCount(count);
+	}
+
+	void setMovieIsPaused(bool paused)
+	{
+		if (m_renderDrawWidget)
+			m_renderDrawWidget->setMovieIsPaused(paused);
+	}
+
+    void updateDrawFrameRect()
+    {
+        if (m_movieFrameRect.width() <= 0 || m_movieFrameRect.height() <= 0)
+            m_movieFrameRect = QRect(0, 0, 640, 480);
+
+        // Set m_drawFrameRect to be the size of the smallest possible
+        // rect conforming to the aspect and containing the whole frame:
+        switch(m_aspect){
+        case Phonon::VideoWidget::AspectRatioWidget:
+            m_drawFrameRect = rect();
+            break;
+        case Phonon::VideoWidget::AspectRatio4_3:
+            m_drawFrameRect = scaleToAspect(m_movieFrameRect, 4, 3);
+            break;
+        case Phonon::VideoWidget::AspectRatio16_9:
+            m_drawFrameRect = scaleToAspect(m_movieFrameRect, 16, 9);
+            break;
+        case Phonon::VideoWidget::AspectRatioAuto:
+        default:
+            m_drawFrameRect = m_movieFrameRect;
+            break;
+        }
+
+        // Scale m_drawFrameRect to fill the widget
+        // without breaking aspect:
+        int widgetWidth = rect().width();
+        int widgetHeight = rect().height();
+        int frameWidth = widgetWidth;
+        int frameHeight = m_drawFrameRect.height() * float(widgetWidth) / float(m_drawFrameRect.width());
+
+        switch(m_scaleMode){
+        case Phonon::VideoWidget::ScaleAndCrop:
+            if (frameHeight < widgetHeight){
+                frameWidth *= float(widgetHeight) / float(frameHeight);
+                frameHeight = widgetHeight;
+            }
+            break;
+        case Phonon::VideoWidget::FitInView:
+        default:
+            if (frameHeight > widgetHeight){
+                frameWidth *= float(widgetHeight) / float(frameHeight);
+                frameHeight = widgetHeight;
+            }
+            break;
+        }
+
+        m_drawFrameRect.setSize(QSize(frameWidth, frameHeight));
+        m_drawFrameRect.moveTo((widgetWidth - frameWidth) / 2.0f, (widgetHeight - frameHeight) / 2.0f);
+
+		if (m_renderDrawWidget)
+			m_renderDrawWidget->setDrawFrameRect(m_drawFrameRect);
+    }
+
+    QRect scaleToAspect(QRect srcRect, int w, int h)
+    {
+        int width = srcRect.width();
+        int height = srcRect.width() * (float(h) / float(w));
+        if (height > srcRect.height()){
+            height = srcRect.height();
+            width = srcRect.height() * (float(w) / float(h));
+        }
+        return QRect(0, 0, width, height);
+    }
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+
+VideoWidget::VideoWidget(QObject *parent) : MediaNode(VideoSink, parent)
+{
+    m_videoRenderWidget = new VideoRenderWidget();
+}
+
+VideoWidget::~VideoWidget()
+{
+    delete m_videoRenderWidget;
+}
+
+QWidget *VideoWidget::widget()
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget;
+}
+
+Phonon::VideoWidget::AspectRatio VideoWidget::aspectRatio() const
+{
+    IMPLEMENTED;
+    return  m_videoRenderWidget->m_aspect;
+}
+
+void VideoWidget::setAspectRatio(Phonon::VideoWidget::AspectRatio aspect)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->setAspectRatio(aspect);
+}
+
+Phonon::VideoWidget::ScaleMode VideoWidget::scaleMode() const
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget->m_scaleMode;
+}
+
+void VideoWidget::setScaleMode(Phonon::VideoWidget::ScaleMode scaleMode)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->setScaleMode(scaleMode);
+}
+
+qreal VideoWidget::brightness() const
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget->m_brightness;
+}
+
+void VideoWidget::setBrightness(qreal value)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->m_brightness = value;
+    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
+        m_videoRenderWidget->updateVideoFrame();
+}
+
+qreal VideoWidget::contrast() const
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget->m_contrast;
+}
+
+void VideoWidget::setContrast(qreal value)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->m_contrast = value;
+    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
+        m_videoRenderWidget->updateVideoFrame();
+}
+
+qreal VideoWidget::hue() const
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget->m_hue;
+}
+
+void VideoWidget::setHue(qreal value)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->m_hue = value;
+    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
+        m_videoRenderWidget->updateVideoFrame();
+}
+
+qreal VideoWidget::saturation() const
+{
+    IMPLEMENTED;
+    return m_videoRenderWidget->m_saturation;
+}
+
+void VideoWidget::setSaturation(qreal value)
+{
+    IMPLEMENTED;
+    m_videoRenderWidget->m_saturation = value;
+    if (m_owningMediaObject && m_owningMediaObject->state() == Phonon::PausedState)
+        m_videoRenderWidget->updateVideoFrame();
+}
+
+void VideoWidget::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    switch (event->type()){
+    case MediaNodeEvent::VideoFrameSizeChanged:
+        m_videoRenderWidget->setMovieRect(*static_cast<QRect *>(event->data()));
+        break;
+	case MediaNodeEvent::VideoOutputCountChanged:
+	     m_videoRenderWidget->updateVideoOutputCount(*static_cast<int *>(event->data()));
+	     break;
+	case MediaNodeEvent::MediaPlaying:
+	     m_videoRenderWidget->setMovieIsPaused(!(*static_cast<bool *>(event->data())));
+	     break;
+	default:
+        break;
+    }
+}
+
+void VideoWidget::updateVideo(VideoFrame &frame){
+	PhononAutoReleasePool pool;
+    m_videoRenderWidget->setVideoFrame(frame);
+    MediaNode::updateVideo(frame);
+}
+
+}} // namespace Phonon::QT7
+
+QT_END_NAMESPACE
+
+#include "moc_videowidget.cpp"
diff -r -U2 -N phonon-4.3.0/waveout/audiooutput.cpp phonon-4.3.0/waveout/audiooutput.cpp
--- phonon-4.3.0/waveout/audiooutput.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/audiooutput.cpp	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,78 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "audiooutput.h"
+#include "mediaobject.h"
+
+#include <QtCore/QVector>
+
+#include <cmath>
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    namespace WaveOut
+    {
+        AudioOutput::AudioOutput(Backend *, QObject *parent)
+        {
+            setParent(parent);
+            m_volume = 0xffff;
+        }
+
+        AudioOutput::~AudioOutput()
+        {
+        }
+
+        int AudioOutput::outputDevice() const
+        {
+            return 0;
+        }
+
+        void AudioOutput::setVolume(qreal newVolume)
+        {
+            m_volume = newVolume;
+            emit volumeChanged(newVolume);
+        }
+
+        void AudioOutput::setCrossFadingProgress(short currentIndex, qreal progress)
+        {
+            Q_UNUSED(currentIndex);
+            Q_UNUSED(progress);
+        }
+
+        bool AudioOutput::setOutputDevice(const AudioOutputDevice & newDevice)
+        {
+            return setOutputDevice(newDevice.index());
+        }
+
+        qreal AudioOutput::volume() const
+        {
+            return m_volume;
+        }
+
+        bool AudioOutput::setOutputDevice(int newDevice)
+        {
+         
+            return (newDevice == 0);
+        }
+
+    }
+}
+
+QT_END_NAMESPACE
+
diff -r -U2 -N phonon-4.3.0/waveout/audiooutput.h phonon-4.3.0/waveout/audiooutput.h
--- phonon-4.3.0/waveout/audiooutput.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/audiooutput.h	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,65 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef PHONON_AUDIOOUTPUT_H
+#define PHONON_AUDIOOUTPUT_H
+
+#include <QtCore/QFile>
+#include <phonon/audiooutputinterface.h>
+
+#include "backend.h"
+
+struct IBaseFilter;
+struct IBasicAudio;
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    namespace WaveOut
+    {
+        class AudioOutput : public QObject, public Phonon::AudioOutputInterface
+        {
+            Q_OBJECT
+           
+                Q_INTERFACES(Phonon::AudioOutputInterface)
+        public:
+            AudioOutput(Backend *back, QObject *parent);
+            ~AudioOutput();
+
+            // Attributes Getters:
+            qreal volume() const;
+            int outputDevice() const;
+            void setVolume(qreal newVolume);
+            bool setOutputDevice(int newDevice);
+            bool setOutputDevice(const AudioOutputDevice & newDevice);
+            void setCrossFadingProgress(short currentIndex, qreal progress);
+
+         Q_SIGNALS:
+            void audioDeviceFailed();
+            void volumeChanged(qreal);
+        private:
+            unsigned int m_volume;
+
+
+        };
+    }
+}
+
+QT_END_NAMESPACE
+
+#endif // PHONON_AUDIOOUTPUT_H
diff -r -U2 -N phonon-4.3.0/waveout/backend.cpp phonon-4.3.0/waveout/backend.cpp
--- phonon-4.3.0/waveout/backend.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/backend.cpp	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,131 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "backend.h"
+
+
+#include "audiooutput.h"
+#include "mediaobject.h"
+
+
+
+#include <QtCore/QSettings>
+#include <QtCore/QSet>
+#include <QtCore/QVariant>
+#include <QtCore/QStringList>
+
+#include <QtCore/QtPlugin>
+
+
+QT_BEGIN_NAMESPACE
+
+// export as Qt/KDE factory as required
+
+Q_EXPORT_PLUGIN2(phonon_waveout, Phonon::WaveOut::Backend);
+
+namespace Phonon
+{
+    namespace WaveOut
+    {
+
+        Backend::Backend(QObject *parent, const QVariantList &)
+            : QObject(parent)
+        {
+        }
+
+        Backend::~Backend()
+        {
+        }
+
+        QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
+        {
+            Q_UNUSED(args);
+            switch (c)
+            {
+            case MediaObjectClass:
+                return new MediaObject(parent);
+            case AudioOutputClass:
+                return new AudioOutput(this, parent);
+            default:
+                return 0;
+            }
+        }
+
+        bool Backend::supportsVideo() const
+        {
+            return false;
+        }
+
+        QStringList Backend::availableMimeTypes() const
+        {
+            QStringList ret;
+            return ret;
+        }
+
+
+        QList<int> Backend::objectDescriptionIndexes(Phonon::ObjectDescriptionType type) const
+        {
+            QList<int> r;
+            if (type == Phonon::AudioOutputDeviceType)
+              r.append(0);
+            return r;
+        }
+
+        QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(Phonon::ObjectDescriptionType type, int index) const
+        {
+            Q_UNUSED(index);
+            QHash<QByteArray, QVariant> r;
+            if (type == Phonon::AudioOutputDeviceType) 
+                r["name"] = QLatin1String("default audio device");
+            return r;
+        }
+
+
+         bool Backend::connectNodes(QObject *node1, QObject *node2)
+         {
+             MediaObject *mediaObject = qobject_cast<MediaObject*> (node1);
+             AudioOutput *audioOutput = qobject_cast<AudioOutput*> (node2);
+
+             if (mediaObject && audioOutput)
+                 mediaObject->setAudioOutput(audioOutput);
+             return true;
+         }
+
+         bool Backend::disconnectNodes(QObject *node1, QObject *node2)
+         {
+             Q_UNUSED(node1);
+             Q_UNUSED(node2);
+             return true;
+         }
+
+         //transaction management
+         bool Backend::startConnectionChange(QSet<QObject *>)
+         {
+             return true;
+         }
+
+         bool Backend::endConnectionChange(QSet<QObject *>)
+         {
+             return true;
+         }
+
+    }
+}
+
+QT_END_NAMESPACE
+
+#include "moc_backend.cpp"
diff -r -U2 -N phonon-4.3.0/waveout/backend.h phonon-4.3.0/waveout/backend.h
--- phonon-4.3.0/waveout/backend.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/backend.h	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,69 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef PHONON_BACKEND_H
+#define PHONON_BACKEND_H
+
+#include <phonon/backendinterface.h>
+#include <phonon/phononnamespace.h>
+
+#include <QtCore/QList>
+
+
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    namespace WaveOut
+    {
+        class AudioOutput;
+        class MediaObject;
+
+        class Backend : public QObject, public Phonon::BackendInterface
+        {
+            Q_OBJECT
+            Q_INTERFACES(Phonon::BackendInterface)
+        public:
+            Backend(QObject *parent = 0, const QVariantList & = QVariantList());
+            virtual ~Backend();
+
+            QObject *createObject(Phonon::BackendInterface::Class, QObject *parent, const QList<QVariant> &args);
+
+            bool supportsVideo() const;
+            QStringList availableMimeTypes() const;
+
+            QList<int> objectDescriptionIndexes(Phonon::ObjectDescriptionType type) const;
+            QHash<QByteArray, QVariant> objectDescriptionProperties(Phonon::ObjectDescriptionType type, int index) const;
+
+            bool connectNodes(QObject *, QObject *);
+            bool disconnectNodes(QObject *, QObject *);
+
+            //transaction management
+            bool startConnectionChange(QSet<QObject *>);
+            bool endConnectionChange(QSet<QObject *>);
+
+        Q_SIGNALS:
+            void objectDescriptionChanged(ObjectDescriptionType);
+
+        };
+    }
+}
+
+QT_END_NAMESPACE
+
+#endif // PHONON_BACKEND_H
diff -r -U2 -N phonon-4.3.0/waveout/mediaobject.cpp phonon-4.3.0/waveout/mediaobject.cpp
--- phonon-4.3.0/waveout/mediaobject.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/mediaobject.cpp	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,684 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "mediaobject.h"
+#include "audiooutput.h"
+
+#include <QtCore/QVector>
+#include <QtCore/QTimerEvent>
+#include <QtCore/QTimer>
+#include <QtCore/QTime>
+#include <QtCore/QLibrary>
+#include <QtCore/QUrl>
+#include <QtCore/QWriteLocker>
+
+#include <phonon/streaminterface.h>
+
+
+#define WAVEHEADER_OFFSET_FORMATTAG        20
+#define WAVEHEADER_OFFSET_CHANNELS         22
+#define WAVEHEADER_OFFSET_SAMPLESPERSEC    24
+#define WAVEHEADER_OFFSET_AVGBYTESPERSEC   28
+#define WAVEHEADER_OFFSET_BLOCKALIGN       32
+#define WAVEHEADER_OFFSET_BITSPERSAMPLE    34
+#define WAVEHEADER_OFFSET_DATA             44
+#define WAVEHEADER_SIZE                    WAVEHEADER_OFFSET_DATA
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    namespace WaveOut
+    {        
+        static unsigned int buffer_size = (16 * 1024 * 4);
+
+        QString getErrorText(MMRESULT error)
+        {
+            ushort b[256];
+            waveOutGetErrorText(error, (LPWSTR)b, 256);
+            return QString::fromUtf16(b);
+        }
+
+        class WorkerThread : public QThread
+        {
+         Q_OBJECT
+         public slots:
+              void stream(QIODevice *file, QByteArray *buffer, bool *finished);
+        };
+
+        void WorkerThread::stream(QIODevice *ioStream, QByteArray *buffer, bool *finished)
+        {
+            (*finished) = false;
+            memset((void*) buffer->data(), 0, buffer->size());
+            qint64 i = ioStream->read(buffer->data(), buffer_size);
+            buffer->resize(i);
+            (*finished) = true;
+        }
+
+
+        void CALLBACK MediaObject::WaveOutCallBack(HWAVEOUT m_hWaveOut, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
+        {
+            Q_UNUSED(m_hWaveOut);
+            Q_UNUSED(dwInstance);
+            Q_UNUSED(dwParam2);
+
+            switch(uMsg)
+            {
+            case WOM_OPEN:
+                break;
+            case WOM_DONE:
+                {
+                    WAVEHDR *waveHeader = (WAVEHDR*)dwParam1;
+                    MediaObject* mediaObject = reinterpret_cast<MediaObject *>(waveHeader->dwUser);
+                    if (mediaObject) {
+                        mediaObject->swapBuffers();
+                    }
+                }
+                break;
+            case WOM_CLOSE:
+                break;
+            }
+        }
+
+        class StreamReader : public Phonon::StreamInterface
+        {
+        public:
+              StreamReader(QObject *parent, const Phonon::MediaSource &source) :
+                  m_seekable(false), m_pos(0), m_size(-1)
+              {
+                  Q_UNUSED(parent);
+                  connectToSource(source);
+              }
+
+              //for Phonon::StreamInterface
+              void writeData(const QByteArray &data)
+              {
+                  QWriteLocker locker(&m_lock);
+                  m_pos += data.size();
+                  m_buffer += data;
+              }
+
+              void endOfData()
+              {
+              }
+
+              void setStreamSize(qint64 newSize)
+              {
+                  QWriteLocker locker(&m_lock);
+                  m_size = newSize;
+              }
+
+              qint64 streamSize() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_size;
+              }
+
+              void setStreamSeekable(bool s)
+              {
+                  QWriteLocker locker(&m_lock);
+                  m_seekable = s;
+              }
+
+              bool streamSeekable() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_seekable;
+              }
+
+              void setCurrentPos(qint64 pos)
+              {
+                  QWriteLocker locker(&m_lock);
+                  m_pos = pos;
+                  seekStream(pos);
+                  m_buffer.clear();
+              }
+
+              qint64 currentPos() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_pos;
+              }
+
+              int currentBufferSize() const
+              {
+                  QReadLocker locker(&m_lock);
+                  return m_buffer.size();
+              }
+
+            //for Phonon::StreamInterface
+            QByteArray m_buffer;
+            bool m_seekable;
+            qint64 m_pos;
+            qint64 m_size;
+            mutable QReadWriteLock m_lock;
+        };
+
+        class IOWrapper : public QIODevice {
+        public:
+            IOWrapper(QObject *parent, const Phonon::MediaSource &source) : m_streamReader(this, source)
+            {
+                Q_UNUSED(parent);
+                setOpenMode(QIODevice::ReadOnly);
+            }
+            bool seek(qint64 pos);
+            qint64 size() const;
+            qint64 pos();
+            bool isReadable() const;
+         protected:
+            qint64 readData (char * data, qint64 maxSize);
+            qint64 writeData(const char *,qint64);
+        private:
+            StreamReader m_streamReader;
+        };
+
+        bool IOWrapper::isReadable () const
+        {
+            return true;
+        }
+
+        qint64 IOWrapper::pos()
+        {
+            return (m_streamReader.streamSeekable() ? m_streamReader.currentPos() : 0);
+        }
+
+        bool IOWrapper::seek( qint64 pos)
+        {
+            if (!m_streamReader.streamSeekable())
+                return false;
+            m_streamReader.setCurrentPos(pos);
+            return true;
+        }
+
+        qint64 IOWrapper::size() const
+        {
+            return m_streamReader.streamSize();
+        }
+
+        qint64 IOWrapper::readData(char * data, qint64 maxSize)
+        {
+            int oldSize = m_streamReader.currentBufferSize();
+            while (m_streamReader.currentBufferSize() < maxSize) {
+                m_streamReader.needData();
+                if (oldSize == m_streamReader.currentBufferSize()) {
+                    break; //we didn't get any data
+                }
+                oldSize = m_streamReader.currentBufferSize();
+            }
+
+            qint64 bytesRead = qMin(qint64(m_streamReader.currentBufferSize()), maxSize);
+            {
+                QWriteLocker locker(&m_streamReader.m_lock);
+                qMemCopy(data, m_streamReader.m_buffer.data(), bytesRead);
+                //truncate the buffer
+                m_streamReader.m_buffer = m_streamReader.m_buffer.mid(bytesRead);
+            }
+            return bytesRead;
+        }
+
+        qint64 IOWrapper::writeData(const char *,qint64)
+        {
+            return 0;
+        }
+
+        MediaObject::MediaObject(QObject *parent) : m_file(0), m_stream(0),
+                                                    m_hWaveOut(0), m_nextBufferIndex(1), 
+                                                    m_mediaSize(-1), m_bufferingFinished(0),
+                                                    m_paused(0), m_tickInterval(0),
+                                                    m_hasNextSource(0), m_hasSource(0),
+                                                    m_sourceIsValid(0), m_errorType(Phonon::NoError),
+                                                    m_currentTime(0), m_transitionTime(0),
+                                                    m_tick(0), m_volume(100), m_prefinishMark(0),
+                                                    m_tickIntervalResolution(0), m_bufferPrepared(0),
+                                                    m_stopped(0)
+        {
+            m_thread = new WorkerThread();
+            connect(this, SIGNAL(outOfData(QIODevice*, QByteArray*, bool*)), m_thread, SLOT(stream(QIODevice*, QByteArray*, bool*)));
+            m_thread->start();
+            m_soundBuffer1.waveHeader = new WAVEHDR;
+            m_soundBuffer2.waveHeader = new WAVEHDR;
+            setParent(parent);
+            setState(Phonon::LoadingState);            
+        }
+
+        MediaObject::~MediaObject()
+        {
+            stop();
+            disconnect(this, SIGNAL(outOfData(QIODevice*, QByteArray*, bool*)), m_thread, SLOT(stream(QIODevice*, QByteArray*, bool*)));
+            do { //The event loop of m_thread might not be started, yet
+                m_thread->quit(); //If the event loop is not started yet quit() does nothing
+                m_thread->wait(100);
+            } while (m_thread->isRunning());
+            delete m_thread;
+            deleteValidWaveOutDevice();
+            delete m_soundBuffer1.waveHeader;
+            delete m_soundBuffer2.waveHeader;
+        }
+
+        Phonon::State MediaObject::state() const
+        {
+           return m_state;
+        }
+
+        bool MediaObject::hasVideo() const
+        {
+            return false;
+        }
+
+        bool MediaObject::isSeekable() const
+        {
+            return !m_stream->isSequential();
+        }
+
+        qint64 MediaObject::totalTime() const
+        {
+            return m_totalTime;
+        }
+
+        qint64 MediaObject::currentTime() const
+        {
+            //this handles inaccuracy when stopping on a title
+            return m_currentTime;
+        }
+
+        qint32 MediaObject::tickInterval() const
+        {
+            return m_tickInterval * m_tickIntervalResolution;
+        }
+
+        void MediaObject::setTickInterval(qint32 newTickInterval)
+        {
+            if ((m_tickIntervalResolution == 0) || (newTickInterval == 0))
+                return;
+            m_tickInterval = newTickInterval / m_tickIntervalResolution;
+            if ((newTickInterval > 0) && (m_tickInterval == 0))
+                m_tickInterval = 1;
+        }
+
+        void MediaObject::pause()
+        {
+            if (!m_paused) {
+                m_paused = true;
+                setState(Phonon::PausedState);
+                if (!(waveOutPause(m_hWaveOut) == MMSYSERR_NOERROR))
+                {
+                    setError(Phonon::NormalError, QLatin1String("cannot pause (system error)"));
+                }
+            }
+        }
+
+        void MediaObject::stop()
+        {
+            setState(Phonon::StoppedState);
+            m_stopped = true;
+            m_paused = false;
+            seek(0);
+            if (!(waveOutReset(m_hWaveOut) == MMSYSERR_NOERROR))
+                setError(Phonon::NormalError, QLatin1String("cannot stop (system error)"));
+        }
+
+        void MediaObject::play()
+        {
+            if ((m_state == Phonon::PlayingState) && !m_paused && !m_stopped)
+                return;
+            if  ((m_state == Phonon::LoadingState) ||
+                 (m_state == Phonon::BufferingState) ||
+                 (m_state == Phonon::ErrorState)) {
+                    setError(Phonon::FatalError, QLatin1String("illegale state for playback"));
+                    return;
+            }
+
+            if (m_state == Phonon::StoppedState)
+                stop();
+            if (m_sourceIsValid) {
+                setState(Phonon::PlayingState);
+                if (!m_paused) {
+                    m_nextBufferIndex = true;
+                    m_stopped = false;
+                    playBuffer(m_soundBuffer1.waveHeader);
+                    playBuffer(m_soundBuffer2.waveHeader);
+                } else {
+                    if (!(waveOutRestart(m_hWaveOut) == MMSYSERR_NOERROR))
+                        setError(Phonon::NormalError, QLatin1String("cannot resume (system)"));
+                }
+            } else {
+                setError(Phonon::FatalError, QLatin1String("cannot playback invalid source"));
+            }
+            m_paused = false;
+        }
+
+        QString MediaObject::errorString() const
+        {
+            
+            return m_errorString;
+        }
+
+        Phonon::ErrorType MediaObject::errorType() const
+        {
+            return Phonon::ErrorType();
+        }
+
+        qint32 MediaObject::prefinishMark() const
+        {
+            return m_prefinishMark;
+        }
+
+        void MediaObject::setPrefinishMark(qint32 newPrefinishMark)
+        {
+            m_prefinishMark = newPrefinishMark;
+        }
+
+        qint32 MediaObject::transitionTime() const
+        {
+            return m_transitionTime;
+        }
+
+        void MediaObject::setTransitionTime(qint32 time)
+        {
+           m_transitionTime = time;
+        }
+
+        qint64 MediaObject::remainingTime() const
+        {
+            return m_totalTime - m_currentTime;
+        }
+
+        Phonon::MediaSource MediaObject::source() const
+        {
+            return Phonon::MediaSource();
+        }
+
+        void MediaObject::setNextSource(const Phonon::MediaSource &source)
+        {
+            m_nextSource = source;
+            m_hasNextSource = true;
+        }
+
+        void MediaObject::setSource(const Phonon::MediaSource &source)
+        {
+            if (m_state == Phonon::PlayingState)
+            {
+                setError(Phonon::NormalError, QLatin1String("source changed while playing"));
+                stop();
+            }
+
+            m_source = source;
+            m_hasSource = true;
+            m_sourceIsValid = false;
+
+            emit currentSourceChanged(source);
+
+            if (source.type() == Phonon::MediaSource::LocalFile) {
+                if (!openWaveFile(source.fileName())) {
+                  setError(Phonon::FatalError, QLatin1String("cannot open media file"));
+                  return ;
+                }
+            } else if (source.type() == Phonon::MediaSource::Stream) {
+                if (m_stream)
+                   delete m_stream;
+                m_stream = new IOWrapper(this, source);
+                m_mediaSize = m_stream->size();
+            } else if (source.type() == Phonon::MediaSource::Url) {
+                if (!openWaveFile(source.url().toLocalFile())) {
+                    setError(Phonon::FatalError, QLatin1String("cannot open media file"));
+                    return ;
+                }
+            } else {
+                setError(Phonon::FatalError, QLatin1String("type of source not supported"));
+                return ;
+            }
+            setState(Phonon::LoadingState);
+
+            if (!readHeader())
+                setError(Phonon::FatalError, QLatin1String("invalid header"));
+            else if (!getWaveOutDevice())
+                setError(Phonon::FatalError, QLatin1String("No waveOut device available"));
+            else if (!fillBuffers())
+                setError(Phonon::FatalError, QLatin1String("no data for buffering"));
+            else if (!prepareBuffers())
+                setError(Phonon::FatalError, QLatin1String("cannot prepare buffers"));
+            else
+                m_sourceIsValid = true;
+
+            if (m_sourceIsValid)
+                setState(Phonon::StoppedState);
+        }
+
+        void MediaObject::seek(qint64 time)
+        {
+            if (!m_sourceIsValid) {
+                setError(Phonon::NormalError, QLatin1String("source is not valid"));
+                return;
+            }
+            if ((time >= 0) && (time < m_totalTime)) {
+                int counter = 0;
+                while (!m_bufferingFinished && (counter < 200)) {
+                  Sleep(20);
+                  counter ++;
+                }
+                if (counter >= 200) {
+                   setError(Phonon::NormalError, QLatin1String("buffering timed out"));
+                   return;
+                }
+
+                m_stream->seek(WAVEHEADER_SIZE + time * m_waveFormatEx.nSamplesPerSec * m_waveFormatEx.wBitsPerSample * m_waveFormatEx.nChannels / 8 / 1000);
+                m_currentTime = time;
+                if (m_state == Phonon::PlayingState)
+                  play();
+            } else {
+                setError(Phonon::NormalError, QLatin1String("seeking out of range"));
+            }
+        }
+
+        void MediaObject::unPrepareBuffers()
+        {
+            if (m_bufferPrepared) {
+            DWORD err1 = waveOutUnprepareHeader(m_hWaveOut, m_soundBuffer1.waveHeader, sizeof(WAVEHDR));
+            DWORD err2 = waveOutUnprepareHeader(m_hWaveOut, m_soundBuffer2.waveHeader, sizeof(WAVEHDR));
+            if (!(err1 == MMSYSERR_NOERROR) || !(err2 == MMSYSERR_NOERROR))
+                setError(Phonon::NormalError, QLatin1String("cannot unprepare buffer") + getErrorText(err1) + getErrorText(err2));
+            }
+            m_bufferPrepared = false;
+        }
+
+        bool MediaObject::prepareBuffers()
+        {
+            memset((void*)m_soundBuffer1.waveHeader, 0, sizeof(WAVEHDR));
+            m_soundBuffer1.waveHeader->lpData = m_soundBuffer1.data.data();
+            m_soundBuffer1.waveHeader->dwBufferLength = m_soundBuffer1.data.size();
+            m_soundBuffer1.waveHeader->dwUser = (DWORD_PTR) this;
+
+            ZeroMemory((void*)m_soundBuffer2.waveHeader, sizeof(WAVEHDR));
+            m_soundBuffer2.waveHeader->lpData = m_soundBuffer2.data.data();
+            m_soundBuffer2.waveHeader->dwBufferLength = m_soundBuffer1.data.size();
+            m_soundBuffer2.waveHeader->dwUser = (DWORD_PTR) this;
+
+            m_bufferPrepared = (waveOutPrepareHeader(m_hWaveOut, m_soundBuffer1.waveHeader, sizeof(WAVEHDR)) == MMSYSERR_NOERROR)
+                && (waveOutPrepareHeader(m_hWaveOut, m_soundBuffer2.waveHeader, sizeof(WAVEHDR)) == MMSYSERR_NOERROR);
+             return m_bufferPrepared;
+        }
+
+        void MediaObject::deleteValidWaveOutDevice()
+        {
+            if (m_hWaveOut) {
+                unPrepareBuffers();
+                if (!(waveOutClose(m_hWaveOut)  == MMSYSERR_NOERROR))
+                    setError(Phonon::NormalError, QLatin1String("cannot close wave device"));
+            }
+        }
+
+        bool MediaObject::getWaveOutDevice()
+        {
+            deleteValidWaveOutDevice();
+
+            for(UINT deviceId = 0; deviceId < waveOutGetNumDevs(); deviceId++)
+            {
+                if(deviceId == waveOutGetNumDevs())
+                    return false;
+                if(waveOutOpen(&m_hWaveOut, WAVE_MAPPER, &m_waveFormatEx, (DWORD)WaveOutCallBack, 0, CALLBACK_FUNCTION) == MMSYSERR_NOERROR)
+                    return m_hWaveOut; //m_hWaveOut !=0;
+            }
+            return false;
+        }
+
+        bool  MediaObject::openWaveFile(QString fileName)
+        {
+            if (m_file)
+                delete m_file;
+            m_file = new QFile(fileName);
+            m_file->setParent(this);
+            m_stream = m_file;
+            m_mediaSize = m_file->size();
+            return (m_file->open(QIODevice::ReadOnly));
+        }
+
+        bool MediaObject::readHeader()
+        {
+            QByteArray header = m_stream->read(WAVEHEADER_SIZE);
+
+            if (header.size() == WAVEHEADER_SIZE) {
+
+                m_waveFormatEx.wFormatTag         = *((WORD* )(header.data() + WAVEHEADER_OFFSET_FORMATTAG     ));
+                m_waveFormatEx.nChannels          = *((WORD* )(header.data() + WAVEHEADER_OFFSET_CHANNELS      ));
+                m_waveFormatEx.nSamplesPerSec     = *((DWORD*)(header.data() + WAVEHEADER_OFFSET_SAMPLESPERSEC ));
+                m_waveFormatEx.nAvgBytesPerSec    = *((DWORD*)(header.data() + WAVEHEADER_OFFSET_AVGBYTESPERSEC));
+                m_waveFormatEx.nBlockAlign        = *((WORD* )(header.data() + WAVEHEADER_OFFSET_BLOCKALIGN    ));
+                m_waveFormatEx.wBitsPerSample     = *((WORD* )(header.data() + WAVEHEADER_OFFSET_BITSPERSAMPLE ));
+
+                m_tickIntervalResolution = (qint64(buffer_size) * 8 * 1000) / m_waveFormatEx.nSamplesPerSec / m_waveFormatEx.wBitsPerSample / m_waveFormatEx.nChannels;
+                if (m_mediaSize > 0)
+                   m_totalTime = ((m_mediaSize - WAVEHEADER_SIZE) * 8 * 1000) / m_waveFormatEx.nSamplesPerSec / m_waveFormatEx.wBitsPerSample / m_waveFormatEx.nChannels;
+                else
+                  m_totalTime = -1;
+                  emit totalTimeChanged(m_totalTime);
+                return true;
+            } else {
+                return false;
+            }
+        }
+        
+        bool MediaObject::fillBuffers()
+        {
+            
+            m_soundBuffer1.data = m_stream->read(buffer_size);
+            m_soundBuffer2.data = m_stream->read(buffer_size);
+
+            m_bufferingFinished = true;
+
+            if (!(m_soundBuffer1.data.size() > 0))
+                setError(Phonon::NormalError, QLatin1String("cannot read source"));
+            return true;
+        }
+
+        void MediaObject::setState(Phonon::State newState)
+        {
+            if (m_state == newState)
+                return;
+            emit stateChanged(newState, m_state);
+            m_state = newState;
+        }
+
+        void MediaObject::setError(ErrorType errorType, QString errorMessage)
+        {
+            m_errorType = errorType;
+            setState(Phonon::ErrorState);
+            m_errorString = errorMessage;
+        }
+
+        void MediaObject::setAudioOutput(QObject *audioOutput)
+        {
+            m_audioOutput = qobject_cast<AudioOutput*>(audioOutput);
+
+            if (m_audioOutput) {
+                m_volume = m_audioOutput->volume();
+                connect(m_audioOutput, SIGNAL(volumeChanged(qreal)), this, SLOT(setVolume(qreal)));
+            }
+        }
+
+        void MediaObject::setVolume(qreal newVolume)
+        {
+            m_volume = newVolume;
+        }
+
+        void MediaObject::swapBuffers()
+        {
+            if (m_stopped || m_paused)
+                return;
+
+            m_currentTime += m_tickIntervalResolution;
+            if (m_tickInterval) {
+                m_tick ++;
+                if (m_tick > (m_tickInterval - 1)) {
+                    emit tick(m_currentTime);
+                    m_tick = 0;
+                }
+            }
+            if ((m_prefinishMark > 0)&& (m_prefinishMark < m_currentTime))
+                emit prefinishMarkReached(m_totalTime - m_currentTime);
+
+            while (!m_bufferingFinished) {
+                setState(Phonon::BufferingState);
+                qWarning() << QLatin1String("buffer underun");
+                Sleep(20);
+            }
+
+            setState(Phonon::PlayingState);
+
+            //if size == o then stop...
+            if (m_nextBufferIndex) {
+                int size = m_soundBuffer1.waveHeader->dwBufferLength = m_soundBuffer1.data.size();
+                if (size == buffer_size) {
+                    playBuffer(m_soundBuffer1.waveHeader);
+                    emit outOfData(m_stream, &m_soundBuffer1.data, &m_bufferingFinished);
+                } else {
+                    playBuffer(m_soundBuffer1.waveHeader);
+                    m_stopped = true;
+                    setState(Phonon::StoppedState);
+                    emit finished();
+                    seek(0);
+                }
+            } else {
+                int size = m_soundBuffer2.waveHeader->dwBufferLength = m_soundBuffer2.data.size();
+                if (size == buffer_size) {
+                    playBuffer(m_soundBuffer2.waveHeader);
+                    emit outOfData(m_stream, &m_soundBuffer2.data, &m_bufferingFinished);
+                } else {
+                    playBuffer(m_soundBuffer2.waveHeader);
+                    m_stopped = true;
+                    setState(Phonon::StoppedState);
+                    emit finished();
+                    seek(0);
+                }
+            }
+            m_nextBufferIndex =! m_nextBufferIndex;
+        }
+
+
+        void MediaObject::playBuffer(WAVEHDR *waveHeader)
+        {
+            DWORD err = waveOutWrite(m_hWaveOut, waveHeader, sizeof(WAVEHDR));
+            if (!err == MMSYSERR_NOERROR) {
+                setError(Phonon::FatalError, QLatin1String("cannot play sound buffer (system) ") + getErrorText(err));
+                m_stopped = true;
+            }
+        }
+    }
+}
+
+QT_END_NAMESPACE
+
+#include "mediaobject.moc"
diff -r -U2 -N phonon-4.3.0/waveout/mediaobject.h phonon-4.3.0/waveout/mediaobject.h
--- phonon-4.3.0/waveout/mediaobject.h	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/waveout/mediaobject.h	2009-02-26 14:34:17.000000000 -0700
@@ -0,0 +1,162 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef PHONON_MEDIAOBJECT_H
+#define PHONON_MEDIAOBJECT_H
+
+#include <phonon/mediaobjectinterface.h>
+
+#include <QtCore/QHash>
+#include <QtCore/QObject>
+#include <QtCore/QQueue>
+#include <QtCore/QBasicTimer>
+#include <QtCore/QWaitCondition>
+#include <QtCore/QMutex>
+#include <QtCore/QThread>
+#include <QFile>
+#include <QIODevice>
+
+#include <windows.h>
+
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class MediaSource;
+
+    namespace WaveOut
+    {
+        class WorkerThread;
+        class AudioOutput;
+
+        class MediaObject : public QObject, public Phonon::MediaObjectInterface
+        {
+        Q_OBJECT
+        Q_INTERFACES(Phonon::MediaObjectInterface)
+
+        public:
+            MediaObject(QObject *parent);
+            ~MediaObject();
+            Phonon::State state() const;
+            bool hasVideo() const;
+            bool isSeekable() const;
+            qint64 currentTime() const;
+            qint32 tickInterval() const;
+
+            void setTickInterval(qint32 newTickInterval);
+            void play();
+            void pause();
+            void stop();
+            void seek(qint64 time);
+
+            QString errorString() const;
+            Phonon::ErrorType errorType() const;
+            qint64 totalTime() const;
+            qint32 prefinishMark() const;
+            void setPrefinishMark(qint32 newPrefinishMark);
+            qint32 transitionTime() const;
+            void setTransitionTime(qint32);
+            qint64 remainingTime() const;
+            MediaSource source() const;
+            void setSource(const MediaSource &source);
+            void setNextSource(const MediaSource &source);
+         
+
+         Q_SIGNALS:
+            void stateChanged(Phonon::State newstate, Phonon::State oldstate);
+            void tick(qint64 time);
+            void metaDataChanged(QMultiMap<QString, QString>);
+            void seekableChanged(bool);
+            void hasVideoChanged(bool);
+            void bufferStatus(int);
+            void finished();
+            void prefinishMarkReached(qint32);
+            void aboutToFinish();
+            void totalTimeChanged(qint64 length) const;
+            void currentSourceChanged(const MediaSource &);
+            void outOfData(QIODevice *ioStream, QByteArray *buffer, bool *m_bufferingFinshed);
+
+        protected:
+            void setAudioOutput(QObject *audioOutput);
+
+        private Q_SLOTS:
+            void setVolume(qreal newVolume);
+
+        private:
+            bool m_nextBufferIndex;
+            bool prepareBuffers();
+            void unPrepareBuffers();
+            bool getWaveOutDevice();
+            bool openWaveFile(QString fileName);
+            bool readHeader();
+            bool boolUpdateBuffer();
+            bool fillBuffers();
+            void swapBuffers();
+            void setState(Phonon::State newState);
+            void setError(ErrorType errorType, QString errorMessage);
+            void deleteValidWaveOutDevice();
+            void playBuffer(WAVEHDR *waveHeader);
+
+            static void CALLBACK WaveOutCallBack(HWAVEOUT hWaveOut, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
+
+             struct {
+            WAVEHDR  *waveHeader;
+            QByteArray data;
+            } m_soundBuffer1, m_soundBuffer2;
+
+            WAVEFORMATEX m_waveFormatEx;
+            HWAVEOUT m_hWaveOut;
+
+            QFile *m_file;
+            QIODevice *m_stream;
+            QString m_errorString;
+
+            WorkerThread *m_thread;
+
+            MediaSource m_source;
+            MediaSource m_nextSource;
+            AudioOutput *m_audioOutput;
+            ErrorType m_errorType;
+
+            qreal m_volume;
+            qint64 m_mediaSize;
+            qint64 m_totalTime;
+            qint64 m_currentTime;
+            qint64 m_transitionTime;
+            qint64 m_prefinishMark;
+            qint64 m_tickIntervalResolution;
+            qint32 m_tickInterval;
+            qint32 m_tick;
+            Phonon::State m_state;
+
+            bool m_bufferingFinished;
+            bool m_paused;
+            bool m_stopped;            
+            bool m_hasNextSource; 
+            bool m_hasSource;
+            bool m_sourceIsValid;
+            bool m_bufferPrepared;
+
+        friend class Backend;
+        };
+    }
+}
+
+QT_END_NAMESPACE
+
+#endif // PHONON_MEDIAOBJECT_H
diff -r -U2 -N phonon-4.3.0/xine/audiodataoutput.cpp phonon-4.3.0/xine/audiodataoutput.cpp
--- phonon-4.3.0/xine/audiodataoutput.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/audiodataoutput.cpp	2009-08-17 10:10:04.000000000 -0700
@@ -1,4 +1,6 @@
 /*  This file is part of the KDE project
+    Copyright (C) 2004 Max Howell <max.howell@methylblue.com>
     Copyright (C) 2006 Tim Beaulen <tbscope@gmail.com>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
 
     This program is free software; you can redistribute it and/or
@@ -20,7 +22,6 @@
 
 #include "audiodataoutput.h"
-#include <QVector>
-#include <QMap>
-#include "sourcenode.h"
+#include "mediaobject.h"
+
 
 namespace Phonon
@@ -28,75 +29,263 @@
 namespace Xine
 {
-class AudioDataOutputXT : public SinkNodeXT
-{
-    void rewireTo(SourceNodeXT *);
-};
 
-AudioDataOutput::AudioDataOutput(QObject *parent)
-    : AbstractAudioOutput(new AudioDataOutputXT, parent)
-    , m_format(Phonon::Experimental::AudioDataOutput::FloatFormat)
-    , m_dataSize(0)
+
+AudioDataOutputXT::AudioDataOutputXT(AudioDataOutput *output) :
+                    SinkNodeXT("AudioDataOutput"),
+                    SourceNodeXT("AudioDataOutput"),
+                    m_frontend(output),
+                    m_audioPort(0),
+                    m_postOutput(0)
 {
+    m_xine = Backend::xine();
+
+    m_firstVpts = -1;
+
+    // Dummy audio port, until we get the proper one
+    xine_audio_port_t *port = xine_open_audio_driver(m_xine, "none", 0);
+
+    // Allocate a new scope plugin
+    m_plugin = (scope_plugin_t*)qMalloc(sizeof(scope_plugin_t));
+
+    // It is also a post plugin
+    post_plugin_t *post_plugin  = (post_plugin_t*)m_plugin;
+
+    //1 audio input, 0 video inputs
+    _x_post_init(post_plugin, 1, 0);
+
+    // Intercept the null audio port (until we get the proper one)
+    intercept(port, true);
+
+    /* code is straight from xine_init_post()
+       can't use that function as it only dlopens the plugins
+       and our plugin is statically linked in */
+    post_plugin->running_ticket = (*m_xine).port_ticket;
+    post_plugin->xine = m_xine;
+
+    // Store a reference to our own object in the post plugin struct
+    m_plugin->audioDataOutput = this;
 }
 
-AudioDataOutput::~AudioDataOutput()
+AudioDataOutputXT::~AudioDataOutputXT()
 {
+    //xine_post_dispose(m_xine, &((post_plugin_t*)m_plugin)->xine_post); //TODO
+    delete m_plugin;
 }
 
+/// Rewires this node to the specified sourcenode. I don't think this is ever used (properly).
 void AudioDataOutputXT::rewireTo(SourceNodeXT *source)
 {
-    Q_UNUSED(source);
+    debug() << Q_FUNC_INFO << "rewiring to " << source;
+    if (!source->audioOutputPort()) { // I can't get no satisfaction
+        debug() << Q_FUNC_INFO << " no audioport in source";
+        return;
+    }
 
-    //xine_post_wire_audio_port(source->outputPort(), m_audioPort);
+    // Make sure the source is sane
+    source->assert();
+
+    // Get the audio input port in our post plugin
+    xine_post_in_t *target = (xine_post_in_t*)xine_post_input(
+                                    &((post_plugin_t*)m_plugin)->xine_post,
+                                    const_cast<char*>("audio in"));
+
+    if (!xine_post_wire(source->audioOutputPort(), target)) {
+        qWarning() << Q_FUNC_INFO << ": Failed to rewire!";
+        return;
+    }
+    m_postOutput = source->audioOutputPort();
+    m_xtSink->rewireTo(source);
+
+    // Make sure things went okay
+    source->assert();
+    SinkNodeXT::assert();
 }
 
-Phonon::Experimental::AudioDataOutput::Format AudioDataOutput::format() const
+/// Returns this Source's audio output port. Don't think this is used either.
+xine_post_out_t *AudioDataOutputXT::audioOutputPort() const
 {
-    return m_format;
+    return m_postOutput;
 }
 
-int AudioDataOutput::dataSize() const
+/// Intercepts a given Xine audio port (called from AudioOutput)
+void AudioDataOutputXT::intercept(xine_audio_port_t *p, bool isNull)
 {
-    return m_dataSize;
+    if (p == m_audioPort) // we're already intercepting this one
+        return;
+    m_audioPort = p;
+
+    post_in_t  *input;
+    post_out_t *output;
+
+    post_plugin_t *post_plugin  = (post_plugin_t*)m_plugin;
+
+    // Populate the port with dummy functions
+    post_audio_port_t *port = _x_post_intercept_audio_port(post_plugin, m_audioPort, &input, &output);
+    /* TODO:
+     *  Do we leak these ports? Or is the Xine reference counting enough?
+     *  Stay tuned for valgrind and interesting questions!
+     */
+
+    if (!port) {
+        qWarning() << Q_FUNC_INFO << "unable to allocate port! (out of memory?)";
+        delete post_plugin;
+        return;
+    }
+
+    // Put in our own callbacks
+    port->new_port.open       = openPort;
+    port->new_port.close      = closePort;
+    port->new_port.put_buffer = putBufferCallback;
+
+    // Store the audio port for future use
+    m_audioPort = &port->new_port;
+
+    // Wire in the port input into our post plugin
+    post_plugin->xine_post.audio_input[0] = &port->new_port;
+    post_plugin->xine_post.type = PLUGIN_POST;
+
+    if (isNull)
+        m_frontend->m_keepInSync = false;
+    else
+        m_frontend->m_keepInSync = true;
 }
 
-int AudioDataOutput::sampleRate() const
+/// Callback function, opens the xine port
+int AudioDataOutputXT::openPort(xine_audio_port_t *port_gen,
+                                xine_stream_t *stream,
+                                uint32_t bits,
+                                uint32_t rate,
+                                int mode)
+{
+    // Reference to the relevant object
+    AudioDataOutputXT *that = ((scope_plugin_t*)((post_audio_port_t*)port_gen)->post)->audioDataOutput;
+
+    post_audio_port_t *port = (post_audio_port_t*)port_gen;
+
+    _x_post_rewire((post_plugin_t*)port->post);
+    _x_post_inc_usage(port);
+
+    port->stream = stream;
+    port->bits = bits;
+    port->rate = rate;
+    port->mode = mode;
+
+    // Set the new audio stream parameters
+    that->m_channels = _x_ao_mode2channels(mode);
+    that->m_frontend->setChannels(that->m_channels);
+    that->m_frontend->m_sampleRate = rate;
+
+    return port->original_port->open(port->original_port, stream, bits, rate, mode);
+}
+
+/// Callback function, closes the xine port
+void AudioDataOutputXT::closePort(xine_audio_port_t *port_gen, xine_stream_t *stream)
 {
-    return 44100;
+    debug() << Q_FUNC_INFO << " closing port " << port_gen;
+    post_audio_port_t *port = (post_audio_port_t*)port_gen;
+
+    // This is the same as closing the port, according to comments in the Xine source
+    port->stream = NULL;
+    port->original_port->close(port->original_port, stream);
+
+    // Decrease the reference counter in the port
+    _x_post_dec_usage(port);
 }
 
-void AudioDataOutput::setFormat(Phonon::Experimental::AudioDataOutput::Format format)
+/// Callback function, receives audio data
+void AudioDataOutputXT::putBufferCallback(xine_audio_port_t * port_gen, audio_buffer_t *buf, xine_stream_t *stream)
 {
-    m_format = format;
+    AudioDataOutputXT *that = ((scope_plugin_t*)((post_audio_port_t*)port_gen)->post)->audioDataOutput;
+
+    // Get the number of samples (audio frames * audio channels)
+    int samples = buf->num_frames * that->m_channels;
+
+    // Present the audio data to our frontend
+    that->m_frontend->packetReady(samples, buf->mem, buf->vpts);
+
+    /* Send the audio buffer back to the original port.
+       This notifies Xine that we have finished processing
+       this buffer, so Xine can give us a new one */
+    post_audio_port_t *port = (post_audio_port_t*)port_gen;
+    port->original_port->put_buffer(port->original_port, buf, stream);
 }
 
-void AudioDataOutput::setDataSize(int size)
+
+/* BACKEND-FRONT OBJECT */
+AudioDataOutput::AudioDataOutput(QObject*)
+: SinkNode(new AudioDataOutputXT(this))
+, SourceNode(static_cast<AudioDataOutputXT *>(SinkNode::m_threadSafeObject.data()))
+, m_mediaObject(0)
 {
-    m_dataSize = size;
+    m_keepInSync = false;
+    m_sampleRate = 44100;
 }
 
-typedef QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > FloatMap;
-typedef QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > IntMap;
+AudioDataOutput::~AudioDataOutput()
+{
+    //K_XT(AudioDataOutput);
+    //delete xt;
+}
 
-inline void AudioDataOutput::convertAndEmit(const QVector<float> &buffer)
+inline void AudioDataOutput::packetReady(const int samples, const qint16 *buffer, const qint64 vpts)
 {
-    if (m_format == Phonon::Experimental::AudioDataOutput::FloatFormat) {
-        FloatMap map;
-        map.insert(Phonon::Experimental::AudioDataOutput::LeftChannel, buffer);
-        map.insert(Phonon::Experimental::AudioDataOutput::RightChannel, buffer);
-        emit dataReady(map);
+    if (m_channels < 0 || m_channels > 2)
+        return;
+
+    // Check if it has been cleared
+    if (m_pendingFrames.isEmpty())
+        m_pendingFrames.append(Frame());
+
+    for (int i=0; i<samples; i++) {
+        if (m_pendingFrames.first().map[Phonon::AudioDataOutput::LeftChannel].size() >= m_dataSize) {
+            m_pendingFrames.prepend(Frame());
+            m_pendingFrames.first().timestamp = vpts;
+
+            // Tell the QVector how much data we're expecting, speeds things up a bit
+            m_pendingFrames.first().map[Phonon::AudioDataOutput::LeftChannel].reserve(m_dataSize);
+            if (m_channels == 2)
+                m_pendingFrames.first().map[Phonon::AudioDataOutput::RightChannel].reserve(m_dataSize);
+        }
+
+        m_pendingFrames.first().map[Phonon::AudioDataOutput::LeftChannel].append(buffer[i]);
+        if (m_channels == 2)
+            m_pendingFrames.first().map[Phonon::AudioDataOutput::RightChannel].append(buffer[i++]);
     }
-    else
-    {
-        IntMap map;
-        QVector<qint16> intBuffer(m_dataSize);
-        for (int i = 0; i < m_dataSize; ++i)
-            intBuffer[i] = static_cast<qint16>(buffer[i] * static_cast<float>(0x7FFF));
-        map.insert(Phonon::Experimental::AudioDataOutput::LeftChannel, intBuffer);
-        map.insert(Phonon::Experimental::AudioDataOutput::RightChannel, intBuffer);
-        emit dataReady(map);
+
+    // Are we supposed to keep our signals in sync?
+    if (m_keepInSync) {
+        /*while (m_mediaObject && !m_pendingFrames.isEmpty() &&
+               m_pendingFrames.first().timestamp < m_mediaObject->stream()->currentVpts() &&
+               m_pendingFrames.first().map[Phonon::AudioDataOutput::LeftChannel].size() >= m_dataSize) {
+            emit dataReady(m_pendingFrames.takeFirst().map);
+        }*/
+        for (int i=0; i<m_pendingFrames.size(); i++) {
+            if (m_pendingFrames[i].timestamp < m_mediaObject->stream()->currentVpts() &&
+                m_pendingFrames[i].map[Phonon::AudioDataOutput::LeftChannel].size() >= m_dataSize) {
+                emit dataReady(m_pendingFrames.takeAt(i).map);
+            }
+        }
+    } else { // Fire at will, as long as there is enough data
+        while (!m_pendingFrames.isEmpty() &&
+               m_pendingFrames.last().map[Phonon::AudioDataOutput::LeftChannel].size() >= m_dataSize)
+            emit dataReady(m_pendingFrames.takeLast().map);
     }
 }
 
+/// Handle events (basically just pass it on)
+void AudioDataOutput::upstreamEvent(Event *e)
+{
+    Q_ASSERT(e);
+    if (e->type() == Event::IsThereAXineEngineForMe) {
+        // yes there is
+        MediaObject *mediaObject = dynamic_cast<MediaObject*>(m_source); //TODO; qobject_cast?
+        if (mediaObject) {
+            SourceNode::downstreamEvent(new HeresYourXineStreamEvent(mediaObject->stream()));
+            m_mediaObject = mediaObject;
+        }
+    } else
+        SourceNode::upstreamEvent(e);
+}
+
 }} //namespace Phonon::Xine
 
diff -r -U2 -N phonon-4.3.0/xine/audiodataoutput.h phonon-4.3.0/xine/audiodataoutput.h
--- phonon-4.3.0/xine/audiodataoutput.h	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/audiodataoutput.h	2009-08-12 15:26:02.000000000 -0700
@@ -1,4 +1,6 @@
 /*  This file is part of the KDE project
+    Copyright (C) 2004 Max Howell <max.howell@methylblue.com>
     Copyright (C) 2006 Tim Beaulen <tbscope@gmail.com>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
 
     This program is free software; you can redistribute it and/or
@@ -21,7 +23,25 @@
 #define Phonon_XINE_AUDIODATAOUTPUT_H
 
-#include "abstractaudiooutput.h"
-#include <QVector>
-#include <phonon/experimental/audiodataoutput.h>
+
+#include "audiooutput.h"
+#include "sourcenode.h"
+#include "sinknode.h"
+#include "events.h"
+
+
+#include <phonon/audiodataoutput.h>
+#include <phonon/audiodataoutputinterface.h>
+
+#include <QLinkedList>
+
+extern "C" {
+    #define this xine_this //HACK; Xine uses “this” as a name for certain variables
+    #define XINE_ENGINE_INTERNAL // We need the port_ticket
+    #include <xine/audio_out.h>
+    #include <xine/post.h>
+    #undef XINE_ENGINE_INTERNAL
+    #undef this
+}
+
 
 namespace Phonon
@@ -29,31 +49,105 @@
 namespace Xine
 {
+class AudioDataOutputXT;
+class AudioDataOutput;
+
+// Our Xine plugin struct
+typedef struct
+{
+    post_plugin_t post;
+
+    AudioDataOutputXT *audioDataOutput;
+} scope_plugin_t;
+
+
+// Struct for storing an audio frame with timestamp
+typedef struct
+{
+    QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > map;
+    qint64 timestamp;
+} Frame;
+
+class AudioDataOutputXT : public SinkNodeXT, public SourceNodeXT
+{
+    public:
+        AudioDataOutputXT(AudioDataOutput *output);
+        ~AudioDataOutputXT();
+
+        xine_post_out_t *audioOutputPort() const;
+        xine_audio_port_t *audioPort() const { return m_audioPort; }
+
+        void intercept(xine_audio_port_t*, bool isNull = false);
+
+        //callback functions
+        static int  openPort(xine_audio_port_t*, xine_stream_t*, uint32_t, uint32_t, int);
+        static void closePort(xine_audio_port_t *, xine_stream_t *);
+        static void putBufferCallback(xine_audio_port_s*, audio_buffer_s* buf, xine_stream_s* stream);
+        static void dispose(post_plugin_t*);
+
+
+    private:
+        void rewireTo(SourceNodeXT *);
+
+        AudioDataOutput    *m_frontend;
+        xine_audio_port_t *m_audioPort;
+        scope_plugin_t       *m_plugin;
+        int                 m_channels;
+        xine_post_out_t  *m_postOutput;
+        int64_t            m_firstVpts;
+
+}; // class AudioDataOutputXT
+
+/**
+ * \author Martin Sandsmark <sandsmark@samfundet.no>
+ */
+class AudioDataOutput : public QObject,
+                        public Phonon::Xine::SinkNode,
+                        public Phonon::Xine::SourceNode,
+                        public Phonon::AudioDataOutputInterface
 
-class AudioDataOutput : public AbstractAudioOutput
 {
     Q_OBJECT
+
+    Phonon::AudioDataOutput* m_frontend;
+    Q_INTERFACES(Phonon::AudioDataOutputInterface Phonon::Xine::SinkNode Phonon::Xine::SourceNode)
+
     public:
         AudioDataOutput(QObject *parent);
         ~AudioDataOutput();
 
+        //Getters
+        MediaStreamTypes inputMediaStreamTypes() const { return Phonon::Xine::Audio; }
+        MediaStreamTypes outputMediaStreamTypes() const { return Phonon::Xine::Audio; }
+        Phonon::AudioDataOutput *frontendObject() const { return m_frontend; }
+        int channels() const { return m_channels; }
+        int dataSize() const { return m_dataSize; }
+        int sampleRate() const { return m_sampleRate; }
+
+        void upstreamEvent(Event*);
+
+        friend class AudioDataOutputXT;
+
     public slots:
-        Phonon::Experimental::AudioDataOutput::Format format() const;
-        int dataSize() const;
-        int sampleRate() const;
-        void setFormat(Phonon::Experimental::AudioDataOutput::Format format);
-        void setDataSize(int size);
+        //Setters
+        void setFrontendObject(Phonon::AudioDataOutput *frontend) { m_frontend = frontend; }
+        void setChannels(int channels) { m_channels = channels; m_pendingFrames.clear(); }
+        void setDataSize(int ds) { m_dataSize = ds; m_pendingFrames.clear(); }
 
     signals:
-        void dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<qint16> > &data);
-        void dataReady(const QMap<Phonon::Experimental::AudioDataOutput::Channel, QVector<float> > &data);
+        void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+        void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<float> > &data);
         void endOfMedia(int remainingSamples);
 
     private:
-        void convertAndEmit(const QVector<float> &buffer);
+        void packetReady(const int samples, const qint16 *buffer, const qint64 vpts);
+
+        int                           m_channels;
+        int                           m_dataSize;
+        int                         m_sampleRate;
+        QList<Frame>       m_pendingFrames;
+        bool                        m_keepInSync;
+        MediaObject               *m_mediaObject;
 
-        Phonon::Experimental::AudioDataOutput::Format m_format;
-        int m_dataSize;
-        QVector<float> m_pendingData;
-};
+}; //class AudioDataOutput
 
 }} //namespace Phonon::Xine
diff -r -U2 -N phonon-4.3.0/xine/audiooutput.cpp phonon-4.3.0/xine/audiooutput.cpp
--- phonon-4.3.0/xine/audiooutput.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/audiooutput.cpp	2010-01-23 07:37:27.000000000 -0700
@@ -27,4 +27,5 @@
 #include <iostream>
 #include <QSet>
+#include <phonon/pulsesupport.h>
 #include "mediaobject.h"
 #include "backend.h"
@@ -34,4 +35,5 @@
 #include "xinethread.h"
 #include "keepreference.h"
+#include "audiodataoutput.h"
 
 #include <xine/audio_out.h>
@@ -128,4 +130,15 @@
     K_XT(AudioOutput);
     xine_audio_port_t *port = 0;
+
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        // Here we trust that the PA plugin is setup correctly and we just want to use it.
+        const QByteArray &outputPlugin = "pulseaudio";
+        debug() << Q_FUNC_INFO << "PA Active: use output plugin:" << outputPlugin;
+        port = xine_open_audio_driver(xt->m_xine, outputPlugin.constData(), 0);
+        debug() << Q_FUNC_INFO << "----------------------------------------------- audio_port created";
+        return port;
+    }
+
     if (!deviceDesc.isValid()) {
         // use null output for invalid devices
@@ -256,5 +269,5 @@
     K_XT(AudioOutput);
     if (!xt->m_xine) {
-        // remeber the choice until we have a xine_t
+        // remember the choice until we have a xine_t
         m_device = newDevice;
         return true;
@@ -286,4 +299,9 @@
         graphChanged();
     }
+
+    AudioDataOutputXT *dataOutput = dynamic_cast<AudioDataOutputXT*>(m_source->threadSafeObject().data());
+    if (dataOutput)
+        dataOutput->intercept(xt->m_audioPort);
+
     return true;
 }
@@ -304,4 +322,9 @@
         Q_ASSERT(xt->m_audioPort == 0);
         xt->m_audioPort = port;
+
+
+        AudioDataOutputXT *dataOutput = dynamic_cast<AudioDataOutputXT*>(m_source->threadSafeObject().data());
+        if (dataOutput)
+            dataOutput->intercept(xt->m_audioPort);
     }
 }
diff -r -U2 -N phonon-4.3.0/xine/backend.cpp phonon-4.3.0/xine/backend.cpp
--- phonon-4.3.0/xine/backend.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/backend.cpp	2010-01-30 04:47:18.000000000 -0700
@@ -22,4 +22,5 @@
 #include "backend.h"
 #include <phonon/experimental/backendinterface.h>
+#include <phonon/pulsesupport.h>
 #include "mediaobject.h"
 #include "effect.h"
@@ -41,7 +42,4 @@
 #include <QtCore/QByteArray>
 #include <QtCore/QThread>
-#include <QtCore/QCoreApplication>
-#include <QtCore/QSet>
-#include <QtCore/QVariant>
 #include <QtDBus/QDBusConnection>
 #include <QtGui/QApplication>
@@ -72,4 +70,9 @@
     m_thread(0)
 {
+    // Initialise PulseAudio support
+    PulseSupport *pulse = PulseSupport::getInstance();
+    pulse->enable();
+    connect(pulse, SIGNAL(objectDescriptionChanged(ObjectDescriptionType)), SLOT(emitObjectDescriptionChanged(ObjectDescriptionType)));
+
     Q_ASSERT(s_instance == 0);
     s_instance = this;
@@ -92,5 +95,5 @@
 
     signalTimer.setSingleShot(true);
-    connect(&signalTimer, SIGNAL(timeout()), SLOT(emitAudioDeviceChange()));
+    connect(&signalTimer, SIGNAL(timeout()), SLOT(emitAudioOutputDeviceChange()));
     QDBusConnection::sessionBus().registerObject("/internal/PhononXine", this, QDBusConnection::ExportScriptableSlots);
 
@@ -117,4 +120,5 @@
 
     s_instance = 0;
+    PulseSupport::shutdown();
 }
 
@@ -490,8 +494,13 @@
 }
 
-void Backend::emitAudioDeviceChange()
+void Backend::emitAudioOutputDeviceChange()
 {
     debug() << Q_FUNC_INFO;
-    emit objectDescriptionChanged(AudioOutputDeviceType);
+    emitObjectDescriptionChanged(AudioOutputDeviceType);
+}
+
+void Backend::emitObjectDescriptionChanged(ObjectDescriptionType type)
+{
+    emit objectDescriptionChanged(type);
 }
 
@@ -548,7 +557,8 @@
 
             const QString iconName = that->m_audioOutputInfos[i].icon;
-            if (!iconName.isEmpty()) {
+            if (!iconName.isEmpty())
+                ret.insert("icon", iconName);
+            else
                 ret.insert("icon", QLatin1String("audio-card"));
-            }
             ret.insert("available", that->m_audioOutputInfos[i].available);
 
@@ -610,4 +620,18 @@
         // This will list the audio drivers, not the actual devices.
         const char *const *outputPlugins = xine_list_audio_output_plugins(m_xine);
+
+        PulseSupport *pulse = PulseSupport::getInstance();
+        if (pulse->isActive()) {
+            for (int i = 0; outputPlugins[i]; ++i) {
+                if (0 == strcmp(outputPlugins[i], "pulseaudio")) {
+                    // We've detected the pulseaudio output plugin. We're done.
+                    return;
+                }
+            }
+
+            // We cannot find the output plugin, so let the support class know.
+            pulse->enable(false);
+        }
+
         for (int i = 0; outputPlugins[i]; ++i) {
             debug() << Q_FUNC_INFO << "outputPlugin: " << outputPlugins[i];
@@ -646,11 +670,9 @@
             } else if (0 == strcmp(outputPlugins[i], "arts")) {
                 addAudioOutput(nextIndex++, -100, tr("aRts"),
-                        tr("<html><p>aRts is the old soundserver and media framework that was used "
-                            "in KDE2 and KDE3. Its use is discuraged.</p></html>"),
+                        tr("<html><p>aRts is the old sound server and media framework that was used "
+                            "in KDE2 and KDE3. Its use is discouraged.</p></html>"),
                         /*icon name */"audio-backend-arts", outputPlugins[i]);
             } else if (0 == strcmp(outputPlugins[i], "pulseaudio")) {
-                addAudioOutput(nextIndex++, 10, tr("PulseAudio"),
-                        xine_get_audio_driver_plugin_description(m_xine, outputPlugins[i]),
-                        /*icon name */"audio-backend-pulseaudio", outputPlugins[i]);
+                // Ignore this. We deal with it as a special case above.
             } else if (0 == strcmp(outputPlugins[i], "esd")) {
                 addAudioOutput(nextIndex++, 8, tr("Esound (ESD)"),
diff -r -U2 -N phonon-4.3.0/xine/backend.h phonon-4.3.0/xine/backend.h
--- phonon-4.3.0/xine/backend.h	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/backend.h	2009-12-17 07:42:04.000000000 -0700
@@ -23,5 +23,4 @@
 
 #include <QtCore/QList>
-#include <QtCore/QList>
 #include <QtCore/QObject>
 #include <QtCore/QPair>
@@ -67,5 +66,5 @@
 typedef QHash<ObjectDescriptionType, ChannelIndexHash> ObjectDescriptionHash;
 
-class Backend : public QObject, public Phonon::BackendInterface
+class Backend : public QObject, public BackendInterface
 {
     Q_OBJECT
@@ -121,5 +120,6 @@
 
     private slots:
-        void emitAudioDeviceChange();
+        void emitAudioOutputDeviceChange();
+        void emitObjectDescriptionChanged(ObjectDescriptionType);
 
     private:
diff -r -U2 -N phonon-4.3.0/xine/CMakeLists.txt phonon-4.3.0/xine/CMakeLists.txt
--- phonon-4.3.0/xine/CMakeLists.txt	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/CMakeLists.txt	2010-01-28 06:27:07.000000000 -0700
@@ -73,4 +73,5 @@
     net_buf_ctrl.c
     volumefader_plugin.cpp
+    kequalizer_plugin.cpp
     plugins.c
     demux_wav.c
@@ -102,6 +103,6 @@
     configure_file(config-xine-widget.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-xine-widget.h )
     
-    add_definitions(-DPHONON_BACKEND_VERSION_4_2)
-    automoc4_add_library(phonon_xine SHARED ${phonon_xine_SRCS})
+    add_definitions(-DPHONON_BACKEND_VERSION_4_4)
+    automoc4_add_library(phonon_xine MODULE ${phonon_xine_SRCS})
     set_target_properties(phonon_xine PROPERTIES PREFIX "")
     target_link_libraries(phonon_xine ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY} ${PHONON_LIBS} ${XINE_LIBRARY})
@@ -114,4 +115,4 @@
     phonon_install_icons(${ICON_INSTALL_DIR})
 else(XINE_FOUND)
-    macro_log_feature(XINE_FOUND "Xine" "libxine is needed to compile phonon xine backend" "http://xinehq.de/")
+    macro_log_feature(XINE_FOUND "Xine" "libxine is needed to compile phonon xine backend" "http://www.xine-project.org/")
 endif(XINE_FOUND)
diff -r -U2 -N phonon-4.3.0/xine/events.h phonon-4.3.0/xine/events.h
--- phonon-4.3.0/xine/events.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/events.h	2009-04-20 01:13:43.000000000 -0700
@@ -112,5 +112,4 @@
         Cleanup,
         RequestSnapshot,
-        SnapshotReady,
         UnloadCommand
     };
@@ -130,5 +129,4 @@
 }
 
-EVENT_CLASS1(SnapshotReady, QImage i, image(i), const QImage, image)
 EVENT_CLASS1(HeresYourXineStream, QExplicitlySharedDataPointer<XineStream> s, stream(s), QExplicitlySharedDataPointer<XineStream>, stream)
 EVENT_CLASS1(HasVideo, bool v, hasVideo(v), const bool, hasVideo)
@@ -139,4 +137,5 @@
 EVENT_CLASS1(SetPrefinishMark, qint32 i, time(i), const qint32, time)
 
+EVENT_CLASS2(RequestSnapshot, QImage& i, QWaitCondition *w, image(i), waitCondition(w), QImage&, image, QWaitCondition *, waitCondition)
 EVENT_CLASS2(Rewire, QList<WireCall> _wireCalls, QList<WireCall> _unwireCalls, wireCalls(_wireCalls), unwireCalls(_unwireCalls), const QList<WireCall>, wireCalls, const QList<WireCall>, unwireCalls)
 EVENT_CLASS2(Reference, bool alt, const QByteArray &m, alternative(alt), mrl(m), const bool, alternative, const QByteArray, mrl)
diff -r -U2 -N phonon-4.3.0/xine/kequalizer_plugin.cpp phonon-4.3.0/xine/kequalizer_plugin.cpp
--- phonon-4.3.0/xine/kequalizer_plugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ phonon-4.3.0/xine/kequalizer_plugin.cpp	2009-12-22 13:41:58.000000000 -0700
@@ -0,0 +1,496 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Artur Szymiec <artur.szymiec@gmail.com>
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+*/
+
+/* Equalizer GPL code Copyright 2001 Anders Johansson ajh@atri.curtin.edu.au
+   Equalizer filter, implementation of a 10 band time domain graphic
+   equalizer using IIR filters. The IIR filters are implemented using a
+   Direct Form II approach, but has been modified (b1 == 0 always) to
+   save computation.
+   
+   Adopted to phnon xine engine plugin by Artur Szymiec in 2009 artur.szymiec@gmail.com
+*/
+
+#ifndef I18N_NOOP
+#define I18N_NOOP(x) x
+#endif
+
+#include "backend.h"
+
+#include <QObject>
+#include <cmath>
+
+#define __STDC_FORMAT_MACROS
+#include <inttypes.h>
+
+#include <xine.h>
+extern "C" {
+// xine headers use the reserved keyword this:
+#define this this_xine
+#include <xine/compat.h>
+#include <xine/post.h>
+#include <xine/xineutils.h>
+#undef this
+
+#define KEQUALIZER_MAX_GAIN 12.0
+#define KEQUALIZER_L       2      // Storage for filter taps
+#define KEQUALIZER_KM      10     // Max number of bands 
+#define KEQUALIZER_Q       1.2247449 
+/* Q value for band-pass filters 1.2247=(3/2)^(1/2)
+gives 4dB suppression @ Fc*2 and Fc/2 */
+#define KEQUALIZER_CF {60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000}
+// Maximum and minimum gain for the bands
+#define KEQUALIZER_G_MAX   +12.0
+#define KEQUALIZER_G_MIN   -12.0
+#define KEQUALIZER_CHANNELS_MAX 6
+
+typedef struct
+{
+    post_class_t post_class;
+    xine_t *xine;
+} kequalizer_class_t;
+
+typedef struct KEqualizerPlugin
+{
+    post_plugin_t post;
+
+    /* private data */
+    pthread_mutex_t    lock;
+    xine_post_in_t params_input;
+
+    int rate;
+    int bits;
+    double preAmp;
+    double eqBands[10];
+    //kequalizer_s kequalizer_t;
+    float   a[KEQUALIZER_KM][KEQUALIZER_L];             // A weights
+    float   b[KEQUALIZER_KM][KEQUALIZER_L];             // B weights
+    float   wq[KEQUALIZER_CHANNELS_MAX][KEQUALIZER_KM][KEQUALIZER_L];    // Circular buffer for W data
+    float   g[KEQUALIZER_CHANNELS_MAX][KEQUALIZER_KM];        // Gain factor for each channel and band
+    int     K;                    // Number of used eq bands
+    int     channels;             // Number of channels
+    /* Functions */
+    void equalize_Buffer(xine_post_t *this_gen,audio_buffer_t *buf);
+    void eq_calc_Bp2(float* a, float* b, float fc, float q);
+    void eq_calc_Gains(xine_post_t *this_gen);
+    void eq_setup_Filters(xine_post_t *this_gen);
+} kequalizer_plugin_t;
+
+/**************************************************************************
+ * parameters
+ *************************************************************************/
+
+typedef struct
+{
+    double preAmp;
+    double eqBands[10];
+} kequalizer_parameters_t;
+
+/*
+ * description of params struct
+ */
+START_PARAM_DESCR(kequalizer_parameters_t)
+
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, preAmp, NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Equalizer pre-amp gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[0], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 1 60Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[1], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 2 170Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[2], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 3 310Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[3], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 4 600Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[4], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 5 1000Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[5], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 6 3000Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[6], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 7 6000Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[7], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 8 12000Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[8], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 9 14000Hz Gain"))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, eqBands[9], NULL, -KEQUALIZER_MAX_GAIN, KEQUALIZER_MAX_GAIN, 0, I18N_NOOP("Band 10 16000Hz Gain"))
+
+END_PARAM_DESCR(param_descr)
+
+static int set_parameters (xine_post_t *this_gen, void *param_gen) 
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+    kequalizer_parameters_t *param = static_cast<kequalizer_parameters_t *>(param_gen);
+
+    pthread_mutex_lock (&that->lock);
+    
+    that->preAmp = param->preAmp;
+    for (int i=0;i<=9;i++){
+        that->eqBands[i]=param->eqBands[i];
+    }
+  
+    that->eq_calc_Gains(this_gen);
+    
+    const char *x = "kequalizer:";
+    Phonon::Xine::debug() << Q_FUNC_INFO
+        << x
+        << param->preAmp
+        << param->eqBands[0]
+        << param->eqBands[1]
+        << param->eqBands[2]
+        << param->eqBands[3]
+        << param->eqBands[4]
+        << param->eqBands[5]
+        << param->eqBands[6]
+        << param->eqBands[7]
+        << param->eqBands[8]
+        << param->eqBands[9]
+        ;    
+    pthread_mutex_unlock (&that->lock);
+    
+    return 1;
+}
+
+static int get_parameters (xine_post_t *this_gen, void *param_gen) 
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+    kequalizer_parameters_t *param = static_cast<kequalizer_parameters_t *>(param_gen);
+
+    pthread_mutex_lock (&that->lock);
+    
+    param->preAmp = that->preAmp;
+    for (int i=0;i<=9;i++){
+        param->eqBands[i]=that->eqBands[i];
+    }
+    
+    pthread_mutex_unlock (&that->lock);
+
+    return 1;
+}
+
+static xine_post_api_descr_t *get_param_descr()
+{
+    return &param_descr;
+}
+
+static char *get_help ()
+{
+    static QByteArray helpText(
+           QObject::tr("Equalizes audio using the very good IIR equalizer code by  "
+                 "Anders Johansson adopted from Audacious project.\n"
+                 "\n"
+                 "Parameters:\n"
+                 "Preamp gain - used to alter up or down all gain values\n"
+                 "10 Equalizer bands - actual IIR equalizer parameters.\n").toUtf8());
+    return helpText.data();
+}
+
+static xine_post_api_t post_api = {
+    set_parameters,
+    get_parameters,
+    get_param_descr,
+    get_help,
+};
+
+
+/**************************************************************************
+ * xine audio post plugin functions
+ *************************************************************************/
+
+static int kequalizer_port_open(xine_audio_port_t *port_gen, xine_stream_t *stream,
+                             uint32_t bits, uint32_t rate, int mode)
+{
+    post_audio_port_t *port = reinterpret_cast<post_audio_port_t *>(port_gen);
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(port->post);
+    xine_post_t *post = reinterpret_cast<xine_post_t *>(port->post);
+
+    _x_post_rewire(&that->post);
+    _x_post_inc_usage(port);
+
+    port->stream = stream;
+    port->bits = bits;
+    port->rate = rate;
+    port->mode = mode;
+    that->rate = rate;
+    that->bits = bits;
+    
+    switch (mode) {
+    case AO_CAP_MODE_STEREO:
+        that->channels = 2;
+        break;
+    case AO_CAP_MODE_4CHANNEL:
+        that->channels = 4;
+        break;
+    case AO_CAP_MODE_4_1CHANNEL:
+    case AO_CAP_MODE_5CHANNEL:
+    case AO_CAP_MODE_5_1CHANNEL:
+        that->channels = 6;
+        break;
+    }
+    
+    that->eq_setup_Filters(post);
+    that->eq_calc_Gains(post);
+    
+    return port->original_port->open(port->original_port, stream, bits, rate, mode);
+}
+
+static void kequalizer_port_close(xine_audio_port_t *port_gen, xine_stream_t *stream)
+{
+    post_audio_port_t *port = reinterpret_cast<post_audio_port_t *>(port_gen);
+
+    port->stream = NULL;
+    port->original_port->close(port->original_port, stream);
+    _x_post_dec_usage(port);
+}
+
+static void kequalizer_port_put_buffer(xine_audio_port_t *port_gen,
+        audio_buffer_t *buf, xine_stream_t *stream)
+{
+    post_audio_port_t *port = reinterpret_cast<post_audio_port_t *>(port_gen);
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(port->post);
+    xine_post_t *post = reinterpret_cast<xine_post_t *>(port->post);
+    
+    // Do actual equalization
+    that->equalize_Buffer(post,buf);
+    // and send the modified buffer to the original port
+    port->original_port->put_buffer(port->original_port, buf, stream);
+    return;
+}
+
+static void kequalizer_dispose(post_plugin_t *this_gen)
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+
+    if (_x_post_dispose(this_gen)) {
+        pthread_mutex_destroy(&that->lock);
+        free(that);
+    }
+}
+
+/* plugin class functions */
+static post_plugin_t *kequalizer_open_plugin(post_class_t *class_gen, int inputs,
+                                          xine_audio_port_t **audio_target,
+                                          xine_video_port_t **video_target)
+{
+    Q_UNUSED(class_gen);
+    Q_UNUSED(inputs);
+    Q_UNUSED(video_target);
+    kequalizer_plugin_t *that;
+    //deprecated: kequalizer_plugin_t *that = static_cast<kequalizer_plugin_t *>(xine_xmalloc(sizeof(kequalizer_plugin_t)));
+    xine_xmalloc_aligned(2,sizeof(kequalizer_plugin_t),(void**)(&that));
+    post_in_t           *input;
+    post_out_t          *output;
+    xine_post_in_t      *input_api;
+    post_audio_port_t   *port;
+
+    // refuse to work without an audio port to decorate
+    if (!that || !audio_target || !audio_target[0]) {
+        free(that);
+        return NULL;
+    }
+
+    // creates 1 audio I/O, 0 video I/O
+    _x_post_init(&that->post, 1, 0);
+    pthread_mutex_init (&that->lock, NULL);
+
+    // init private data
+   
+    // the following call wires our plugin in front of the given audio_target
+    port = _x_post_intercept_audio_port(&that->post, audio_target[0], &input, &output);
+    // the methods of new_port are all forwarded to audio_target, overwrite a few of them here:
+    port->new_port.open       = kequalizer_port_open;
+    port->new_port.close      = kequalizer_port_close;
+    port->new_port.put_buffer = kequalizer_port_put_buffer;
+
+    // add a parameter input to the plugin
+    input_api       = &that->params_input;
+    input_api->name = "parameters";
+    input_api->type = XINE_POST_DATA_PARAMETERS;
+    input_api->data = &post_api;
+    xine_list_push_back(that->post.input, input_api);
+
+    that->post.xine_post.audio_input[0] = &port->new_port;
+
+    // our own cleanup function
+    that->post.dispose = kequalizer_dispose;
+
+    return &that->post;
+}
+
+#if XINE_MAJOR_VERSION < 1 || (XINE_MAJOR_VERSION == 1 && (XINE_MINOR_VERSION < 1 || (XINE_MINOR_VERSION == 1 && XINE_SUB_VERSION < 90)))
+#define NEED_DESCRIPTION_FUNCTION 1
+#else
+#define NEED_DESCRIPTION_FUNCTION 0
+#endif
+
+#define PLUGIN_DESCRIPTION I18N_NOOP("Fade in or fade out with different fade curves")
+#define PLUGIN_IDENTIFIER "KVolumeFader"
+
+#if NEED_DESCRIPTION_FUNCTION
+static char *kequalizer_get_identifier(post_class_t *class_gen)
+{
+    Q_UNUSED(class_gen);
+    return PLUGIN_IDENTIFIER;
+}
+
+static char *kequalizer_get_description(post_class_t *class_gen)
+{
+    Q_UNUSED(class_gen);
+    static QByteArray description(QObject::tr(PLUGIN_DESCRIPTION).toUtf8());
+    return description.data();
+}
+#endif
+
+static void kequalizer_class_dispose(post_class_t *class_gen)
+{
+    free(class_gen);
+}
+
+/* plugin class initialization function */
+void *init_kequalizer_plugin (xine_t *xine, void *)
+{
+    kequalizer_class_t *_class = static_cast<kequalizer_class_t *>(malloc(sizeof(kequalizer_class_t)));
+
+    if (!_class) {
+        return NULL;
+    }
+
+    _class->post_class.open_plugin     = kequalizer_open_plugin;
+#if NEED_DESCRIPTION_FUNCTION
+    _class->post_class.get_identifier  = kequalizer_get_identifier;
+    _class->post_class.get_description = kequalizer_get_description;
+#else
+    _class->post_class.description     = PLUGIN_DESCRIPTION;
+    _class->post_class.text_domain     = "phonon-xine";
+    _class->post_class.identifier      = PLUGIN_IDENTIFIER;
+#endif
+    _class->post_class.dispose         = kequalizer_class_dispose;
+
+    _class->xine                       = xine;
+
+    return _class;
+}
+
+/* Filter functions */
+
+// 2nd order Band-pass Filter design
+void KEqualizerPlugin::eq_calc_Bp2(float* a, float* b, float fc, float q)
+{ 
+    double th= 2.0 * M_PI * fc;
+    double C = (1.0 - tan(th*q/2.0))/(1.0 + tan(th*q/2.0));
+
+    a[0] = (1.0 + C) * cos(th);
+    a[1] = -1 * C;
+  
+    b[0] = (1.0 - C)/2.0;
+    b[1] = -1.0050;
+}
+
+void KEqualizerPlugin::eq_calc_Gains(xine_post_t *this_gen)
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+    // Sanity check
+    if(that->channels<1 || that->channels>KEQUALIZER_CHANNELS_MAX)
+       return;
+    // adjust gains including preamp value
+    float b[10];
+    float adj = 0.0;
+    
+    // Get bands from config
+    for(int i = 0; i < 10; i++){
+        b[i] = that->eqBands[i] + that->preAmp;
+    }   
+    
+    for(int i = 0; i < 10; i++)
+        if(fabsf(b[i]) > fabsf(adj)) adj = b[i];
+
+    if(fabsf(adj) > KEQUALIZER_G_MAX) {
+        adj = adj > 0.0 ? KEQUALIZER_G_MAX - adj : -KEQUALIZER_G_MAX - adj;
+        for(int i = 0; i < 10; i++) b[i] += adj;
+    }
+     // Recalculate set gains to internal coeficient gains
+    for(int i=0;i<that->channels;i++){
+        
+        for(int k = 0 ; k<KEQUALIZER_KM ; k++){
+            if(b[k] > KEQUALIZER_G_MAX){
+                b[k]=KEQUALIZER_G_MAX;
+            }else if(b[k] < KEQUALIZER_G_MIN){
+                b[k]=KEQUALIZER_G_MIN;
+            }
+            that->g[i][k] = pow(10.0,b[k]/20.0)-1.0;
+       }
+    }
+}
+
+void KEqualizerPlugin::eq_setup_Filters(xine_post_t *this_gen)
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+    int k =0;
+    float F[KEQUALIZER_KM] = KEQUALIZER_CF;
+
+    // Calculate number of active filters
+    that->K=KEQUALIZER_KM;
+    while(F[that->K-1] > (float)that->rate/(KEQUALIZER_Q*2.0))
+      that->K--;
+    
+    if(that->K != KEQUALIZER_KM){
+        Phonon::Xine::debug() << Q_FUNC_INFO 
+        << "[kequalizer] Limiting the number of filters to" 
+        << "due to low sample rate =>"
+        << that->K;
+    }
+    // Generate filter taps
+    for(k=0;k<that->K;k++)
+      that->eq_calc_Bp2(that->a[k],that->b[k],F[k]/((float)that->rate),KEQUALIZER_Q);
+}
+
+void KEqualizerPlugin::equalize_Buffer(xine_post_t *this_gen, audio_buffer_t *buf)
+{
+    kequalizer_plugin_t *that = reinterpret_cast<kequalizer_plugin_t *>(this_gen);
+    const int bufferLength = buf->num_frames * that->channels;
+    
+    if (buf->format.bits == 16 || buf->format.bits == 0) {
+        int16_t         ci   = that->channels;            // Index for channels
+        int16_t         nch  = that->channels;             // Number of channels
+
+        while(ci--){
+        float*        g   = that->g[ci];      // Gain factor 
+        int16_t*      in  = ((int16_t*)static_cast<int16_t *>(buf->mem))+ci;
+        int16_t*      out = ((int16_t*)static_cast<int16_t *>(buf->mem))+ci;
+        int16_t*      end = in + bufferLength;//sizeof(int16_t); // Block loop end
+        
+            while(in < end){
+                  register int      k  = 0;         // Frequency band index
+                  register float    yt = *in;       // Current input sample
+                  in+=nch;
+         
+                  // Run the filters
+                  for(;k<that->K;k++){
+                        // Pointer to circular buffer wq
+                        register float* wq = that->wq[ci][k];
+                        // Calculate output from AR part of current filter
+                        register float w=yt*that->b[k][0] + wq[0]*that->a[k][0] + wq[1]*that->a[k][1];
+                        // Calculate output form MA part of current filter
+                        yt+=(w + wq[1]*that->b[k][1])*g[k];
+                        // Update circular buffer
+                        wq[1] = wq[0];
+                        wq[0] = w;
+                  }
+                  // Output data to buffer 
+                  // NOTE maybe we need to add more sophisticated convertion method from float to ine like in libSAD with dithering ??
+                  // NOTE for now this clipping have to be enough
+                  *out =  yt <= (float)32767 ? ( yt >= (float)-32768 ? (int16_t)yt : -32768 ) : 32767;
+                  out+=nch;//nch;
+                  } 
+        }
+    }else{
+        Phonon::Xine::debug() << Q_FUNC_INFO << "broken bits " << buf->format.bits;    
+    }
+}
+
+
+} // extern "C"
diff -r -U2 -N phonon-4.3.0/xine/macros.h phonon-4.3.0/xine/macros.h
--- phonon-4.3.0/xine/macros.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/macros.h	2009-02-26 14:33:54.000000000 -0700
@@ -7,5 +7,5 @@
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Trolltech ASA 
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
diff -r -U2 -N phonon-4.3.0/xine/mediaobject.cpp phonon-4.3.0/xine/mediaobject.cpp
--- phonon-4.3.0/xine/mediaobject.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/mediaobject.cpp	2009-11-14 12:57:21.000000000 -0700
@@ -318,4 +318,20 @@
 }
 
+static QByteArray mrlEncode(QByteArray mrl)
+{
+    for (int i = 0; i < mrl.size(); ++i) {
+        const unsigned char c = static_cast<unsigned char>(mrl.at(i));
+        // we assume that the other invalid characters
+        // are already escaped due to the call to QUrl.toEncoded()
+        if (c == '#') {
+            char enc[4];
+            qsnprintf(enc, 4, "%%%02X", c);
+            mrl = mrl.left(i) + QByteArray(enc, 3) + mrl.mid(i + 1);
+            i += 2;
+        }
+    }
+    return mrl;
+}
+
 void MediaObject::setSourceInternal(const MediaSource &source, HowToSetTheUrl how)
 {
@@ -341,11 +357,16 @@
             return;
         }
-        switch (how) {
-        case GaplessSwitch:
-            m_stream->gaplessSwitchTo(source.url());
-            break;
-        case HardSwitch:
-            m_stream->setUrl(source.url());
-            break;
+        {
+            const QByteArray &mrl = (source.url().scheme() == QLatin1String("") ?
+                    "file:/" + mrlEncode (source.url().toEncoded()) :
+                    mrlEncode (source.url().toEncoded()));
+            switch (how) {
+                case GaplessSwitch:
+                    m_stream->gaplessSwitchTo(mrl);
+                    break;
+                case HardSwitch:
+                    m_stream->setMrl(mrl);
+                    break;
+            }
         }
         break;
@@ -412,5 +433,5 @@
 //X {
 //X     m_titles.clear();
-//X 
+//X
 //X }
 
@@ -661,5 +682,5 @@
     case Event::RequestSnapshot:
         // postEvent takes ownership of the event and will delete it when done
-        QCoreApplication::postEvent(m_stream, new Event(e->type()));
+        QCoreApplication::postEvent(m_stream, copyEvent(static_cast<RequestSnapshotEvent*>(e)));
         break;
     case Event::SetParam:
diff -r -U2 -N phonon-4.3.0/xine/plugins.c phonon-4.3.0/xine/plugins.c
--- phonon-4.3.0/xine/plugins.c	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/plugins.c	2009-05-27 08:01:24.000000000 -0700
@@ -29,7 +29,9 @@
 extern void *init_kbytestream_plugin (xine_t *xine, void *data);
 extern void *init_kvolumefader_plugin (xine_t *xine, void *data);
+extern void *init_kequalizer_plugin (xine_t *xine, void *data);
 /*extern void *init_kmixer_plugin(xine_t *xine, void *data);*/
 
 static const post_info_t kvolumefader_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
+static const post_info_t kequalizer_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
 /*static const post_info_t kmixer_special_info = { XINE_POST_TYPE_AUDIO_FILTER };*/
 
@@ -41,4 +43,5 @@
     { PLUGIN_INPUT, 17, (char *)"KBYTESTREAM" , XINE_VERSION_CODE, NULL                      , &init_kbytestream_plugin  },
     { PLUGIN_POST , 9 , (char *)"KVolumeFader", XINE_VERSION_CODE, &kvolumefader_special_info, &init_kvolumefader_plugin },
+    { PLUGIN_POST , 9 , (char *)"KEqualizer", XINE_VERSION_CODE, &kequalizer_special_info, &init_kequalizer_plugin },
     /*{ PLUGIN_POST , 9 , "KMixer"      , XINE_VERSION_CODE, &kmixer_special_info      , &init_kmixer_plugin       },*/
     { PLUGIN_NONE , 0 , (char *)""            , 0                , NULL                      , NULL                      }
diff -r -U2 -N phonon-4.3.0/xine/sinknode.h phonon-4.3.0/xine/sinknode.h
--- phonon-4.3.0/xine/sinknode.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/sinknode.h	2009-08-03 16:24:29.000000000 -0700
@@ -58,4 +58,7 @@
     friend class WireCall;
     friend class XineStream;
+    friend class AudioDataOutput;
+    friend class AudioOutput;
+
     public:
         SinkNode(SinkNodeXT *_xt);
diff -r -U2 -N phonon-4.3.0/xine/sourcenode.cpp phonon-4.3.0/xine/sourcenode.cpp
--- phonon-4.3.0/xine/sourcenode.cpp	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/sourcenode.cpp	2009-08-03 16:24:29.000000000 -0700
@@ -23,4 +23,5 @@
 #include "events.h"
 #include "keepreference.h"
+#include "audiooutput.h"
 
 namespace Phonon
diff -r -U2 -N phonon-4.3.0/xine/sourcenode.h phonon-4.3.0/xine/sourcenode.h
--- phonon-4.3.0/xine/sourcenode.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/sourcenode.h	2009-08-03 16:24:29.000000000 -0700
@@ -54,4 +54,5 @@
 
         friend class XineThread;
+        friend class AudioDataOutputXT;
 
         // hold a ref to the sink that we're connected to to make 100% sure it's always valid
diff -r -U2 -N phonon-4.3.0/xine/videowidget.cpp phonon-4.3.0/xine/videowidget.cpp
--- phonon-4.3.0/xine/videowidget.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/videowidget.cpp	2009-04-20 01:13:43.000000000 -0700
@@ -345,10 +345,9 @@
     QImage img;
     QMutexLocker lock(&m_snapshotLock);
-    const_cast<VideoWidget *>(this)->upstreamEvent(new Event(Event::RequestSnapshot));
+    const_cast<VideoWidget *>(this)->upstreamEvent(new RequestSnapshotEvent(img, &m_snapshotWait) );
     if (m_snapshotWait.wait(&m_snapshotLock, 1000)) {
-        img = m_snapshotImage;
-        m_snapshotImage = QImage();
+      return img;
     }
-    return img;
+    return QImage();
 }
 
@@ -473,8 +472,4 @@
     K_XT(VideoWidget);
 
-    if (cursor().shape() == Qt::BlankCursor) {
-        setCursor(QCursor(Qt::ArrowCursor));
-    }
-
     x11_rectangle_t   rect;
     xine_event_t      *event = new xine_event_t;
@@ -644,10 +639,4 @@
         }
         break;
-    case Event::SnapshotReady:
-        m_snapshotLock.lock();
-        m_snapshotImage = static_cast<const SnapshotReadyEvent *>(e)->image;
-        m_snapshotWait.wakeAll();
-        m_snapshotLock.unlock();
-        break;
     default:
         QCoreApplication::sendEvent(this, e);
diff -r -U2 -N phonon-4.3.0/xine/videowidget.h phonon-4.3.0/xine/videowidget.h
--- phonon-4.3.0/xine/videowidget.h	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/videowidget.h	2009-08-20 06:39:02.000000000 -0700
@@ -93,8 +93,8 @@
 };
 
-class VideoWidget : public QWidget, public Phonon::VideoWidgetInterface, public Phonon::Xine::SinkNode, public Phonon::Experimental::SnapshotInterface
+class VideoWidget : public QWidget, public Phonon::VideoWidgetInterfaceLatest, public Phonon::Xine::SinkNode, public Phonon::Experimental::SnapshotInterface
 {
     Q_OBJECT
-    Q_INTERFACES(Phonon::VideoWidgetInterface Phonon::Xine::SinkNode Phonon::Experimental::SnapshotInterface)
+    Q_INTERFACES( Phonon::VideoWidgetInterface Phonon::Xine::SinkNode Phonon::Experimental::SnapshotInterface)
     public:
         VideoWidget(QWidget *parent = 0);
@@ -154,5 +154,4 @@
         mutable QMutex m_snapshotLock;
         mutable QWaitCondition m_snapshotWait;
-        mutable QImage m_snapshotImage;
 
         QSize m_sizeHint;
diff -r -U2 -N phonon-4.3.0/xine/volumefadereffect.cpp phonon-4.3.0/xine/volumefadereffect.cpp
--- phonon-4.3.0/xine/volumefadereffect.cpp	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/volumefadereffect.cpp	2009-09-28 04:49:00.000000000 -0700
@@ -100,7 +100,13 @@
     case FadeToParameter:
         xt->m_parameters.fadeTo = newValue.toDouble();
+        if (xt->m_pluginApi) {
+            xt->m_pluginApi->set_parameters(xt->m_plugin, &xt->m_parameters);
+        }
         break;
     case FadeTimeParameter:
         xt->m_parameters.fadeTime = newValue.toInt();
+        if (xt->m_pluginApi) {
+            xt->m_pluginApi->set_parameters(xt->m_plugin, &xt->m_parameters);
+        }
         break;
     case StartFadeParameter:
@@ -153,4 +159,10 @@
     //debug() << Q_FUNC_INFO << volume;
     xt->m_parameters.currentVolume = volume;
+    // when we set the volume, set the fadeTo as well, so that we
+    // don't immediately fade back again
+    xt->m_parameters.fadeTo = volume;
+    if (xt->m_pluginApi) {
+        xt->m_pluginApi->set_parameters(xt->m_plugin, &xt->m_parameters);
+    }
 }
 
@@ -170,4 +182,7 @@
     //debug() << Q_FUNC_INFO << curve;
     xt->m_parameters.fadeCurve = curve;
+    if (xt->m_pluginApi) {
+        xt->m_pluginApi->set_parameters(xt->m_plugin, &xt->m_parameters);
+    }
 }
 
diff -r -U2 -N phonon-4.3.0/xine/volumefader_plugin.cpp phonon-4.3.0/xine/volumefader_plugin.cpp
--- phonon-4.3.0/xine/volumefader_plugin.cpp	2008-11-24 10:12:01.000000000 -0700
+++ phonon-4.3.0/xine/volumefader_plugin.cpp	2009-09-28 07:43:17.000000000 -0700
@@ -139,10 +139,11 @@
  * description of params struct
  */
-static char *enum_fadeCurve[] = { "Fade3Decibel", "Fade6Decibel", "Fade9Decibel", "Fade12Decibel", NULL };
+static const char *enum_fadeCurve[] = { "Fade3Decibel", "Fade6Decibel", "Fade9Decibel", "Fade12Decibel", NULL };
+
 START_PARAM_DESCR(kvolumefader_parameters_t)
-PARAM_ITEM(POST_PARAM_TYPE_INT, fadeCurve, enum_fadeCurve, 0.0, 0.0, 0, I18N_NOOP ("fade curve"))
-PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, currentVolume, NULL, 0.0, maxVolume, 0, I18N_NOOP("current volume"))
-PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, fadeTo, NULL, 0.0, maxVolume, 0, I18N_NOOP("volume to fade to"))
-PARAM_ITEM(POST_PARAM_TYPE_INT, fadeTime, NULL, 0.0, 10000.0, 0, I18N_NOOP("fade time in milliseconds"))
+PARAM_ITEM(POST_PARAM_TYPE_INT, fadeCurve, const_cast<char**>(enum_fadeCurve), 0.0, 0.0, 0, const_cast<char*>( I18N_NOOP("fade curve") ))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, currentVolume, NULL, 0.0, maxVolume, 0, const_cast<char*>( I18N_NOOP("current volume") ))
+PARAM_ITEM(POST_PARAM_TYPE_DOUBLE, fadeTo, NULL, 0.0, maxVolume, 0, const_cast<char*>( I18N_NOOP("volume to fade to") ))
+PARAM_ITEM(POST_PARAM_TYPE_INT, fadeTime, NULL, 0.0, 10000.0, 0, const_cast<char*>( I18N_NOOP("fade time in milliseconds") ))
 END_PARAM_DESCR(param_descr)
 
@@ -159,5 +160,15 @@
     that->fadeTime = param->fadeTime;
     that->curveLength = static_cast<int>((param->fadeTime * that->rate) / 1000);
-    that->oneOverCurveLength = 1000.0f / (param->fadeTime * that->rate);
+    if ( that->curveLength == 0 )
+    {
+        // we've been asked to fade instantly, so pre-calculate everything
+        that->oneOverCurveLength = 0.0f;
+        that->fadeStart += that->fadeDiff;
+        that->fadeDiff = 0.0f;
+    }
+    else
+    {
+        that->oneOverCurveLength = 1000.0f / (param->fadeTime * that->rate);
+    }
     const char *x = "unknown";
     switch (that->fadeCurve) {
@@ -284,5 +295,15 @@
     }
     that->curveLength = static_cast<int>((that->fadeTime * that->rate) / 1000);
-    that->oneOverCurveLength = 1000.0f / (that->fadeTime * that->rate);
+    if ( that->curveLength == 0 )
+    {
+        // we've been asked to fade instantly, so pre-calculate everything
+        that->oneOverCurveLength = 0.0f;
+        that->fadeStart += that->fadeDiff;
+        that->fadeDiff = 0.0f;
+    }
+    else
+    {
+        that->oneOverCurveLength = 1000.0f / (that->fadeTime * that->rate);
+    }
 
     return port->original_port->open(port->original_port, stream, bits, rate, mode);
@@ -382,5 +403,5 @@
     Q_UNUSED(video_target);
 
-    kvolumefader_plugin_t *that = static_cast<kvolumefader_plugin_t *>(xine_xmalloc(sizeof(kvolumefader_plugin_t)));
+    kvolumefader_plugin_t *that = static_cast<kvolumefader_plugin_t *>(calloc(1, sizeof(kvolumefader_plugin_t)));
     post_in_t             *input;
     post_out_t            *output;
@@ -443,5 +464,5 @@
 {
     Q_UNUSED(class_gen);
-    return PLUGIN_IDENTIFIER;
+    return const_cast<char*>(PLUGIN_IDENTIFIER);
 }
 
@@ -462,5 +483,5 @@
 void *init_kvolumefader_plugin (xine_t *xine, void *)
 {
-    kvolumefader_class_t *_class = static_cast<kvolumefader_class_t *>(malloc(sizeof(kvolumefader_class_t)));
+    kvolumefader_class_t *_class = static_cast<kvolumefader_class_t *>(calloc(1,sizeof(kvolumefader_class_t)));
 
     if (!_class) {
diff -r -U2 -N phonon-4.3.0/xine/xine.desktop phonon-4.3.0/xine/xine.desktop
--- phonon-4.3.0/xine/xine.desktop	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/xine.desktop	2010-02-04 04:25:54.000000000 -0700
@@ -11,25 +11,95 @@
 
 Name=Xine
+Name[bg]=Xine
+Name[ca]=Xine
+Name[ca@valencia]=Xine
+Name[cs]=Xine
+Name[da]=Xine
+Name[de]=Xine
+Name[el]=Xine
+Name[en_GB]=Xine
+Name[eo]=Xine
+Name[es]=Xine
+Name[et]=Xine
+Name[eu]=Xine
+Name[fi]=Xine
+Name[fr]=Xine
+Name[ga]=Xine
+Name[gl]=Xine
+Name[hsb]=Xine
+Name[hu]=Xine
+Name[id]=Xine
+Name[is]=Xine
+Name[it]=Xine
+Name[ja]=Xine
+Name[ko]=Xine
+Name[ku]=Xine
+Name[lt]=Xine
+Name[lv]=Xine
+Name[nb]=Xine
+Name[nds]=Xine
+Name[nl]=Xine
+Name[nn]=Xine
+Name[pa]=ਜ਼ਾਈਨ
+Name[pl]=Xine
+Name[pt]=Xine
+Name[pt_BR]=Xine
+Name[ru]=Xine
+Name[se]=Xine
+Name[sk]=Xine
+Name[sl]=Xine
+Name[sr]=Ксин
+Name[sr@ijekavian]=Ксин
+Name[sr@ijekavianlatin]=Xine
+Name[sr@latin]=Xine
+Name[sv]=Xine
+Name[tr]=Xine
+Name[uk]=Xine
 Name[x-test]=xxXinexx
+Name[zh_CN]=Xine
+Name[zh_TW]=Xine
 
 Comment=Phonon Xine backend
+Comment[bg]=Phonon през Xine
 Comment[ca]=Dorsal del Xine pel Phonon
+Comment[ca@valencia]=Dorsal del Xine pel Phonon
+Comment[cs]=Phonon Xine backend
 Comment[da]=Xine-backend til Phonon
 Comment[de]=Phonon-Treiber für Xine
 Comment[el]=Σύστημα υποστήριξης του Phonon Xine
+Comment[en_GB]=Phonon Xine backend
 Comment[es]=Motor Xine para Phonon
 Comment[et]=Phononi Xine taustaprogramm
+Comment[eu]=Phonon Xine backend
+Comment[fi]=Phonon Xine-taustaohjelma
+Comment[fr]=Système de gestion Xine pour Phonon 
 Comment[ga]=Inneall Phonon Xine
 Comment[gl]=Infraestrutura de Xine para Phonon
+Comment[hsb]=Phonon Xine backend
+Comment[hu]=Phonon Xine modul
+Comment[id]=Phonon Xine backend
+Comment[is]=Phonon Xine bakendi
+Comment[it]=Motore Xine di Phonon
 Comment[ja]=Phonon Xine バックエンド
 Comment[ko]=Phonon Xine 백엔드
+Comment[ku]=Binesaza Phonon Xine
+Comment[lt]=Phonon Xine galinė sąsaja
 Comment[lv]=Phonon Xine aizmugure
+Comment[nb]=Xine-motor for Phonon
 Comment[nds]=Phonon-Hülpprogrmm Xine
 Comment[nl]=Xine-backend (Phonon)
 Comment[nn]=Xine-motor for Phonon
 Comment[pa]=ਫੋਨੋਨ ਜ਼ਾਇਨ ਬੈਕਐਂਡ
+Comment[pl]=Obsługa Xine przez Phonon
 Comment[pt]=Infra-estrutura de Xine para o Phonon
-Comment[pt_BR]=Infraestrutura Phonon Xine
+Comment[pt_BR]=Infraestrutura Xine do Phonon
+Comment[ru]=Механизм Xine для Phonon
+Comment[se]=Phonon Xine duogášmohtor
 Comment[sk]=Phonon Xine podsystém
+Comment[sl]=Hrbtenica Xine za Phonon
+Comment[sr]=Ксин као позадина Фонона
+Comment[sr@ijekavian]=Ксин као позадина Фонона
+Comment[sr@ijekavianlatin]=Xine kao pozadina Phonona
+Comment[sr@latin]=Xine kao pozadina Phonona
 Comment[sv]=Phonon Xine-gränssnitt
 Comment[tr]=Phonon Xine arka ucu
diff -r -U2 -N phonon-4.3.0/xine/xinestream.cpp phonon-4.3.0/xine/xinestream.cpp
--- phonon-4.3.0/xine/xinestream.cpp	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/xinestream.cpp	2010-01-30 11:20:04.000000000 -0700
@@ -505,5 +505,9 @@
     xine_audio_port_t *audioPort = 0;
     xine_video_port_t *videoPort = 0;
-    Q_ASSERT(m_mediaObject);
+    if (!m_mediaObject) {
+        qWarning("request to create a stream, but no valid audio/video outputs are given/available");
+        error(Phonon::FatalError, tr("Xine failed to create a stream."));
+        return false;
+    }
     QSet<SinkNode *> sinks = m_mediaObject->sinks();
     debug() << Q_FUNC_INFO << "MediaObject is connected to " << sinks.size() << " nodes";
@@ -620,10 +624,4 @@
 
 // called from main thread
-void XineStream::gaplessSwitchTo(const QUrl &url)
-{
-    gaplessSwitchTo(url.toEncoded());
-}
-
-// called from main thread
 void XineStream::gaplessSwitchTo(const QByteArray &mrl)
 {
@@ -790,5 +788,10 @@
         }
         changeState(Phonon::StoppedState);
-        xine_close(m_stream); // TODO: is it necessary? should xine_close be called as late as possible?
+        // Some other thread may have "nicely" closed the stream before we got to it
+        // better to check for its existence first before we crash the program
+        // FIXME: This does happen in practice, but shouldn't. (B.K.O. 196320)
+        if (m_stream) {
+            xine_close(m_stream); // TODO: is it necessary? should xine_close be called as late as possible?
+        }
         m_streamInfoReady = false;
         m_prefinishMarkReachedNotEmitted = true;
@@ -1212,5 +1215,8 @@
                     return true;
                 }
-                handleDownstreamEvent(new SnapshotReadyEvent(qimg));
+                   RequestSnapshotEvent *event=static_cast<RequestSnapshotEvent*>(ev);
+                   event->image=qimg;
+                   event->waitCondition->wakeAll();
+//                 handleDownstreamEvent(new SnapshotReadyEvent(qimg));
             }
         }
@@ -1229,5 +1235,5 @@
             setMrlInternal(e->mrl);
             m_errorType = Phonon::NoError;
-            m_errorString = QString();
+            m_errorString.clear();
             if (!m_stream) {
                 changeState(Phonon::LoadingState);
@@ -1517,5 +1523,11 @@
                 return true; // cannot seek
             }
-            m_currentTime = e->time;
+
+            // The stream demuxer will (hopefully) give us a better idea of
+            // where we are in the stream (maybe it will round the time to the
+            // nearest frame rather than the exact time desired).
+            if (!xine_get_pos_length(m_stream, 0, &m_currentTime, 0) || !m_currentTime)
+                m_currentTime = e->time;
+
             const int timeToSignal = m_totalTime - m_prefinishMark - e->time;
             if (m_prefinishMark > 0) {
@@ -1653,5 +1665,6 @@
     QByteArray lang;
     lang.resize(150);
-    get_xine_stream_text(m_stream, index, lang.data());
+    if (!get_xine_stream_text(m_stream, index, lang.data()))
+        lang = QByteArray();
     QHash<QByteArray, QVariant> properities;
     properities.insert("name", QString(lang));
@@ -1707,10 +1720,4 @@
 }
 
-// called from main thread
-void XineStream::setUrl(const QUrl &url)
-{
-    setMrl(url.toEncoded());
-}
-
 // called from main thread
 void XineStream::setMrl(const QByteArray &mrl, StateForNewMrl sfnm)
diff -r -U2 -N phonon-4.3.0/xine/xinestream.h phonon-4.3.0/xine/xinestream.h
--- phonon-4.3.0/xine/xinestream.h	2009-01-08 07:47:18.000000000 -0700
+++ phonon-4.3.0/xine/xinestream.h	2009-10-03 12:00:19.000000000 -0700
@@ -62,4 +62,5 @@
 {
     Q_OBJECT
+
     public:
         static void xineEventListener(void *, const xine_event_t *);
@@ -87,5 +88,4 @@
         void useGaplessPlayback(bool);
         void useGapOf(int gap);
-        void gaplessSwitchTo(const QUrl &url);
         void gaplessSwitchTo(const QByteArray &mrl);
         void closeBlocking();
@@ -122,4 +122,6 @@
         int audioChannelsSize() const;
 
+        int64_t currentVpts() { return xine_get_current_vpts(m_stream); }
+
         enum StateForNewMrl {
             // no use: Loading, Error, Buffering
@@ -142,5 +144,4 @@
         void unload();
     public slots:
-        void setUrl(const QUrl &url);
         void setMrl(const QByteArray &mrl, StateForNewMrl = StoppedState);
         void play();

diff -r -U2 -N qt-x11-free-3.3.8b/ChangeLog.immodule qt-x11-free-3.3.8b/ChangeLog.immodule
--- qt-x11-free-3.3.8b/ChangeLog.immodule	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/ChangeLog.immodule	2009-10-18 14:38:38.725205556 -0700
@@ -0,0 +1,2076 @@
+2007-11-16  Daisuke Kameda <daisuke@kde.gr.jp>
+
+	* Update to Qt 3.3.8
+
+2006-12-29  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* Update to Qt 3.3.7
+
+2006-12-29  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* Update to Qt 3.3.6
+
+2006-03-17  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* merge two patch
+	  - http://developer.kde.org/~dirk/im/fix-im-crash-on-exit.diff
+	  - http://developer.kde.org/~dirk/im/qt-x11-immodule-fix-inputcontext-crash.diff
+	
+2005-10-18  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - fixed small bug.
+	
+2005-10-12  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* src/kernel/qinputcontext.cpp
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - marge SUSE patch proposed in
+		http://lists.freedesktop.org/archives/immodule-qt/2005-July/000735.html
+	
+2005-10-11  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* Fix the bug in qlineedit.cpp
+	  - discussed at https://bugzilla.novell.com/show_bug.cgi?id=117115
+	
+2005-09-28  Daisuke Kameda <daisuke@kde.gr.jp>
+	
+	* Update to Qt 3.3.5 and small bugfix follows.
+	  - Fix the bug in qwidget.cpp as 
+		http://lists.freedesktop.org/archives/immodule-qt/2005-March/000716.html
+	  - Modify displayName() of Q*Plugin returning book title style 
+		capitalized text
+	
+2004-10-10  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/kernel/qinputcontext.cpp
+	  - enable composing and inputting from other
+		application (e.g, input-pad)
+	
+2004-09-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* changes.immodule
+	  - Describe a bugfix
+	
+2004-09-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/inputmethod/qinputcontextinterface_p.h
+	  - Update UUID of QInputContextFactory in accordance with API change
+	    of QInputContext to avoid loading old invalid plugins
+	
+2004-09-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* README.immodule
+	  - Add 'About this release' section
+	  - Update version information
+	  - Update to follow the change of configure options
+	  - Modify some English expressions
+	
+	* changes.immodule
+	  - Move release information to README.immodule
+	  - Add differences from previous release
+	  - Add description about incremental change indication
+	
+	* ChangeLog.immodule
+	  - Update
+	
+2004-09-09  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qapplication.cpp
+	  - (removePostedEvents):
+	    * Fix infinite loop condition
+	    * delete receiver->postedEvents if the list has been empty
+	
+2004-09-09  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit backports some code fragments from Qt4 branch to make
+	  input method plugins source compatible with Qt4.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (QInputContext): Add 'parent' arg
+	
+	* src/kernel/qinputcontext.h
+	  - Exclude qptrlist.h when compile with Qt4
+	  - (struct QInputContextMenu): Exclude member variables when compile
+	    with Qt4
+	  - (QInputContext): Add 'parent' arg
+	  - (addActionsTo): New function for Qt4
+	
+2004-09-08  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit renames input method module from 'input' to 'inputmehod'
+	  because the name 'input' is too generic to indicate its function
+	
+	* configure
+	  - Replace configuration options '-im' and '-im-ext' with
+	    '-inputmethod' and '-inputmethod-ext' to be consistent with the
+	    name of input method module subdirectory 'inputmethod'
+	  - Rename the module name 'input' with 'inputmethod'
+	
+	* src/qt.pro
+	  - Rename the module name 'input' with 'inputmethod'
+	  - Rename some variable names inaccordance with the renaming of the
+	    module
+	  - Replace 'qt_input.pri' with 'qt_inputmethod.pri' in accordance
+	    with the renaming of the file
+	
+	* src/inputmethod/qt_input.pri
+	  - Rename to qt_inputmethod.pri
+	* src/inputmethod/qt_input.pri
+	  - Renamed from qt_input.pri
+	  - Replace module names
+	  - Rename some variable names inaccordance with the renaming of the
+	    module
+	
+2004-09-08  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* Rename input module subdirectory from "input" to "inputmethod"
+	
+2004-09-08  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit contains following issues
+	  - An API change. Return type of QInputContext::identifierName and
+	    QInputContext::language has been changed from QCString which is
+	    deprecated in Qt4 to QString to make plugins source compatible
+	    with Qt4.
+	  - Other backports from Qt4 branch
+	  - Fix event receiving order inversion between QKeyEvent and
+	    QIMEvent. The code is implemented based on Cougar's and
+	    Kazuki's. Thank you the efforts. See following discussion for
+	    further information.
+	    http://freedesktop.org/pipermail/immodule-qt/2004-September/000447.html
+	    http://freedesktop.org/pipermail/immodule-qt/2004-September/000497.html
+	
+	* src/kernel/qinputcontext.h
+	  - (identifierName, language): Change return type from QCString to QString
+	  - (addMenusTo): Make Qt3 specific
+	* src/kernel/qinputcontext.cpp
+	  - (identifierName):
+	    * Change return type from QCString to QString
+	    * Modify the function description comment
+	  - (language): Change return type from QCString to QString
+	
+	* src/kernel/qwidget.cpp
+	  - (clearFocus): Enclose immodule specific code by #if
+	    defined(Q_WS_X11)
+	
+	* src/kernel/qapplication.h
+	  - Add 'class QIMEvent' declaration
+	  - (removePostedEvents): New overriding function
+	* src/kernel/qapplication_x11.cpp
+	  - Remove redundant 'class QInputContext' declaration
+	  - (postIMEvent): Fix the event receiving order inversion problem
+	  - (x11_apply_settings): Replace QString::find() which is deprecated
+	    in Qt4 with QString::startsWith()
+	  - (postEvent): Fix invalid QIMEvent compression that ignores IMStart
+	    boundary
+	  - (removePostedEvents): Original version of the function. Replace
+	    the implementation with 2-args version. The behavior is not
+	    changed
+	  - (removePostedEvents): New overriding function. This function only
+	    removes events that has specified event type. The implementation
+	    is copied from original version of the function and modified to
+	    accept event_type. This function is required by postIMEvent()
+	  - (setActiveWindow): Enclose immodule specific code by #if
+	    defined(Q_WS_X11)
+	
+	* src/input/qinputcontextinterface_p.h
+	  - Modify a coding style to follow Trolltech's one for Qt3
+	
+	* src/input/qinputcontextplugin.h
+	  - Fix typos in comment
+	* src/input/qinputcontextplugin.cpp
+	  - (keys, QInputContextPlugin, ~QInputContextPlugin): Modify the
+	    function description comment
+	
+	* src/input/qinputcontextfactory.h
+	  - Remove #include "qinputcontext.h" to reduce compilation dependency
+	  - Add 'class QWidget' declaration
+	  - Remove inappropriate #ifndef QT_NO_STRINGLIST. QStringList is now
+	    required feature for immodule. See also changes of qfeatures.h
+	* src/input/qinputcontextfactory.cpp
+	  - Add #include "qinputcontext.h"
+	  - Remove unnecessary #include "qpopupmenu.h"
+	  - Remove inappropriate #ifndef QT_NO_STRINGLIST. QStringList is now
+	    required feature for immodule. See also changes of qfeatures.h
+	
+	* src/tools/qfeatures.h
+	  - Define QT_NO_IM if QT_NO_STRINGLIST is defined
+	  - Define QT_NO_IM_EXTENSIONS if QT_NO_IM or QT_NO_STRINGLIST is
+	    defined
+	
+	* plugins/src/inputmethods/inputmethods.pro
+	  - Rename conditional configuration symbol from "im" to "inputmethod"
+	    inaccordance with chanege of configure script
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h
+	  - (identifierName, language): Change return type from QCString to
+	    QString
+	
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp
+	  - (identifierName, language): Change return type from QCString to
+	    QString
+	  - (createImSelPopup): Replace QString::find() which is deprecated in
+	    Qt4 with QString::startsWith()
+	
+	* plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp
+	  - (create): Replace QString::find() which is deprecated in Qt4 with
+	    QString::startsWith()
+	
+	* plugins/src/inputmethods/xim/qximinputcontext.h
+	  - (language): Change return type from QCString to QString
+	  - (identifierName):
+	    * Change return type from QCString to QString
+	    * Move inline implementation to qximinputcontext_x11.cpp
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - (language): Change return type from QCString to QString
+	  - (identifierName):
+	    * Change return type from QCString to QString
+	    * Move implementation from qximinputcontext.h
+	  - (language): Replace QString::find() which is deprecated in Qt4 with
+	    QString::startsWith()
+	
+2004-08-19  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (keys): Modify the function description comment
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (create_manager): Fix plugin directory from "/input" to "/inputmethods"
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (KeyTbl): Add translations for Japanese and Korean alias keys
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit disables default IM configuration feature using qtrc and
+	  qtconfig in BC mode. See following discussion for further
+	  information.
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000416.html
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (x11_apply_settings): 
+	    * Move immodule handling into #ifndef QT_NO_IM rather than QT_NO_XIM
+	    * Move qtrc handling into #ifndef QT_NO_IM_EXTENSIONS
+	
+	* src/inputmethods/imsw-multi/qmultiinputcontext.cpp
+	  - (QMultiInputContext): Move qtrc handling into #ifndef
+	    QT_NO_IM_EXTENSIONS
+	
+	* tools/qtconfig/mainwindow.cpp
+	  - (MainWindow): Move qtrc handling into #ifndef QT_NO_IM_EXTENSIONS
+	
+	* src/kernel/qt_x11.pri
+	  - Remove unnecessary configuration
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	Merge differences between qt-x11-free-3.3.2 and qt-x11-free-3.3.3
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/imsw-multi/imsw-multi.pro
+	* plugins/src/inputmethods/simple/simple.pro
+	* plugins/src/inputmethods/imsw-none/imsw-none.pro
+	* plugins/src/inputmethods/xim/xim.pro
+	  - Remove inappropriate 'thread' from CONFIG. Thanks to Takumi
+	    Asaki for reporting
+	
+2004-08-18  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* tools/qtconfig/mainwindow.cpp
+	  - (MainWindow): Modify a comment
+	  - (fileSave): Fix inappropriate /qt/DefaultInputMethodSwitcher
+	    overwriting. Thanks Takumi Asaki for the reporting
+	
+2004-08-17  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/imsw-multi/imsw-multi.pro
+	* plugins/src/inputmethods/simple/simple.pro
+	* plugins/src/inputmethods/imsw-none/imsw-none.pro
+	* plugins/src/inputmethods/xim/xim.pro
+	  - Change plugin directory from $QTDIR/plugins/input/ to
+	    $QTDIR/plugins/inputmethods/
+	* changes.immodule
+	  - Add a description for the change of plugin directory
+	
+2004-08-17  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qnamespace.h
+	  - (Qt::Key) Add a comment about Korean-specific keyboard
+	    support based on the information from Choe Hwanjin. Thanks
+	    for the information. See following discussion for further
+	    information
+	    http://freedesktop.org/pipermail/immodule-qt/2004-August/000402.html
+	  - (Qt::Key) Comment out some Korean-specific keys that has an
+	    equivalent generic key
+	
+2004-08-14  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This is preparation for qt-x11-immodule-unified-qt3.3.2-20040814
+	
+	* ChangeLog.immodule
+	  - Update
+	
+2004-08-14  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* changes.immodule
+	  - Add and modify some descriptions
+	
+	* configure
+	  - Rewrite some codes to avoid patch rejection against Qt
+	    3.3.3. Logically equivalent.
+	* src/widgets/qtextedit.cpp
+	  - Rewrite some codes to avoid patch rejection against Qt
+	    3.3.3. Logically equivalent.
+	* src/widgets/qlineedit.cpp
+	  - Rewrite some codes to avoid patch rejection against Qt
+	    3.3.3. Logically equivalent.
+	
+2004-08-13  LiuCougar  <liucougar@gmail.com>
+	
+	cleanup: get rid of some warnings
+2004-08-12  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* changes.immodule
+	  - New file. This file has been written for both users and
+	    developers to inform important changes
+	
+2004-08-12  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This is preparation for qt-x11-immodule-unified-qt3.3.2-20040812
+	
+	* ChangeLog.immodule
+	  - Update
+	
+2004-08-12  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext, createInputContext): Fix qic location
+	  - (destroyInputContext): Add safety check
+	
+2004-08-12  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* configure
+	  - Fix incomplete qconfig configuratoin about QT_NO_IM and
+	    QT_NO_IM_EXTENSIONS
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext, createInputContext, destroyInputContext): Fix
+	    invalid pointer reference
+	
+2004-08-12  LiuCougar  <liucougar@gmail.com>
+	
+	fixed a compile issue in my gentoo box (gcc 3.3.3, glibc 2.3.3
+2004-08-12  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* configure
+	  - Fix option consistency handling between '-im' and '-im-ext'
+	
+	* README.immodule
+	  - Fix a typo
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* README.immodule
+	  - Modify a little
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* README.immodule
+	  - New file. Some explanation has been described
+	
+	* ChangeLog.immodule
+	  - New file
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - (language): Remove QLocale dependency to be compiled on Qt 3.2.x
+	    or earlier
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit merges 'Binary Compatible branch' into the trunk to
+	  reduce maintenance cost. Now binary compatibility is
+	  configurable. Binary incompatible features are surrounded by
+	  #ifndef QT_NO_IM_EXTENSIONS
+	
+	* configure
+	  - Add '-im' option to enable immodule feature (default yes).
+	  - Add '-im-ext' option to enable more immodule extensions (default
+	    no). Specify this option 'no' to keep binary compatibility with
+	    standard Qt3
+	
+	* src/kernel/qt_x11.pri
+	  - Add conditional QT_NO_IM and QT_NO_IM_EXTENSIONS definition in
+	    accordance with '-im' and '-im-ext' options
+	
+	* src/kernel/qwidget.h
+	  - (icHolderWidget): New function for QT_NO_IM_EXTENSIONS
+	  - (ic): Add #ifndef QT_NO_IM_EXTENSIONS for binary incompatible
+	    variable
+	  - (xic): Add #ifdef QT_NO_IM_EXTENSIONS for binary compatible
+	    variable
+	* src/kernel/qwidget_x11.cpp
+	  - (create): Add #ifndef QT_NO_IM_EXTENSIONS
+	  - (destroy): Make some codes QT_NO_IM_EXTENSIONS independent
+	  - (createTLSysExtra): Add a code fragment for QT_NO_IM_EXTENSIONS
+	  - (deleteTLSysExtra): Modify a comment
+	  - (getInputContext, changeInputContext, createInputContext,
+	    destroyInputContext): Merge code fragments for QT_NO_IM_EXTENSIONS
+	  - (deleteExtra): Merge a comment for QT_NO_IM_EXTENSIONS
+	
+	* src/kernel/qapplication.h
+	  - (locateICHolderWidget, icHolderWidgets, create_xim, close_xim):
+	    New functions for QT_NO_IM_EXTENSIONS
+	* src/kernel/qapplication_x11.cpp
+	  - (create_im, close_im): Add #ifndef QT_NO_IM_EXTENSIONS
+	  - (create_xim, close_xim): Merge functions for QT_NO_IM_EXTENSIONS
+	  - (qt_init_internal, qt_cleanup): Merge code fragments for
+	    QT_NO_IM_EXTENSIONS
+	
+	* plugins/src/inputmethods/inputmethods.pro
+	  - Make plugin compilations configurable with '-im' option
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/xim/qximinputcontext.h
+	  - Replace QXIMINPUTCONTEXT_P_H with QXIMINPUTCONTEXT_H
+	
+	* src/widgets/qlineedit.cpp
+	  - (QLineEditPrivate::updateMicroFocusHint): Modify the comment a
+	    little
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is participating with recent 'keyword static of C++'
+	  discussion.  See
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000344.html
+	  for further information
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (QETWidget::translateKeyEventInternal): Prevent interwidget key
+	    state transition about RTL extensions. This code had been written
+	    by Daisuke Kameda in qt-x11-immodule-all-qt3.3.1-20040316.diff
+	
+	* src/widgets/qlineedit.cpp
+	  - (QLineEditPrivate::updateMicroFocusHint): Add a comment that
+	    explains that old rect variable is intentionally static
+	
+2004-08-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit turns the argument of QInputContext::filterEvent() into
+	  const. See
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000335.html
+	  for further information
+	
+	* src/kernel/qinputcontext.h
+	  - (filterEvent): Follow the API change
+	* src/kernel/qinputcontext.cpp
+	  - (filterEvent): Follow the API change
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	  - (filterEvent): Follow the API change
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	  - (filterEvent): Follow the API change
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h
+	  - (filterEvent): Follow the API change
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp
+	  - (filterEvent): Follow the API change
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/simple/xcompose2q.rb
+	  - Update to accept Compose flie of X.org's X11R6.7.0
+	  - Accept 'XCOMM' as comment sign to accept raw source file
+	  - Accept both " " and "\"" as valid RHS
+	* plugins/src/inputmethods/simple/composetable.cpp
+	  - Update Compose table from XFree86 4.3.0 to X.org's X11R6.7.0
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit replaces the invalid header words 'This file is
+	  part of the kernel module' of following files with 'This file
+	  is part of the input method module'
+	
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.cpp
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.h
+	* plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h
+	* plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	* plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	* plugins/src/inputmethods/simple/composetable.cpp
+	* plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp
+	* plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h
+	* plugins/src/inputmethods/xim/qximinputcontextplugin.cpp
+	* plugins/src/inputmethods/xim/qximinputcontextplugin.h
+	* plugins/src/inputmethods/xim/qximinputcontext.h
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/simple/xcompose2q.rb
+	  - Fix broken translation entries for most ASCII characters
+	* plugins/src/inputmethods/simple/composetable.cpp
+	  - Translate again with fixed xcompose2q.rb. This fixes many
+	    translation entries involving ascii character such as
+	    "<Multi_key> <space> <minus>"
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/simple/xcompose2q.rb
+	  - New file. This script is used for translating X's Compose
+	    table into QSimpleInputContext's table
+	  - Some bugs included
+	  - Although I had released previous versions of this script
+	    under GPL, I have released this version under another
+	    license. See header
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	  - Follow Trolltech's coding style for Qt3
+	  - Remove unnecessary headers
+	  - (UNITIZE): Moved from qsimpleinputcontext.cpp. QT_ prefix is not
+	    required since a macro does not pollute symbol space
+	  - (struct _ComposeTableElement): Rename to QComposeTableElement
+	  - (struct QComposeTableElement): Renamed from _ComposeTableElement
+	  - (struct _ComposeTable): Rename to QComposeTable
+	  - (struct QComposeTable): Renamed from _ComposeTable
+	  - (isPreeditRelocationEnabled): Remove unnecessary overloading
+	    function
+	  - (isPreeditPreservationEnabled): Remove unnecessary function
+	  - (checkComposeTable): Follow the renaming of the types of args
+	  - (defaultComposeTable): New static member variable
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	  - Separate composing table definition to composetable.cpp
+	  - Remove unnecessary headers
+	  - Replace 'true' and 'false' with 'TRUE' and 'FALSE' to follow
+	    Trolltech's coding style for Qt3
+	  - Replace _ComposeTableElement with QComposeTableElement to follow
+	    the renaming
+	  - Replace ComposeTable with QComposeTable to follow the renaming
+	  - (UNITIZE): Move to qsimpleinputcontext.h
+	  - (defaultTable): Move to composetable.cpp
+	  - (qtComposeTable): Move to composetable.cpp as defaultComposeTable
+	  - (filterEvent):
+	    * Clean up
+	    * Add a comment about key compression
+	    * replace qtComposeTable with defaultComposeTable to follow the
+	      renaming
+	  - (unsetFocus): Remove unnecessary isPreeditPreservationEnabled()
+	    check
+	  - (identifierName): Remove 'FIXME' comment
+	  - (isPreeditRelocationEnabled): Remove unnecessary overloading
+	    function
+	  - (isPreeditPreservationEnabled): Remove unnecessary function
+	
+	* plugins/src/inputmethods/simple/composetable.cpp
+	  - New file. This file has been separated from
+	    qsimpleinputcontext.cpp to achieve following issues
+	    * increase table maintenance ability
+	    * ease editing code part of QSimpleInputContext
+	    * ease development log tracking
+	    * ease copyright tracking
+	    * enclose UTF-8 comments into this file only
+	  - Add original header from Compose file of XFree86 4.3.0
+	  - (defaultTable) Moved from qsimpleinputcontext.cpp
+	  - (defaultComposeTable): New variable definition
+	
+	* plugins/src/inputmethods/simple/simple.pro
+	  - Add composetable.cpp to SOURCES
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp
+	  - (displayName, description): Modify the descriptions appropriately
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - Replace #include "qximinputcontext_p.h" with
+	    "qximinputcontext.h". XIM plugin is now working properly
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit changes the XIM input method into plugin. A little
+	  modification is still required to work. See next commit information
+	
+	* src/input/qinputcontextfactory.cpp
+	  - Remove XIM dependency
+	  - (create, keys): Remove XIM dependent codes
+	
+	* src/input/qt_input.pri
+	  - Remove QXIMInputContext entries
+	* src/input/qximinputcontext_p.h
+	  - Moved to plugins/src/inputmethods/xim/qximinputcontext.h
+	* src/input/qximinputcontext_x11.cpp
+	  - Moved to plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	
+	* plugins/src/inputmethods/inputmethods.pro
+	  - Add xim to SUBDIRS
+	* plugins/src/inputmethods/xim
+	  - New directory
+	* plugins/src/inputmethods/xim/xim.pro
+	  - New file
+	* plugins/src/inputmethods/xim/qximinputcontextplugin.h
+	  - New file
+	  - (class QXIMInputContextPlugin): New class
+	  - (QXIMInputContextPlugin, ~QXIMInputContextPlugin, keys, create,
+	    languages, displayName, description): New function
+	* plugins/src/inputmethods/xim/qximinputcontextplugin.cpp
+	  - New file
+	* plugins/src/inputmethods/xim/qximinputcontext.h
+	  - Moved from src/input/qximinputcontext_p.h. No code changes have
+	    been applied. A little modification is required to work. See next
+	    commit information
+	* plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
+	  - Moved from src/input/qximinputcontext_x11.cpp. No code changes have
+	    been applied
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qximinputcontext_p.h
+	  - (QXIMInputContext): Remove the arg 'widget' to conform to standard
+	    QInputContext API
+	* src/input/qximinputcontext_x11.cpp
+	  - (QXIMInputContext): Remove the arg 'widget' to conform to standard
+	    QInputContext API
+	  - (setHolderWidget): Add QInputContext::setHolderWidget() to fix
+	    inproper overriding
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Remove the arg from QXIMInputContext()
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qximinputcontext_p.h
+	  - (setHolderWidget): New override function
+	* src/input/qximinputcontext_x11.cpp
+	  - (QXIMInputContext): Split most part of the initialization code
+	    into setHolderWidget() to allow null widget. This is required to
+	    make imsw-none working properly
+	  - (setHolderWidget): New function
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (x11_apply_settings): Restrict defaultIM to be an IM-switcher. An
+	    IM-switcher has a 'imsw-' prefix
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit adds imsw-none IM-switcher plugin according to
+	  following discussion with Takumi Asaki. Thanks for the opinion.
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000320.html
+	
+	* plugins/src/inputmethods/inputmethods.pro
+	  - Add imsw-none to SUBDIRS
+	* plugins/src/inputmethods/imsw-none/imsw-none.pro
+	  - New file
+	* plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h
+	  - New file
+	  - (class QNoneInputContextPlugin): New class
+	* plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp
+	  - New file
+	  - (QNoneInputContextPlugin, ~QNoneInputContextPlugin, keys,
+	    languages, displayName, description): New function
+	  - (create): New function. Read key from QT_IM_MODULE or
+	    /qt/DefaultInputMethod of qtrc and creates input context with the
+	    key
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* Rename input method plugin names to accord with other plugin names
+	
+	* plugins/src/inputmethods/imsw-multi/imsw-multi.pro
+	  - Rename plugin name to qimsw-multi from qmultiinputcontextplugin
+	* plugins/src/inputmethods/simple/simple.pro
+	  - Rename plugin name to qsimple from qsimpleinputcontextplugin
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/imsw-multi/multi.pro
+	  - Move to imsw-multi.pro
+	* plugins/src/inputmethods/imsw-multi/imsw-multi.pro
+	  - Move from multi.pro
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* plugins/src/inputmethods/multi
+	  - Move to imsw-multi
+	* plugins/src/inputmethods/imsw-multi
+	  - Move from multi
+	* plugins/src/inputmethods/inputmethods.pro
+	  - Replace 'multi' with 'imsw-multi' in SUBDIRS
+	
+2004-08-10  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	  - add full dead/multi key entries
+	  - fix some bugs
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit changes pluggable popup menu API in accordance with
+	  following discussion with Lars Knoll. Thanks for the advice.
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000300.html
+	
+	* src/kernel/qinputcontext.cpp
+	  - (actions): New function
+	  - (exportMenusInto): Remove to rename to addMenusTo()
+	  - (addMenusTo):
+	    * New function. Renamed from exportMenusInto()
+	    * Follow introduction of enum QInputContextMenu::Action
+	    * Add an explanation for this utility function to the function
+	      description
+	
+	* src/kernel/qinputcontext.h
+	  - (QInputContextMenu::Action): New enum
+	  - (menus): Restrict to use with Qt3 only
+	  - (qt4menus): Remove to replace with actions()
+	  - (actions): New function for Qt4
+	
+	* src/widgets/qtextedit.cpp
+	  - (createPopupMenu): Replace exportMenusInto() with addMenusTo()
+	* src/widgets/qlineedit.cpp
+	  - (createPopupMenu): Replace exportMenusInto() with addMenusTo()
+	
+2004-08-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit changes the two input methods into plugin
+	
+	* src/input/qt_input.pri
+	  - Remove QSimpleInputContext and QMultiInputContext entries
+	* src/input/qmultiinputcontext.h
+	  - Moved to plugins/src/inputmethods/multi/qmultiinputcontext.h
+	* src/input/qmultiinputcontext.cpp
+	  - Moved to plugins/src/inputmethods/multi/qmultiinputcontext.cpp
+	* src/input/qsimpleinputcontext.h
+	  - Moved to plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	* src/input/qsimpleinputcontext.cpp
+	  - Moved to plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	
+	* plugins/src/src.pro
+	  - Add 'inputmethods' to SUBDIRS. The directory name 'inputmethods'
+	    is intended to be compatible with Qt/Embedded. Install directory
+	    name is still kept as 'input' for backward compatibility
+	* plugins/src/inputmethods/inputmethods.pro
+	  - New file
+	
+	* plugins/src/inputmethods/multi/multi.pro
+	  - New file
+	* plugins/src/inputmethods/multi/qmultiinputcontextplugin.h
+	  - New file
+	* plugins/src/inputmethods/multi/qmultiinputcontextplugin.cpp
+	  - New file
+	* plugins/src/inputmethods/multi/qmultiinputcontext.h
+	  - Moved from src/input/qmultiinputcontext.h. No code changes have
+	    been applied
+	* plugins/src/inputmethods/multi/qmultiinputcontext.cpp
+	  - Moved from src/input/qmultiinputcontext.cpp. No code changes have
+	    been applied
+	
+	* plugins/src/inputmethods/simple/simple.pro
+	  - New file
+	* plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h
+	  - New file
+	* plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp
+	  - New file
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.h
+	  - Moved from src/input/qsimpleinputcontext.h. No code changes have
+	    been applied
+	* plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
+	  - Moved from src/input/qsimpleinputcontext.cpp. No code changes have
+	    been applied
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Remove dedicated instantiation handling for
+	    QSimpleInputContext and QMultiInputContext
+	
+	* tools/qtconfig/mainwindow.h
+	  - (inputMethodIdentifiers): New member variable
+	* tools/qtconfig/mainwindow.cpp
+	  - (MainWindow):
+	    * Replace identifier name of input methods with displaynames
+	    * Add filtering out process for IM-switchers that has "imsw-"
+	      prefix
+	    * Disable sorting for input method names
+	    * Modify some comments
+	    * Simplify setCurrentItem() handling for inputMethodCombo widget
+	    * Add recorded input method name to the display name of unknown
+	      input method
+	    * Save recorded input method name even if unknown input method
+	  - (fileSave):
+	    * Save /qt/DefaultInputMethodSwitcher with default value
+	      "imsw-multi"
+	    * Save identifier name of the input method rather than display name
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Update the class description comment
+	
+	* src/input/qinputcontextplugin.cpp
+	  - (class QInputContextPlugin): Update the class description comment
+	  - (keys): Update the function description comment
+	  - (languages, displayName, description): Add the function
+	    description comment
+	
+	
+2004-08-05  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit adds generic pluggable popup menu feature. See
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000266.html
+	  for further information. The implementation may be altered in
+	  accordance with discussion in the list.
+	
+	* src/kernel/qinputcontext.h
+	  - (struct QInputContextMenu): New struct
+	  - (qt4menus): New function. Just a placeholder for now
+	  - (menus): New function
+	  - (exportMenusInto): New function
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Add 'Text widget implementor's guide'
+	    section to the class description comment
+	  - (menus): New function
+	  - (exportMenusInto): New function
+	
+	* src/input/qmultiinputcontext.h
+	  - (qt4menus): New function. Just a placeholder for now
+	  - (menus): New function
+	* src/input/qmultiinputcontext.cpp
+	  - (menus):
+	    * New function to follow new API. The function merges slave menus
+	      and QMultiInputContext's own 'Select Input Method' menu
+	    * The functionality is ported from QLineEdit::createPopupMenu()
+	    * An accelerator has been added as 'Select Input &Method'
+	
+	* src/widgets/qtextedit.cpp
+	  - Remove QMultiInputContext dependency
+	  - (createPopupMenu): Replace QMultiInputContext dependent submenu
+	    handling with the pluggable popup menu
+	* src/widgets/qlineedit.cpp
+	  - Remove QMultiInputContext dependency
+	  - (createPopupMenu): Replace QMultiInputContext dependent submenu
+	    handling with the pluggable popup menu
+	
+	* src/kernel/qwidget.h
+	  - Remove #include "qinputcontext.h" to reduce compile time when we
+	    hacked qinputcontext.h
+	
+2004-08-04  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qmultiinputcontext.cpp
+	  - use QInputContextFactory::description and set whatsthis help
+	
+2004-08-03  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit adds QInputContextFactory::description() feature
+	
+	* src/input/qinputcontextinterface_p.h
+	  - Update the UUID because the interface has been changed
+	  - (description): New function
+	
+	* src/input/qinputcontextplugin.h
+	  - (description): New function
+	
+	* src/input/qinputcontextfactory.h
+	  - (description): New function
+	  - (QInputContextPluginPrivate::description): New function
+	* src/input/qinputcontextfactory.cpp
+	  - (description): New function
+	  - (displayName): Replace fallback value with empty string instead of
+	    null
+	
+2004-08-03  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit alters the configuration convention about
+	  IM-switcher. See
+	  http://freedesktop.org/pipermail/immodule-qt/2004-August/000232.html
+	  for further information. The implementation may be altered in
+	  accordance with discussion in the list.
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (defaultIM): Replace "xim" with "imsw-multi"
+	  - (x11_apply_settings):
+	    * Replace the environment variable name QT_IM_MODULE with
+	      QT_IM_SWITCHER
+	    * Replace the qtrc variable name /qt/DefaultInputMethod with
+	      /qt/DefaultInputMethodSwitcher
+	    * Replace "xim" with "imsw-multi" for default plugin
+	
+	* src/input/qmultiinputcontext.h
+	  - (lastCreatedIMKey): Remove to rename to currentIMKey
+	  - (currentIMKey): New member variable. Renamed from lastCreatedIMKey
+	    because the semantics of the variable has been changed by
+	    introduction of QT_IM_SWITCHER
+	
+	* src/input/qmultiinputcontext.cpp
+	  - Replace lastCreatedIMKey with currentIMKey
+	  - (QMultiInputContext): Add default input method specification
+	    feature using QT_IM_MODULE and /qt/DefaultInputMethod
+	  - (createImSelPopup):
+	    * Add IM-switcher plugin elimination feature using "imsw-" prefix
+	    * Add dispName.isNull() checking
+	    * Apply some rewriting without altering logic for human readability
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Replace the identifier name "multi" with "imsw-multi"
+	
+2004-08-03  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* This commit implements table searching suite
+	
+	- QKeyEvent::text() is restricted to only one character,
+	  so qsimpleic use QChar::unicode() value in case keys are
+	  pressed otherwise composing keys are pressed.
+	
+	- Composing Table is temporally deleted for testing.
+	  Need to prepare proper entries.
+	  Now qsimpleic can deal with capital letter more cleaner way
+	
+	* Next, I introduce X's composing parser to qsimpleic
+	
+2004-08-02  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (x11_apply_settings): Merge the comment about defaultIM
+	    overwritten by r52 from r45
+	
+2004-07-31  LiuCougar  <liucougar@gmail.com>
+	
+	new environment variable QT_IM_MODULE to overwrite the default inputmethod plugin
+2004-07-31  LiuCougar  <liucougar@gmail.com>
+	
+	"deleteLater" is safer then "delete" QObject directly
+2004-07-30  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qnamespace.h
+	  - (Qt::Key):
+	    * Replace dead key values with new one to avoid keycode conflict
+	    * Add a comment about the latin 1 keycodes
+	    * Add some comments about the offset for keycode from X keycode
+	* src/kernel/qevent.cpp
+	  - (key): Add a comment about latin 1 keycodes to the function
+	    description.
+	
+	* src/kernel/qapplication_x11.cpp
+	  - Define define XK_XKB_KEYS to include dead key definitions from
+	    keysymdef.h
+	   - Remove XK_dead_ keys definition
+	
+2004-07-29  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* Change to use displayName() in IM-Switch Popupmenu
+	
+	* src/input/qmultiinputcontext.h
+	  - (keyDict): new variable
+	* src/input/qmultiinputcontext.cpp
+	  - (createImSelPopup): use displanName() on popup and store key in keyDict
+	  - (changeInputMethodWithMenuId): find key from using keyDict
+	
+	* Problem *
+	  - if key=="XIM", displayName(key) is QString::null
+	* Wish *
+	  - add "virtual QString description( const QString &key ) = 0;" for showing the description of IM on PopupMenu as a whatsthis help
+	
+2004-07-28  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qinputcontextinterface_p.h
+	  - Update the UUID because the interface has been changed
+	  - (languages): New function
+	  - (displayName): New function
+	
+	* src/input/qinputcontextplugin.h
+	  - (languages): New function
+	  - (displayName): New function
+	* src/input/qinputcontextplugin.cpp
+	  - (QInputContextPluginPrivate::languages): New function
+	  - (QInputContextPluginPrivate::displayName): New function
+	
+	* src/input/qinputcontextfactory.h
+	  - (languages): New function
+	  - (displayName): New function
+	* src/input/qinputcontextfactory.cpp
+	  - (languages): New function
+	  - (displayName): New function
+	
+2004-07-27  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qinputcontext.h
+	  - (deletionRequested): New signal. Added for fatal error handling
+	* src/kernel/qinputcontext.cpp
+	  - (deletionRequested): Add the function description comment
+	* src/kernel/qwidget.h
+	  - (destroyInputContext): Change ordinary function to slot to receive
+	    the signal QInputContext::deletionRequested()
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext, createInputContext):
+	    * Connect deletionRequested() signal of qic to destroyInputContext()
+	    * Follow renaming of QApplication::imEventReceived() to postIMEvent()
+	  - (destroyInputContext): Modify the function description comment
+	
+	* src/input/qximinputcontext_p.h
+	  - (close): New function
+	* src/input/qximinputcontext_x11.cpp
+	  - (close_xim):
+	    * Remove invalid QApplication::close_im() invocation
+	    * Add proper finalization using deletionRequested() signal
+	  - (close): New function
+	
+	* src/kernel/qapplication.h
+	  - (imEventReceived): Remove this inappropriate name to rename to
+	    postIMEvent()
+	  - (postIMEvent): New slot. Renamed from imEventReceived()
+	* src/kernel/qapplication_x11.cpp
+	  - (imEventReceived): Remove this inappropriate name to rename to
+	    postIMEvent()
+	  - (postIMEvent): New slot. Renamed from imEventReceived()
+	  - (close_im): Remove unused commented out code. The code had already
+	    been moved to qximinputcontext.cpp
+	
+	* src/input/qmultiinputcontext.h
+	  - (destroyInputContext): New slot
+	  - (imEventReceived): Remove this inappropriate name to rename to
+	    postIMEvent()
+	  - (postIMEvent): New slot. Renamed from imEventReceived()
+	* src/input/qmultiinputcontext.cpp
+	  - (QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX): New macro. Defined as default
+	  - (filterEvent): Insert #ifdef QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX
+	  - (destroyInputContext): New slot. Processes deletionRequested from slave
+	  - (imEventReceived): Remove this inappropriate name to rename to
+	    postIMEvent()
+	  - (postIMEvent): New slot. Renamed from imEventReceived()
+	  - (slave):
+	    * Add proper instanciation code for popup menu mode
+	    * Insert #ifdef QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX
+	  - (changeInputMethod(int)):
+	    * Add error handling for no available input methods
+	    * Insert #ifdef QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX
+	  - (changeInputMethod(QString)):
+	    * Add error handling for no available input methods
+	    * Add default selection for null key
+	    * Connect deletionRequested() signal
+	    * Fix debug message
+	* src/widgets/qtextedit.cpp
+	  - (createPopupMenu):
+	    * Add NULL check for input context
+	    * Replace the label "SelectInputMethod" with "Select Input Method"
+	* src/widgets/qlineedit.cpp
+	  - (createPopupMenu):
+	    * Add NULL check for input context
+	    * Replace the label "SelectInputMethod" with "Select Input Method"
+	
+2004-07-27  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext):
+	    * Remove unnecessary createInputContext()
+	    * Reorder the code fragments to reduce temporal memory consumption
+	
+2004-07-27  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment and variable name update. No actual code is
+	  modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Modify the class description comment
+	  - (filterEvent): Mark the argument as /* const */ to make it const
+	    in future
+	  - (reset): Add a requirement to the function description comment for
+	    reimplementation
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (locateICHolderWidget, icHolderWidgets, changeAllInputContext):
+	    Modify the function description comment
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext):
+	    * Rename 'name' with 'identifierName' to eliminate the ambiguity
+	    * Modify the function description comment
+	    * Modify a comment
+	    * Follow Trolltech's coding style
+	  - (createInputContext):
+	    * Modify the function description comment
+	    * Modify a comment
+	  - (resetInputContext): Modify the function description comment
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (defaultIM): Modify the comment
+	  - (changeAllInputContext):
+	    * Rename 'name' with 'identifierName' to eliminate the ambiguity
+	    * Follow Trolltech's coding style
+	  - (defaultInputMethod): Modify the function description comment
+	  - (x11_apply_settings): Modify a comment
+	
+	* src/input/qinputcontextplugin.cpp
+	  - (class QInputContextPlugin): Modify the class description comment
+	  - (create): Modify the function description comment
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Modify the function description comment
+	
+2004-07-24  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qinputcontext.cpp
+	  - Add #if defined(Q_WS_X11) around X11 platform specific
+	    functions. these functions cannot be moved to
+	    qinputcontext_x11.cpp at now since the QInputContextPrivate is
+	    defined in qinputcontext.cpp. This will be fixed in porting to
+	    Qt4.
+	  - (filterEvent): Add the function description comment according
+	    with the Simplified API (filtering precedence, key compression)
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (locateICHolderWidget, icHolderWidgets, changeAllInputContext):
+	    Modify the function description comment
+	
+2004-07-24  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment update. No code is modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Add the class description comment according
+	    with the Simplified API (preedit relocation is done, not entirely
+	    completed yet)
+	
+2004-07-24  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit contains the fixes in response to Lars Knoll's
+	  advice. Thanks for the advice.
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (x11_apply_settings): Remove trUtf8() from "xim" to specify the
+	    default input method
+	
+	* src/kernel/qapplication_x11.cpp, src/input/qximinputcontext_x11.cpp
+	  - (ximServer, xim_preferred_style, composingKeycode, input_mapper):
+	    Add qt_ prefix to avoid symbol space pollution
+	  - (qt_ximServer, qt_xim_preferred_style, qt_ximComposingKeycode,
+	    qt_input_mapper): Renamed from above one
+	
+2004-07-24  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment update. No code is modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Modify several expressions
+	
+2004-07-23  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment update. No code is modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Add the class description comment according
+	    with the Simplified API (preedit preservation is done, not
+	    entirely completed yet)
+	  - (QInputContext, focusWidget, setFocusWidget, isComposing,
+	    setFocus, unsetFocus): Modify a typo in the function description
+	    comment
+	
+2004-07-23  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qsimpleinputcontext.cpp
+	  - Modify the file header description
+	* src/input/qmultiinputcontext.cpp
+	  - Modify the file header description
+	* src/input/qsimpleinputcontext.h
+	  - Modify the file header description
+	* src/input/qmultiinputcontext.h
+	  - Modify the file header description
+	
+2004-07-23  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qsimpleinputcontext.h
+	  - Add a copyright and license header
+	
+	* src/input/qsimpleinputcontext.cpp
+	  - Add a copyright and license header
+	
+2004-07-23  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment update. No code is modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContext): Add the class description comment according
+	    with the Simplified API (not completed yet)
+	  - (QInputContext): Modify a expression in the function description
+	    comment
+	  - (sendIMEventInternal, font): Modify a typo in the function
+	    description comment
+	
+2004-07-23  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qsimpleinputcontext.cpp
+	  - OOps. fix typo.
+	
+2004-07-23  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qsimpleinputcontext.cpp
+	  - follow Qt coding rule
+	  - more valid capitalize case 
+	
+2004-07-23  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qinputcontextfactory.cpp
+	  - enable QSimpleInputContext by specifying in qtrc "DefaultInputMethod=simple"
+	
+2004-07-23  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* This commit add simple table based InputContext for dead/multi key support
+	
+	* src/input/qsimpleinputcontext.h, src/input/qsimpleinputcontext.cpp
+	  - simple table based InputContext
+	
+2004-07-22  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* kernel/qapplication_x11.cpp, kernel/qnamespace.h
+	  - add dead key entries
+	
+2004-07-22  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit is a comment update. No code is modified.
+	
+	* src/kernel/qinputcontext.cpp
+	  - (holderWidget, setHolderWidget, focusWidget, setFocusWidget,
+	    releaseComposingWidget, isPreeditRelocationEnabled, isComposing,
+	    sendIMEventInternal, sendIMEvent): Add the function description comment
+	    according with the Simplified API
+	  - (QInputContext, setFocus, unsetFocus): Update the function
+	    description comment according with the Simplified API
+	  - (~QInputContext, imEventGenerated): Add the function description
+	    comment
+	  - (reset, identifierName, language, filterEvent): Update the
+	    function description comment
+	  - (setMicroFocus, mouseHandler, reset, identifierName, language):
+	    Modify a expression in the function description comment
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (icHolderWidget, resetInputContext, focusInputContext,
+	    unfocusInputContext, sendMouseEventToInputContext): Update the
+	    function description comment
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (imEventReceived): Update the function description comment
+	
+2004-07-21  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qmultiinputcontext.h
+	  - (createImSelPopup): new function
+	  - (changeInputMethodWithMenuId): new slot
+	  - (changeInputMethod(QString)): new function
+	  - (popup): new variable
+	  - (lastCreatedIMKey): new variable
+	
+	* src/input/qmultiinputcontext.cpp
+	  - add #ifndef QT_NO_IM
+	  - (createImSelPopup): create QPopupMenu object which can switch IM.
+	    Currently selected IM is marked as checked.
+	
+	* src/input/qinputcontextfactory.h
+	  - remove "class QPopupMenu"
+	
+	* src/widget/qtextedit.cpp
+	  - add im-switch popup to the menu which is shown when widget is right-clicked.
+	
+	* src/widget/qlineedit.cpp
+	  - add im-switch popup to the menu which is shown when widget is right-clicked.
+	
+2004-07-21  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qinputcontext.cpp
+	  - (filterEvent, setMicroFocus, mouseHandler): Update the function
+	    description comment according with the Simplified API
+	  - (reset, identifierName, language): Update the function description
+	    comment
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qmultiinputcontext.cpp
+	  - (changeInputMethod): Fix invalid imIndex circulation. Thanks
+	    to Kazuki for reporting
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit enables a flexible signal connection
+	  configuration. Default behavior is based on Cougar's
+	  suggestion. Thanks.
+	
+	* src/input/qmultiinputcontext.h
+	  - (beIndirectlyConnected): New instance variable
+	
+	* src/input/qmultiinputcontext.cpp
+	  - (QMultiInputContext): Add beIndirectlyConnected to initializer list
+	  - (imEventReceived): Add a function description comment
+	  - (changeInputMethod): Connect imEventGenerated signal of slave
+	    according with beIndirectlyConnected. The default behavior is
+	    changed as directly connected to imEventGenerated signal of this
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (setMicroFocusHint): Update the comment about XIM handling
+	  - (focusInputContextunfocusInputContext,
+	    sendMouseEventToInputContext): Add the function description comment
+	
+	* src/kernel/qinputcontext_x11.cpp
+	  - (x11FilterEvent): Update the function description comment
+	    according with the Simplified API
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qmultiinputcontext.cpp
+	  - (changeInputMethod): Fix the conversion to const char * from
+	    identifierName()
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/input/qximinputcontext_p.h
+	  - (identifierName): Replace the result "XIM" with "xim" to be
+	    consistent with corresponding immodule of GTK+
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (defaultIM, x11_apply_settings): Replace "XIM" with "xim"
+	
+	* src/input/qinputcontextfactory.cpp
+	  - (create, keys): Replace "XIM" with "xim"
+	
+	* tools/qtconfig/mainwindow.cpp
+	  - (MainWindow): Replace "XIM" with "xim"
+	
+2004-07-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit enables QInputContext proxying, and provide an
+	  experimental immodule-switcher QMultiInputContext as its
+	  examples. The changes is following.
+	
+	  1. Use signal to deliver QIMEvent instead of explicit
+	     postEvent(). This enables QIMEvent proxying and better platform
+	     abstraction. Corresponding slot is created as
+	     QApplication::imEventReceived().
+	
+	  2. Move some methods of QInputContext to public from protected or
+	     private. This enables that proxy-IM can access slave methods.
+	
+	  3. Make some methods of QInputContext virtual. This enables
+	     overriding the methods as proxy
+	
+	  4. Rename QInputContext::name() to identifierName() to avoid
+	     conflicting with QObject::name()
+	
+	  This patch does not break binary compatibility from vanilla Qt3.
+	  But it costs immodule developer small modification.
+	
+	* src/kernel/qinputcontext.h
+	  - (class QInputContext): Inherit QObject and add Q_OBJECT macro
+	  - (name): Remove to rename to identifierName() to avoid conflicting
+	    with QObject::name()
+	  - (identifierName): New function. Renamed from name()
+	  - (isComposing, isPreeditRelocationEnabled): Move to public from
+	    protected to allow proxying
+	  - (setFocusWidget,setHolderWidget, releaseComposingWidget): Move to
+	    public from private to allow proxying
+	  - (focusWidget, holderWidget):
+	    * Make public from protected
+	    * Make virtual to allow overriding the method as proxy
+	  - (imEventGenerated): New signal
+	
+	* src/kernel/qinputcontext.cpp
+	  - (QInputContext): Add QObject() to initializer list
+	  - (sendIMEventInternal): Replace QApplication::postEvent with signal
+	    emitting according to the change
+	  - (name): Remove to rename to identifierName() to avoid conflicting
+	    with QObject::name()
+	  - (identifierName):
+	    * New function. Renamed from name()
+	    * Return type has changed to QCString from QString to avoid using
+	      of i18n string and confusing this with display name for endusers
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (changeInputContext): Add QObject::connect() to follow the change
+	    of IMEvent flow
+	  - (createInputContext): Add QObject::connect() to follow the change
+	    of IMEvent flow
+	
+	* src/kernel/qapplication.h
+	  - (imEventReceived): New slot
+	* src/kernel/qapplication_x11.cpp
+	  - (imEventReceived): New slot to relay QIMEvent to event queue using
+	    postEvent()
+	
+	* src/input/qmultiinputcontext.h
+	  - New file. Copyright and licensing information is temporarily
+	    adapted to our cirmumstances
+	  - (QMultiInputContext): New class
+	  - (QMultiInputContext): New function
+	  - (~QMultiInputContext): New function
+	  - (identifierName): New function
+	  - (language): New function
+	  - (x11FilterEvent): New function. Added based on Cougar's
+	    advice. Thanks
+	  - (filterEvent): New function
+	  - (reset): New function
+	  - (setFocus): New function
+	  - (unsetFocus): New function
+	  - (setMicroFocus): New function
+	  - (mouseHandler): New function
+	  - (font): New function
+	  - (isComposing): New function
+	  - (isPreeditRelocationEnabled): New function
+	  - (focusWidget): New function
+	  - (holderWidget): New function
+	  - (setFocusWidget): New function
+	  - (setHolderWidget): New function
+	  - (releaseComposingWidget): New function
+	  - (slave): New function
+	  - (slave): New function (const QInputContext *slave() const)
+	  - (changeInputMethod): New function
+	  - (imEventReceived): New slot
+	* src/input/qmultiinputcontext.cpp
+	  - New file. Copyright and licensing information is temporarily
+	    adapted to our cirmumstances
+	  - (QMultiInputContext): New function
+	  - (~QMultiInputContext): New function
+	  - (identifierName): New function
+	  - (language): New function
+	  - (x11FilterEvent): New function. Added based on Cougar's
+	    advice. Thanks
+	  - (filterEvent): New function. Filters Control+Alt+Key_Down and
+	    Control+Alt+Key_Up as IM selection keys as temporary
+	    implementation. We should show popup menu
+	  - (reset): New function
+	  - (setFocus): New function
+	  - (unsetFocus): New function
+	  - (setMicroFocus): New function
+	  - (mouseHandler): New function
+	  - (font): New function
+	  - (isComposing): New function
+	  - (isPreeditRelocationEnabled): New function
+	  - (focusWidget): New function
+	  - (holderWidget): New function
+	  - (setFocusWidget): New function
+	  - (setHolderWidget): New function
+	  - (releaseComposingWidget): New function
+	  - (slave): New function
+	  - (slave): New function (const QInputContext *slave() const)
+	  - (changeInputMethod): New function
+	  - (imEventReceived): New slot
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Add QMultiInputContext instanciation. Use the name
+	    "multi" to specify it
+	* src/input/qinputcontextfactory.h
+	  - Add #include "qinputcontext.h" to avoid compilation error
+	
+	* src/input/qximinputcontext_p.h
+	  - (class QXIMInputContext): Add Q_OBJECT macro to follow the API change
+	  - (name): Remove to follow the API change
+	  - (identifierName):
+	    * New function. Renamed from name()
+	    * Return type has changed to QCString from QString to follow the
+	      API change
+	  - (isPreeditRelocationEnabled): Move to public from protected to
+	    follow the API change
+	  - (isComposing): Remove unnecessary access permission breaker
+	    because QInputContext::isComposing() have made public
+	* src/input/qximinputcontext_x11.cpp
+	  - (isComposing): Remove unnecessary access permission breaker
+	    because QInputContext::isComposing() have made public
+	
+	* src/input/qt_input.pri
+	  - Add qmultiinputcontext.h and multiinputcontext.cpp
+	
+2004-07-18  LiuCougar  <liucougar@gmail.com>
+	
+	use virtual insert version to make subclasses work as expected (merged from bc-branch r19)
+2004-07-16  Kazuki Ohta  <mover@hct.zaq.ne.jp>
+	
+	* src/input/qinputcontextfactory.h: not the definition of QInputContextPlugin
+	
+2004-07-13  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qapplication_x11.cpp
+	  - (x11ProcessEvent): Add comment for key event filtering considerations
+	  - (QETWidget::translateKeyEvent): Add comment for key compression
+	    considerations
+	
+2004-07-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* src/kernel/qwidget.h
+	  - (sendMouseEventToInputContext): Move into #if defined(Q_WS_X11)
+	    because it is not implemented in other platforms
+	
+2004-07-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* This commit fixes a mismerge with my Simplified API patches
+	
+	* src/kernel/qwidget_x11.cpp
+	  - (destroyInputContext): Replace the code with original Simplified
+	    API patch. See the comment to recognize the original intention
+	  - (focusInputContext): Fix a condition to call qic->setFocus() as
+	    originally written. See added comment to recognize the original
+	    intention
+	
+	* src/kernel/qwidget.h
+	  - (changeInputContext): Move into #if defined(Q_WS_X11) as
+	    originally written because it is not implemented in other
+	    platforms
+	
+	* src/input/qximinputcontext_p.h
+	  - (mouseHandler): Fix a typo as originally written
+	
+	* src/input/qximinputcontext_x11.cpp
+	  - Fix a comment location to express original intention
+	
+2004-07-08  LiuCougar  <liucougar@gmail.com>
+	
+	replace sendEvent with postEvent in qinputcontext to improve the process performance of IMCompose events
+2004-07-08  YamaKen  <yamaken@bp.iij4u.or.jp>
+	
+	* Insert the comment 'UPDATED COMMENT REQUIRED' into some places for future
+	  modifications
+	* Modify some comments
+	* Replace 'InputMethod' in some comments with 'input method'
+	* Replace 'InputContext' in some comments with 'input context'
+	
+	* src/kernel/qinputcontext.h
+	  - Move description of QInputContext to qinputcontext.cpp
+	* src/kernel/qinputcontext.cpp
+	  - Move description of QInputContext from qinputcontext.h
+	
+2004-07-07  Daisuke Kameda  <kaminmat@cc.rim.or.jp>
+	
+	Adding the function which realize mapping arbitrary input context and widget:
+	QApplication::locateICHolderWidget()
+	QApplication::icHolderWidgets()
+	QWidget::icHolderWidget()
+	QWidget::getInputContext()
+	
+	Adding the function which changes input method:
+	QApplication::changeAllInputContext()
+	QWidget::changeInputContext()
+	QApplication::defaultInputMethod()
+	
+	change QApplication::create_xim() to QApplication::create_im()
+	change QApplication::close_xim() to QApplication::close_im()
+	
+	
+2004-07-06  Daisuke Kameda  <kaminmat@cc.rim.or.jp>
+	
+	"QLineEdit should only setMicroFocus if the cursorRect has changed" by cougar
+	
+2004-07-06  Daisuke Kameda  <kaminmat@cc.rim.or.jp>
+	
+	Re-Creating immodule for Qt/X11 trunk
+
+2004-06-22  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qinputcontext.h
+	  - (sendIMEvent): Private version of sendIMEvent(). Remove to
+	    rename to sendIMEventInternal
+	  - (sendIMEventInternal): Rename from sendIMEvent and accept
+	    discrete variables rather than QEvent *e to be adaptable
+	    to Qt/Embedded
+	* src/kernel/qinputcontext.cpp
+	  - (sendIMEvent): Protected version of sendIMEvent(). Move
+	    QEvent construction to sendIMEventInternal()
+	  - (sendIMEvent): Private version of sendIMEvent(). Remove to
+	    rename to sendIMEventInternal
+	  - (sendIMEventInternal):
+	    * Rename from sendIMEvent
+	    * accept discrete variables rather than QEvent *e to be
+	      adaptable to Qt/Embedded
+	    * Add placeholder for Qt/Embedded
+	  - (setFocusWidget): Follow specification change of sendIMEvent()
+
+2004-06-20  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qevent.h
+	  - (class QIMError): Remove to rename to QIMErrorEvent
+	  - (class QIMErrorEvent): Rename from QIMError
+	  - (QIMErrorEvent::isDeleteIC): Remove to rename to isDeletionRequest
+	  - (QIMErrorEvent::isDeletionRequest): Rename from isDelete
+
+	* src/kernel/qwidget.h
+	  - (imErrorEvent): Follow renaming of QIMError
+	* src/kernel/qwidget.cpp
+	  - (imErrorEvent): Follow renaming of QIMError and
+	    QIMError::isDeleteIC()
+	  - (event): Follow renaming of QIMError
+
+	* src/kernel/qinputcontext.h
+	  - (ownerWidget): Remove to rename to holderWidget
+	  - (holderWidget): Rename from ownerWidget
+	  - (setOwnerWidget): Remove to rename to setHolderWidget
+	  - (setHolderWidget): Rename from setOwnerWidget
+	  - (releaseComposingWidget): New function.
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContextPrivate): Rename ownerWidget to holderWidget
+	  - (ownerWidget): Remove to rename to holderWidget
+	  - (holderWidget): Rename from ownerWidget
+	  - (setOwnerWidget): Remove to rename to setHolderWidget
+	  - (setHolderWidget): Rename from setOwnerWidget
+	  - (sendIMError): Follow renaming of QIMError and
+	    QIMError::isDeleteIC()
+	  - (releaseComposingWidget): New function.
+
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Follow renaming of QInputContext::setOwnerWidget()
+
+	* src/kernel/qwidget_x11.cpp
+	  - (destroy): Add qic->releaseComposingWidget() to reset
+	    preserved composing information involving this widget
+
+2004-06-15  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qwidget_x11.cpp
+	  - (setMicroFocusHint): Replace relative coordinate with
+	    global one for qic->setMicroFocus(). This is required to
+	    share particular IM plugin code with Qt/Embedded
+
+	* src/widgets/qlineedit.cpp
+	  - (sendMouseEventToInputContext): Add button event sending
+	    when clicking on out of preedit
+
+	* src/widgets/qtextedit.cpp
+	  - (sendMouseEventToInputContext): Add button event sending
+	    when clicking on out of preedit
+
+	* src/input/qximinputcontext_p.h
+	  - (isComposing): New function
+	  - (composing, cpos, sellen): Remove to follow API change
+	  - (isPreeditRelocationEnabled): New overriding function to
+	    follow API change
+	  - (isPreeditPreservationEnabled): New function
+
+	* src/input/qximinputcontext_x11.cpp
+	  - (xic_start_callback, xic_draw_callback, xic_done_callback,
+	    x11FilterEvent, reset): Replace qic->composing with
+	    qic->isComposing() to use automatic compose state tracking
+	    of QInputContext
+	  - (QXIMInputContext): Remove composing, cpos, sellen from
+	    initializer list
+	  - (sendIMEvent): Remove remembering of cpos, sellen
+	  - (reset): Replace IMEnd event sending with
+	    QInputContext::reset()
+	  - (resetClientState): Remove cpos, sellen, composing
+	  - (isComposing): Exported interface for xic callbacks to
+	    access protected QInputContext::isComposing()
+	  - (setMicroFocus): Follow API change that replaces relative
+	    coordinate with global one
+	  - (mouseHandler): Add approprate reset on clicking
+	  - (setFocus, unsetFocus): Remove preedit preservation and
+	    relocation to follow API change. They are moved to
+	    QInputContext as generarization
+	  - (isPreeditRelocationEnabled): New function to follow API
+	    change.
+	  - (isPreeditPreservationEnabled): New function. This
+	    indicates that whether preedit state should be preserved
+	    or not when focusing out the widget
+
+2004-06-14  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qinputcontext.h
+	  - (setFocus): Remove hasPreservedPreedit arg
+	  - (unsetFocus): Remove preservePreedit arg
+	  - (isPreeditRelocationEnabled): New function
+	  - (isComposing): New function
+
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContextPrivate): Reorganize variables for
+	    preedit relocation
+	  - (QInputContextPrivate::resetComposingState): New function
+	  - (QInputContextPrivate::updateComposingState): New function
+	  - (setFocusWidget): Add preedit relocation support. Preedit
+	    state is relocated to another text widget when the shared
+	    context has focused on the another text widget. This
+	    feature is mainly used by Japanese input methods
+	  - (isPreeditRelocationEnabled): New function. Preedit
+	    relocation is enabled only if this function returned TRUE.
+	  - (isComposing): New function. Returns current composing
+	    state as result of automatic compose state tracking
+	    through sendIMEvent(). The function is for used by
+	    subclass of QInputContext to know preedit state of the
+	    widget. Although QWidget and QInputContextFactory can
+	    access to the function as friend, they must not use the
+	    function to know composing state of contexts. Keep less
+	    relationship to simplify input method development
+	  - (sendIMEvent): New 1-arg overloaded function. The function
+	    encupsulates platform-dependent IMEvent sending. Only
+	    Q_WS_X11 is supported for now. Q_WS_QWS should be supported
+	  - (sendIMEvent):
+	    * 4-args version of the overloaded function
+	    * Isolate platform-dependent event sending process to
+	      separated function
+	    * Add preedit relocation support
+	    * Add compose state tracking support
+	  - (unsetFocus): Add reset() for simple ephemeral input
+	    contexts
+	  - (mouseHandler): Add reset() when clicking for simple
+	    ephemeral input contexts
+	  - (reset): Add preedit finalization code. Overriding
+	    function should call this function to ensure proper
+	    preedit state
+
+2004-06-11  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qlineedit.cpp
+	  - (QLineEditPrivate::xToPosInternal, QLineEditPrivate::xToPos):
+	    Fix loose placement to tail when clicking beyond the string
+
+2004-06-10  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qinputcontext.h
+	  - Remove several pointers to QWidget to share concrete IM
+	    implementation code with Qt/Embedded. The IM model of
+	    Qt/Embedded requires that widgets and input contexts are
+	    existing in another process
+	  - (QInputContext): Remove the QWidget * arg
+	  - (focusWidget, ownerWidget):
+	    * Move to protected and unrecommended
+	    * Move the inline function definition to qinputcontext.cpp
+	  - (filterEvent): Remove unnecessary keywidget
+	  - (setFocus):
+	    * Remove newFocusWidget arg
+	    * Add hasPreservedPreedit arg
+	  - (unsetFocus): Add preservePreedit arg
+	  - (sendIMError): New function to hide ownerWidget from
+	    derived QInputContext
+	  - (composingWidget, setComposingWidget): New function to support
+	    preedit relocation of shared context on focus transition
+	  - (setFocusWidget, setOwnerWidget): New function to
+	    implement internal functionality on Qt/X11 platform
+	  - (d): New variable to hide ABI change
+	  - (QInputContext, operator=): New function to disable copy
+	    constructor and operator=
+
+	* src/kernel/qinputcontext.cpp
+	  - (class QInputContextPrivate): New class to hide ABI change
+	  - (QInputContext):
+	    * Follow API change
+	    * Follow introducing QInputContextPrivate
+	  - (~QInputContext): Follow introducing QInputContextPrivate
+	  - (ownerWidget):
+	    * Move from qinputcontext.h
+	    * Follow introducing QInputContextPrivate
+	  - (setOwnerWidget): New function to complement removal of
+	    the arg of QInputContext constructor
+	  - (composingWidget, setComposingWidget): New function. These
+	    functions are participating with preedit relocation of shared
+	    context on focus transition
+	  - (focusWidget):
+	    * Move from qinputcontext.h
+	    * Follow introducing QInputContextPrivate
+	    * Follow introducing composingWidget
+	  - (setFocusWidget): New function to complement removal of
+	    the QWidget * arg of setFocus()
+	  - (filterEvent): Follow API change of removal of keywidget
+	  - (sendIMEvent): Add #ifdef to isolate Qt/X11 dependent code
+	  - (sendIMError): New function to hide ownerWidget() from
+	    derived QInputContext. This is required to share particular
+	    IM plugin code with Qt/Embedded
+	  - (setFocus, unsetFocus): Follow API change
+
+	* src/input/qinputcontextfactory.cpp
+	  - (create): Add ownerWidget initialization for new context
+
+	* src/kernel/qwidget.cpp
+	  - (setFocus): Remove unnecessary shared input context
+	    checking
+
+	* src/kernel/qwidget_x11.cpp
+	  - (setActiveWindow): Replace duplicated code with
+	    focusInputContext()
+	  - (getInputContext): Return input context only if
+	    isInputMethodEnabled() widget, otherwise returns 0. This
+	    is required for proper focus transition handling
+	  - (unfocusInputContext): Follow API change of
+	    QInputContext::unsetFocus()
+
+	* src/kernel/qapplication.cpp
+	  - (setActiveWindow): Follow change of QWidget::unfocusInputContext()
+
+	* src/kernel/qapplication_x11.cpp
+	  - (x11ProcessEvent): Follow API change of
+	    QInputContext::filterEvent()
+
+	* src/input/qximinputcontext_p.h
+	  - (setFocus, unsetFocus): Follow API Change
+	  - (hasFocus): New function
+	  - (close): New function
+
+	* src/input/qximinputcontext.cpp
+	  - Remove unrecommended focusWidget() and ownerWidget()
+	  - (ximWidgetList): Remove to replace with ximContextList
+	  - (ximContextList): New variable
+	  - (xic_draw_callback): Replace focusWidget() with hasFocus()
+	    to follow API Change
+	  - (QXIMInputContext):
+	    * Follow API change
+	    * Follow replacing to ximContextList
+	  - (~QXIMInputContext):
+	    * Follow replacing to ximContextList
+	    * Remove unnecessary QInputContext::unsetFocus()
+	  - (close_xim):
+	    * Follow replacing to ximContextList
+	    * Follow API change 
+	  - (close, hasFocus): New function. Exported interface for
+	    xic_draw_callback to access protected features
+	  - (setFocus, unsetFocus): Follow API change
+
+2004-06-09  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qwidget.cpp
+
+	  - (hide): Remove unfocusInputContext(). This caused
+	    excessive invalid QInputContext::unsetFocus().
+	    QWidget::deactivateWidgetCleanup() handles
+	    unfocusInputContext() appropriately via
+	    qApp->setActiveWindow( 0 ).
+
+2004-06-08  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qrichtext_p.h
+	  - (QTextCursor::place): New 5-args overloaded function
+	  - (QTextCursor::place): 3-args version of the function is
+	    reimplemented as inline function using new 5-args one.
+	* src/kernel/qrichtext.cpp
+	  - (QTextCursor::place): Remove 3-args version of the function
+	  - (QTextCursor::place): New 5-args overloaded function. This
+	    is copied from 3-args one and added new args loosePlacing
+	    and matchBetweenCharacters
+
+	* src/widgets/qtextedit.cpp
+	  - (sendMouseEventToInputContext): Send mouse event when only
+	    mouse cursor is placed within preedit area. This is
+	    accomplished by new 5-args QTextCursor::place()
+	  - (contentsContextMenuEvent): Disable context menu when in
+	    IM composing state
+	  - (drawContents): Add updateMicroFocusHint() to follow
+	    dragging of active window by the showed candidate window
+	  - (contentsMouseMoveEvent): Fix cursor vanishing on IM
+	    composing state
+
+	* src/kernel/qlineedit.cpp
+	  - (sendMouseEventToInputContext): Exclude character at
+	    preedit[preeditLength] from being handled as preedit
+	  - (contextMenuEvent): Disable context menu when in IM
+	    composing state
+	  - (focusInEvent): Fix invalid MicroFocusHint position which
+	    caused that candidate window is always showed at end of
+	    the preedit when active window is show() back
+
+2004-06-07  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qwidget_x11.cpp
+	  - (reparentSys): Fix an invalid assumption about input
+	    context location involving destroyInputContext()
+	  - (deleteTLSysExtra): Remove destroyInputContext() because
+	    the input context is not a extra data and should be
+	    destroyed in QWidget::destroy()
+	  - (destroyInputContext): Remove icHolderWidget() because
+	    this function is called to destroy the input context that
+	    belongs to the widget itself
+	  - (destroy): Replace 'this->ic' with 'ic'
+	  - (create): Replace 'this->ic' with 'ic'
+
+	* src/kernel/qwidget.cpp
+	  - (hide): Add unfocusInputContext()
+
+	* src/kernel/qapplication.cpp
+	  - (setActiveWindow): Add unfocusInputContext()
+
+	* src/kernel/qlineedit.cpp
+	  - (QLineEditPrivate::xToPosInternal): New function. Copied
+	      from xToPos and Remove the safety limiter.
+	  - (QLineEditPrivate::xToPos): Reimprement using xToPosInternal
+	  - (sendMouseEventToInputContext):
+	    * Fix position boundary as matching with character
+	      boundary rather than center of character
+	    * Send mouse event when only mouse cursor is placed within
+	      preedit area. This is accomplished by replacing xToPos()
+	      with xToPosInternal()
+
+2004-06-04  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qinputcontext.h
+	  - (font): New function. Returns the font of focusWidget()
+	* src/kernel/qinputcontext.cpp
+	  - (font): New function
+
+	* src/kernel/qwidget_x11.cpp
+	  - (setActiveWindow, focusInputContext): Avoid calling
+	     qic->setFocus() if the target is identical widget
+	  - (setMicroFocusHint, setActiveWindow, createInputContext,
+	     destroyInputContext, resetInputContext,
+	     focusInputContext): Remove obsolete comment around qic
+	     retrieving
+
+	* src/input/qximinputcontext_x11.cpp
+	  - (language): Return Chinese languages appropriately (such
+	     as "zh_CN")
+
+2004-06-03  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/kernel/qinputcontext.h
+	- (getOwnerWidget): Remove to rename to ownerWidget
+	- (ownerWidget): New function. Rename from getOwnerWidget to
+	  be consistent with the name focusWidget
+	- (focusWidget): New function. Add to make IM-related
+	  communication with focusWidget easy. The name is imported
+	  from QApplication::focusWidget to be supposed same role
+	- (language): Change return type to QCString from const char *
+	- (filterEvent): Change args. Passes QEvent *event rather than
+	  preexpanded key event values. This is intended to pass other
+	  IM-related events in future. The IM-related events are
+	  supposed as QWheelEvent, QTabletEvent and so on
+	- (setFocusHint): Remove to be appropriate name
+	- (setMicroFocus):
+	  * Rename from setFocusHint to be appropriate name. This
+	    function instructs 'MicroFocus' rect within a widget that
+	    is different to normal focus for widgets, so the name
+	    'setFocus' is invalid. And 'Hint' is a concept for the
+	    manager of this class and loses the meaning when passed to
+	    this class. The passed values are not a hint but have
+	    well-defined actual effect, so the name 'Hint' is
+	    invalid. Finally, Qt/Embedded 2.3.7 has a samely named
+	    method in QWSInputMethod
+	  * Remove the arg 'widget' to consistent with the new
+	    focusWidget() method
+	- (mouseHandler): New function. The method interface is
+	  imported from QWSInputMethod::mouseHandler() of Qt/Embedded
+	  2.3.7 and extended for desktop system
+	- (sendIMEvent): New function. Conventional function to send
+	  QIMEvent to appropriate widget using focusWidget(). IM
+	  developers can send IMEvents without tracking focuswidget by
+	  themself
+	- (ownerWidget): Remove to Rename to _ownerWidget
+	- (_ownerWidget): New variable. Renamed from ownerWidget to
+	  avoid name conflict with ownerWidget()
+	- (_focusWidget): New variable.
+	* src/kernel/qinputcontext.cpp
+	  - (QInputContext): Follow API change
+	  - (~QInputContext): Clean up
+	  - (filterEvent): Follow API change
+	  - (sendIMEvent): New function.
+	  - (setFocusHint): Remove to follow new API
+	  - (setMicroFocus): copied from setFocusHint and reimplement to
+	    follow new API
+	  - (mouseHandler): New function
+	  - (language): Follow API change
+
+	* src/kernel/qwidget.h
+	  - (sendMouseEventToInputContext): New function
+	  - (unfocusInputContext): New function
+
+	* src/kernel/qwidget.cpp
+	  - (setFocus): Invoke unfocusInputContext() with previous
+	    focus widget to delegate reset responsibility to input
+	    context instead of resetInputContext() directly. See also
+	    comment for further information
+	  - (clearFocus): Add unfocusInputContext();
+	  - (event): Delegate reset responsibility to input context
+	    instead of resetInputContext() directly. See also comment
+	    for further information
+
+	* src/kernel/qwidget_x11.cpp
+	  - (setMicroFocusHint): Modify to follow API change
+	  - (setActiveWindow): Modify to follow API change
+	  - (focusInputContext): Modify to follow API change
+	  - (unfocusInputContext): New function
+	  - (sendMouseEventToInputContext): New function
+
+	* src/kernel/qapplication_x11.cpp
+	  - (class QETWidget): Change translateKeyEventInternal definition
+	  - (x11ProcessEvent): Change QInputContext::filterEvent()
+	    invocation to follow API change
+	  - (translateKeyEventInternal):
+	    * Add new arg statefulTranslation to enable duplicate call
+	    within single event loop. This is required to support both
+	    QInputContext::filterEvent() and RTL extensions
+	    * Restore accidencially omitted qt_mode_switch_remove_mask
+	    handling
+
+	* src/input/qximinputcontext_p.h
+	  - (class QXIMInputContext): Follow API change of QInputContext
+	  - (language): Change return type to follow new API
+	  - (setFocus): Change arg to follow new API
+	  - (setFocusHint): Remove to follow new API
+	  - (setMicroFocus): New method to follow new API
+	  - (mouseHandler): New method to follow new API
+	  - (sendIMEvent): New method (reimp)
+	  - (focusWidget): Remove to follow new API
+	  - (cpos): New variable
+	  - (sellen): New variable
+	* src/input/qximinputcontext_x11.cpp
+	  - (qt_compose_emptied): Remove as result of optimization. It
+	    has become unnecessary now
+	  - (xic_start_callback): Add IMStart event sending as
+	    result of optimization
+	  - (xic_draw_callback): Optimize state management for IMEvent
+	    sending, and simplify using sendIMEvent()
+	  - (xic_done_callback): Simplify using sendIMEvent()
+	  - (QXIMInputContext):
+	    * Follow class definition change
+	    * Follow API change
+	  - (~QXIMInputContext): Modify to follow API change
+	  - (x11FilterEvent): Optimize state management for IMEvent
+	    sending, and simplify using sendIMEvent()
+	  - (sendIMEvent): New function. Implement to remember last
+	    IMEvent information
+	  - (reset): Simplify using sendIMEvent()
+	  - (resetClientState): Follow class definition change
+	  - (setFocusHint): Remove to follow new API
+	  - (setMicroFocus): copied from setFocusHint and modified to
+	    follow new API
+	  - (mouseHandler): New function. Implemented to reset the
+	    context on MouseButtonPress except for Japanese IM. See
+	    also comment for further information
+	  - (setFocus): Reimplement to follow new API. Automatically
+	    handles appropriate IMEvent sending on focus transition
+	  - (unsetFocus): Reimplement to follow new API. Implemented to
+	    reset the context on FocusOut except for Japanese IM. See
+	    also comment for further information
+
+	* src/widgets/qlineedit.h
+	  - (sendMouseEventToInputContext): New function
+	* src/widgets/qlineedit.cpp
+	  - (QLineEditPrivate::composeMode): New function
+	  - (QLineEditPrivate::hasIMSelection): New function
+	  - (QLineEditPrivate::preeditLength): New function
+	  - (QLineEditPrivate::imSelectionLength): New function
+	  - (mousePressEvent, mouseMoveEvent, mouseReleaseEvent,
+	     mouseDoubleClickEvent): Support QInputContext::mouseHandler()
+	  - (sendMouseEventToInputContext): New function. Retrieve the
+	    position and call QWidget::sendMouseEventToInputContext()
+	  - (drawContents): Follow API change
+
+	* src/widgets/qtextedit.h
+	  - (sendMouseEventToInputContext): New function
+	* src/widgets/qtextedit.cpp
+	  - (QTextEditPrivate::composeMode): New function
+	  - (sendMouseEventToInputContext): New function. Retrieve the
+	    position and call QWidget::sendMouseEventToInputContext()
+	  - (imComposeEvent, imEndEvent): Clean up with composeMode()
+	  - (contentsMousePressEvent, contentsMouseMoveEvent,
+	     contentsMouseReleaseEvent, contentsMouseDoubleClickEvent):
+	    Support QInputContext::mouseHandler()
+
+2004-06-01  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* src/input/qximinputcontext_x11.cpp (x11FilterEvent): Fix
+	  commit problem except for on-the-spot style
+
+2004-05-31  YamaKen  <yamaken@bp.iij4u.or.jp>
+
+	* First 'Simplified API' patch. A lot of changes to be described
+
+2004-03-16  Daisuke Kameda  <kaminmat@cc.rim.or.jp>
+
+	* A lot of changes to be described before this date. Almost
+	  of code are written by Daisuke Kameda
diff -r -U2 -N qt-x11-free-3.3.8b/changes.immodule qt-x11-free-3.3.8b/changes.immodule
--- qt-x11-free-3.3.8b/changes.immodule	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/changes.immodule	2009-10-18 14:38:38.728534060 -0700
@@ -0,0 +1,248 @@
+This file describes significant change from
+qt-x11-immodule-bc-qt3.3.2-20040623.
+
+Differences from previous release
+(qt-x11-immodule-unified-qt3.3.3-20040819) are itemized with '+'
+sign. Search it to track incremental change.
+
+****************************************************************************
+*                           For users                                      *
+****************************************************************************
+
+General
+-------
+
++ A strange character inversion problem on some input methods has been
+  fixed
+
+
+Input methods
+-------------
+
+- Added "simple" input method which provides dead/multi key composing
+  for latin languages
+
+
+User Interface
+--------------
+
+- Added input method selection menu in the context menu of text
+  widgets
+
+
+Configuration
+-------------
+
++ default IM configuration feature of qtconfig has been disabled in BC
+  mode. This is a political change to avoid the confusion about input
+  method configuration in accordance with GTK+ environment.
+
+  See following discussion for further information.
+
+  http://freedesktop.org/pipermail/immodule-qt/2004-August/000416.html
+
+- Added new environment variables QT_IM_SWITCHER and QT_IM_MODULE to
+  set user's favorite input method as default. See README.immodule for
+  examples.
+
+
+Build & Install
+---------------
+
++ configure options have been changed for internal reasons. See 'How
+  to install' section of README.immodule
+
+- This version of immodule requires corresponding version of each
+  input method plugins (i.e. update your additional input method
+  plugins)
+
+- Plugin directory has been changed from $QTDIR/plugins/input/ to
+  $QTDIR/plugins/inputmethods/. Delete old directory.
+
+- Some codes have been changed to allow compiling against Qt 3.2.x or
+  earlier.
+
+
+****************************************************************************
+*                          For develpers                                   *
+****************************************************************************
+
+Documents
+---------
+
+- Almost description of QInputContext and QInputContextPlugin has been
+  filled. Feel free to ask obscure things at our mailinglist.
+
+
+New features
+------------
+
+- Pluggable input method switcher
+
+  Now we can write input method switcher as an ordinary input method
+  plugin. The two plugins 'imsw-multi' and 'imsw-none' are provided as
+  default. But the architecture needs more discussion about whether
+  the design is right or not. Join the discussion.
+
+- Pluggable popup menu
+
+  Any input method can provide its own popup menu. See
+  http://freedesktop.org/pipermail/immodule-qt/2004-August/000266.html
+  for further information.
+
+- QInputContext proxying
+
+  Some methods of QInputContext have been changed to enable
+  QInputContext proxying. This feature is required to implement
+  pluggable input method switcher.
+
+
+General
+-------
+
++ QInputContext has been source compatible with Qt4 version. Basic
+  input method plugin can be source compatible without #ifdef. Only
+  pluggable popup menu requires #ifdef'ed different code. In addition,
+  be careful about use of classes that is deprecated in Qt4.
+
+- Our two development tree for Qt3 'Binary Compatible' and 'ALL' have
+  been merged into this unified source tree. The source tree is called
+  'Unified' patch.
+
+- 'dead keys' for latin languages have been added into Qt::Key
+
+- Added plugins/src/inputmethods directory to build input method
+  plugins within the Qt source tree. The directory name 'inputmethods'
+  is intended to be compatible with Qt/Embedded. Install directory
+  name is still kept as 'input' for backward compatibility
+
+- Changed XIM input method to a plugin instead of directly link into
+  libqt
+
+- Plugin directory has been changed from $QTDIR/plugins/input/ to
+  $QTDIR/plugins/inputmethods/. Replace install directory with new
+  one.
+
+- Fixed some bugs in previous qt-x11-immodule-bc-qt3.3.2-20040623. See
+  following log for more detail.
+
+  * src/kernel/qwidget_x11.cpp
+    - (destroyInputContext): Replace the code with original Simplified
+      API patch. See the comment to recognize the original intention
+    - (focusInputContext): Fix a condition to call qic->setFocus() as
+      originally written. See added comment to recognize the original
+      intention
+
+- QLocale dependency has been removed to be compiled on Qt 3.2.x or
+  earlier
+
+- Many internal improvements and cleanups
+
+
+API Changes in qt-x11-immodule-unified-qt3.3.3-20040910
+-------------------------------------------------------
++ QInputContext
+
+  * QInputContext()
+
+    Added 'parent' arg to be compatible with Qt4. Since the arg
+    defaults to 0, no modification of plugins are required.
+
+  * language()
+  * identifierName()
+
+    Return type of these two methods have been changed from QCString
+    which is deprecated in Qt4 to QString to make plugins source
+    compatible with Qt4.
+
+  * addActionsTo()
+
+    New method for Qt4 text widget developer
+
+
+API Changes in qt-x11-immodule-unified-qt3.3.3-20040812
+-------------------------------------------------------
+
+- QInputContext proxying
+
+  QInputContext have been changed as follows to enable QInputContext
+  proxying.
+
+  1. Use signal to deliver QIMEvent instead of explicit
+     postEvent(). This enables QIMEvent proxying and better platform
+     abstraction. Corresponding slot is created as
+     QApplication::imEventReceived().
+
+  2. Move some methods of QInputContext to public from protected or
+     private. This enables that proxy-IM can access slave methods.
+
+  3. Make some methods of QInputContext virtual. This enables
+     overriding the methods as proxy
+
+  4. Rename QInputContext::name() to identifierName() to avoid
+     conflicting with QObject::name()
+
+
+- QInputContext
+
+  * language()
+
+    New method to indicate current language
+
+  * menus()
+
+    New method for the pluggable popup menu feature
+
+  * addMenusTo()
+
+    New method for text widget developer
+
+  * deletionRequested()
+
+    New signal to request deletion of this instance. This is added for
+    fatal error handling
+
+  * identifierName()
+
+    This replaces name() of previous API to avoid conflicting with
+    QObject::name(), and to distinguish the role from displayName()
+
+  * filterEvent()
+
+    Turn the argument into const. See
+    http://freedesktop.org/pipermail/immodule-qt/2004-August/000335.html
+    for further information
+
+  * isComposing
+  * isPreeditRelocationEnabled
+
+    Move to public from protected to allow proxying
+
+  * setFocusWidget
+  * setHolderWidget
+  * releaseComposingWidget
+
+    Move to public from private to allow proxying
+
+  * focusWidget
+  * holderWidget
+
+    - Make public from protected to allow proxying
+    - Make virtual to allow overriding the method as proxy
+
+- QInputContextPlugin
+
+  * languages()
+
+    New method which returns what languages are supported by the
+    QInputContext instance
+
+  * displayName()
+
+    New method which returns a user friendly i18n-ized name of the
+    QInputContext instance
+
+  * description()
+
+    New method which returns a i18n-ized brief description of the
+    QInputContext instance
diff -r -U2 -N qt-x11-free-3.3.8b/configure qt-x11-free-3.3.8b/configure
--- qt-x11-free-3.3.8b/configure	2008-01-15 12:09:15.000000000 -0700
+++ qt-x11-free-3.3.8b/configure	2009-10-18 14:38:38.755209867 -0700
@@ -223,5 +223,5 @@
 
 # licensed modules depend on type of commercial license
-MODULES="styles tools kernel widgets dialogs iconview workspace"
+MODULES="styles tools kernel widgets dialogs iconview workspace inputmethod"
 [ "$PLATFORM_QWS" = "yes" ] && [ "$Products" = "qt-professional" ] && MODULES="$MODULES network"
 [ "$Products" != "qt-professional" ] && MODULES="$MODULES network canvas table xml opengl sql"
@@ -270,4 +270,7 @@
 CFG_GFX_AVAILABLE=
 CFG_STYLE_AVAILABLE=
+#Keep this position for CFG_IM* to avoid patch rejection
+CFG_IM=yes
+CFG_IM_EXT=no
 CFG_TABLET=auto
 CFG_XKB=auto
@@ -401,4 +404,10 @@
 	VAL=no
 	;;
+    #Qt style yes options for immodule
+    #Keep this place to avoid patch rejection
+    -inputmethod|-inputmethod-ext)
+	VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+	VAL=yes
+	;;
     -embedded)
 	VAR=embedded
@@ -1020,4 +1029,18 @@
 	CFG_DLOPEN_OPENGL="$VAL"
 	;;
+    inputmethod)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_IM="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    inputmethod-ext)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_IM_EXT="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
     *)
 	UNKNOWN_OPT=yes
@@ -1899,4 +1922,11 @@
 fi
 
+# immodule extensions
+if [ "$CFG_IM" = "no" ]; then
+    CFG_IM_EXT=no
+fi
+if [ "$CFG_IM_EXT" = "yes" ]; then
+    CFG_IM=yes
+fi
 
 #-------------------------------------------------------------------------------
@@ -2206,4 +2236,18 @@
         XKN=" "
     fi
+    if [ "$CFG_IM" = "no" ]; then
+        IMY=" "
+        IMN="*"
+    else
+        IMY="*"
+        IMN=" "
+    fi
+    if [ "$CFG_IM_EXT" = "no" ]; then
+        IXY=" "
+        IXN="*"
+    else
+        IXY="*"
+        IXN=" "
+    fi
     cat << EOF
 
@@ -2254,4 +2298,12 @@
 			 (instead of linking with OpenGL libraries directly).
 
+ $IMN  -no-inputmethod .... Do not compile immodule (extensible input method)
+			 support.
+ $IMY  -inputmethod ....... Compile immodule support.
+
+ $IXN  -no-inputmethod-ext  Do not compile more immodule extensions support.
+ $IXY  -inputmethod-ext ... Compile more immodule extensions support.
+			 (breaks ABI with standard Qt3).
+
 EOF
 fi
@@ -2987,4 +3039,14 @@
         QMAKE_CONFIG="$QMAKE_CONFIG xkb"
     fi
+    if [ "$CFG_IM" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG inputmethod"
+    elif [ "$CFG_IM" = "no" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IM"
+    fi
+    if [ "$CFG_IM_EXT" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG inputmethod-ext"
+    elif [ "$CFG_IM_EXT" = "no" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IM_EXTENSIONS"
+    fi
 elif [ "$PLATFORM_MAC" = "yes" ]; then
     if [ "$CFG_TABLET" = "yes" ]; then
@@ -3111,5 +3173,5 @@
 #
 #   Modules:
-#     styles tools kernel widgets dialogs iconview workspace
+#     styles tools kernel widgets dialogs iconview workspace inputmethod
 #
 #   Enterprise/Open Source edition modules:
@@ -3119,4 +3181,6 @@
 #     stl
 #
+#     X11     : inputmethod-ext
+#
 # Things that do not affect the Qt API/ABI:
 #     system-jpeg no-jpeg jpeg
@@ -3140,8 +3204,8 @@
 #     ipv6
 #
-#     X11     : xftnameunparse x11sm xinerama xcursor xrandr xrender xftfreetype xkb
+#     X11     : xftnameunparse x11sm xinerama xcursor xrandr xrender xftfreetype xkb inputmethod
 #     Embedded: embedded ft
 #
-ALL_OPTIONS="styles tools kernel widgets dialogs iconview workspace network canvas table xml opengl sql stl"
+ALL_OPTIONS="styles tools kernel widgets dialogs iconview workspace inputmethod network canvas table xml opengl sql stl"
 BUILD_CONFIG=
 BUILD_OPTIONS=
@@ -3157,5 +3221,5 @@
 	;;
 
-    styles|tools|kernel|widgets|dialogs|iconview|workspace|network|canvas|table|xml|opengl|sql|stl)
+    styles|tools|kernel|widgets|dialogs|iconview|workspace|inputmethod|network|canvas|table|xml|opengl|sql|stl)
 	# these config options affect the Qt API/ABI. they should influence
 	# the generation of the buildkey, so we don't skip them
@@ -3504,4 +3568,6 @@
     echo "Xft support ......... $CFG_FREETYPE"
     echo "XKB Support ......... $CFG_XKB"
+    echo "immodule support .... $CFG_IM"
+    echo "immodule ext support  $CFG_IM_EXT"
 elif [ "$PLATFORM_MAC" = "yes" ]; then
     echo "Accessibility ....... $CFG_ACCESSIBILITY"
diff -r -U2 -N qt-x11-free-3.3.8b/configure.orig qt-x11-free-3.3.8b/configure.orig
--- qt-x11-free-3.3.8b/configure.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/configure.orig	2008-01-15 12:09:15.000000000 -0700
@@ -0,0 +1,3801 @@
+#!/bin/sh
+#
+#
+# Configures to build the Qt library
+#
+# Copyright (C) 1999-2008 Trolltech ASA.  All rights reserved.
+#
+
+
+#-------------------------------------------------------------------------------
+# script initialization
+#-------------------------------------------------------------------------------
+
+# the name of this script
+relconf=`basename $0`
+# the directory of this script is the "source tree"
+relpath=`dirname $0`
+relpath=`(cd $relpath; /bin/pwd)`
+# the current directory is the "build tree" or "object tree"
+outpath=`/bin/pwd`
+
+# later cache the command line in config.status
+OPT_CMDLINE=`echo $@ | sed "s,-v ,,g; s,-v$,,g"`
+
+# initialize global variables
+QMAKE_SWITCHES=
+QMAKE_VARS=
+QMAKE_CONFIG=
+
+SUPPORTED=
+
+#-------------------------------------------------------------------------------
+# operating system detection
+#-------------------------------------------------------------------------------
+
+# need that throughout the script
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+
+#-------------------------------------------------------------------------------
+# window system detection
+#-------------------------------------------------------------------------------
+
+PLATFORM_X11=no
+PLATFORM_MAC=no
+PLATFORM_QWS=no
+PLATFORM_QNX=no
+
+if [ -f $relpath/src/kernel/qapplication_mac.cpp ] && [ -d /System/Library/Frameworks/Carbon.framework ]; then
+    # Qt/Mac
+    # ~ the Carbon SDK exists
+    # ~ src/kernel/qapplication_mac.cpp is present
+    # ~ this is the internal edition and Qt/Mac sources exist
+    PLATFORM_MAC=maybe
+elif [ -f $relpath/src/kernel/qapplication_qws.cpp ]; then
+    # Qt/Embedded
+    # ~ src/kernel/qapplication_qws.cpp is present
+    # ~ this is the open source or commercial edition
+    # ~ this is the internal edition and Qt/Embedded is explicitly enabled
+    # ~ this is the internal edition and the OS is QNX
+    if [ "$UNAME_SYSTEM" = "QNX" ]; then
+	PLATFORM_QNX=maybe
+    else
+	PLATFORM_QWS=maybe
+    fi
+fi
+
+
+#-------------------------------------------------------------------------------
+# check commercial license
+#-------------------------------------------------------------------------------
+
+# Qtopia Edition.
+if [ -f $relpath/LICENSE.Qtopia ]; then
+    Edition="qtopia"
+    Licensee="Qtopia"
+    Products="qt-enterprise"
+# Open Source Edition - may only be used under the terms of the QPL or GPL.
+# Qt/X11, Qt/Embedded
+elif [ -f $relpath/LICENSE.QPL -o -f $relpath/LICENSE.GPL2 -o -f $relpath/LICENSE.GPL3 ]; then
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    [ "$PLATFORM_QWS" = "maybe" ] && PLATFORM_QWS=yes
+    Edition="free"
+    Licensee="Free"
+    Products="qt-free"
+# Evaluation version.
+# Qt/X11, Qt/Embedded, Qt/Mac
+elif [ -f $relpath/LICENSE.EVAL ]; then
+    [ "$PLATFORM_QWS" = "maybe" ] && PLATFORM_QWS=yes
+    Edition="eval"
+    Licensee="Evaluation"
+    Products="qt-eval"
+# Internal Trolltech edition.
+# Qt/X11, Qt/Embedded, Qt/Mac, Qt/QNX
+elif [ -f $relpath/LICENSE.TROLL ]; then
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    [ "$PLATFORM_QNX" = "maybe" ] && PLATFORM_QNX=yes
+    Edition="troll"
+    Licensee="Trolltech"
+    Products="qt-internal"
+# Commercial edition - needs a license.
+# Qt/X11, Qt/Embedded, Qt/Mac
+elif [ -f $relpath/.LICENSE ]; then
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    [ "$PLATFORM_QWS" = "maybe" ] && PLATFORM_QWS=yes
+    echo
+    Desc=""
+    if [ -f $HOME/.qt-license ]; then
+	. $HOME/.qt-license >/dev/null 2>&1
+	if [ -z "$LicenseKey" ]; then
+	    echo
+	    echo "You are using an old license file."
+	    echo
+	    echo "Please install the license file supplied by Trolltech,"
+	    echo "or install the Qt Open Source Edition if you intend to develop"
+	    echo "open source software."
+	    exit 1
+	fi
+    else
+	if [ -z "$LicenseKey" ]; then
+	    echo
+	    if echo '\c' | grep '\c' >/dev/null; then
+		echo -n "Please enter your license key: "
+	    else
+		echo "Please enter your license key: \c"
+	    fi
+	    read LicenseKey
+	fi
+    fi
+    if echo $LicenseKey | grep "....-....-...." >/dev/null 2>&1; then
+	# get the first character of the key
+	keyTest=`echo $LicenseKey | cut -b1`
+	# this character should fit the platform
+	if [ "$PLATFORM_QWS" = "yes" ]; then
+	    case $keyTest in
+	    A|B|C|D|E|F|G|H|a|b|c|d|e|f|g|h)
+		# Qt/Embedded
+		echo
+		;;
+	    *)
+		echo
+		echo "You are not licensed for the Qt/Embedded platform."
+		echo
+		echo "Please contact sales@trolltech.com to upgrade your license"
+		echo "to include the Qt/Embedded platform, or install the"
+		echo "Qt Open Source Edition if you intend to develop open source"
+		echo "software."
+		exit 1
+		;;
+	    esac
+	elif [ "$PLATFORM_MAC" = "yes" ]; then
+	    case $keyTest in
+	    *) ###
+		# Qt/Mac
+		echo
+		;;
+	    *)
+		echo
+		echo "You are not licensed for the Qt/Mac platform."
+		echo
+		echo "Please contact sales@trolltech.com to upgrade your license"
+		echo "to include the Qt/Mac platform."
+		exit 1
+		;;
+	    esac
+	else
+	    case $keyTest in
+	    6|7|8|9|E|F|G|H|e|f|g|h)
+		# Qt/X11
+		echo
+		;;
+	    *)
+		echo
+		echo "You are not licensed for the Qt/X11 platform."
+		echo
+		echo "Please contact sales@trolltech.com to upgrade your license to"
+		echo "include the Qt/X11 platform, or install the Qt Open Source Edition"
+		echo "if you intend to develop open source software."
+		exit 1
+		;;
+	    esac
+	fi
+	case $keyTest in
+	4|5|8|9|C|D|G|H|c|d|g|h)
+	    # Enterprise
+	    Products=qt-enterprise
+	    Desc="Enterprise"
+	    Edition="ent"
+	    ;;
+	*)
+	    # Professional
+	    Products=qt-professional
+	    Desc="Professional"
+	    Edition="pro"
+	    ;;
+	esac
+	case $keyTest in
+	3|5|7|9|B|D|F|H|b|d|f|h)
+	    # US
+	    cp -f $relpath/.LICENSE-US $relpath/LICENSE
+	    ;;
+	*)
+	    cp -f $relpath/.LICENSE $relpath/LICENSE
+	    ;;
+	esac
+    else
+	echo
+	echo "Invalid license key. Please check the license key."
+	exit 1
+    fi
+else
+    echo "The LICENSE, LICENSE.QPL, or LICENSE.GPL2 file shipped with"
+    echo "this software has disappeared."
+    echo
+    echo "Sorry, you are not licensed to use this software."
+    echo "Try re-installing."
+    echo
+    exit 1
+fi
+
+# licensed modules depend on type of commercial license
+MODULES="styles tools kernel widgets dialogs iconview workspace"
+[ "$PLATFORM_QWS" = "yes" ] && [ "$Products" = "qt-professional" ] && MODULES="$MODULES network"
+[ "$Products" != "qt-professional" ] && MODULES="$MODULES network canvas table xml opengl sql"
+CFG_MODULES_AVAILABLE=$MODULES
+QMAKE_VARS="$QMAKE_VARS \"QT_PRODUCT=$Products\""
+QMAKE_VARS="$QMAKE_VARS \"styles += windows motif mac platinum sgi cde motifplus\""
+QMAKE_VARS="$QMAKE_VARS \"kbd-drivers += tty\" \"mouse-drivers += pc\""
+
+
+#-------------------------------------------------------------------------------
+# initalize variables
+#-------------------------------------------------------------------------------
+
+# QTDIR may be set and point to an old or system-wide Qt installation
+unset QTDIR
+
+# initalize internal variables
+CFG_CONFIGURE_EXIT_ON_ERROR=yes
+CFG_PROFILE=no
+CFG_EXCEPTION_SUPPORT=unspecified
+CFG_INCREMENTAL=auto
+CFG_QCONFIG=full
+CFG_EMBEDDED=no
+CFG_DEBUG=no
+CFG_SHARED=yes
+CFG_GIF=no
+CFG_THREAD=auto
+CFG_SM=auto
+CFG_XSHAPE=auto
+CFG_XINERAMA=auto
+CFG_BIG_CODECS=yes
+CFG_ZLIB=yes
+CFG_PNG=yes
+CFG_LIBPNG=qt
+CFG_JPEG=auto
+CFG_LIBJPEG=qt
+CFG_MNG=auto
+CFG_LIBMNG=qt
+CFG_XCURSOR=auto
+CFG_XRANDR=auto
+CFG_XRENDER=auto
+CFG_FREETYPE=auto
+CFG_QWS_FREETYPE=yes
+CFG_SQL_AVAILABLE=
+CFG_SQL_AUTODETECTED=
+CFG_GFX_AVAILABLE=
+CFG_STYLE_AVAILABLE=
+CFG_TABLET=auto
+CFG_XKB=auto
+CFG_NIS=auto
+CFG_CUPS=auto
+CFG_LARGEFILE=auto
+CFG_NEWABI=no ### need to break ABI for full Large File support...
+CFG_STL=auto
+CFG_PRECOMPILE=no
+CFG_IPV6=auto
+CFG_NAS=no
+CFG_QWS_DEPTHS=prompted
+CFG_USER_BUILD_KEY=
+CFG_ACCESSIBILITY=auto
+CFG_DLOPEN_OPENGL=no
+CFG_ENDIAN=auto
+D_FLAGS=
+I_FLAGS=
+L_FLAGS=
+R_FLAGS=
+l_FLAGS=
+QCONFIG_FLAGS=
+XPLATFORM=
+PLATFORM=$QMAKESPEC
+QMAKE_PROJECTS=
+QMAKE_IGNORE_PROJECTS=
+OPT_CONCURRENT=0
+OPT_SHADOW=maybe
+OPT_FAST=auto
+OPT_VERBOSE=no
+OPT_HELP=
+
+# initalize variables used for installation
+QT_INSTALL_PREFIX=
+QT_INSTALL_DOCS=
+QT_INSTALL_HEADERS=
+QT_INSTALL_LIBS=
+QT_INSTALL_BINS=
+QT_INSTALL_PLUGINS=
+QT_INSTALL_DATA=
+QT_INSTALL_TRANSLATIONS=
+QT_INSTALL_SYSCONF=
+
+
+#-------------------------------------------------------------------------------
+# check SQL drivers and styles available in this package
+#-------------------------------------------------------------------------------
+
+CFG_SQL_AVAILABLE=`find $relpath/plugins/src/sqldrivers/* -prune -type d -exec basename {} \;`
+# normalize whitespace
+CFG_SQL_AVAILABLE=`echo $CFG_SQL_AVAILABLE`
+
+CFG_STYLE_AVAILABLE=`find $relpath/plugins/src/styles/* -prune -type d -exec basename {} \;`
+# normalize whitespace
+CFG_STYLE_AVAILABLE=`echo $CFG_STYLE_AVAILABLE`
+
+#-------------------------------------------------------------------------------
+# parse command line arguments
+#-------------------------------------------------------------------------------
+
+# parse the arguments, setting things to "yes" or "no"
+while [ "$#" -gt 0 ]; do
+    CURRENT_OPT="$1"
+    UNKNOWN_ARG=no
+    case $1 in
+    #Autoconf style options
+    --enable-*)
+	VAR=`echo $1 | sed "s,^--enable-\(.*\),\1,"`
+	VAL=yes
+	;;
+    --disable-*)
+	VAR=`echo $1 | sed "s,^--disable-\(.*\),\1,"`
+	VAL=no
+	;;
+    --*=*)
+	VAR=`echo $1 | sed "s,^--\(.*\)=.*,\1,"`
+	VAL=`echo $1 | sed "s,^--.*=\(.*\),\1,"`
+	;;
+    --no-*)
+	VAR=`echo $1 | sed "s,^--no-\(.*\),\1,"`
+	VAL=no
+	;;
+    --*)
+	VAR=`echo $1 | sed "s,^--\(.*\),\1,"`
+	VAL=yes
+	;;
+    #Qt plugin options
+    -no-*-*|-plugin-*-*|-qt-*-*)
+	VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+	VAL=`echo $1 | sed "s,^-\([^-]*\).*,\1,"`
+	;;
+    #Qt style no options
+    -no-*)
+	VAR=`echo $1 | sed "s,^-no-\(.*\),\1,"`
+	VAL=no
+	;;
+    #Qt style yes options
+    -incremental|-qvfb|-profile|-shared|-static|-sm|-thread|-xinerama|-xshape|-tablet|-pch|-stl|-ipv6|-freetype|-big-codecs|-xcursor|-xrandr|-xrender|-xft|-xkb|-nis|-cups|-largefile|-h|-help|-v|-verbose|-debug|-release|-fast|-version-script|-dlopen-opengl)
+	VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+	VAL=yes
+	;;
+    #Qt style options that pass an argument
+    -qconfig)
+	if [ "$PLATFORM_QWS" = "yes" ]; then
+	    CFG_QCONFIG="$VAL"
+	    VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+	    shift
+	    VAL=$1
+	else
+	    UNKNOWN_ARG=yes
+	fi
+	;;
+    -prefix|-docdir|-headerdir|-plugindir|-datadir|-libdir|-bindir|-translationdir|-sysconfdir|-depths|-make|-nomake|-platform|-xplatform|-buildkey)
+	VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+	shift
+	VAL=$1
+	;;
+    #Qt style complex options in one command
+    -enable-*|-disable-*)
+	VAR=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+	VAL=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+	;;
+    #Qt Builtin/System style options
+    -no-*|-system-*|-qt-*)
+	VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+	VAL=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+	;;
+    #Options that cannot be generalized
+    -k|-continue)
+	VAR=fatal_error
+	VAL=no
+	;;
+    -embedded)
+	VAR=embedded
+	# this option may or may not be followed by an argument
+	if [ -z $2 ] || echo $2 | grep '^-' >/dev/null 2>&1; then
+	    VAL=auto
+	else
+	    shift;
+	    VAL=$1
+	fi
+	;;
+    -*-endian)
+	VAR=endian
+	VAL=`echo $1 | sed "s,^-\(.*\)-.*,\1,"`
+	;;
+    -j?*)
+	VAR="concurrent"
+	VAL="`echo $1 | sed 's,-j,,'`"
+	;;
+    -D?*|-D)
+	VAR="define"
+	if [ "$1" = "-D" ]; then
+	    shift
+	    VAL="$1"
+	else
+	    VAL=`echo $1 | sed 's,-D,,'`
+        fi
+	;;
+    -I?*|-I)
+	VAR="ipath"
+	if [ "$1" = "-I" ]; then
+	    shift
+	    VAL="$1"
+	else
+	    VAL=`echo $1 | sed 's,-I,,'`
+        fi
+	;;
+    -L?*|-L)
+	VAR="lpath"
+	if [ "$1" = "-L" ]; then
+	    shift
+	    VAL="$1"
+	else
+	    VAL=`echo $1 | sed 's,-L,,'`
+        fi
+	;;
+    -R?*|-R)
+	VAR="rpath"
+	if [ "$1" = "-R" ]; then
+	    shift
+	    VAL="$1"
+	else
+	    VAL=`echo $1 | sed 's,-R,,'`
+        fi
+	;;
+    -l?*)
+	VAR="link"
+	VAL=`echo $1 | sed 's,-l,,'`
+	;;
+    *)
+	UNKNOWN_ARG=yes
+	;;
+    esac
+    if [ "$UNKNOWN_ARG" = "yes" ]; then
+	echo "$1: unknown argument"
+	OPT_HELP=yes
+	ERROR=yes
+	shift
+	continue
+     fi
+    shift
+
+    UNKNOWN_OPT=no
+    case $VAR in
+    accessibility)
+       	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_ACCESSIBILITY="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    prefix)
+	QT_INSTALL_PREFIX="$VAL"
+	;;
+    docdir)
+	QT_INSTALL_DOCS="$VAL"
+	;;
+    headerdir)
+	QT_INSTALL_HEADERS="$VAL"
+	;;
+    plugindir)
+	QT_INSTALL_PLUGINS="$VAL"
+	;;
+    datadir)
+	QT_INSTALL_DATA="$VAL"
+	;;
+    libdir)
+	QT_INSTALL_LIBS="$VAL"
+	;;
+    translationdir)
+	QT_INSTALL_TRANSLATIONS="$VAL"
+	;;
+    sysconfdir)
+	QT_INSTALL_SYSCONF="$VAL"
+	;;
+    qconfig)
+	CFG_QCONFIG="$VAL"
+	;;
+    bindir)
+	QT_INSTALL_BINS="$VAL"
+	;;
+    buildkey)
+	CFG_USER_BUILD_KEY="$VAL"
+	;;
+    embedded)
+	CFG_EMBEDDED="$VAL"
+	if [ "$PLATFORM_QNX" != "no" -o "$PLATFORM_QWS" != "no" ]; then
+	    if [ "$PLATFORM_QNX" = "maybe" ]; then
+		PLATFORM_QNX=yes
+	    elif [ "$PLATFORM_QWS" = "maybe" ]; then
+		PLATFORM_QWS=yes
+	    fi
+	else
+	    echo "No license exists to enable Qt/Embedded. Disabling."
+	    CFG_EMBEDDED=no
+	fi
+	;;
+    endian)
+        if [ "$VAL" = "little" ]; then
+            CFG_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$VAL" = "big" ]; then
+	    CFG_ENDIAN="Q_BIG_ENDIAN"
+        else
+	    UNKNOWN_OPT=yes
+	fi
+        ;;
+    depths)
+	CFG_QWS_DEPTHS="$VAL"
+	;;
+    qvfb) # left for commandline compatibility, not documented
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    [ "$VAL" = "yes" ] && QMAKE_VARS="$QMAKE_VARS \"gfx-drivers += qvfb\""
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    nomake)
+	QMAKE_IGNORE_PROJECTS="$QMAKE_IGNORE_PROJECTS $VAL"
+	;;
+    make)
+	if [ -f $relpath/$VAL ]; then
+	    QMAKE_PROJECTS="$QMAKE_PROJECTS $relpath/$VAL"
+	else
+	    if [ -d $relpath/$VAL ]; then
+		QMAKE_PROJECTS="$QMAKE_PROJECTS `find $relpath/$VAL -name '*.pro' -print`"
+	    else
+		QMAKE_PROJECTS="$QMAKE_PROJECTS `find $relpath/. -name '*.pro' -print`"
+	    fi
+	fi
+	;;
+    x11)
+        if [ "$Edition" = "troll" ] && [ "$VAL" = "yes" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+		PLATFORM_MAC=no
+	    elif [ "$PLATFORM_QWS" = "yes" ]; then
+		PLATFORM_QWS=no
+	    fi
+	    PLATFORM_X11=yes
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    profile)
+	if [ "$VAL" = "yes" ]; then
+	    CFG_PROFILE=yes
+	    QMAKE_VARS="$QMAKE_VARS QMAKE_CFLAGS+=-pg QMAKE_CXXFLAGS+=-pg"
+	    QMAKE_VARS="$QMAKE_VARS QMAKE_LFLAGS+=-pg"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    exceptions|g++-exceptions)
+	if [ "$VAL" = "no" ]; then
+	    CFG_EXCEPTION_SUPPORT=no
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    version-script)
+	if [ "$VAL" = "yes" ]; then
+	    QMAKE_CONFIG="$QMAKE_CONFIG version_script"
+	fi
+	;;
+    platform)
+	PLATFORM="$VAL"
+	# keep compatibility with old platform names
+	case $PLATFORM in
+	aix-64)
+	    PLATFORM=aix-xlc-64
+	    ;;
+	hpux-o64)
+	    PLATFORM=hpux-acc-o64
+	    ;;
+	hpux-n64)
+	    PLATFORM=hpux-acc-64
+	    ;;
+	hpux-acc-n64)
+	    PLATFORM=hpux-acc-64
+	    ;;
+	irix-o32)
+	    PLATFORM=irix-cc-o32
+	    ;;
+	irix-n32)
+	    PLATFORM=irix-cc
+	    ;;
+	irix-64)
+	    PLATFORM=irix-cc-64
+	    ;;
+	irix-cc-n64)
+	    PLATFORM=irix-cc-64
+	    ;;
+	reliant-64)
+	    PLATFORM=reliant-cds-64
+	    ;;
+	solaris-64)
+	    PLATFORM=solaris-cc-64
+	    ;;
+	solaris-64)
+	    PLATFORM=solaris-cc-64
+	    ;;
+	openunix-cc)
+	    PLATFORM=unixware-cc
+	    ;;
+	openunix-g++)
+	    PLATFORM=unixware-g++
+	    ;;
+	unixware7-cc)
+	    PLATFORM=unixware-cc
+	    ;;
+	unixware7-g++)
+	    PLATFORM=unixware-g++
+	    ;;
+	esac
+	;;
+    xplatform)
+	XPLATFORM="$VAL"
+	;;
+    release)
+	if [ "$VAL" = "yes" ]; then
+	    CFG_DEBUG=no
+	elif [ "$VAL" = "no" ]; then
+	    CFG_DEBUG=yes
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    debug)
+	CFG_DEBUG="$VAL"
+	;;
+    static)
+	if [ "$VAL" = "yes" ]; then
+	    CFG_SHARED=no
+	elif [ "$VAL" = "no" ]; then
+	    CFG_SHARED=yes
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    incremental)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_INCREMENTAL="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    fatal_error)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_CONFIGURE_EXIT_ON_ERROR="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    shared)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_SHARED="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    gif)
+	[ "$VAL" = "qt" ] && VAL=yes
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_GIF="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+	;;
+    sm)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_SM="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+        fi
+
+	;;
+    thread)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_THREAD="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xinerama)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XINERAMA="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xshape)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XSHAPE="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    tablet)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_TABLET="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    stl)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_STL="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    pch)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_PRECOMPILE="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    ipv6)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_IPV6="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    freetype)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_QWS_FREETYPE="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    zlib)
+	[ "$VAL" = "qt" ] && VAL=yes
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+	    CFG_ZLIB="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	[ "$VAL" = "no" ] && CFG_LIBPNG=no
+	;;
+    libpng)
+	[ "$VAL" = "yes" ] && VAL=qt
+	if [ "$VAL" = "no " ]; then
+	    echo "-no-png is left for compatibility, in the future please use -no-imgfmt-png"
+	    CFG_PNG=no
+	fi
+	if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+	    CFG_LIBPNG="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    libmng)
+	[ "$VAL" = "yes" ] && VAL=qt
+	if [ "$VAL" = "no " ]; then
+	    echo "-no-mng is left for compatibility, in the future please use -no-imgfmt-mng"
+	    CFG_MNG=no
+	fi
+	if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+	    CFG_LIBMNG="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    libjpeg|jpeg)
+	[ "$VAL" = "yes" ] && VAL=qt
+	if [ "$VAR" = "jpeg" ]; then
+	    echo "-${VAL}-jpeg is left for compatibility, in the future please use -${VAL}-libjpeg"
+	fi
+	if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+	    CFG_LIBJPEG="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	if [ "$VAL" = "no " ]; then
+	    echo "-no-jpeg is left for compatibility, in the future please use -no-imgfmt-jpeg"
+	    CFG_JPEG=no
+	fi
+	;;
+    nas-sound)
+	if [ "$VAL" = "system" ] || [ "$VAL" = "no" ]; then
+	    CFG_NAS="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    big-codecs)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_BIG_CODECS="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xcursor)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XCURSOR="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xrandr)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XRANDR="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xrender)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XRENDER="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xft)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_FREETYPE="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    xkb)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_XKB="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    cups)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_CUPS="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    nis)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_NIS="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    largefile)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_LARGEFILE="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    newabi)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_NEWABI="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    enable) #left for commandline compatibility, not documented
+	MODULE="$VAL"
+	if [ -n $MODULE -a -d "$relpath/src/$MODULE" ]; then
+	    if echo "${MODULES}" | grep $MODULE >/dev/null 2>&1; then
+		MODULES="$MODULES $MODULE"
+	    fi
+	fi
+	;;
+    disable)
+	MODULE="$VAL"
+	if [ -d "$relpath/src/$MODULE" ]; then
+	    MODULES=`echo $MODULES | sed -e "s/$MODULE//"`
+	else
+	    echo "Unknown module disabled: $MODULE"
+	fi
+	;;
+    h|help)
+	if [ "$VAL" = "yes" ]; then
+	    OPT_HELP="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    imgfmt-*|style-*|sql-*|gfx-*|kbd-*|mouse-*)
+	# if Qt style options were used, $VAL can be "no", "qt", or "plugin"
+	# if autoconf style options were used, $VAL can be "yes" or "no"
+	[ "$VAL" = "yes" ] && VAL=qt
+	# now $VAL should be "no", "qt", or "plugin"... double-check
+	if [ "$VAL" != "no" ] && [ "$VAL" != "qt" ] && [ "$VAL" != "plugin" ]; then
+	    UNKNOWN_OPT=yes
+	fi
+	# now $VAL is "no", "qt", or "plugin"
+	OPT="$VAL"
+	VAL=`echo $VAR | sed "s,^[^-]*-\([^-]*\).*,\1,"`
+	VAR=`echo $VAR | sed "s,^\([^-]*\).*,\1,"`
+	ERROR=no
+	# now $OPT is "no", "qt", or "plugin"
+	if [ "$VAR" = "imgfmt" ]; then
+	    [ "$OPT" = "qt" ] && OPT=yes
+	    # now $OPT is "no", "yes", or "plugin"
+	    case "$VAL" in
+	    jpeg) CFG_JPEG=$OPT ;;
+	    mng) CFG_MNG=$OPT ;;
+	    png) CFG_PNG=$OPT ;;
+	    *) ERROR=yes ;;
+	    esac
+	else
+	    if [ "$VAR" = "style" ]; then
+		ERROR=yes
+		for d in $CFG_STYLE_AVAILABLE; do
+		    if [ "$VAL" = "$d" ]; then
+			ERROR=no
+			break
+		    fi
+		done
+	    elif [ "$VAR" = "sql" ]; then
+		ERROR=yes
+		for d in $CFG_SQL_AVAILABLE; do
+		    if [ "$VAL" = "$d" ]; then
+			ERROR=no
+			break
+		    fi
+		done
+	    fi
+	    if [ "$OPT" = "plugin" ] || [ "$OPT" = "qt" ]; then
+		if [ "$OPT" = "plugin" ]; then
+		    [ "$VAR" = "style" ] && QMAKE_VARS="$QMAKE_VARS \"${VAR}s -= $VAL\""
+		    VAR="${VAR}-${OPT}"
+		else
+		    if [ "$VAR" = "sql" ] || [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "mouse" ]; then
+			VAR="${VAR}-driver"
+		    fi
+		fi
+		QMAKE_VARS="$QMAKE_VARS \"${VAR}s += $VAL\""
+	    elif [ "$OPT" = "no" ]; then
+		PLUG_VAR="${VAR}-plugin"
+		if [ "$VAR" = "sql" ] || [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "mouse" ]; then
+		    IN_VAR="${VAR}-driver"
+		else
+		    IN_VAR="${VAR}"
+		fi
+		QMAKE_VARS="$QMAKE_VARS \"${IN_VAR}s -= $VAL\" \"${PLUG_VAR}s -= $VAL\""
+	    fi
+	fi
+        if [ "$ERROR" = "yes" ]; then
+	   echo "$CURRENT_OPT: unknown argument"
+	   OPT_HELP=yes;
+	fi
+	;;
+    v|verbose)
+	if [ "$VAL" = "yes" ]; then
+	    if [ "$OPT_VERBOSE" = "$VAL" ]; then 	    # takes two verboses to turn on qmake debugs
+		QMAKE_SWITCHES="$QMAKE_SWITCHES -d"
+            else
+		OPT_VERBOSE=yes
+	    fi
+        elif [ "$VAL" = "no" ]; then
+	    if [ "$OPT_VERBOSE" = "$VAL" ] && echo "$QMAKE_SWITCHES" | grep ' -d' >/dev/null 2>&1; then
+		QMAKE_SWITCHES=`echo $QMAKE_SWITCHES | sed "s, -d,,"`
+	    else
+		OPT_VERBOSE=no
+            fi
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    fast)
+	if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    OPT_FAST="$VAL"
+	else
+	    UNKNOWN_OPT=yes
+	fi
+	;;
+    concurrent)
+	OPT_CONCURRENT="$VAL"
+	;;
+    define)
+	D_FLAGS="$D_FLAGS $VAL"
+	;;
+    ipath)
+	I_FLAGS="$I_FLAGS -I${VAL}"
+	;;
+    lpath)
+	L_FLAGS="$L_FLAGS -L${VAL}"
+	;;
+    rpath)
+	R_FLAGS="$R_FLAGS \$\${QMAKE_RPATH}${VAL}"
+	;;
+    link)
+	l_FLAGS="$l_FLAGS -l${VAL}"
+	;;
+    dlopen-opengl)
+	CFG_DLOPEN_OPENGL="$VAL"
+	;;
+    *)
+	UNKNOWN_OPT=yes
+	;;
+    esac
+    if [ "$UNKNOWN_OPT" = "yes" ]; then
+	echo "${CURRENT_OPT}: invalid command-line switch"
+	OPT_HELP=yes
+	ERROR=yes
+    fi
+done
+
+#-------------------------------------------------------------------------------
+# post initialize QT_INSTALL_* variables, and generate qconfig.cpp
+#-------------------------------------------------------------------------------
+
+# default $outpath
+[ -z "$QT_INSTALL_PREFIX" ]       && QT_INSTALL_PREFIX=$outpath
+# default PREFIX/doc
+[ -z "$QT_INSTALL_DOCS" ]         && QT_INSTALL_DOCS=$QT_INSTALL_PREFIX/doc
+# default PREFIX/include
+[ -z "$QT_INSTALL_HEADERS" ]      && QT_INSTALL_HEADERS=$QT_INSTALL_PREFIX/include
+# default PREFIX/lib
+[ -z "$QT_INSTALL_LIBS" ]         && QT_INSTALL_LIBS=$QT_INSTALL_PREFIX/lib
+# default PREFIX/bin
+[ -z "$QT_INSTALL_BINS" ]         && QT_INSTALL_BINS=$QT_INSTALL_PREFIX/bin
+# default PREFIX/plugins
+[ -z "$QT_INSTALL_PLUGINS" ]      && QT_INSTALL_PLUGINS=$QT_INSTALL_PREFIX/plugins
+# default PREFIX
+[ -z "$QT_INSTALL_DATA" ]         && QT_INSTALL_DATA=$QT_INSTALL_PREFIX
+# default PREFIX/translations
+[ -z "$QT_INSTALL_TRANSLATIONS" ] && QT_INSTALL_TRANSLATIONS=$QT_INSTALL_PREFIX/translations
+# default PREFIX/etc/settings
+[ -z "$QT_INSTALL_SYSCONF" ]      && QT_INSTALL_SYSCONF=$QT_INSTALL_PREFIX/etc/settings
+
+# generate qconfig.cpp
+[ -d $outpath/src/tools ] || mkdir -p $outpath/src/tools
+cat > $outpath/src/tools/qconfig.cpp.new <<EOF
+/* Install paths from configure */
+
+static const char QT_INSTALL_PREFIX      [267] = "qt_nstpath=$QT_INSTALL_PREFIX";
+static const char QT_INSTALL_BINS        [267] = "qt_binpath=$QT_INSTALL_BINS";
+static const char QT_INSTALL_DOCS        [267] = "qt_docpath=$QT_INSTALL_DOCS";
+static const char QT_INSTALL_HEADERS     [267] = "qt_hdrpath=$QT_INSTALL_HEADERS";
+static const char QT_INSTALL_LIBS        [267] = "qt_libpath=$QT_INSTALL_LIBS";
+static const char QT_INSTALL_PLUGINS     [267] = "qt_plgpath=$QT_INSTALL_PLUGINS";
+static const char QT_INSTALL_DATA        [267] = "qt_datpath=$QT_INSTALL_DATA";
+static const char QT_INSTALL_TRANSLATIONS[267] = "qt_trnpath=$QT_INSTALL_TRANSLATIONS";
+static const char QT_INSTALL_SYSCONF     [267] = "qt_cnfpath=$QT_INSTALL_SYSCONF";
+
+/* strlen( "qt_xxxpath=" ) == 11 */
+const char *qInstallPath()             { return QT_INSTALL_PREFIX       + 11; }
+const char *qInstallPathDocs()         { return QT_INSTALL_DOCS         + 11; }
+const char *qInstallPathHeaders()      { return QT_INSTALL_HEADERS      + 11; }
+const char *qInstallPathLibs()         { return QT_INSTALL_LIBS         + 11; }
+const char *qInstallPathBins()         { return QT_INSTALL_BINS         + 11; }
+const char *qInstallPathPlugins()      { return QT_INSTALL_PLUGINS      + 11; }
+const char *qInstallPathData()         { return QT_INSTALL_DATA         + 11; }
+const char *qInstallPathTranslations() { return QT_INSTALL_TRANSLATIONS + 11; }
+const char *qInstallPathSysconf()      { return QT_INSTALL_SYSCONF      + 11; }
+EOF
+
+# avoid unecessary rebuilds by copying only if qconfig.cpp has changed
+if cmp -s $outpath/src/tools/qconfig.cpp $outpath/src/tools/qconfig.cpp.new; then
+    rm -f $outpath/src/tools/qconfig.cpp.new
+else
+    [ -f $outpath/src/tools/qconfig.cpp ] && chmod +w $outpath/src/tools/qconfig.cpp
+    mv $outpath/src/tools/qconfig.cpp.new $outpath/src/tools/qconfig.cpp
+    chmod -w $outpath/src/tools/qconfig.cpp
+fi
+
+
+#-------------------------------------------------------------------------------
+# build tree initialization
+#-------------------------------------------------------------------------------
+
+#where to find which..
+unixtests=$relpath/config.tests/unix
+WHICH=$unixtests/which.test
+
+### skip this if the user just needs help...
+if [ "$OPT_HELP" != "yes" ]; then
+
+# create the include and include/qmake directory (for qconfig.h and qmodules.h)
+[ -d $outpath/include/qmake ] || mkdir -p $outpath/include/qmake
+
+# create temporary qconfig.h for compiling qmake
+# when building qmake, we use #defines for the install paths,
+# however they are real functions in the library
+cat >>$outpath/include/qmake/qconfig.h <<EOF
+/* All features enabled while building qmake */
+EOF
+
+# create temporary qmodules.h for compiling qmake
+cat >>$outpath/include/qmake/qmodules.h <<EOF
+/* All modules enabled while building qmake */
+EOF
+
+# is this a shadow build?
+if [ "$OPT_SHADOW" = "maybe" ]; then
+    OPT_SHADOW=no
+    if [ "$relpath" != "$outpath" ] && [ '!' -f "$outpath/configure" ]; then
+	if [ -h "$outpath" ]; then
+	    [ "$relpath" -ef "$outpath" ] || OPT_SHADOW=yes
+	else
+	    OPT_SHADOW=yes
+        fi
+    fi
+fi
+if [ "$OPT_VERBOSE" = "yes" -a "$OPT_SHADOW" = "yes" ]; then
+    echo "Performing shadow build..."
+fi
+
+#detect how mng should be built
+if [ "$CFG_MNG" = "auto" ]; then
+    if [ "$CFG_EMBEDDED" = "yes" ]; then
+	CFG_MNG=no
+    elif [ "$CFG_SHARED" = "yes" ]; then
+	CFG_MNG=plugin
+    else
+	CFG_MNG=yes
+    fi
+fi
+
+#detect how jpeg should be built
+if [ "$CFG_JPEG" = "auto" ]; then
+    if [ "$CFG_EMBEDDED" = "yes" ]; then
+	CFG_JPEG=no
+    elif [ "$CFG_MNG" = "yes" ]; then
+	CFG_JPEG=yes
+    elif [ "$CFG_SHARED" = "yes" ]; then
+	CFG_JPEG=plugin
+    else
+	CFG_JPEG=yes
+    fi
+fi
+
+#detect accessibility
+if [ "$CFG_ACCESSIBILITY" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ]; then
+	CFG_ACCESSIBILITY=yes
+    else
+	CFG_ACCESSIBILITY=no
+    fi
+fi
+
+# if the source tree is different from the build tree,
+# symlink or copy part of the sources
+if [ "$OPT_SHADOW" = "yes" ]; then
+    echo "Preparing build tree..."
+    [ -d $outpath/bin ] || mkdir -p $outpath/bin
+
+    # need a top level makefile, prefer gnu internally
+    if [ -f $relpath/GNUmakefile ]; then
+	rm -f $outpath/Makefile
+	ln -s $relpath/GNUmakefile $outpath/Makefile
+    elif [ -f $relpath/Makefile ]; then
+	rm -f $outpath/Makefile
+	ln -s $relpath/Makefile $outpath/Makefile
+    else
+	echo "No top level Makefile." >&2
+	exit 1
+    fi
+
+    # symlink the qmake directory
+    for a in `find $relpath/qmake`; do
+	my_a=`echo $a | sed "s,^${relpath}/,${outpath}/,"`
+	if [ '!' -f $my_a ]; then
+	    if [ -d $a ]; then
+		# directories are created...
+		mkdir -p $my_a
+	    else
+		a_dir=`dirname $my_a`
+		[ -d $a_dir ] || mkdir -p $a_dir
+		# ... and files are symlinked
+		case `basename $a` in
+		*.o|*.d|GNUmakefile*|qmake)
+		    ;;
+		*)
+		    rm -f $my_a
+		    ln -s $a $my_a
+		    ;;
+		esac
+	    fi
+	fi
+    done
+
+    # symlink the mkspecs directory
+    mkdir -p $outpath/mkspecs
+    rm -f $outpath/mkspecs/*
+    ln -s $relpath/mkspecs/* $outpath/mkspecs
+    rm -f $outpath/mkspecs/default
+
+    # symlink the linguist/doc directory (to make the assistant happy)
+    mkdir -p $outpath/tools/linguist
+    rm -f $outpath/tools/linguist/doc
+    ln -s $relpath/tools/linguist/doc $outpath/tools/linguist/doc
+
+    # symlink the designer/templates directory (to make the designer find
+    # the templates)
+    mkdir -p $outpath/tools/designer
+    rm -f $outpath/tools/designer/templates
+    ln -s $relpath/tools/designer/templates $outpath/tools/designer/templates
+    # symlink the designer/interfaces directory (for the validator)
+    rm -f $outpath/tools/designer/interfaces
+    ln -s $relpath/tools/designer/interfaces $outpath/tools/designer/interfaces
+    # symlink designer/editor/editor.h, dlldefs.h, viewmanager.h (for the validator)
+    mkdir -p $outpath/tools/designer/editor
+    rm -f $outpath/tools/designer/editor/editor.h
+    ln -s $relpath/tools/designer/editor/editor.h $outpath/tools/designer/editor/editor.h
+    rm -f $outpath/tools/designer/editor/dlldefs.h
+    ln -s $relpath/tools/designer/editor/dlldefs.h $outpath/tools/designer/editor/dlldefs.h
+    rm -f $outpath/tools/designer/editor/viewmanager.h
+    ln -s $relpath/tools/designer/editor/viewmanager.h $outpath/tools/designer/editor/viewmanager.h
+
+    # symlink the doc directory
+    rm -f $outpath/doc
+    ln -s $relpath/doc $outpath/doc
+else
+    # override the Windows Makefile
+    if [ -f "$relpath/GNUmakefile" ]; then
+	[ "$Edition" = "troll" ] && $WHICH chflags >/dev/null 2>&1 && chflags nouchg $outpath/Makefile
+	rm -f $outpath/Makefile
+	cp $relpath/GNUmakefile $outpath/Makefile
+	chmod +w $outpath/Makefile
+    fi
+fi
+
+# binaries from qt
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_MOC=$outpath/bin/moc\""
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_UIC=$outpath/bin/uic -L \$\$QT_BUILD_TREE/plugins\""
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_QMAKE=$outpath/bin/qmake\""
+# hacky src line
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_MOC_SRC=$outpath/src/moc\""
+
+# find out which awk we want to use, prefer gawk, then nawk, then regular awk
+AWK=
+for e in gawk nawk awk; do
+    if $WHICH $e >/dev/null 2>&1 && ( $e -f /dev/null /dev/null ) >/dev/null 2>&1; then
+	AWK=$e
+    	break
+    fi
+done
+if [ "$OPT_FAST" = "auto" ]; then
+   if [ ! -z "$AWK" ] && [ "$Edition" = "troll" ]; then
+       OPT_FAST=yes
+   else
+       OPT_FAST=no
+   fi
+fi
+
+# find a make command
+MAKE=
+for mk in gmake make; do
+    if $WHICH $mk >/dev/null 2>&1; then
+	MAKE=`$WHICH $mk`
+	break
+    fi
+done
+if [ -z "$MAKE" ]; then
+    echo "You don't seem to have 'make' or 'gmake' in your PATH."
+    echo "Cannot proceed."
+    exit 1
+fi
+
+fi ### help
+
+
+#-------------------------------------------------------------------------------
+# auto-detect all that hasn't been specified in the arguments
+#-------------------------------------------------------------------------------
+
+[ "$PLATFORM_QWS" = "yes" -a "$CFG_EMBEDDED" = "no" ] && CFG_EMBEDDED=auto
+if [ "$CFG_EMBEDDED" != "no" ]; then
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+    QNX:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/qnx-rtp-g++
+#	[ "$CFG_EMBEDDED" = "qnx4" ] && PLATFORM_QNX=qws/qnx4-cc
+	if [ -z "$XPLATFORM" ]; then
+	    [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+	    XPLATFORM="$PLATFORM"
+        fi
+	CFG_STL=no
+	CFG_QWS_QVFB=no
+	;;
+    Darwin:*)
+	[ -z "$PLATFORM" ] && PLATFORM=qws/macx-generic-g++
+	if [ -z "$XPLATFORM" ]; then
+	    [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+	    XPLATFORM="qws/macx-$CFG_EMBEDDED-g++"
+	fi
+	;;
+    FreeBSD:*)
+	[ -z "$PLATFORM" ] && PLATFORM=qws/freebsd-generic-g++
+	if [ -z "$XPLATFORM" ]; then
+	    [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+	    XPLATFORM="qws/freebsd-$CFG_EMBEDDED-g++"
+	fi
+	;;
+    SunOS:5*)
+	[ -z "$PLATFORM" ] && PLATFORM=qws/solaris-generic-g++
+	if [ -z "$XPLATFORM" ]; then
+	    [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+	    XPLATFORM="qws/solaris-$CFG_EMBEDDED-g++"
+	fi
+	;;
+    Linux:*)
+	if [ -z "$PLATFORM" ]; then
+	    case "$UNAME_MACHINE" in
+	    *86)
+		PLATFORM=qws/linux-x86-g++
+		;;
+	    *)
+		PLATFORM=qws/linux-generic-g++
+		;;
+	    esac
+	fi
+	if [ -z "$XPLATFORM" ]; then
+	    if [ "$CFG_EMBEDDED" = "auto" ]; then
+		case "$UNAME_MACHINE" in
+		*86)
+		    CFG_EMBEDDED=x86
+		    ;;
+		*)
+		    CFG_EMBEDDED=generic
+		    ;;
+		esac
+	    fi
+	    XPLATFORM="qws/linux-$CFG_EMBEDDED-g++"
+	fi
+	;;
+    *)
+	echo "Qt/Embedded is not supported on this platform. Disabling."
+	CFG_EMBEDDED=no
+	PLATFORM_QWS=no
+	PLATFORM_QNX=no
+	;;
+    esac
+fi
+if [ -z "$PLATFORM" ]; then
+    PLATFORM_NOTES=
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+     Darwin:*)
+	if [ "$PLATFORM_MAC" = "yes" ]; then
+	  PLATFORM=macx-g++
+	# PLATFORM=macx-pbuilder
+	else
+	  PLATFORM=darwin-g++
+	fi
+	;;
+     AIX:*)
+	#PLATFORM=aix-g++
+	PLATFORM=aix-xlc
+	#PLATFORM=aix-xlc-64
+	PLATFORM_NOTES="
+	    - Also available for AIX: aix-g++ aix-xlc-64
+	"
+	;;
+     QNX:*)
+	PLATFORM=qnx-g++
+	;;
+     GNU:*)
+	PLATFORM=hurd-g++
+	;;
+     dgux:*)
+	PLATFORM=dgux-g++
+	;;
+#     DYNIX/ptx:4*)
+#	PLATFORM=dynix-g++
+#	;;
+     ULTRIX:*)
+	PLATFORM=ultrix-g++
+	;;
+     FreeBSD:*)
+	PLATFORM=freebsd-g++
+	;;
+     OpenBSD:*)
+	PLATFORM=openbsd-g++
+	;;
+     NetBSD:*)
+	PLATFORM=netbsd-g++
+	;;
+     BSD/OS:*|BSD/386:*)
+	PLATFORM=bsdi-g++
+	;;
+     IRIX*:*)
+	#PLATFORM=irix-g++
+	PLATFORM=irix-cc
+	#PLATFORM=irix-cc-64
+	PLATFORM_NOTES="
+	    - Also available for IRIX: irix-g++ irix-cc-64
+	"
+	;;
+     HP-UX:*)
+	#PLATFORM=hpux-g++
+	PLATFORM=hpux-acc
+	#PLATFORM=hpux-acc-64
+	#PLATFORM=hpux-cc
+	#PLATFORM=hpux-acc-o64
+	PLATFORM_NOTES="
+	    - Also available for HP-UX: hpux-g++ hpux-acc-64 hpux-acc-o64
+	"
+	;;
+     OSF1:*)
+	#PLATFORM=tru64-g++
+	PLATFORM=tru64-cxx
+	PLATFORM_NOTES="
+	    - Also available for Tru64: tru64-g++
+	"
+	;;
+     Linux:*)
+	PLATFORM=linux-g++
+	PLATFORM_NOTES="
+	    - Also available for Linux: linux-kcc linux-icc linux-cxx
+	"
+	;;
+     SunOS:5*)
+	#PLATFORM=solaris-g++
+	PLATFORM=solaris-cc
+	#PLATFORM=solaris-cc64
+	PLATFORM_NOTES="
+	    - Also available for Solaris: solaris-g++ solaris-cc-64
+	"
+	;;
+     ReliantUNIX-*:*|SINIX-*:*)
+	PLATFORM=reliant-cds
+	#PLATFORM=reliant-cds-64
+	PLATFORM_NOTES="
+	    - Also available for Reliant UNIX: reliant-cds-64
+	"
+	;;
+     CYGWIN*:*)
+	PLATFORM=cygwin-g++
+	;;
+     LynxOS*:*)
+	PLATFORM=lynxos-g++
+	;;
+     OpenUNIX:*)
+	#PLATFORM=unixware-g++
+        PLATFORM=unixware-cc
+	PLATFORM_NOTES="
+	    - Also available for OpenUNIX: unixware-g++
+	"
+        ;;
+     UnixWare:*)
+	#PLATFORM=unixware-g++
+	PLATFORM=unixware-cc
+	PLATFORM_NOTES="
+	    - Also available for UnixWare: unixware-g++
+	"
+	;;
+     SCO_SV:*)
+	#PLATFORM=sco-g++
+	PLATFORM=sco-cc
+	PLATFORM_NOTES="
+	    - Also available for SCO OpenServer: sco-g++
+	"
+	;;
+     UNIX_SV:*)
+	PLATFORM=unixware-g++
+	;;
+     *)
+	if [ "$OPT_HELP" != "yes" ]; then
+	    echo
+	    for p in $PLATFORMS; do
+		echo "    $relconf $* -platform $p"
+	    done
+	    echo >&2
+	    echo "   The build script does not currently recognize all" >&2
+	    echo "   platforms supported by Qt." >&2
+	    echo "   Rerun this script with a -platform option listed to" >&2
+	    echo "   set the system/compiler combination you use." >&2
+	    echo >&2
+	    exit 2
+	fi
+    esac
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QNX" = "yes" ]; then
+    CFG_SM=no
+    MODULES=`echo $MODULES | sed -e 's/opengl//'`
+    PLATFORMS=`find $relpath/mkspecs/qws | sed "s,$relpath/mkspecs/qws/,,"`
+else
+    PLATFORMS=`find $relpath/mkspecs/ -type f | grep -v qws | sed "s,$relpath/mkspecs/qws/,,"`
+fi
+
+##if [ "$OPT_CONCURRENT" = "0" ] && echo $MAKEFLAGS | grep '.* *-j[0-9]* *.*' >/dev/null 2>&1; then
+#    OPT_CONCURRENT=`echo $MAKEFLAGS | sed "s,.* *-j\([0-9]*\) *.*,\1,"`
+#fi
+
+[ -z "$XPLATFORM" ] && XPLATFORM="$PLATFORM"
+if [ -d "$PLATFORM" ]; then
+  QMAKESPEC="$PLATFORM"
+else
+  QMAKESPEC="$relpath/mkspecs/${PLATFORM}"
+fi
+if [ -d "$XPLATFORM" ]; then
+  XQMAKESPEC="$XPLATFORM"
+else
+  XQMAKESPEC="$relpath/mkspecs/${XPLATFORM}"
+fi
+if [ "$QMAKESPEC" = "$XQMAKESPEC" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG nocrosscompiler"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+   if [ `basename $QMAKESPEC` = "macx-pbuilder" ] || [ `basename $XQMAKESPEC` = "macx-pbuilder" ]; then
+      echo >&2
+      echo "   Platform 'macx-pbuilder' should not be used when building Qt/Mac." >&2
+      echo "   Please build Qt/Mac with 'macx-g++', then if you would like to" >&2
+      echo "   use mac-pbuilder on your application code it can link to a Qt/Mac" >&2
+      echo "   built with 'macx-g++'" >&2
+      echo >&2
+      exit 2
+  fi
+fi
+
+# check specified platforms are supported
+if [ '!' -d "$QMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "   	$QMAKESPEC"
+    echo
+    echo "   Please see the PLATFORMS file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -d "$XQMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "   	$XQMAKESPEC"
+    echo
+    echo "   Please see the PLATFORMS file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -f "${XQMAKESPEC}/qplatformdefs.h" ]; then
+    echo
+    echo "   The specified system/compiler port is not complete:"
+    echo
+    echo "   	$XQMAKESPEC/qplatformdefs.h"
+    echo
+    echo "   Please contact qt-bugs@trolltech.com."
+    echo
+    exit 2
+fi
+
+# now look at the configs and figure out what platform we are config'd for
+[ '!' -z "`grep QMAKE_LIBS_X11 $XQMAKESPEC/qmake.conf | awk '{print $3;}'`" ] && PLATFORM_X11=yes
+### echo "$XQMAKESPEC" | grep mkspecs/qws >/dev/null 2>&1 && PLATFORM_QWS=yes
+
+# find default thread option for target
+if grep >/dev/null '^QMAKE_LIBS_THREAD' $XQMAKESPEC/qmake.conf; then
+    AUTOTHREAD=yes
+    AUTOTHREAD=no  ### leave off for now
+else
+    AUTOTHREAD=never
+fi
+# common qmake.conf file but dependency on OS version
+if [ "$UNAME_SYSTEM" = "HP-UX" ]; then
+    if echo $UNAME_RELEASE | grep -E "^B\.(09|10)" >/dev/null 2>&1; then
+	AUTOTHREAD=never
+    fi
+fi
+if [ "$UNAME_SYSTEM" = "SunOS" ]; then
+    # Solaris 2.5 and 2.6 have libposix4, which was renamed to librt for Solaris >=7
+    if echo $UNAME_RELEASE | grep "^5\.[5|6]" >/dev/null 2>&1; then
+	sed -e "s,-lrt,-lposix4," $XQMAKESPEC/qmake.conf > $XQMAKESPEC/qmake.conf.new
+	mv $XQMAKESPEC/qmake.conf.new $XQMAKESPEC/qmake.conf
+    fi
+fi
+if [ $AUTOTHREAD = never ]; then
+    if [ "$CFG_THREAD" = "yes" ]; then
+	echo
+	echo "ERROR: Qt is not configured to support threading on this platform"
+	echo "       See the THREAD settings in $XQMAKESPEC/qmake.conf"
+	echo
+	exit 2
+    fi
+    AUTOTHREAD=no
+fi
+[ "$CFG_THREAD" = "auto" ] && CFG_THREAD=$AUTOTHREAD
+
+
+#-------------------------------------------------------------------------------
+# tests that don't need qmake (must be run before displaying help)
+#-------------------------------------------------------------------------------
+
+# auto-detect precompiled header support
+if [ "$CFG_PRECOMPILE" = "auto" ]; then
+    if $unixtests/precomp.test $XQMAKESPEC $OPT_VERBOSE; then
+        CFG_PRECOMPILE=no
+    else
+        CFG_PRECOMPILE=yes
+    fi
+fi
+
+# auto-detect SQL-modules support
+if echo $MODULES | grep sql >/dev/null; then
+    MYSQL_REQ="-lmysqlclient mysql.h"
+    OCI_REQ="-lclntsh -lwtc8 oci.h"
+    PSQL_REQ="-lpq postgres.h libpq/libpq-fs.h catalog/pg_type.h libpq-fe.h"
+    ODBC_REQ="-lodbc sql.h sqlext.h"
+    TDS_REQ="-lsybdb sybfront.h sybdb.h"
+    DB2_REQ="-ldb2 sqlcli.h sqlcli1.h"
+    IBASE_REQ="-lgds ibase.h"
+    for _SQLDR in $CFG_SQL_AVAILABLE; do
+	case $_SQLDR in
+	mysql)
+	    $unixtests/checkavail "MySQL" $OPT_VERBOSE $MYSQL_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED mysql"
+	;;
+	psql)
+	    $unixtests/checkavail "PostgreSQL" $OPT_VERBOSE $PSQL_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED psql"
+	    ;;
+	odbc)
+	    $unixtests/checkavail "ODBC" $OPT_VERBOSE $ODBC_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED odbc"
+	    ;;
+	oci)
+	    $unixtests/checkavail "OCI" $OPT_VERBOSE $OCI_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED oci"
+	    ;;
+	tds)
+	    $unixtests/checkavail "TDS" $OPT_VERBOSE $TDS_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED tds"
+	    ;;
+	db2)
+	    $unixtests/checkavail "DB2" $OPT_VERBOSE $DB2_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED db2"
+	    ;;
+	ibase)
+	    $unixtests/checkavail "IBASE" $OPT_VERBOSE $IBASE_REQ $L_FLAGS $I_FLAGS && CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED ibase"
+	    ;;
+	sqlite)
+	    if [ -f $relpath/src/3rdparty/sqlite/sqlite.h ]; then
+		CFG_SQL_AUTODETECTED="$CFG_SQL_AUTODETECTED sqlite"
+	    fi
+	    ;;
+	*)
+	    if [ "$OPT_VERBOSE" = "yes" ]; then
+		echo "unknown SQL driver: $_SQLDR"
+	    fi
+	    ;;
+	esac
+    done
+fi
+# auto-detect NIS support
+if [ "$CFG_NIS" != "no" ]; then
+    if $unixtests/nis.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	if [ "$CFG_NIS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+	    echo "NIS support cannot be enabled due to functionality tests!"
+	    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+	    echo " If you believe this message is in error you may use the continue"
+	    echo " switch (-continue) to $0 to continue."
+	    exit 101
+	else
+	    CFG_NIS=no
+        fi
+    else
+	CFG_NIS=yes
+    fi
+fi
+# auto-detect CUPS support
+if [ "$CFG_CUPS" != "no" ]; then
+    if $unixtests/cups.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	if [ "$CFG_CUPS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+	    echo "Cups support cannot be enabled due to functionality tests!"
+	    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+	    echo " If you believe this message is in error you may use the continue"
+	    echo " switch (-continue) to $0 to continue."
+	    exit 101
+	else
+	    CFG_CUPS=no
+        fi
+    else
+	CFG_CUPS=yes
+    fi
+fi
+
+#mac
+QT_MAC_VERSION=
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    mactests=$relpath/config.tests/mac
+    QT_MAC_VERSION=`$mactests/mac_version.test "$OPT_VERBOSE" "$relpath" "$outpath"`
+    if [ "$CFG_TABLET" = "auto" ]; then
+	CFG_TABLET=yes
+    fi
+fi
+
+# x11
+if [ "$PLATFORM_X11" = "yes" ]; then
+    x11tests=$relpath/config.tests/x11
+
+    # auto-detect OpenGL support
+    if echo $MODULES | grep opengl >/dev/null; then
+	if $x11tests/opengl.test $XQMAKESPEC $CFG_THREAD $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    MODULES=`echo $MODULES | sed -e 's/opengl//'`
+        else
+	    if [ "$CFG_DLOPEN_OPENGL" = "yes" ]; then
+		QMAKE_CONFIG="$QMAKE_CONFIG dlopen_opengl"
+	    fi
+	fi
+    fi
+    # auto-detect Xcursor support
+    if [ "$CFG_XCURSOR" != "no" ]; then
+        if $x11tests/xcursor.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XCURSOR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xcursor support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+            else
+                CFG_XCURSOR=no
+            fi
+	else
+            CFG_XCURSOR=yes
+        fi
+    fi
+    # auto-detect XRandR support (resize and rotate extension)
+    if [ "$CFG_XRANDR" != "no" ]; then
+	if $x11tests/xrandr.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XRANDR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XRandR support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRANDR=no
+	    fi
+	else
+	    CFG_XRANDR=yes
+	fi
+    fi
+    # auto-detect XRender support
+    if [ "$CFG_XRENDER" != "no" ]; then
+	if $x11tests/xrender.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XRENDER" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XRender support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRENDER=no
+		CFG_FREETYPE=no
+	    fi
+	else
+	    CFG_XRENDER=yes
+	fi
+    else
+	CFG_FREETYPE=no
+    fi
+    # auto-detect Xft support
+    if [ "$CFG_XRENDER" = "yes" ] && [ "$CFG_FREETYPE" != "no" ]; then
+	mkdir -p $outpath/config.tests/x11
+	if $x11tests/xfreetype.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_FREETYPE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xft support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_FREETYPE=no
+	    fi
+	else
+	    CFG_FREETYPE=yes
+	fi
+    fi
+    # add freetype2 include path
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.inc ];then
+	QMAKE_VARS="$QMAKE_VARS \"INCLUDEPATH+=`cat $outpath/config.tests/x11/xft.inc`\""
+    fi
+    rm -f $outpath/config.tests/x11/xft.inc
+    # add Xft specific libraries
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.lib ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11=`cat $outpath/config.tests/x11/xft.lib` \$\$QMAKE_LIBS_X11\""
+    fi
+    rm -f $outpath/config.tests/x11/xft.lib
+    # add Xft specific config options
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.cfg ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG `cat $outpath/config.tests/x11/xft.cfg`"
+    fi
+    rm -f $outpath/config.tests/x11/xft.cfg
+    # auto-detect Session Management support
+    if [ "$CFG_SM" = "auto" ]; then
+	if $x11tests/sm.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_SM" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Session Management support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_SM=no
+	    fi
+	else
+	    CFG_SM=yes
+	fi
+    fi
+    # auto-detect SHAPE support
+    if [ "$CFG_XSHAPE" != "no" ]; then
+	if $x11tests/xshape.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XSHAPE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XShape support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+            else
+                CFG_XSHAPE=no
+            fi
+	else
+	    CFG_XSHAPE=yes
+	fi
+    fi
+    # auto-detect Xinerama support
+    if [ "$CFG_XINERAMA" != "no" ]; then
+	if $x11tests/xinerama.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XINERAMA" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xinerama support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XINERAMA=no
+	    fi
+	else
+	    CFG_XINERAMA=yes
+	fi
+    fi
+    # auto-detect tablet support (currenlty only in IRIX)
+    if [ "$CFG_TABLET" = "auto" ]; then
+	case $PLATFORM in
+	irix-*)
+	    if $x11tests/xinput.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+		if [ "$CFG_TABLET" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		    echo "Tablet support cannot be enabled due to functionality tests!"
+		    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		    echo " If you believe this message is in error you may use the continue"
+		    echo " switch (-continue) to $0 to continue."
+		    exit 101
+		else
+		    CFG_TABLET=no
+		fi
+	    else
+		CFG_TABLET=yes
+	    fi
+	    ;;
+	*)
+	    CFG_TABLET=no
+	    ### add error message for the "yes" case on non-IRIX systems
+	    ;;
+	esac
+    fi
+    # auto-detect XKB support
+    if [ "$CFG_XKB" != "no" ]; then
+	if $x11tests/xkb.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
+	    if [ "$CFG_XKB" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XKB support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XKB=no
+	    fi
+	else
+	    CFG_XKB=yes
+	fi
+    fi
+fi
+
+# embedded graphics
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    CFG_GFX_AVAILABLE=`find $relpath/plugins/src/gfxdrivers/* -prune -type d -print | awk -F/ '{print $NF}'`
+    CFG_GFX_AVAILABLE=`echo $CFG_GFX_AVAILABLE`
+fi
+
+
+#-------------------------------------------------------------------------------
+# help - interactive parts of the script _after_ this section please
+#-------------------------------------------------------------------------------
+
+# next, emit a usage message if something failed.
+if [ "$OPT_HELP" = "yes" ]; then
+    [ "x$ERROR" = "xyes" ] && echo
+    if [ "$CFG_THREAD" = "yes" ]; then
+	THY="*"
+	THN=" "
+    else
+	THY=" "
+	THN="*"
+    fi
+    if [ "$CFG_NIS" = "no" ]; then
+	NSY=" "
+	NSN="*"
+    else
+	NSY="*"
+	NSN=" "
+    fi
+    if [ "$CFG_CUPS" = "no" ]; then
+	CUY=" "
+	CUN="*"
+    else
+	CUY="*"
+	CUN=" "
+    fi
+    if [ "$CFG_LARGEFILE" = "no" ]; then
+	LFSY=" "
+	LFSN="*"
+    else
+	LFSY="*"
+	LFSN=" "
+    fi
+    if [ "$CFG_STL" = "auto" ]; then
+	SHY="*"
+	SHN=" "
+    else
+	SHY=" "
+	SHN="*"
+    fi
+    if [ "$CFG_PRECOMPILE" = "auto" ]; then
+	PHY="*"
+	PHN=" "
+    else
+	PHY=" "
+	PHN="*"
+    fi
+    if [ "$CFG_IPV6" = "auto" ]; then
+	I6Y="*"
+	I6N=" "
+    else
+	I6Y=" "
+	I6N="*"
+    fi
+
+    cat <<EOF
+Usage:  $relconf [-prefix dir] [-buildkey key] [-docdir dir] [-headerdir dir]
+	[-libdir dir] [-bindir dir] [-plugindir dir ] [-datadir dir]
+	[-translationdir dir] [-sysconfdir dir] [-debug] [-release]
+	[-no-gif] [-qt-gif] [-no-sm] [-sm] [-qt-zlib] [-system-zlib]
+	[-qt-libjpeg] [-system-libjpeg] [-qt-libpng] [-system-libpng]
+	[-qt-libmng] [-system-libmng] [-no-thread] [-thread] [-no-nis] [-nis]
+	[-no-cups] [-cups] [-no-largefile] [-largefile] [-version-script]
+	[-no-stl] [-stl] [-no-ipv6 ] [-ipv6] [-Istring] [-lstring]
+	[-Lstring] [-Rstring] [-disable-<module>] [-with-<module setting>]
+	[-without-<module setting>] [-fast] [-no-fast]
+
+Installation options:
+
+ These are optional, but you may specify install directories.
+
+    -prefix dir ........ This will install everything relative dir
+			  (default $QT_INSTALL_PREFIX)
+
+ You may use these to separate different parts of the install:
+
+    -bindir dir ........ Executables will be installed to dir
+			  (default PREFIX/bin)
+    -libdir dir ........ Libraries will be installed to dir
+			  (default PREFIX/lib)
+    -docdir dir ........ Documentation will be installed to dir
+			  (default PREFIX/doc)
+    -headerdir dir ..... Headers will be installed to dir
+			  (default PREFIX/include)
+    -plugindir dir ..... Plugins will be installed to dir
+                          (default PREFIX/plugins)
+    -datadir dir ....... Data used by Qt programs will be installed to dir
+                          (default PREFIX)
+    -translationdir dir  Translations of Qt programs will be installed to dir
+                          (default PREFIX/translations)
+    -sysconfdir dir ...  Settings used by Qt programs will be looked for in dir
+                          (default PREFIX/etc/settings)
+
+ You may use these options to turn on strict plugin loading.
+
+    -buildkey key ...... Build the Qt library and plugins using the specified
+			 key.  When the library loads plugins, it will only
+			 load those that have a matching key.
+
+Configure options:
+
+ The defaults (*) are usually acceptable.  If marked with a plus (+) a test
+ for that feature has not been done yet, but will be evaluated later, the
+ plus simply denotes the default value. Here is a short explanation of each
+ option:
+
+ *  -release ........... Compile and link Qt with debugging turned off.
+    -debug ............. Compile and link Qt with debugging turned on.
+
+ *  -shared ............ Create and use a shared Qt library (libqt.so).
+    -static ............ Create and use a static Qt library (libqt.a).
+
+ *  -no-gif ............ Do not compile in GIF reading support.
+    -qt-gif ............ Compile in GIF reading support.
+			 See src/kernel/qgif.h
+
+ *  -qt-zlib ........... Use the zlib bundled with Qt.
+    -system-zlib ....... Use zlib from the operating system.
+			 See http://www.gzip.org/zlib
+
+    -fast .............. Configure Qt quickly by generating Makefiles only for
+			 library and subdirectory targets.  All other Makefiles
+			 are created as wrappers, which will in turn run qmake.
+ *  -no-fast ........... Configure Qt normally by generating Makefiles for all
+			 project files.
+
+    -no-exceptions ..... Disable exceptions on platforms that support it.
+
+    -version-script .... Use a version script when linking the Qt library.
+			 Internal symbols will be marked as local. Requires
+			 a recent GNU binutils package.
+
+			 WARNING: Experimental, may be removed in future
+			 versions.
+
+    -platform target ... The operating system and compiler you are building
+			 on ($PLATFORM).
+    -xplatform target .. The target platform when cross-compiling.
+
+			 See the PLATFORMS file for a list of supported
+			 operating systems and compilers.
+
+    -Dstring ........... Add an explicit define to the preprocessor.
+    -Istring ........... Add an explicit include path.
+    -Lstring ........... Add an explicit library path.
+    -Rstring ........... Add an explicit dynamic library runtime search path.
+    -lstring ........... Add an explicit library.
+
+    -disable-<module> ..... Disable <module> where module is one of:
+                            [ $CFG_MODULES_AVAILABLE ]
+
+    -qt-sql-<driver> ...... Enable a SQL <driver> in the Qt Library, by default
+                            none are turned on.
+    -plugin-sql-<driver> .. Enable SQL <driver> as a plugin to be linked to
+                            at run time.
+    -no-sql-<driver> ...... Disable SQL <driver> entirely.
+
+                            Possible values for <driver>:
+                            [ $CFG_SQL_AVAILABLE ]
+
+                            Auto-Detected on this system:
+                            [$CFG_SQL_AUTODETECTED ]
+
+                            By default none of the SQL drivers are built,
+			    even if they are auto-detected.
+
+    -qt-style-<style> ..... Enable a GUI <style> in the Qt Library, by default
+                            all available styles are on.
+    -plugin-style-<style> . Enable GUI <style> as a plugin to be linked to
+                            at run time.
+    -no-style-<style> ..... Disable GUI <style> entirely.
+
+                            Possible values for <style>:
+                            [ $CFG_STYLE_AVAILABLE ]
+
+ $THN  -no-thread ............ Do not compile threading support.
+ $THY  -thread ............... Compile threading support.
+
+ $NSN  -no-nis ............... Do not compile NIS support.
+ $NSY  -nis .................. Compile NIS support.
+
+ $PHN  -no-pch ............... Do not use precompiled header support.
+ $PHY  -pch .................. Use precompiled header support.
+
+ $CUN  -no-cups............... Do not compile CUPS support.
+ $CUY  -cups ................. Compile CUPS support.
+
+ $SHN  -no-stl ............... Do not compile STL support.
+ $SHY  -stl .................. Compile STL support.
+
+ $I6N  -no-ipv6 .............. Do not compile IPv6 support.
+ $I6Y  -ipv6 ................. Compile IPv6 support.
+
+    -verbose .............. Print verbose information about each step of the
+    -v .................... configure process.
+
+    -continue.............. Continue as far as possible if an error occurs.
+
+    -help ................. Print help and usage information.
+    -h .................... Print help and usage information.
+
+Image Formats:
+
+    -plugin-imgfmt-<format> Enable <format> to be linked to at runtime.
+                            Uses specified lib<format>.
+    -qt-imgfmt-<format> ... Enable <format> to be linked into Qt.
+                            Uses specified lib<format>.
+    -no-imgfmt-<format> ... Fully disable <format> from Qt.
+
+                            Possible values for <format>:
+                            [ png jpeg mng ]
+
+Third Party Image Loading Libraries:
+
+ *  -qt-libpng ......... Use the libpng bundled with Qt.
+    -system-libpng ..... Use libpng from the operating system.
+			 See http://www.libpng.org/pub/png
+
+ *  -qt-libjpeg ........ Use the libjpeg bundled with Qt.
+    -system-libjpeg .... Use jpeglib from the operating system.
+			 See http://www.ijg.org
+
+ *  -qt-libmng ......... Use the libmng bundled with Qt.
+    -system-libmng ..... Use libmng from the operating system.
+			 See http://www.libmng.com
+EOF
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    cat << EOF
+
+Qt/Mac only:
+
+    -no-tablet ......... Do not compile Tablet support.
+ *  -tablet ............ Compile Tablet support.
+
+    -no-accessibility .. Do not compile Accessibility support.
+ *  -accessibility ..... Compile Accessibility support.
+EOF
+fi
+
+if [ "$PLATFORM_X11" = "yes" ]; then
+    if [ "$CFG_SM" = "no" ]; then
+	SMY=" "
+	SMN="*"
+    else
+	SMY="*"
+	SMN=" "
+    fi
+    if [ "$CFG_XSHAPE" = "no" ]; then
+        SHY=" "
+        SHN="*"
+    else
+        SHY="*"
+        SHN=" "
+    fi
+    if [ "$CFG_XINERAMA" = "no" ]; then
+	XRY=" "
+	XRN="*"
+    else
+	XRY="*"
+	XRN=" "
+    fi
+    if [ "$CFG_FREETYPE" = "no" ]; then
+	XFTY=" "
+	XFTN="*"
+    else
+	XFTY="*"
+	XFTN=" "
+    fi
+    if [ "$CFG_XCURSOR" = "no" ]; then
+        XCY=" "
+        XCN="*"
+    else
+        XCY="*"
+        XCN=" "
+    fi
+    if [ "$CFG_XRANDR" = "no" ]; then
+        XZY=" "
+        XZN="*"
+    else
+        XZY="*"
+        XZN=" "
+    fi
+    if [ "$CFG_XRENDER" = "no" ]; then
+	XRY=" "
+	XRN="*"
+    else
+	XRY="*"
+	XRN=" "
+    fi
+    if [ "$CFG_TABLET" = "no" ]; then
+	XIY=" "
+	XIN="*"
+    else
+	XIY="*"
+	XIN=" "
+    fi
+    if [ "$CFG_XKB" = "no" ]; then
+        XKY=" "
+        XKN="*"
+    else
+        XKY="*"
+        XKN=" "
+    fi
+    cat << EOF
+
+Qt/X11 only:
+
+ *  -no-nas-sound ...... Do not compile in NAS sound support.
+    -system-nas-sound .. Use NAS libaudio from the operating system.
+			 See http://radscan.com/nas.html
+
+ $SMN  -no-sm ............. Do not support X Session Management.
+ $SMY  -sm ................ Support X Session Management, links in -lSM -lICE.
+
+ $SHN  -no-xshape ......... Do not compile XShape support.
+ $SHY  -xshape ............ Compile XShape support.
+                         Requires X11/extensions/shape.h.
+
+ $XRN  -no-xinerama ....... Do not compile Xinerama (multihead) support.
+ $XRY  -xinerama .......... Compile Xinerama support.
+			 Requires X11/extensions/Xinerama.h and libXinerama.
+
+ $XCN  -no-xcursor ........ Do not compile Xcursor support.
+ $XCY  -xcursor ........... Compile Xcursor support.
+                         Requires X11/Xcursor/Xcursor.h and libXcursor.
+
+ $XZN  -no-xrandr ......... Do not compile XRandR (resize and rotate) support.
+ $XZY  -xrandr ............ Compile XRandR support.
+                         Requires X11/extensions/Xrandr.h and libXrandr.
+
+ $XRN  -no-xrender ........ Do not compile XRender support.
+ $XRY  -xrender ........... Compile XRender support.
+			 Requires Xft support (see -xft below),
+			 X11/extensions/Xrender.h and libXrender
+
+ $XFTN  -no-xft ............ Do not compile Xft (anti-aliased font) support.
+ $XFTY  -xft ............... Compile Xft support.
+			 Requires X11/Xft/Xft.h and libXft.
+
+ $XIN  -no-tablet ......... Do not compile Tablet support.
+ $XIY  -tablet ............ Compile Tablet support.
+			 Requires IRIX with wacom.h and libXi or
+			 XFree86 with X11/extensions/XInput.h and libXi.
+
+ $XKN  -no-xkb ............ Do not compile XKB (X KeyBoard extension) support.
+ $XKY  -xkb ............... Compile XKB support.
+
+ *  -no-dlopen-opengl .. Qt links against OpenGL libraries directly.
+    -dlopen-opengl ..... Qt uses dlopen(3) to resolve OpenGL functions
+			 (instead of linking with OpenGL libraries directly).
+
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QNX" = "yes" ]; then
+    cat << EOF
+
+Qt/Embedded only:
+
+    -embedded arch...... This will enable the embedded build, you must have a
+			 proper license for this switch to work.
+
+    -little-endian ..... Target platform is little endian (LSB first).
+    -big-endian ........ Target platform is big endian (MSB first).
+
+                         You only need to specify the endianness when
+                         cross-compiling, otherwise the host
+                         endianness will be used.
+
+    -no-freetype ....... Qt/Embedded only: do not compile in FreeType2 support.
+ *  -freetype .......... Qt/Embedded only: add FreeType2 font support.
+
+    -no-zlib ........... No compression library -- implies -no-libpng
+
+    -qconfig local ..... Use src/tools/qconfig-local.h rather than the
+			 default ($CFG_QCONFIG).
+
+    -depths list ....... Comma-separated list of supported bit-per-pixel
+			 depths, from:  4, 8, 16, 24, and 32.
+			 (8bpp is required by the VGA16 driver)
+
+    -qt-gfx-<driver> ... Enable a graphics <driver> in the Qt Library.
+    -plugin-gfx-<driver> Enable graphics <driver> as a plugin to be
+                         linked to at run time.
+    -no-gfx-<driver> ... Disable graphics <driver> entirely.
+
+                         Possible values for <driver>: [ $CFG_GFX_AVAILABLE ]
+
+    -qt-kbd-<driver> ... Enable a keyboard <driver> in the Qt Library.
+    -no-kbd-<driver> ... Disable keyboard <driver> entirely.
+
+                         Possible values for <driver>: [ sl5000 tty usb yopy vr41xx ]
+
+    -qt-mouse-<driver> . Enable a mouse <driver> in the Qt Library.
+    -no-mouse-<driver> . Disable mouse <driver> entirely.
+
+                         Possible values for <driver>: [ pc bus linuxtp yopy vr41xx ]
+
+EOF
+fi
+
+   [ "x$ERROR" = "xyes" ] && exit 1
+   exit 0
+fi
+
+
+# -----------------------------------------------------------------------------
+# LICENSING, INTERACTIVE PART
+# -----------------------------------------------------------------------------
+
+# check for license confirmation
+if [ "$Edition" = "qtopia" ]; then
+    if [ "$PLATFORM_X11" = "yes" ]; then
+	Platform="Qt/X11"
+    else
+	echo
+	echo "Internal error: unknown platform."
+	echo
+	exit 2
+    fi
+    TheLicense=`head -n 1 $relpath/LICENSE.Qtopia`
+    while true; do
+        echo
+        echo "This is the $Platform Qtopia Edition."
+        echo
+        echo "You are licensed to use this software under the terms of"
+        echo "the $TheLicense."
+        echo
+        echo "Type '?' to view the $TheLicense."
+        echo "Type 'yes' to accept this license offer."
+        echo "Type 'no' to decline this license offer."
+        echo
+        if echo '\c' | grep '\c' >/dev/null; then
+            echo -n "Do you accept the terms of the $TheLicense? "
+        else
+            echo "Do you accept the terms of the $TheLicense? \c"
+        fi
+        read acceptance
+        echo
+	if [ "$acceptance" = yes ]; then
+	    break
+	else
+	    if [ "$acceptance" = no ]; then
+		echo "You are not licensed to use this software."
+		echo
+		exit 0
+	    elif [ "$acceptance" = "?" ]; then
+		more $relpath/LICENSE.Qtopia
+	    fi
+	fi
+    done
+elif [ "$Edition" = "free" ]; then
+    while true; do
+	if [ "$PLATFORM_QWS" = "yes" ]; then
+	    echo
+	    echo "This is the Qt/Embedded Open Source Edition."
+	    echo
+	    echo "You are licensed to use this software under the terms of"
+	    echo "the GNU General Public License (GPL) versions 2 or 3."
+	    echo
+	    affix="the"
+	elif [ "$PLATFORM_MAC" = "yes" ]; then
+	    echo
+	    echo "This is the Qt/Mac Open Source Edition."
+	    echo
+	    echo "You are licensed to use this software under the terms of"
+	    echo "the GNU General Public License (GPL) versions 2 or 3."
+	    echo
+	    affix="the"
+	elif [ "$PLATFORM_X11" = "yes" ]; then
+	    echo
+	    echo "This is the Qt/X11 Open Source Edition."
+	    echo
+	    echo "You are licensed to use this software under the terms of either"
+	    echo "the Q Public License (QPL) or the GNU General Public License (GPL)"
+	    echo "versions 2 or 3."
+	    echo
+	    echo "Type 'Q' to view the Q Public License."
+	    affix="either"
+	else
+	    echo
+	    echo "Internal error."
+	    echo
+	    exit 2
+	fi
+	echo "Type '2' to view the GNU General Public License version 2."
+	echo "Type '3' to view the GNU General Public License version 3."
+	echo "Type 'yes' to accept this license offer."
+	echo "Type 'no' to decline this license offer."
+	echo
+	if echo '\c' | grep '\c' >/dev/null; then
+	    echo -n "Do you accept the terms of $affix license? "
+	else
+	    echo "Do you accept the terms of $affix license? \c"
+	fi
+	read acceptance
+	echo
+	if [ "$acceptance" = "yes" ]; then
+	    break
+	elif [ "$acceptance" = "no" ]; then
+	    echo "You are not licensed to use this software."
+	    echo
+	    exit 0
+	elif [ "$acceptance" = "2" ]; then
+	    more $relpath/LICENSE.GPL2
+	elif [ "$acceptance" = "3" ]; then
+	    more $relpath/LICENSE.GPL3
+	elif [ "$acceptance" = "Q" -o "$acceptance" = "q" ]; then
+	    if [ "$PLATFORM_QWS" != "yes" ]; then
+		more $relpath/LICENSE.QPL
+	    fi
+	fi
+    done
+elif [ "$Edition" = "eval" ]; then
+    while true; do
+	if [ "$PLATFORM_QWS" = "yes" ]; then
+	    echo
+	    echo "This is the Qt/Embedded Evaluation version."
+	    echo
+	elif [ "$PLATFORM_X11" = "yes" ]; then
+	    echo
+	    echo "This is the Qt/X11 Evaluation version."
+	    echo
+	else
+	    echo >&2
+	    echo "Internal error." >&2
+	    echo >&2
+	    exit 2
+	fi
+	echo "You are licensed to use this software under the terms of"
+	echo "the Qt EVALUATION VERSION LICENSE AGREEMENT"
+	echo
+	echo "Type '?' to view the Evaluation License."
+	echo "Type 'yes' to accept this license offer."
+	echo "Type 'no' to decline this license offer."
+	echo
+	if echo '\c' | grep '\c' >/dev/null; then
+	    echo -n "Do you accept the terms of the license? "
+	else
+	    echo "Do you accept the terms of the license? \c"
+	fi
+	read acceptance
+	echo
+	if [ "$acceptance" = "yes" ]; then
+	    break
+	elif [ "$acceptance" = "no" ] ;then
+	    echo "You are not licensed to use this software."
+	    echo
+	    exit 0
+	elif [ "$acceptance" = "?" ]; then
+	    more $relpath/LICENSE.EVAL
+	fi
+    done
+elif [ "$Edition" = "troll" ]; then
+    if [ "$PLATFORM_QNX" = "yes" ]; then
+	Platform="Qt/QNX"
+    elif [ "$PLATFORM_QWS" = "yes" ]; then
+	Platform="Qt/Embedded"
+    elif [ "$PLATFORM_MAC" = "yes" ]; then
+	Platform="Qt/Mac"
+    elif [ "$PLATFORM_X11" = "yes" ]; then
+	Platform="Qt/X11"
+    else
+	echo
+	echo "Internal error: unknown platform."
+	echo
+	exit 2
+    fi
+    echo
+    echo "This is the Trolltech in-house version of $Platform."
+    echo
+else
+    if [ -f $HOME/.qt-license ]; then
+	ExpiryDate=`echo $ExpiryDate | sed -e "s,-,,g" | tr -d "\n\r"`
+	[ -z "$ExpiryDate" ] && ExpiryDate="0"
+	Today=`date +%Y%m%d`
+	if [ "$Today" -gt "$ExpiryDate" ]; then
+	    echo
+	    echo "WARNING  WARNING  WARNING  WARNING"
+	    echo
+	    echo "  Your support and upgrade period has expired."
+	    echo
+	    echo "  You may continue to use your last licensed release"
+	    echo "  of Qt under the terms of your existing license"
+	    echo "  agreement. But you are not entitled to technical"
+	    echo "  support, nor are you entitled to use any more recent"
+	    echo "  Qt releases."
+	    echo
+	    echo "  Please contact sales@trolltech.com to renew your"
+	    echo "  support and upgrades for this license."
+	    echo
+	    echo "WARNING  WARNING  WARNING  WARNING"
+	    echo
+	    sleep 3
+	fi
+    fi
+    if [ "$PLATFORM_QWS" = "yes" ]; then
+	Platform="Qt/Embedded"
+    elif [ "$PLATFORM_MAC" = "yes" ]; then
+	Platform="Qt/Mac"
+    elif [ "$PLATFORM_X11" = "yes" ]; then
+	Platform="Qt/X11"
+    else
+	echo >&2
+	echo "Internal error." >&2
+	echo >&2
+	exit 2
+    fi
+    echo
+    echo "This is the $Platform $Desc Edition."
+    echo
+    while true; do
+	echo
+	echo "Type '?' to view the $Platform License."
+	echo "Type 'yes' to accept this license offer."
+	echo "Type 'no' to decline this license offer."
+	echo
+	if echo '\c' | grep '\c' >/dev/null; then
+	    echo -n "Do you accept the terms of the $Platform License? "
+	else
+	    echo "Do you accept the terms of the $Platform License? \c"
+	fi
+	read acceptance
+	echo
+	if [ "$acceptance" = "yes" ]; then
+	    break
+	elif [ "$acceptance" = "no" ]; then
+	    echo "You are not licensed to use this software."
+	    echo
+	    exit 0
+	else [ "$acceptance" = "?" ]
+	    more $relpath/LICENSE
+	fi
+    done
+fi
+
+# work around for broken system header files in IRIX 6.5.18 - 6.5.22
+case "$PLATFORM" in
+irix-cc*)
+    IRIX_VERSION=`uname -R | awk '{FS=".";print $4}' | sed s/\[m\|f\]//g`
+    MIPSPRO_MINOR_VERSION=`CC -version 2>&1 | awk '{FS=".";print $2}'`
+    if [ "$MIPSPRO_MINOR_VERSION" -gt "3" -a "$IRIX_VERSION" -ge "18" \
+	 -a "$IRIX_VERSION" -le "22" ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_CXXFLAGS+=-LANG:libc_in_namespace_std=off\""
+    fi
+    ;;
+*)
+    IRIX_VERSION=-1
+    MIPSPRO_MINOR_VERSION=-1
+    ;;
+esac
+
+# -----------------------------------------------------------------------------
+# build qmake
+# -----------------------------------------------------------------------------
+
+# symlink includes
+if [ -x "$relpath/bin/syncqt" ]; then
+    QTDIR=$relpath perl $relpath/bin/syncqt -inc $relpath/include
+    [ "$OPT_SHADOW" = "yes" ] && QTDIR=$relpath perl $relpath/bin/syncqt -inc $outpath/include
+fi
+
+if [ "$OPT_SHADOW" = "yes" ]; then
+    # we are doing a shadow build, so we need to use the includes from
+    # $outpath/include as well
+    QMAKE_VARS="$QMAKE_VARS \"INCLUDEPATH+=${outpath}/include\""
+fi
+
+# build qmake
+if true; then ###[ '!' -f "$outpath/bin/qmake" ];
+    echo "Creating qmake. Please wait..."
+    rm -f mkspecs/default
+    ln -s `echo $QMAKESPEC | sed "s,^${relpath}/mkspecs/,,"` mkspecs/default
+    # fix makefiles
+    for mkfile in GNUmakefile Makefile; do
+	EXTRA_LFLAGS=
+	EXTRA_CFLAGS=
+	in_mkfile="${mkfile}.in"
+	if [ "$mkfile" = "Makefile" ]; then
+#	    if which qmake >/dev/null 2>&1 && [ -f qmake/qmake.pro ]; then
+#		(cd qmake && qmake) >/dev/null 2>&1 && continue
+#	    fi
+	    in_mkfile="${mkfile}.unix"
+	fi
+	in_mkfile="$relpath/qmake/$in_mkfile"
+	mkfile="$outpath/qmake/$mkfile"
+	if [ -f "$mkfile" ]; then
+	    [ "$Edition" = "troll" ] && $WHICH chflags >/dev/null 2>&1 && chflags nouchg $mkfile
+	    rm -f $mkfile
+	fi
+	[ -f "$in_mkfile" ] || continue
+
+	echo "########################################################################" >$mkfile
+	echo "## This file was autogenerated by configure, all changes will be lost ##" >>$mkfile
+	echo "########################################################################" >>$mkfile
+        EXTRA_CFLAGS="\$(QMAKE_CFLAGS)"
+        EXTRA_CXXFLAGS="\$(QMAKE_CXXFLAGS)"
+        EXTRA_LFLAGS="\$(QMAKE_LFLAGS)"
+	grep "^QMAKE_CC[^_A-Z0-9]" $QMAKESPEC/qmake.conf | sed "s,QMAKE_CC,CC," >>$mkfile
+	grep "^QMAKE_CXX[^_A-Z0-9]" $QMAKESPEC/qmake.conf | sed "s,QMAKE_CXX,CXX," >>$mkfile
+        grep "^QMAKE_CFLAGS[^_A-Z0-9]" $QMAKESPEC/qmake.conf >>$mkfile
+        grep "^QMAKE_CXXFLAGS[^_A-Z0-9]" $QMAKESPEC/qmake.conf | sed "s,\$\$QMAKE_CFLAGS,\$(QMAKE_CFLAGS)," >>$mkfile
+        grep "^QMAKE_LFLAGS[^_A-Z0-9]" $QMAKESPEC/qmake.conf >>$mkfile
+	if [ "$CFG_DEBUG" = "yes" ]; then
+            grep "QMAKE_CFLAGS_DEBUG[^_A-Z0-9]" $QMAKESPEC/qmake.conf >>$mkfile
+	    EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QMAKE_CFLAGS_DEBUG)"
+	    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(QMAKE_CXXFLAGS_DEBUG)"
+        fi
+	if [ "$PLATFORM_MAC" = "yes" ]; then
+	    echo "CARBON_LFLAGS +=-framework CoreServices" >>$mkfile
+	    EXTRA_LFLAGS="$EXTRA_LFLAGS \$(CARBON_LFLAGS)"
+	    EXTRA_CFLAGS="$EXTRA_CFLAGS \$(CARBON_CFLAGS) -DQT_MACOSX_VERSION=$QT_MAC_VERSION"
+	    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(CARBON_CFLAGS) -DQT_MACOSX_VERSION=$QT_MAC_VERSION"
+	    EXTRA_SOURCES="qurl.o qsettings_mac.o"
+	elif [ "$PLATFORM" = "tru64-cxx" ]; then
+	    echo "OSF_LFLAGS = -lm"  >>$mkfile
+	    EXTRA_LFLAGS="$EXTRA_LFLAGS \$(OSF_LFLAGS)"
+        elif [ "$PLATFORM_QNX" = "yes" ]; then
+	  echo "QNX_LFLAGS += -fhonor-std -fno-builtins -pipe" >>$mkfile
+	  echo "QNX_CFLAGS += -lcpp" >>$mkfile
+	  EXTRA_LFLAGS="$EXTRA_CFLAGS \$(QNX_LFLAGS)"
+	  EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QNX_CFLAGS)"
+	fi
+	[ "$CFG_EMBEDDED" != "no" ] && EXTRA_CFLAGS="$EXTRA_CFLAGS -DQWS"
+	if [ '!' -z "$D_FLAGS" ]; then
+	    for DEF in $D_FLAGS; do
+		EXTRA_CFLAGS="$EXTRA_CFLAGS -D${DEF}"
+	    done
+        fi
+	if [ "$MIPSPRO_MINOR_VERSION" -gt "3" \
+	      -a "$IRIX_VERSION" -ge "18" -a "$IRIX_VERSION" -le "22" ]; then
+	    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS -LANG:libc_in_namespace_std=off"
+	fi
+	QMAKE_BIN_DIR="$QT_INSTALL_BINS"
+	[ -z "$QMAKE_BIN_DIR" ] && QMAKE_BIN_DIR="${QT_INSTALL_PREFIX}/bin"
+	QMAKE_DATA_DIR="$QT_INSTALL_DATA"
+	[ -z "$QMAKE_DATA_DIR" ] && QMAKE_DATA_DIR="${QT_INSTALL_PREFIX}"
+        echo >>$mkfile
+	sed -e "s,@SOURCE_PATH@,$relpath,g" -e "s,@BUILD_PATH@,$outpath,g" \
+	    -e "s,@QMAKE_CFLAGS@,$EXTRA_CFLAGS,g" -e "s,@QMAKE_LFLAGS@,$EXTRA_LFLAGS,g" \
+            -e "s,@QMAKE_CXXFLAGS@,$EXTRA_CXXFLAGS,g" \
+	    -e "s,@QT_INSTALL_BINS@,\$(INSTALL_ROOT)$QMAKE_BIN_DIR,g" \
+	    -e "s,@QT_INSTALL_DATA@,\$(INSTALL_ROOT)$QMAKE_DATA_DIR,g" \
+	    -e "s,@QMAKE_QTOBJS@,$EXTRA_SOURCES,g" -e "s,@QMAKESPEC@,$QMAKESPEC,g" $in_mkfile >>$mkfile
+
+	if [ "$Edition" = "troll" ] &&
+	    $WHICH makedepend >/dev/null 2>&1 && grep 'depend:' "$mkfile" >/dev/null 2>&1; then
+	    (cd $outpath/qmake && $MAKE -f $mkfile depend) >/dev/null 2>&1
+	fi
+    done
+
+    (cd $outpath/qmake; $MAKE || (echo "qmake failed to build. Aborting." && exit 2)) || exit 2
+fi
+
+# clean up temporary qconfig.h and qmodules.h
+rm -f $outpath/include/qmake/qconfig.h
+rm -f $outpath/include/qmake/qmodules.h
+rmdir $outpath/include/qmake
+
+
+#-------------------------------------------------------------------------------
+# tests that need qmake
+#-------------------------------------------------------------------------------
+
+# work around broken X11 headers when using GCC 2.95 or later
+if [ "$PLATFORM_X11" = "yes" ]; then
+    NOTYPE=no
+    $x11tests/notype.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath && NOTYPE=yes
+    [ $NOTYPE = "yes" ] && QMAKE_VARS="$QMAKE_VARS \"QMAKE_CXXFLAGS+=-fpermissive\""
+fi
+
+# find if the compiler supports enough of STL for our purposes
+if [ $PLATFORM = "hpux-acc" -a "$CFG_STL" != "no" ]; then
+   echo
+   echo "As of aCC A.3.0.30 you may enable STL support in Qt by adding -AA"
+   echo "to the QMAKE_CXXFLAGS and QMAKE_LFLAGS variables in"
+   echo "$XQMAKESPEC/qmake.conf"
+   echo "and re-running configure. Make sure to use the -AA compiler switch"
+   echo "in all your software projects using Qt as it turns on the new C++"
+   echo "Standard Library which is not binary compatible with the old one."
+   echo
+fi
+
+if [ "$CFG_ENDIAN" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ]; then
+        true
+    elif $unixtests/endian.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath; then
+        CFG_ENDIAN="Q_LITTLE_ENDIAN"
+    else
+        CFG_ENDIAN="Q_BIG_ENDIAN"
+    fi
+fi
+
+if [ "$CFG_STL" = "auto" ]; then
+    if $unixtests/stl.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath; then
+	if [ "$CFG_STL" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+	    echo "STL support cannot be enabled due to functionality tests!"
+	    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+	    echo " If you believe this message is in error you may use the continue"
+	    echo " switch (-continue) to $0 to continue."
+	    exit 101
+	else
+	    CFG_STL=no
+	fi
+    else
+	CFG_STL=yes
+    fi
+fi
+
+# find if the platform supports IPv6
+if [ "$CFG_IPV6" = "auto" ]; then
+    if $unixtests/ipv6.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath; then
+	if [ "$CFG_IPV6" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+	    echo "IPv6 support cannot be enabled due to functionality tests!"
+	    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+	    echo " If you believe this message is in error you may use the continue"
+	    echo " switch (-continue) to $0 to continue."
+	    exit 101
+	else
+	    CFG_IPV6=no
+	fi
+    else
+	CFG_IPV6=yes
+    fi
+fi
+
+# find if the platform supports X/Open Large File compilation environment
+if [ "$CFG_LARGEFILE" = "auto" ]; then
+    if $unixtests/largefile.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath; then
+	if [ "$CFG_LARGEFILE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+	    echo "Large file support cannot be enabled due to functionality tests!"
+	    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+	    echo " If you believe this message is in error you may use the continue"
+	    echo " switch (-continue) to $0 to continue."
+	    exit 101
+	else
+	    CFG_LARGEFILE=no
+	fi
+    else
+	CFG_LARGEFILE=yes
+    fi
+fi
+
+
+#-------------------------------------------------------------------------------
+# ask for all that hasn't been auto-detected or specified in the arguments
+#-------------------------------------------------------------------------------
+
+### fix this: user input should be validated in a loop
+if [ "$CFG_QWS_DEPTHS" = "prompted" -a "$PLATFORM_QWS" = "yes" ]; then
+    echo
+    echo "Choose pixel-depths to support:"
+    echo
+    echo "   4. 4bpp grayscale - also enables 8bpp"
+    echo "   8. 8bpp"
+    echo "  16. 16bpp"
+    echo "  24. 24bpp - also enables 32bpp"
+    echo "  32. 32bpp"
+    echo
+    echo "Each depth adds around 100Kb on 80386."
+    echo
+    echo "Your choices (default 8,16,32):"
+    read CFG_QWS_DEPTHS
+    if [ -z "$CFG_QWS_DEPTHS" ] || [ "$CFG_QWS_DEPTHS" = "yes" ]; then
+	CFG_QWS_DEPTHS=8,16,32
+    fi
+fi
+if [ -n "$CFG_QWS_DEPTHS" -a "$PLATFORM_QWS" = "yes" ]; then
+    D4=;D8=;D16=;D24=;D32=
+    for D in `echo "$CFG_QWS_DEPTHS" | sed -e 's/,/ /g'`; do
+	case "$D" in
+	    4) D4=y; D8=y
+	;;  8) D8=y
+	;; 16) D16=y
+	;; 24) D24=y; D32=y
+	;; 32) D32=y
+	esac
+    done
+    if [ -z "$D4" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_DEPTH_4"
+    fi
+    if [ -z "$D8" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_DEPTH_8"
+    fi
+    if [ -z "$D16" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_DEPTH_16"
+    fi
+    if [ -z "$D24" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_DEPTH_24"
+    fi
+    if [ -z "$D32" ]; then
+	QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_DEPTH_32"
+    fi
+fi
+
+# enable accessibility
+if [ "$CFG_ACCESSIBILITY" = "yes" ]; then
+   QMAKE_CONFIG="$QMAKE_CONFIG accessibility"
+fi
+
+# update QMAKE_CONFIG to show our current predefined configuration
+case "$CFG_QCONFIG" in
+minimal|small|medium|large|full)
+    # these are a sequence of increasing functionality
+    for c in minimal small medium large full; do
+	QMAKE_CONFIG="$QMAKE_CONFIG $c-config"
+	if [ "$CFG_QCONFIG" = $c ]; then
+	    break;
+	fi
+    done
+    ;;
+*)
+    # not known to be sufficient for anything
+    if [ '!' -f $relpath/src/tools/qconfig-$CFG_QCONFIG.h ]; then
+	echo >&2 "No such configuration: $CFG_QCONFIG"
+	OPT_HELP=yes
+    fi
+esac
+
+# update QMAKE_CONFIG to show which modules are being built
+for MODULE in $MODULES; do
+    if [ -d "$relpath/src/$MODULE" ]; then
+	M=`echo $MODULE | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+	QMAKE_CONFIG="$QMAKE_CONFIG $MODULE"
+    fi
+done
+
+
+#-------------------------------------------------------------------------------
+# ??? ### please add a title to this section
+#-------------------------------------------------------------------------------
+
+# build up the variables for output
+QMAKE_OUTDIR=""
+case $Products in
+qt-enterprise)
+    QMAKE_CONFIG="$QMAKE_CONFIG enterprise"
+    ;;
+qt-internal)
+    # QMAKE_CONFIG="$QMAKE_CONFIG internal"
+    ;;
+*)
+    ;;
+esac
+
+if [ "$CFG_DEBUG" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}debug"
+    QMAKE_CONFIG="$QMAKE_CONFIG debug"
+elif [ "$CFG_DEBUG" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}release"
+    QMAKE_CONFIG="$QMAKE_CONFIG release"
+fi
+if [ "$CFG_SHARED" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-shared"
+    QMAKE_CONFIG="$QMAKE_CONFIG dll"
+elif [ "$CFG_SHARED" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-static"
+    QMAKE_CONFIG="$QMAKE_CONFIG staticlib"
+fi
+if [ "$CFG_THREAD" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-mt"
+    QMAKE_CONFIG="$QMAKE_CONFIG thread"
+fi
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QNX" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-emb-$CFG_EMBEDDED"
+    QMAKE_CONFIG="$QMAKE_CONFIG embedded"
+    rm -f src/.moc/$QMAKE_OUTDIR/allmoc.cpp # needs remaking if config changes
+fi
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_INCDIR_QT=$relpath/include\""
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBDIR_QT=$outpath/lib\""
+QMAKE_VARS="$QMAKE_VARS \"QMAKE_RTLDIR_QT=$QT_INSTALL_LIBS\""
+QMAKE_VARS="$QMAKE_VARS \"OBJECTS_DIR=.obj/$QMAKE_OUTDIR\" \"MOC_DIR=.moc/$QMAKE_OUTDIR\""
+if [ "$CFG_LARGEFILE" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG largefile"
+fi
+if [ "$CFG_STL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STL"
+else
+    QMAKE_CONFIG="$QMAKE_CONFIG stl"
+fi
+[ "$CFG_PRECOMPILE" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG precompile_header"
+if [ "$CFG_IPV6" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IPV6"
+else
+    QMAKE_CONFIG="$QMAKE_CONFIG ipv6"
+fi
+# don't add the link line if we build the image formats as a plugin
+if [ "$CFG_LIBMNG" = "system" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG system-mng"
+    if [ "$CFG_MNG" = "yes" ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT+=-lmng\""
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT_THREAD+=-lmng\""
+    fi
+fi
+if [ "$CFG_MNG" = "no" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG no-mng"
+elif [ "$CFG_MNG" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG mng"
+fi
+if [ "$CFG_LIBJPEG" = "system" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG system-jpeg"
+    if [ "$CFG_JPEG" = "yes" ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT+=-ljpeg\""
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT_THREAD+=-ljpeg\""
+    fi
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG no-jpeg"
+elif [ "$CFG_JPEG" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG jpeg"
+fi
+if [ "$CFG_LIBPNG" = "no" ]; then
+    CFG_PNG="no"
+fi
+if [ "$CFG_LIBPNG" = "system" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG system-png"
+    if [ "$CFG_PNG" = "yes" ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT+=-lpng\""
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT_THREAD+=-lpng\""
+    fi
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG no-png"
+elif [ "$CFG_PNG" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG png"
+fi
+if [ "$CFG_GIF" = "no" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG no-gif"
+elif [ "$CFG_GIF" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG gif"
+fi
+if [ "x$PLATFORM_MAC" = "xyes" ]; then
+    [ "$CFG_ZLIB" = "yes" ] && CFG_ZLIB="system"
+fi
+if [ "$CFG_ZLIB" = "no" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG no-zlib"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_COMPRESS"
+elif [ "$CFG_ZLIB" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG zlib"
+elif [ "$CFG_ZLIB" = "system" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG system-zlib"
+    QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT+=-lz\""
+    QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_QT_THREAD+=-lz\""
+fi
+[ "$CFG_NIS" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG nis"
+[ "$CFG_CUPS" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG cups"
+[ "$CFG_NAS" = "system" ] && QMAKE_CONFIG="$QMAKE_CONFIG nas"
+[ "$CFG_BIG_CODECS" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG bigcodecs"
+
+[ "$CFG_QWS_FREETYPE" = "yes" -a "x$CFG_EMBEDDED" != "xno" ] && QMAKE_CONFIG="$QMAKE_CONFIG ft"
+if [ "$PLATFORM_X11" = "yes" ]; then
+    [ "$CFG_SM" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG x11sm"
+
+    # for some reason, the following libraries are not always build shared,
+    # so *every* program/lib (including Qt) has to link against them
+    if [ "$CFG_XSHAPE" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG xshape"
+    fi
+    if [ "$CFG_XINERAMA" = "yes" ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG xinerama"
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11 = -lXinerama \$\$QMAKE_LIBS_X11\""
+    fi
+    if [ "$CFG_XCURSOR" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG xcursor"
+        QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11 = -lXcursor \$\$QMAKE_LIBS_X11\""
+    fi
+    if [ "$CFG_XRANDR" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG xrandr"
+        QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11 = -lXrandr \$\$QMAKE_LIBS_X11\""
+    fi
+    if [ "$CFG_XRENDER" = "yes" ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG xrender"
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11 = -lXrender \$\$QMAKE_LIBS_X11\""
+    fi
+    if [ "$CFG_FREETYPE" = "yes" ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG xftfreetype"
+    fi
+    if [ "$CFG_TABLET" = "yes" ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG tablet"
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11 = -lXi \$\$QMAKE_LIBS_X11\""
+    fi
+    if [ "$CFG_XKB" = "yes" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG xkb"
+    fi
+elif [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_TABLET" = "yes" ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG tablet"
+    fi
+fi
+
+[ '!' -z "$D_FLAGS" ] && QMAKE_VARS="$QMAKE_VARS \"DEFINES+=$D_FLAGS\""
+[ '!' -z "$L_FLAGS" ] && QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBDIR_FLAGS+=$L_FLAGS\""
+[ '!' -z "$l_FLAGS" ] && QMAKE_VARS="$QMAKE_VARS \"LIBS+=$l_FLAGS\""
+
+if [ '!' -z "$R_FLAGS" ]; then
+    if grep QMAKE_RPATH $XQMAKESPEC/qmake.conf >/dev/null; then
+	echo # Using -R/-rpath, so no need to warn
+    else
+	echo
+	echo "ERROR: -R cannot be used on this platform as \$QMAKE_RPATH is"
+	echo "       undefined."
+	echo
+	exit 1
+    fi
+    QMAKE_VARS="$QMAKE_VARS \"QMAKE_LFLAGS+=$R_FLAGS\""
+fi
+
+if [ '!' -z "$I_FLAGS" ]; then
+    QMAKE_VARS="$QMAKE_VARS \"QMAKE_CFLAGS+=$I_FLAGS\""
+    QMAKE_VARS="$QMAKE_VARS \"QMAKE_CXXFLAGS+=$I_FLAGS\""
+fi
+
+# install things
+QMAKE_VARS="$QMAKE_VARS \"QT_INSTALL_PREFIX=${QT_INSTALL_PREFIX}\""
+QMAKE_VARS="$QMAKE_VARS \"docs.path=${QT_INSTALL_DOCS}\""
+QMAKE_VARS="$QMAKE_VARS \"headers.path=${QT_INSTALL_HEADERS}\""
+QMAKE_VARS="$QMAKE_VARS \"plugins.path=${QT_INSTALL_PLUGINS}\""
+QMAKE_VARS="$QMAKE_VARS \"libs.path=${QT_INSTALL_LIBS}\""
+QMAKE_VARS="$QMAKE_VARS \"bins.path=${QT_INSTALL_BINS}\""
+QMAKE_VARS="$QMAKE_VARS \"data.path=${QT_INSTALL_DATA}\""
+QMAKE_VARS="$QMAKE_VARS \"translations.path=${QT_INSTALL_TRANSLATIONS}\""
+
+# turn off exceptions for the compilers that support it
+COMPILER=`echo $PLATFORM | cut -f 2- -d-`
+if [ "$CFG_EXCEPTION_SUPPORT" = "no" ]; then
+    case "$COMPILER" in
+    g++*)
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_CFLAGS+=-fno-exceptions\""
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_CXXFLAGS+=-fno-exceptions\""
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LFLAGS+=-fno-exceptions\""
+	;;
+    cc*)
+	case "$PLATFORM" in
+	irix-cc*)
+	    QMAKE_VARS="$QMAKE_VARS \"QMAKE_CFLAGS+=-LANG:exceptions=off\""
+	    QMAKE_VARS="$QMAKE_VARS \"QMAKE_CXXFLAGS+=-LANG:exceptions=off\""
+	    QMAKE_VARS="$QMAKE_VARS \"QMAKE_LFLAGS+=-LANG:exceptions=off\""
+	    ;;
+	*) ;;
+	esac
+	;;
+    *) ;;
+    esac
+fi
+
+#-------------------------------------------------------------------------------
+# part of configuration information goes into qmodules.h
+#-------------------------------------------------------------------------------
+
+rm -f $outpath/include/qmodules.h.new
+cat >$outpath/include/qmodules.h.new << EOF
+/* These modules are present in this configuration of Qt */
+EOF
+for MODULE in $MODULES; do
+    if [ -d "$relpath/src/$MODULE" ]; then
+	M=`echo $MODULE | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+	echo "#define QT_MODULE_$M" >>$outpath/include/qmodules.h.new
+    fi
+done
+
+# avoid unecessary rebuilds by copying only if qmodules.h has changed
+if cmp -s $outpath/include/qmodules.h $outpath/include/qmodules.h.new; then
+    rm -f $outpath/include/qmodules.h.new
+else
+    [ -f $outpath/include/qmodules.h ] && chmod +w $outpath/include/qmodules.h
+    mv -f $outpath/include/qmodules.h.new $outpath/include/qmodules.h
+    chmod -w $outpath/include/qmodules.h
+fi
+
+#-------------------------------------------------------------------------------
+# generate QT_BUILD_KEY
+#-------------------------------------------------------------------------------
+
+# some compilers generate binary incompatible code between different versions,
+# so we need to generate a build key that is different between these compilers
+case "$COMPILER" in
+g++*)
+    # GNU C++
+    QMAKE_CONF_COMPILER=`grep "QMAKE_CXX[^_A-Z0-9a-z]" $QMAKESPEC/qmake.conf | sed "s,.* *= *\(.*\)$,\1,"`
+    COMPILER_VERSION=`${QMAKE_CONF_COMPILER} --version 2>/dev/null`
+    case "$COMPILER_VERSION" in
+    *2.95.*)
+	COMPILER_VERSION="2.95.*"
+	;;
+    *3.*)
+	COMPILER_VERSION="3.*"
+	;;
+    *4.*)
+	COMPILER_VERSION="4"
+	;;
+    *)
+	;;
+    esac
+    [ ! -z "$COMPILER_VERSION" ] && COMPILER="g++-${COMPILER_VERSION}"
+    ;;
+*)
+    #
+    ;;
+esac
+
+# QMAKE_CONFIG can contain the following:
+#
+# Things that affect the Qt API/ABI:
+#
+#   Options:
+#     minimal-config small-config medium-config large-config full-config
+#
+#   Modules:
+#     styles tools kernel widgets dialogs iconview workspace
+#
+#   Enterprise/Open Source edition modules:
+#     network canvas table xml opengl sql
+#
+#   Options:
+#     stl
+#
+# Things that do not affect the Qt API/ABI:
+#     system-jpeg no-jpeg jpeg
+#     system-mng no-mng mng
+#     system-png no-png png
+#     system-zlib no-zlib zlib
+#     no-gif gif
+#     debug release
+#     dll staticlib
+#
+#     internal
+#     nocrosscompiler
+#     enterprise
+#     thread
+#     GNUmake
+#     largefile
+#     nis
+#     nas
+#     bigcodecs
+#     tablet
+#     ipv6
+#
+#     X11     : xftnameunparse x11sm xinerama xcursor xrandr xrender xftfreetype xkb
+#     Embedded: embedded ft
+#
+ALL_OPTIONS="styles tools kernel widgets dialogs iconview workspace network canvas table xml opengl sql stl"
+BUILD_CONFIG=
+BUILD_OPTIONS=
+
+# determine the build options
+for config_option in $QMAKE_CONFIG; do
+    SKIP="yes"
+    case "$config_option" in
+    *-config)
+	# take the last *-config setting.  this is the highest config being used,
+	# and is the one that we will use for tagging plugins
+	BUILD_CONFIG="$config_option"
+	;;
+
+    styles|tools|kernel|widgets|dialogs|iconview|workspace|network|canvas|table|xml|opengl|sql|stl)
+	# these config options affect the Qt API/ABI. they should influence
+	# the generation of the buildkey, so we don't skip them
+   	SKIP="no"
+	;;
+
+    *) # skip all other options since they don't affect the Qt API/ABI.
+	;;
+    esac
+
+    if [ "$SKIP" = "no" ]; then
+	BUILD_OPTIONS="$BUILD_OPTIONS $config_option"
+    fi
+done
+
+# put the options that we are missing into .options
+rm -f .options
+for opt in `echo $ALL_OPTIONS`; do
+    SKIP="no"
+    if echo $BUILD_OPTIONS | grep $opt >/dev/null 2>&1; then
+	SKIP="yes"
+    fi
+    if [ "$SKIP" = "no" ]; then
+	echo "$opt" >> .options
+    fi
+done
+
+# reconstruct BUILD_OPTIONS with a sorted negative feature list
+# (ie. only things that are missing are will be put into the build key)
+BUILD_OPTIONS=
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+	BUILD_OPTIONS="$BUILD_OPTIONS no-$opt"
+    done
+fi
+rm -f .options
+
+# QT_NO* defines affect the Qt API (and binary compatibility).  they need
+# to be included in the build key
+for build_option in $D_FLAGS; do
+    case "$build_option" in
+    QT_NO*)
+	echo "$build_option" >> .options
+	;;
+    *)
+	# skip all other compiler defines
+	;;
+    esac
+done
+
+# sort the compile time defines (helps ensure that changes in this configure
+# script don't affect the QT_BUILD_KEY generation)
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+	BUILD_OPTIONS="$BUILD_OPTIONS $opt"
+    done
+fi
+rm -f .options
+
+BUILD_OPTIONS="$BUILD_CONFIG $BUILD_OPTIONS"
+QT_BUILD_KEY="$CFG_USER_BUILD_KEY $UNAME_MACHINE $UNAME_SYSTEM $COMPILER $BUILD_OPTIONS"
+# strip out leading/trailing/extra whitespace
+QT_BUILD_KEY=`echo $QT_BUILD_KEY | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+
+#-------------------------------------------------------------------------------
+# part of configuration information goes into qconfig.h
+#-------------------------------------------------------------------------------
+
+case "$CFG_QCONFIG" in
+full)
+    echo "/* Everything */" >$outpath/include/qconfig.h.new
+    ;;
+*)
+    QCONFIGFILE=qconfig-$CFG_QCONFIG.h
+    echo "/* Copied from $QCONFIGFILE */" >$outpath/include/qconfig.h.new
+    cat $relpath/src/tools/$QCONFIGFILE >>$outpath/include/qconfig.h.new
+    ;;
+esac
+cat >> $outpath/include/qconfig.h.new <<EOF
+
+/* License information */
+#define QT_PRODUCT_LICENSEE "$Licensee"
+#define QT_PRODUCT_LICENSE  "$Products"
+
+/* Build key */
+#define QT_BUILD_KEY "$QT_BUILD_KEY"
+
+/* Machine byte-order */
+#define Q_BIG_ENDIAN 4321
+#define Q_LITTLE_ENDIAN 1234
+EOF
+if [ "$CFG_ENDIAN" = "auto" ]; then
+cat >> $outpath/include/qconfig.h.new << EOF
+#if defined(__BIG_ENDIAN__)
+# define Q_BYTE_ORDER Q_BIG_ENDIAN
+#elif defined(__LITTLE_ENDIAN__)
+# define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+# message "Unable to determine byte order!"
+#endif
+EOF
+else
+echo "#define Q_BYTE_ORDER $CFG_ENDIAN" >> $outpath/include/qconfig.h.new
+fi
+
+cat >> $outpath/include/qconfig.h.new << EOF
+/* Compile time features */
+EOF
+[ '!' -z "$LicenseKey" ] && echo "#define QT_PRODUCT_LICENSEKEY \"$LicenseKey\"" >>$outpath/include/qconfig.h.new
+
+if [ "$CFG_LARGEFILE" = "yes" ]; then
+    echo "#define QT_LARGEFILE_SUPPORT 64" >>$outpath/include/qconfig.h.new
+    if [ "$CFG_NEWABI" = "yes" ]; then
+	echo "#define QT_ABI_QT4 1" >>$outpath/include/qconfig.h.new
+    fi
+fi
+
+$unixtests/ptrsize.test $XQMAKESPEC $OPT_VERBOSE $relpath $outpath
+echo "#define QT_POINTER_SIZE $?" >>$outpath/include/qconfig.h.new
+
+if [ ! -z "$QT_MAC_VERSION" ]; then
+    echo "#define QT_MACOSX_VERSION  ${QT_MAC_VERSION}  /*from config.tests*/" >>$outpath/include/qconfig.h.new
+fi
+
+## find excluded styles and add this to $QCONFIG_FLAGS
+
+VSTYLE=no
+VNO=no
+for QMVAR in $QMAKE_VARS; do
+
+STRIPPED=`echo $QMVAR | sed 's,^",,' | sed 's,"$,,'`
+
+if [ "$VSTYLE" = "yes" ]; then
+	if [ "$VNO" = "yes" ]; then
+		NOSTYLE=`echo $STRIPPED | tr '[:lower:]' '[:upper:]'`
+		QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_$NOSTYLE"
+		VSTYLE=no
+		VNO=no
+    	else
+		if [ "$STRIPPED" = "-=" ]; then
+			VNO=yes
+		else
+			VSTYLE=no
+		fi
+	fi
+else
+	if [ "$STRIPPED" = "styles" ]; then
+		VSTYLE=yes
+	fi
+fi
+done
+
+
+if [ -n "$QCONFIG_FLAGS" ]; then
+    for cfg in $QCONFIG_FLAGS; do
+
+cat >>$outpath/include/qconfig.h.new << EOF
+#ifndef $cfg
+# define $cfg
+#endif
+
+EOF
+    done
+fi
+
+# avoid unecessary rebuilds by copying only if qconfig.h has changed
+if cmp -s $outpath/include/qconfig.h $outpath/include/qconfig.h.new; then
+    rm -f $outpath/include/qconfig.h.new
+else
+    [ -f $outpath/include/qconfig.h ] && chmod +w $outpath/include/qconfig.h
+    mv $outpath/include/qconfig.h.new $outpath/include/qconfig.h
+    chmod -w $outpath/include/qconfig.h
+fi
+
+
+#-------------------------------------------------------------------------------
+# save configuration into .qmake.cache
+#-------------------------------------------------------------------------------
+
+CACHEFILE=$outpath/.qmake.cache
+[ -f $CACHEFILE.tmp ] && rm -f $CACHEFILE.tmp
+cat >>$CACHEFILE.tmp <<EOF
+CONFIG += $QMAKE_CONFIG dylib create_prl link_prl
+QMAKESPEC = $XPLATFORM
+QT_SOURCE_TREE = $relpath
+QT_BUILD_TREE = $outpath
+QMAKE_ABSOLUTE_SOURCE_ROOT = \$\$QT_SOURCE_TREE
+EOF
+# cmdline args
+quoted=no
+tmp=""
+for i in $QMAKE_VARS; do
+    if [ "$quoted" = "no" ]; then
+	case "$i" in
+	\"*\") echo $i | sed 's,^",,' | sed 's,"$,,' >>$CACHEFILE.tmp ;;
+	\"*) quoted=yes ; tmp=$i ;;
+	*) echo $i >>$CACHEFILE.tmp ;;
+	esac
+    else
+	case "$i" in
+	*\") quoted=no
+	   echo $tmp $i | sed 's,^",,' | sed 's,"$,,' >>$CACHEFILE.tmp
+	   tmp="" ;;
+	*) tmp="$tmp $i" >>$CACHEFILE.tmp ;;
+    esac
+    fi
+done
+# incrementals
+INCREMENTAL=""
+[ "$CFG_INCREMENTAL" = "auto" ] && $WHICH p4 >/dev/null 2>&1 && [ "$Edition" = "troll" ] && CFG_INCREMENTAL="yes"
+if [ "$CFG_INCREMENTAL" = "yes" ]; then
+    openfiles=`find $relpath -perm u+w -mtime -3 | grep 'cpp$'`
+    for f in $openfiles; do
+	# don't need to worry about generated files
+	[ -r `echo $f | sed "s,cpp$,ui,"` ] && continue
+	basename $f | grep '^moc_' >/dev/null 2>&1 && continue
+	# done
+	INCREMENTAL="$INCREMENTAL `basename $f | sed 's,.cpp,.o,'`"
+    done
+    [ '!' -z "$INCREMENTAL" ] && echo "QMAKE_INCREMENTAL += $INCREMENTAL" >>$CACHEFILE.tmp
+    [ -r "$outpath/.qmake.incremental" ] && echo "include($outpath/.qmake.incremental)" >>$CACHEFILE.tmp
+fi
+
+# replace .qmake.cache if it differs from the newly created temp file
+if cmp -s $CACHEFILE.tmp $CACHEFILE; then
+    rm -f $CACHEFILE.tmp
+else
+    mv -f $CACHEFILE.tmp $CACHEFILE
+fi
+
+
+#-------------------------------------------------------------------------------
+# give feedback on configuration
+#-------------------------------------------------------------------------------
+
+case "$COMPILER" in
+g++*)
+    if [ "$CFG_EXCEPTION_SUPPORT" != "no" ]; then
+	cat <<EOF
+
+	This target is using the GNU C++ compiler ($PLATFORM).
+
+	Recent versions of this compiler automatically include code for
+	exceptions, which increase both the size of the Qt library and the
+	amount of memory taken by your applications.
+
+	You may choose to re-run `basename $0` with the -no-exceptions
+	option to compile Qt without exceptions. This is completely binary
+	compatible, and existing applications should continue to work.
+
+EOF
+    fi
+    ;;
+cc*)
+    case "$PLATFORM" in
+    irix-cc*)
+	if [ "$CFG_EXCEPTION_SUPPORT" != "no" ]; then
+	    cat <<EOF
+
+	This target is using the MIPSpro C++ compiler ($PLATFORM).
+
+	You may choose to re-run `basename $0` with the -no-exceptions
+	option to compile Qt without exceptions. This will make the
+	size of the Qt library smaller and reduce the amount of memory
+	taken by your applications.
+
+EOF
+	fi
+	;;
+    *) ;;
+    esac
+    ;;
+*) ;;
+esac
+
+echo
+if [ "$XPLATFORM" = "$PLATFORM" ]; then
+    echo "Build type:    $PLATFORM"
+else
+    echo "Building on:   $PLATFORM"
+    echo "Building for:  $XPLATFORM"
+fi
+
+if [ -n "$PLATFORM_NOTES" ]; then
+    echo "Platform notes:"
+    echo "$PLATFORM_NOTES"
+else
+    echo
+fi
+
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo "qmake vars ...... $QMAKE_VARS"
+    echo "qmake switches .. $QMAKE_SWITCHES"
+fi
+
+[ "$OPT_CONCURRENT" != "0" ] && echo "Concurrent .......... $OPT_CONCURRENT"
+[ "$CFG_INCREMENTAL" = "yes" ] && [ '!' -z "$INCREMENTAL" ] && echo "Incremental ......... $INCREMENTAL"
+echo "Configuration ....... $QMAKE_CONFIG"
+echo "STL support ......... $CFG_STL"
+echo "PCH support ......... $CFG_PRECOMPILE"
+echo "IPv6 support ........ $CFG_IPV6"
+echo "Thread support ...... $CFG_THREAD"
+echo "NIS support ......... $CFG_NIS"
+echo "CUPS support ........ $CFG_CUPS"
+if [ "$CFG_LARGEFILE" = "yes" ]; then
+    echo "Large File support .. partial"
+else
+    echo "Large File support .. $CFG_LARGEFILE"
+fi
+echo "GIF support ......... $CFG_GIF"
+if [ "$CFG_MNG" = "no" ]; then
+    echo "MNG support ......... $CFG_MNG"
+else
+    echo "MNG support ......... $CFG_MNG ($CFG_LIBMNG)"
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    echo "JPEG support ........ $CFG_JPEG"
+else
+    echo "JPEG support ........ $CFG_JPEG ($CFG_LIBJPEG)"
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    echo "PNG support ......... $CFG_PNG"
+else
+    echo "PNG support ......... $CFG_PNG ($CFG_LIBPNG)"
+fi
+echo "zlib support ........ $CFG_ZLIB"
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    echo "Embedded support .... $CFG_EMBEDDED"
+else
+    if echo $MODULES | grep opengl >/dev/null; then
+	opengl=yes
+    else
+	opengl=no
+    fi
+    echo "OpenGL support ...... $opengl"
+fi
+if [ "$PLATFORM_X11" = "yes" ]; then
+    echo "NAS sound support ... $CFG_NAS"
+    echo "Session management .. $CFG_SM"
+    echo "XShape support ...... $CFG_XSHAPE"
+    echo "Xinerama support .... $CFG_XINERAMA"
+    echo "Tablet support ...... $CFG_TABLET"
+    echo "Xcursor support ..... $CFG_XCURSOR"
+    echo "XRandR support ...... $CFG_XRANDR"
+    echo "XRender support ..... $CFG_XRENDER"
+    echo "Xft support ......... $CFG_FREETYPE"
+    echo "XKB Support ......... $CFG_XKB"
+elif [ "$PLATFORM_MAC" = "yes" ]; then
+    echo "Accessibility ....... $CFG_ACCESSIBILITY"
+    echo "Tablet support ...... $CFG_TABLET"
+fi
+
+# complain about not being able to use plugins if we are using a static build
+if [ "$CFG_SHARED" = "no" ]; then
+    echo
+    echo "WARNING: Using static linking will disable the use of plugins."
+    echo "Make sure you compile ALL needed modules into the library."
+    echo
+fi
+echo
+
+sepath=`echo $relpath | sed -e 's/\\./\\\\./g'`
+PROCS=1
+EXEC=""
+
+
+#-------------------------------------------------------------------------------
+# build makefiles based on the configuration
+#-------------------------------------------------------------------------------
+
+echo "Finding project files. Please wait..."
+if [ -z "$QMAKE_PROJECTS" ]; then
+    QMAKE_PROJECTS=`find $relpath/. -name '*.pro' -print | sed 's-/\./-/-'`
+else
+    QT_PROJECTS=
+    for a in `echo $QMAKE_PROJECTS`; do
+	put_in="$a"
+	for leave_out in `echo $QMAKE_IGNORE_PROJECTS`; do
+	    if [ "$put_in" = "$leave_out" ]; then
+		put_in=
+		break;
+	    fi
+	done
+	[ ! -z "$put_in" ] && QT_PROJECTS="$QT_PROJECTS $put_in"
+    done
+    if [ -e "${relpath}/projects.pro" ]; then
+	for mkfile in "${outpath}/Makefile" "${outpath}/GNUmakefile"; do
+	    [ -f "$mkfile" ] && chmod +w "$mkfile"
+	    $outpath/bin/qmake "QT_PROJECTS=$QT_PROJECTS" ${relpath}/projects.pro -o $mkfile
+	done
+    fi
+fi
+
+# .projects      -> projects to process
+# .projects.1    -> qt and moc
+# .projects.2    -> subdirs and libs
+# .projects.3    -> the rest
+rm -f .projects .projects.1 .projects.2 .projects.3
+
+if [ -z "$AWK" ]; then
+    for p in `echo $QMAKE_PROJECTS`; do
+	echo $p >> .projects
+    done
+else
+    cat >projects.awk <<EOF
+BEGIN {
+    files = 0
+    target_file = ""
+    input_file = ""
+
+    first = "./.projects.1.tmp"
+    second = "./.projects.2.tmp"
+    third = "./.projects.3.tmp"
+}
+
+FNR == 1 {
+    if ( input_file ) {
+  if ( ! target_file )
+      target_file = third
+  print input_file >target_file
+    }
+
+    matched_target = 0
+    template_lib = 0
+    input_file = FILENAME
+    target_file = ""
+}
+
+/^(TARGET.*=)/ {
+    if ( \$3 == "qt" || \$3 == "moc" ) {
+  target_file = first
+	matched_target = 1
+    }
+}
+
+matched_target == 0 && /^(TEMPLATE.*=)/ {
+    if ( \$3 == "subdirs" )
+  target_file = second
+    else if ( \$3 == "lib" )
+  template_lib = 1
+    else
+  target_file = third
+}
+
+matched_target == 0 && template_lib == 1 && /^(CONFIG.*=)/ {
+    if ( \$0 ~ /plugin/ )
+	target_file = third
+    else
+  target_file = second
+}
+
+END {
+    if ( input_file ) {
+  if ( ! target_file )
+      target_file = third
+  print input_file >>target_file
+    }
+}
+
+EOF
+
+    rm -f .projects.all
+    for p in `echo $QMAKE_PROJECTS`; do
+       echo $p >> .projects.all
+    done
+
+    # if you get errors about the length of the command line to awk, change the -l arg
+    # to split below
+    split -l 100 .projects.all .projects.all.
+    for p in .projects.all.*; do
+       $AWK -f projects.awk `cat $p`
+       [ -f .projects.1.tmp ] && cat .projects.1.tmp >> .projects.1
+       [ -f .projects.2.tmp ] && cat .projects.2.tmp >> .projects.2
+       [ -f .projects.3.tmp ] && cat .projects.3.tmp >> .projects.3
+       rm -f .projects.1.tmp .projects.2.tmp .projects.3.tmp $p
+    done
+    rm -f .projects.all* projects.awk
+
+    [ -f .projects.1 ] && cat .projects.1 >>.projects
+    [ -f .projects.2 ] && cat .projects.2 >>.projects
+    rm -f .projects.1 .projects.2
+    if [ -f .projects.3 ] && [ "$OPT_FAST" = "no" ]; then
+       cat .projects.3 >>.projects
+       rm -f .projects.3
+    fi
+fi
+# don't sort Qt and MOC in with the other project files
+# also work around a segfaulting uniq(1)
+if [ -f .sorted.projects.2 ]; then
+    sort .sorted.projects.2 > .sorted.projects.2.new
+    mv -f .sorted.projects.2.new .sorted.projects.2
+    cat .sorted.projects.2 >> .sorted.projects.1
+fi
+[ -f .sorted.projects.1 ] && sort .sorted.projects.1 >> .sorted.projects
+rm -f .sorted.projects.2 .sorted.projects.1
+for p in `echo $QMAKE_IGNORE_PROJECTS`; do
+    if [ -f .projects ]; then
+	grep -v $p .projects > .tmp
+	mv -f .tmp .projects
+    fi
+    if [ -f .projects.3 ]; then
+	grep -v $p .projects.3 > .tmp
+	mv -f .tmp .projects.3
+    fi
+done
+
+NORM_PROJECTS=0
+FAST_PROJECTS=0
+if [ -f .projects ]; then
+   uniq .projects >.tmp
+   mv -f .tmp .projects
+   NORM_PROJECTS=`cat .projects | wc -l | sed -e "s, ,,g"`
+fi
+if [ -f .projects.3 ]; then
+   uniq .projects.3 >.tmp
+   mv -f .tmp .projects.3
+   FAST_PROJECTS=`cat .projects.3 | wc -l | sed -e "s, ,,g"`
+fi
+echo "  `expr $NORM_PROJECTS + $FAST_PROJECTS` projects found."
+echo
+
+echo "Creating makefiles. Please wait..."
+for file in .projects .projects.3; do
+    [ '!' -f "$file" ] && continue
+    for a in `cat $file`; do
+	case $a in
+	*-kde.pro|*qtmain.pro) continue ;;
+	*/qmake/qmake.pro) continue ;;
+	*projects.pro) continue ;;
+	*-pro.pro)
+	    [ "x$Edition" != "xpro" ] && continue
+	;;
+	*moc*) SPEC=$QMAKESPEC ;;
+	*) SPEC=$XQMAKESPEC ;;
+	esac
+	dir=`dirname $a | sed -e "s;$sepath;.;g"`
+	test -d $dir || mkdir -p $dir
+	OUTDIR=$outpath/$dir
+	if [ -f "${OUTDIR}/Makefile" ] && [ "$OPT_FAST" = "yes" ]; then
+	    # fast configure - the makefile exists, skip it
+	    # since the makefile exists, it was generated by qmake, which means we
+	    # can skip it, since qmake has a rule to regenerate the makefile if the .pro
+	    # file changes...
+	    [ "$OPT_VERBOSE" = "yes" ] && echo "  skipping $a"
+	    continue;
+	fi
+	QMAKE_SPEC_ARGS="-spec $SPEC"
+	if echo '\c' | grep '\c' >/dev/null; then
+	    echo -n "  for $a"
+	else
+	    echo "  for $a\c"
+	fi
+
+	if [ "$file" = ".projects.3" ]; then
+	    if echo '\c' | grep '\c' >/dev/null; then
+		echo -n " (fast)"
+	    else
+		echo " (fast)\c"
+	    fi
+	    echo
+	    cat >${OUTDIR}/Makefile <<EOF
+# ${OUTDIR}/Makefile: generated by configure
+#
+# WARNING: This makefile will be replaced with a real makefile.
+# All changes made to this file will be lost.
+
+all clean install qmake Makefile: FORCE
+	$outpath/bin/qmake $QMAKE_SWITCHES $QMAKE_SPEC_ARGS -o $OUTDIR $a
+	cd $OUTDIR
+	\$(MAKE) \$@
+
+FORCE:
+
+EOF
+	else
+	    EXEC="$outpath/bin/qmake $QMAKE_SWITCHES $QMAKE_SPEC_ARGS -o $OUTDIR $a"
+	    if [ "$OPT_VERBOSE" = "yes" ]; then
+		echo " (`basename $SPEC`)"
+		if echo '\c' | grep '\c' >/dev/null; then
+		    echo -n "$EXEC"
+		else
+		    echo "$EXEC\c"
+		fi
+	    fi
+	    echo
+
+	    [ -f "${OUTDIR}/Makefile" ] && chmod +w ${OUTDIR}/Makefile
+	    if [ "$OPT_CONCURRENT" = "0" ] || [ "$OPT_CONCURRENT" = "1" ]; then
+		/bin/sh -c "$EXEC"
+	    else
+		/bin/sh -c "$EXEC" &
+		if [ "$PROCS" != "$OPT_CONCURRENT" ]; then
+		    PROCS=`expr $PROCS + 1`
+		else
+		    PROCS=1
+		    [ "$OPT_VERBOSE" = "yes" ] && echo "Waiting.."
+		    wait #wait for the processes to end
+		fi
+	    fi
+       fi
+    done
+done
+rm -f .projects .projects.3
+
+#Special Qt/Mac thing. We bootched permissions in Qt 3.3.0 beta 1.
+#This is probably the only easy place to detect and remove it ourselves
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ -d /Library/Qt ]; then
+        lslad=`ls -lad /Library/Qt | grep '^d......rwx'`
+	if [ -z "$lslad" ]; then
+	    echo
+	    removed=no
+	    rm -rf /Library/Qt && removed=yes
+	    if [ "$removed" = "no" ]; then
+		cat <<EOF
+
+    The directory '/Library/Qt' has incorrect permissions and configure could
+    not fix it automatically. Please remove this direcotry by hand.
+
+EOF
+	    fi
+	fi
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# finally save the executed command to another script
+#-------------------------------------------------------------------------------
+if [ `basename $0` != "config.status" ]; then
+    [ -f $outpath/config.status ] && rm -f $outpath/config.status
+    echo "#!/bin/sh" >$outpath/config.status
+    echo "if [ \"\$#\" -gt 0 ]; then" >>$outpath/config.status
+    echo "  echo yes | $relpath/$relconf $OPT_CMDLINE \"\$@\"" >>$outpath/config.status
+    echo "else" >>$outpath/config.status
+    echo "  echo yes | $relpath/$relconf $OPT_CMDLINE" >>$outpath/config.status
+    echo "fi" >>$outpath/config.status
+    chmod +x $outpath/config.status
+fi
+
+echo
+echo Qt is now configured for building. Just run $MAKE.
+echo To reconfigure, run $MAKE confclean and configure.
+echo
diff -r -U2 -N qt-x11-free-3.3.8b/include/private/qrichtext_p.h qt-x11-free-3.3.8b/include/private/qrichtext_p.h
--- qt-x11-free-3.3.8b/include/private/qrichtext_p.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/include/private/qrichtext_p.h	2009-10-18 14:38:39.231872222 -0700
@@ -366,5 +366,6 @@
 
     bool place( const QPoint &pos, QTextParagraph *s ) { return place( pos, s, FALSE ); }
-    bool place( const QPoint &pos, QTextParagraph *s, bool link );
+    bool place( const QPoint &pos, QTextParagraph *s, bool link ) { return place( pos, s, link, TRUE, TRUE ); }
+    bool place( const QPoint &pos, QTextParagraph *s, bool link, bool loosePlacing, bool matchBetweenCharacters );
     void restoreState();
 
diff -r -U2 -N qt-x11-free-3.3.8b/include/qapplication.h qt-x11-free-3.3.8b/include/qapplication.h
--- qt-x11-free-3.3.8b/include/qapplication.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qapplication.h	2009-10-18 14:38:39.108543295 -0700
@@ -55,4 +55,7 @@
 class QTranslator;
 class QEventLoop;
+#if defined(Q_WS_X11)
+class QIMEvent;
+#endif
 #if defined(Q_WS_QWS)
 class QWSDecoration;
@@ -276,6 +279,17 @@
 #endif
 #if defined(Q_WS_X11)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    virtual QWidget *locateICHolderWidget( QWidget *w );
+    virtual QWidgetList *icHolderWidgets();
+    static void create_im();
+    static void close_im();
+#else
+    QWidget *locateICHolderWidget( QWidget *w );
+    QWidgetList *icHolderWidgets();
     static void create_xim();
     static void close_xim();
+#endif
+    static QString defaultInputMethod();
+    void	changeAllInputContext( const QString & );
     static bool x11_apply_settings();
 #endif
@@ -332,4 +346,10 @@
 #endif
 
+#if defined(Q_WS_X11)
+private slots:
+    void postIMEvent( QObject *receiver, QIMEvent *event );
+#endif
+
+private:
 #ifdef QT_THREAD_SUPPORT
     static QMutex   *qt_mutex;
@@ -381,7 +401,10 @@
     bool	     is_session_restored;
 #endif
-#if defined(Q_WS_X11) && !defined (QT_NO_STYLE )
+#if defined(Q_WS_X11)
+#if !defined (QT_NO_STYLE)
     static void x11_initialize_style();
 #endif
+    static QString defaultIM; // default input method's name in this application.
+#endif
 
     static QSize     app_strut;
@@ -400,4 +423,5 @@
     static bool      sendSpontaneousEvent( QObject *receiver, QEvent *event );
     static void      removePostedEvent( QEvent * );
+    static void      removePostedEvents( QObject *receiver, int event_type );
 
     friend class QWidget;
diff -r -U2 -N qt-x11-free-3.3.8b/include/qfeatures.h qt-x11-free-3.3.8b/include/qfeatures.h
--- qt-x11-free-3.3.8b/include/qfeatures.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qfeatures.h	2009-10-18 14:38:39.301868931 -0700
@@ -983,2 +983,12 @@
 #endif
 
+// Input method
+#if !defined(QT_NO_IM) && (defined(QT_NO_STRINGLIST))
+#define QT_NO_IM
+#endif
+
+// Input method extensions
+#if !defined(QT_NO_IM_EXTENSIONS) && (defined(QT_NO_IM) || defined(QT_NO_STRINGLIST))
+#define QT_NO_IM_EXTENSIONS
+#endif
+
diff -r -U2 -N qt-x11-free-3.3.8b/include/qlineedit.h qt-x11-free-3.3.8b/include/qlineedit.h
--- qt-x11-free-3.3.8b/include/qlineedit.h	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qlineedit.h	2009-10-18 14:38:39.325202691 -0700
@@ -200,4 +200,5 @@
 #endif
     void contextMenuEvent( QContextMenuEvent * );
+    bool sendMouseEventToInputContext( QMouseEvent *e );
     virtual QPopupMenu *createPopupMenu();
     void windowActivationChange( bool );
diff -r -U2 -N qt-x11-free-3.3.8b/include/qnamespace.h qt-x11-free-3.3.8b/include/qnamespace.h
--- qt-x11-free-3.3.8b/include/qnamespace.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qnamespace.h	2009-10-18 14:38:39.181875955 -0700
@@ -401,4 +401,85 @@
 	Key_Direction_L = 0x1059,
 	Key_Direction_R = 0x1060,
+
+	// International input method support (X keycode - 0xEE00, the
+	// definition follows Qt/Embedded 2.3.7) Only interesting if
+	// you are writing your own input method
+        
+	// International & multi-key character composition
+	Key_Multi_key           = 0x1120,  // Multi-key character compose
+	Key_Codeinput           = 0x1137,
+	Key_SingleCandidate     = 0x113c,
+	Key_MultipleCandidate   = 0x113d,
+	Key_PreviousCandidate   = 0x113e,
+
+	// Misc Functions
+	Key_Mode_switch         = 0x117e,  // Character set switch
+	//Key_script_switch       = 0x117e,  // Alias for mode_switch
+
+	// Japanese keyboard support
+	Key_Kanji               = 0x1121,  // Kanji, Kanji convert
+	Key_Muhenkan            = 0x1122,  // Cancel Conversion
+	//Key_Henkan_Mode         = 0x1123,  // Start/Stop Conversion
+	Key_Henkan              = 0x1123,  // Alias for Henkan_Mode
+	Key_Romaji              = 0x1124,  // to Romaji
+	Key_Hiragana            = 0x1125,  // to Hiragana
+	Key_Katakana            = 0x1126,  // to Katakana
+	Key_Hiragana_Katakana   = 0x1127,  // Hiragana/Katakana toggle
+	Key_Zenkaku             = 0x1128,  // to Zenkaku
+	Key_Hankaku             = 0x1129,  // to Hankaku
+	Key_Zenkaku_Hankaku     = 0x112a,  // Zenkaku/Hankaku toggle
+	Key_Touroku             = 0x112b,  // Add to Dictionary
+	Key_Massyo              = 0x112c,  // Delete from Dictionary
+	Key_Kana_Lock           = 0x112d,  // Kana Lock
+	Key_Kana_Shift          = 0x112e,  // Kana Shift
+	Key_Eisu_Shift          = 0x112f,  // Alphanumeric Shift
+	Key_Eisu_toggle         = 0x1130,  // Alphanumeric toggle
+	//Key_Kanji_Bangou        = 0x1137,  // Codeinput
+	//Key_Zen_Koho            = 0x113d,  // Multiple/All Candidate(s)
+	//Key_Mae_Koho            = 0x113e,  // Previous Candidate
+
+	// Korean keyboard support
+	//
+	// In fact, many Korean users need only 2 keys, Key_Hangul and
+	// Key_Hangul_Hanja. But rest of the keys are good for future.
+
+	Key_Hangul              = 0x1131,  // Hangul start/stop(toggle)
+	Key_Hangul_Start        = 0x1132,  // Hangul start
+	Key_Hangul_End          = 0x1133,  // Hangul end, English start
+	Key_Hangul_Hanja        = 0x1134,  // Start Hangul->Hanja Conversion
+	Key_Hangul_Jamo         = 0x1135,  // Hangul Jamo mode
+	Key_Hangul_Romaja       = 0x1136,  // Hangul Romaja mode
+	//Key_Hangul_Codeinput    = 0x1137,  // Hangul code input mode
+	Key_Hangul_Jeonja       = 0x1138,  // Jeonja mode
+	Key_Hangul_Banja        = 0x1139,  // Banja mode
+	Key_Hangul_PreHanja     = 0x113a,  // Pre Hanja conversion
+	Key_Hangul_PostHanja    = 0x113b,  // Post Hanja conversion
+	//Key_Hangul_SingleCandidate   = 0x113c,  // Single candidate
+	//Key_Hangul_MultipleCandidate = 0x113d,  // Multiple candidate
+	//Key_Hangul_PreviousCandidate = 0x113e,  // Previous candidate
+	Key_Hangul_Special      = 0x113f,  // Special symbols
+	//Key_Hangul_switch       = 0x117e,  // Alias for mode_switch
+
+        // dead keys (X keycode - 0xED00 to avoid the conflict)
+        Key_Dead_Grave          = 0x1250,
+        Key_Dead_Acute          = 0x1251,
+        Key_Dead_Circumflex     = 0x1252,
+        Key_Dead_Tilde          = 0x1253,
+        Key_Dead_Macron         = 0x1254,
+        Key_Dead_Breve          = 0x1255,
+        Key_Dead_Abovedot       = 0x1256,
+        Key_Dead_Diaeresis      = 0x1257,
+        Key_Dead_Abovering      = 0x1258,
+        Key_Dead_Doubleacute    = 0x1259,
+        Key_Dead_Caron          = 0x125a,
+        Key_Dead_Cedilla        = 0x125b,
+        Key_Dead_Ogonek         = 0x125c,
+        Key_Dead_Iota           = 0x125d,
+        Key_Dead_Voiced_Sound   = 0x125e,
+        Key_Dead_Semivoiced_Sound = 0x125f,
+        Key_Dead_Belowdot       = 0x1260,
+        Key_Dead_Hook           = 0x1261,
+        Key_Dead_Horn           = 0x1262,
+
 	Key_Space = 0x20,		// 7 bit printable ASCII
 	Key_Any = Key_Space,
@@ -473,4 +554,9 @@
 
 	// Latin 1 codes adapted from X: keysymdef.h,v 1.21 94/08/28 16:17:06
+	//
+	// This is mainly for compatibility - applications and input
+	// methods should not use the Qt keycodes between 128 and 255,
+	// but should rather use the QKeyEvent::text(). See
+	// QETWidget::translateKeyEventInternal() for more details.
 
 	Key_nobreakspace = 0x0a0,
diff -r -U2 -N qt-x11-free-3.3.8b/include/qtextedit.h qt-x11-free-3.3.8b/include/qtextedit.h
--- qt-x11-free-3.3.8b/include/qtextedit.h	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qtextedit.h	2009-10-18 14:38:39.375200628 -0700
@@ -215,5 +215,7 @@
 	RedoIndentation = 0x0001,
 	CheckNewLines = 0x0002,
-	RemoveSelected = 0x0004
+	RemoveSelected = 0x0004,
+	AsIMCompositionText = 0x0008,  // internal use
+	WithIMSelection = 0x0010       // internal use
     };
 
@@ -443,4 +445,5 @@
 #endif
     void contentsContextMenuEvent( QContextMenuEvent *e );
+    bool sendMouseEventToInputContext( QMouseEvent *e );
     bool focusNextPrevChild( bool next );
     QTextDocument *document() const;
diff -r -U2 -N qt-x11-free-3.3.8b/include/qwidget.h qt-x11-free-3.3.8b/include/qwidget.h
--- qt-x11-free-3.3.8b/include/qwidget.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/include/qwidget.h	2009-10-18 14:38:39.285199339 -0700
@@ -53,4 +53,8 @@
 #endif // QT_H
 
+#if defined(Q_WS_X11) && !defined(QT_NO_IM)
+class QInputContext;
+#endif
+
 class QLayout;
 struct QWExtra;
@@ -539,4 +543,16 @@
     int		 metric( int )	const;
 
+#if defined(Q_WS_X11)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    virtual QWidget *icHolderWidget();
+#else
+    QWidget *icHolderWidget();
+#endif
+    QInputContext *getInputContext();
+    void	 changeInputContext( const QString & );
+    void	 sendMouseEventToInputContext( int x, QEvent::Type type,
+					       Qt::ButtonState button,
+					       Qt::ButtonState state );
+#endif
     void	 resetInputContext();
 
@@ -570,4 +586,7 @@
 private slots:
     void	 focusProxyDestroyed();
+#if defined(Q_WS_X11)
+    void	 destroyInputContext();
+#endif
 
 private:
@@ -575,6 +594,6 @@
 #if defined(Q_WS_X11)
     void	 createInputContext();
-    void	 destroyInputContext();
     void	 focusInputContext();
+    void	 unfocusInputContext();
     void	 checkChildrenDnd();
 #elif defined(Q_WS_MAC)
@@ -648,4 +667,7 @@
     QLayout 	*lay_out;
 #endif
+#if defined(Q_WS_X11) && !defined(QT_NO_IM) && !defined(QT_NO_IM_EXTENSIONS)
+    QInputContext *ic;				// Input Context
+#endif
     QWExtra	*extra;
 #if defined(Q_WS_QWS)
@@ -953,5 +975,7 @@
     uint     uspos : 1;				// User defined position
     uint     ussize : 1;			// User defined size
-    void    *xic;				// XIM Input Context
+#if defined(QT_NO_IM_EXTENSIONS)
+    void    *xic;				// Input Context
+#endif
 #endif
 #if defined(Q_WS_MAC)
diff -r -U2 -N qt-x11-free-3.3.8b/make-symlinks.sh qt-x11-free-3.3.8b/make-symlinks.sh
--- qt-x11-free-3.3.8b/make-symlinks.sh	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/make-symlinks.sh	2009-10-18 14:38:38.755209867 -0700
@@ -0,0 +1,12 @@
+#!/bin/sh
+cd include
+rm -f q*.h
+ln -s ../src/*/q*.h .
+ln -s ../extensions/*/src/q*.h .
+ln -s ../tools/assistant/lib/qassistantclient.h .
+ln -s ../tools/designer/uilib/qwidgetfactory.h .
+rm -f q*_p.h
+cd private
+rm -f q*_p.h
+ln -s ../../src/*/q*_p.h .
+
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/imsw-multi.pro qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/imsw-multi.pro
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/imsw-multi.pro	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/imsw-multi.pro	2009-10-18 14:38:38.755209867 -0700
@@ -0,0 +1,14 @@
+TEMPLATE = lib
+TARGET   = qimsw-multi
+DESTDIR  = ../../../inputmethods
+
+INCLUDEPATH += .
+CONFIG      += qt warn_on debug plugin
+target.path += $$plugins.path/inputmethods
+INSTALLS    += target
+
+# Input
+HEADERS += qmultiinputcontext.h \
+           qmultiinputcontextplugin.h
+SOURCES += qmultiinputcontext.cpp \
+           qmultiinputcontextplugin.cpp
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.cpp	2009-10-18 14:38:38.761866183 -0700
@@ -0,0 +1,379 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QMultiInputContext class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qmultiinputcontext.h"
+#include <qinputcontextfactory.h>
+#include <qstringlist.h>
+#include <qpopupmenu.h>
+#ifndef QT_NO_IM_EXTENSIONS
+#include <qsettings.h>
+#endif
+
+#include <stdlib.h>
+
+#define QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX
+
+QMultiInputContext::QMultiInputContext()
+    : QInputContext(), _slave( 0 ), imIndex( 0 ), cachedFocus( FALSE ),
+      cachedFocusWidget( 0 ), cachedHolderWidget( 0 ),
+      beIndirectlyConnected( FALSE ), popup( NULL ), currentIMKey( QString::null )
+{
+    keyDict.setAutoDelete( true );
+    keyDict.clear();
+
+    if ( getenv( "QT_IM_MODULE" ) ) {
+        currentIMKey = getenv( "QT_IM_MODULE" );
+    } else {
+#ifndef QT_NO_IM_EXTENSIONS
+	QSettings settings;
+        currentIMKey = settings.readEntry( "/qt/DefaultInputMethod", "xim" );
+#else
+	currentIMKey = "xim";
+#endif
+    }
+}
+
+QMultiInputContext::~QMultiInputContext()
+{
+    keyDict.clear();
+}
+
+
+QString QMultiInputContext::identifierName()
+{
+    return ( slave() ) ? slave()->identifierName() : "";
+}
+
+QString QMultiInputContext::language()
+{
+    return ( slave() ) ? slave()->language() : "";
+}
+
+
+#if defined(Q_WS_X11)
+bool QMultiInputContext::x11FilterEvent( QWidget *keywidget, XEvent *event )
+{
+    return ( slave() ) ? slave()->x11FilterEvent( keywidget, event ) : FALSE;
+}
+#endif // Q_WS_X11
+
+
+bool QMultiInputContext::filterEvent( const QEvent *event )
+{
+#if !defined(QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX)
+    if ( event->type() == QEvent::KeyPress ) {
+	QKeyEvent *keyevent = (QKeyEvent *)event;
+
+	// filter selection key
+	// Control+Alt+Key_Down: change to next input method
+	// Control+Alt+Key_Up:   change to previous input method
+	if ( ( keyevent->state() & Qt::ControlButton ) &&
+	     ( keyevent->state() & Qt::AltButton ) ) {
+	    if ( keyevent->key() == Qt::Key_Up ) {
+		changeInputMethod( --imIndex );
+		return TRUE;
+	    } else if ( keyevent->key() == Qt::Key_Down ) {
+		changeInputMethod( ++imIndex );
+		return TRUE;
+	    }
+	}
+    }
+#endif
+
+    return ( slave() ) ? slave()->filterEvent( event ) : FALSE;
+}
+
+void QMultiInputContext::reset()
+{
+    if ( slave() )
+	slave()->reset();
+}
+
+
+void QMultiInputContext::setFocus()
+{
+    cachedFocus = TRUE;
+    if ( slave() )
+	slave()->setFocus();
+}
+
+void QMultiInputContext::unsetFocus()
+{
+    cachedFocus = FALSE;
+    if ( slave() )
+	slave()->unsetFocus();
+}
+
+void QMultiInputContext::setMicroFocus( int x, int y, int w, int h, QFont *f )
+{
+    if ( slave() )
+	slave()->setMicroFocus( x, y, w, h, f );
+}
+
+void QMultiInputContext::mouseHandler( int x, QEvent::Type type,
+				       Qt::ButtonState button,
+				       Qt::ButtonState state )
+{
+    if ( slave() )
+	slave()->mouseHandler( x, type, button, state );
+}
+
+QFont QMultiInputContext::font() const
+{
+    return ( slave() ) ? slave()->font() : QInputContext::font();
+}
+
+void QMultiInputContext::destroyInputContext()
+{
+    if ( _slave ) {
+	// _slave->reset() may not properly work in the case, so we
+	// manually resets the composing state of text widget
+	if ( _slave->focusWidget() ) {
+	    QIMEvent *terminator = new QIMEvent( QEvent::IMEnd, QString::null, -1 );
+	    emit imEventGenerated( _slave->focusWidget(), terminator );
+	}
+	_slave->deleteLater();
+	_slave = 0;
+    }
+}
+
+
+/*!
+    This function is a placeholder for future experiment or extension
+    such as commit string snooping. set beIndirectlyConnected = TRUE
+    to activate this virtual function.
+*/
+void QMultiInputContext::postIMEvent( QObject *receiver, QIMEvent *event )
+{
+    emit imEventGenerated( receiver, event );
+}
+
+
+#if defined(Q_WS_X11)
+QWidget *QMultiInputContext::focusWidget() const
+{
+    return ( slave() ) ? slave()->focusWidget() : 0;
+}
+
+QWidget *QMultiInputContext::holderWidget() const
+{
+    return ( slave() ) ? slave()->holderWidget() : 0;
+}
+
+
+void QMultiInputContext::setFocusWidget( QWidget *w )
+{
+    cachedFocusWidget = w;
+    if ( slave() )
+	slave()->setFocusWidget( w );
+}
+
+void QMultiInputContext::setHolderWidget( QWidget *w )
+{
+    cachedHolderWidget = w;
+    if ( slave() )
+	slave()->setHolderWidget( w );
+}
+
+void QMultiInputContext::releaseComposingWidget( QWidget *w )
+{
+    if ( slave() )
+	slave()->releaseComposingWidget( w );
+}
+
+#endif
+
+bool QMultiInputContext::isComposing() const
+{
+    return ( slave() ) ? slave()->isComposing() : FALSE;
+}
+
+bool QMultiInputContext::isPreeditRelocationEnabled()
+{
+    return ( slave() ) ? slave()->isPreeditRelocationEnabled() : FALSE;
+}
+
+QInputContext *QMultiInputContext::slave()
+{
+    if ( ! _slave ) {
+#if !defined(QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX)
+	changeInputMethod( imIndex );
+#else
+	changeInputMethod( currentIMKey );
+#endif
+    }
+
+    return _slave;
+}
+
+const QInputContext *QMultiInputContext::slave() const
+{
+    return _slave;
+}
+
+void QMultiInputContext::changeInputMethod( int newIndex )
+{
+#if !defined(QT_NO_IM_QMULTIINPUTCONTEXT_IMINDEX)
+    QStringList keys = QInputContextFactory::keys();
+    if ( keys.size() == 0 )
+	return;
+
+    if ( newIndex >= (int)keys.size() ) {
+	imIndex = 0;
+    } else if ( newIndex < 0 ) {
+	imIndex = keys.size() - 1;
+    } else {
+	imIndex = newIndex;
+    }
+
+    changeInputMethod( keys[imIndex] );
+#endif
+}
+
+void QMultiInputContext::changeInputMethod( QString key )
+{
+    QStringList keys = QInputContextFactory::keys();
+    if ( keys.size() == 0 )
+	return;
+
+    if ( key.isEmpty() )
+	key = keys[0];
+
+    if ( _slave ) {
+	_slave->reset();
+	delete _slave;
+    }
+
+    _slave = QInputContextFactory::create( key, cachedHolderWidget );
+    if ( _slave ) {
+	insertChild( _slave );
+
+	const char *method;
+	if ( beIndirectlyConnected ) {
+	    method = SLOT(imEventReceived(QObject *,QIMEvent *));
+	} else {
+	    method = SIGNAL(imEventGenerated(QObject *,QIMEvent *));
+	}
+	connect( _slave, SIGNAL(imEventGenerated(QObject *,QIMEvent *)),
+		 this, method );
+	connect( _slave, SIGNAL(deletionRequested()),
+		 this, SLOT(destroyInputContext()) );
+
+	if ( cachedFocus ) {
+	    _slave->setFocus();
+	    _slave->setFocusWidget( cachedFocusWidget );
+	}
+
+        currentIMKey = key;
+
+	qDebug( "QMultiInputContext::changeInputMethod(): index=%d, slave=%s",
+		imIndex, (const char *)_slave->identifierName() );
+    }
+}
+
+QPtrList<QInputContextMenu> *QMultiInputContext::menus()
+{
+    QInputContextMenu *imSelMenu = new QInputContextMenu;
+    imSelMenu->title = tr( "Select Input &Method" );
+    imSelMenu->popup = createImSelPopup();
+
+    QPtrList<QInputContextMenu> *result = new QPtrList<QInputContextMenu>;
+    result->append( imSelMenu );
+
+    QPtrList<QInputContextMenu> *slaveMenus = ( slave() ) ? slave()->menus() : 0;
+    if ( slaveMenus ) {
+	for ( QPtrList<QInputContextMenu>::Iterator it = slaveMenus->begin();
+	      it != slaveMenus->end();
+	      ++it ) {
+	    QInputContextMenu *slaveMenu = *it;
+	    result->append( slaveMenu );
+	}
+	delete slaveMenus;
+    }
+
+    return result;
+}
+
+QPopupMenu *QMultiInputContext::createImSelPopup()
+{
+    if ( popup )
+        delete popup;
+
+    popup = new QPopupMenu();
+    keyDict.clear();
+
+    QStringList keys = QInputContextFactory::keys();
+    for ( uint i=0; i < keys.size(); i++ ) {
+	QString idName = keys[i];
+	bool isIMSwitcher = idName.startsWith( "imsw-" );
+
+	if ( ! isIMSwitcher ) {
+	    QString dispName = QInputContextFactory::displayName( idName );
+	    if ( dispName.isEmpty() )
+		dispName = idName;
+
+	    int id = popup->insertItem( dispName );
+	    keyDict.insert( (long)id, new QString( idName ) );
+
+	    if ( idName == currentIMKey )
+		popup->setItemChecked( id, true );
+
+            QString descriptionStr = QInputContextFactory::description( idName );
+            if ( ! descriptionStr.isEmpty() )
+                popup->setWhatsThis( id, descriptionStr );
+	}
+    }
+
+    QObject::connect( popup, SIGNAL(activated(int)),
+                      this, SLOT(changeInputMethodWithMenuId(int)) );
+
+    return popup;
+}
+
+void QMultiInputContext::changeInputMethodWithMenuId( int menuid )
+{
+    QString *key = keyDict.find( (long)menuid );
+    changeInputMethod( (*key) );
+}
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontext.h	2009-10-18 14:38:38.761866183 -0700
@@ -0,0 +1,124 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QMultiInputContext class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QMULTIINPUTCONTEXT_H
+#define QMULTIINPUTCONTEXT_H
+
+#ifndef QT_NO_IM
+
+#include <qnamespace.h>
+#include <qwidget.h>
+#include <qinputcontext.h>
+#include <qguardedptr.h>
+#include <qintdict.h>
+
+class QPopupMenu;
+
+class QMultiInputContext : public QInputContext
+{
+    Q_OBJECT
+public:
+    QMultiInputContext();
+    ~QMultiInputContext();
+
+    QString identifierName();
+    QString language();
+
+#if defined(Q_WS_X11)
+    bool x11FilterEvent( QWidget *keywidget, XEvent *event );
+#endif // Q_WS_X11
+    bool filterEvent( const QEvent *event );
+    void reset();
+
+    void setFocus();
+    void unsetFocus();
+    void setMicroFocus( int x, int y, int w, int h, QFont *f = 0 );
+    void mouseHandler( int x, QEvent::Type type,
+		       Qt::ButtonState button, Qt::ButtonState state );
+    QFont font() const;
+    bool isComposing() const;
+    bool isPreeditRelocationEnabled();
+    
+#if (QT_VERSION-0 >= 0x040000)
+    QPtrList<QMenu> *qt4menus();
+#endif
+    QPtrList<QInputContextMenu> *menus();
+    QPopupMenu *createImSelPopup();    
+
+#if defined(Q_WS_X11)
+    QWidget *focusWidget() const;
+    QWidget *holderWidget() const;
+
+    void setFocusWidget( QWidget *w );
+    void setHolderWidget( QWidget *w );
+    void releaseComposingWidget( QWidget *w );
+#endif
+
+public slots:
+    virtual void destroyInputContext();
+    virtual void postIMEvent( QObject *receiver, QIMEvent *event );
+
+protected slots:
+    void changeInputMethodWithMenuId( int menuid );
+
+protected:
+    QInputContext *slave();
+    const QInputContext *slave() const;
+    
+    void changeInputMethod( int newIndex );
+    void changeInputMethod( QString name );
+
+    QInputContext *_slave;
+    int imIndex;
+    bool cachedFocus;
+    QWidget *cachedFocusWidget;
+    QWidget *cachedHolderWidget;
+    bool beIndirectlyConnected;
+
+    QIntDict<QString> keyDict;
+    QGuardedPtr<QPopupMenu> popup;
+    QString currentIMKey;
+};
+
+#endif //Q_NO_IM
+
+#endif // QMULTIINPUTCONTEXT_H
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.cpp	2009-10-18 14:38:38.761866183 -0700
@@ -0,0 +1,88 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QMultiInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qmultiinputcontext.h"
+#include "qmultiinputcontextplugin.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+QMultiInputContextPlugin::QMultiInputContextPlugin()
+{
+}
+
+QMultiInputContextPlugin::~QMultiInputContextPlugin()
+{
+}
+
+QStringList QMultiInputContextPlugin::keys() const
+{
+    // input method switcher should named with "imsw-" prefix to
+    // prevent to be listed in ordinary input method list.
+    return QStringList( "imsw-multi" );
+}
+
+QInputContext *QMultiInputContextPlugin::create( const QString &key )
+{
+    return new QMultiInputContext;
+}
+
+QStringList QMultiInputContextPlugin::languages( const QString &key )
+{
+    return QStringList( "" );
+}
+
+QString QMultiInputContextPlugin::displayName( const QString &key )
+{
+    return tr( "Multiple Input Method Switcher" );
+}
+
+QString QMultiInputContextPlugin::description( const QString &key )
+{
+    return tr( "Multiple input method switcher that uses the context menu of the text widgets" );
+}
+
+
+Q_EXPORT_PLUGIN( QMultiInputContextPlugin )
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.h qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-multi/qmultiinputcontextplugin.h	2009-10-18 14:38:38.765203535 -0700
@@ -0,0 +1,63 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QMultiInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qmultiinputcontext.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+class QMultiInputContextPlugin : public QInputContextPlugin
+{
+    Q_OBJECT
+public:
+    QMultiInputContextPlugin();
+    ~QMultiInputContextPlugin();
+
+    QStringList keys() const;
+    QInputContext *create( const QString &key );
+    QStringList languages( const QString &key );
+    QString displayName( const QString &key );
+    QString description( const QString &key );
+};
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/imsw-none.pro qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/imsw-none.pro
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/imsw-none.pro	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/imsw-none.pro	2009-10-18 14:38:38.765203535 -0700
@@ -0,0 +1,12 @@
+TEMPLATE = lib
+TARGET   = qimsw-none
+DESTDIR  = ../../../inputmethods
+
+INCLUDEPATH += .
+CONFIG      += qt warn_on debug plugin
+target.path += $$plugins.path/inputmethods
+INSTALLS    += target
+
+# Input
+HEADERS += qnoneinputcontextplugin.h
+SOURCES += qnoneinputcontextplugin.cpp
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.cpp	2009-10-18 14:41:26.735191383 -0700
@@ -0,0 +1,102 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QNoneInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include <stdlib.h>
+
+#ifndef QT_NO_IM
+#include "qnoneinputcontextplugin.h"
+#include <qinputcontextfactory.h>
+#include <qsettings.h>
+
+
+QNoneInputContextPlugin::QNoneInputContextPlugin()
+{
+}
+
+QNoneInputContextPlugin::~QNoneInputContextPlugin()
+{
+}
+
+QStringList QNoneInputContextPlugin::keys() const
+{
+    // input method switcher should named with "imsw-" prefix to
+    // prevent to be listed in ordinary input method list.
+    return QStringList( "imsw-none" );
+}
+
+QInputContext *QNoneInputContextPlugin::create( const QString &key )
+{
+    QString actuallySpecifiedKey;
+
+    bool isIMSwitcher = key.startsWith( "imsw-" );
+    if ( ! isIMSwitcher )
+	return 0;
+
+    if ( getenv( "QT_IM_MODULE" ) ) {
+        actuallySpecifiedKey = getenv( "QT_IM_MODULE" );
+    } else {
+	QSettings settings;
+        actuallySpecifiedKey = settings.readEntry( "/qt/DefaultInputMethod", "xim" );
+    }
+
+    return QInputContextFactory::create( actuallySpecifiedKey, 0 );
+}
+
+QStringList QNoneInputContextPlugin::languages( const QString &key )
+{
+    return QStringList( "" );
+}
+
+QString QNoneInputContextPlugin::displayName( const QString &key )
+{
+    return tr( "Dummy Input Method Switcher" );
+}
+
+QString QNoneInputContextPlugin::description( const QString &key )
+{
+    return tr( "Dummy input method switcher that uses the context menu of the text widgets" );
+}
+
+
+Q_EXPORT_PLUGIN( QNoneInputContextPlugin )
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/imsw-none/qnoneinputcontextplugin.h	2009-10-18 14:38:38.781875608 -0700
@@ -0,0 +1,62 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QNoneInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+class QNoneInputContextPlugin : public QInputContextPlugin
+{
+    Q_OBJECT
+public:
+    QNoneInputContextPlugin();
+    ~QNoneInputContextPlugin();
+
+    QStringList keys() const;
+    QInputContext *create( const QString &key );
+    QStringList languages( const QString &key );
+    QString displayName( const QString &key );
+    QString description( const QString &key );
+};
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/inputmethods.pro qt-x11-free-3.3.8b/plugins/src/inputmethods/inputmethods.pro
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/inputmethods.pro	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/inputmethods.pro	2009-10-18 14:38:38.781875608 -0700
@@ -0,0 +1,11 @@
+TEMPLATE = subdirs
+
+unix {
+	!embedded:!mac:CONFIG	   += x11
+}
+# XIM should be enabled only for X11 platform, but following
+# configuration is not working properly yet
+#im:x11:SUBDIRS += xim
+
+inputmethod:SUBDIRS += imsw-none imsw-multi simple
+inputmethod:SUBDIRS += xim
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/composetable.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/composetable.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/composetable.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/composetable.cpp	2009-10-18 14:38:38.958543842 -0700
@@ -0,0 +1,5605 @@
+/****************************************************************************
+** $Id$
+**
+** Compose table for QSimpleInputContext class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+// The compose table included in file is converted from a Compose file
+// of X.org's X11R6.7.0. Original header is follows
+
+// UTF-8 (Unicode) compose sequence
+// David.Monniaux@ens.fr
+//
+// $XFree86: xc/nls/Compose/en_US.UTF-8,v 1.11 2004/01/06 13:14:04 pascal Exp $
+
+
+#include "qsimpleinputcontext.h"
+
+#include <qnamespace.h>
+
+static const QComposeTableElement defaultTable[] = {
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, 0x0000, 0x004f, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0x0055, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0x006f, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0000, 0x0075, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0041, 0, 0, 0, 0}, 0x00c1 }, // U00C1 # LATIN CAPITAL LETTER A WITH ACUTE
+// /* broken */    { {0x0000, 0x0041, 0, 0, 0, 0}, 0x00c0 }, // U00C0 # LATIN CAPITAL LETTER A WITH GRAVE
+// /* broken */    { {0x0000, 0x0041, 0, 0, 0, 0}, 0x00c3 }, // U00C3 # LATIN CAPITAL LETTER A WITH TILDE
+// /* broken */    { {0x0000, 0x0041, 0, 0, 0, 0}, 0x1ea2 }, // U1EA2 # LATIN CAPITAL LETTER A WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0041, 0, 0, 0, 0}, 0x1ea0 }, // U1EA0 # LATIN CAPITAL LETTER A WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0042, 0, 0, 0, 0}, 0x1e04 }, // U1E04 # LATIN CAPITAL LETTER B WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0043, 0, 0, 0, 0}, 0x0106 }, // U0106 # LATIN CAPITAL LETTER C WITH ACUTE
+// /* broken */    { {0x0000, 0x0044, 0, 0, 0, 0}, 0x1e0c }, // U1E0C # LATIN CAPITAL LETTER D WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0045, 0, 0, 0, 0}, 0x1ebc }, // U1EBC # LATIN CAPITAL LETTER E WITH TILDE
+// /* broken */    { {0x0000, 0x0045, 0, 0, 0, 0}, 0x1eb8 }, // U1EB8 # LATIN CAPITAL LETTER E WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0045, 0, 0, 0, 0}, 0x00c9 }, // U00C9 # LATIN CAPITAL LETTER E WITH ACUTE
+// /* broken */    { {0x0000, 0x0045, 0, 0, 0, 0}, 0x00c8 }, // U00C8 # LATIN CAPITAL LETTER E WITH GRAVE
+// /* broken */    { {0x0000, 0x0045, 0, 0, 0, 0}, 0x1eba }, // U1EBA # LATIN CAPITAL LETTER E WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0047, 0, 0, 0, 0}, 0x01f4 }, // U01F4 # LATIN CAPITAL LETTER G WITH ACUTE
+// /* broken */    { {0x0000, 0x0048, 0, 0, 0, 0}, 0x1e24 }, // U1E24 # LATIN CAPITAL LETTER H WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0049, 0, 0, 0, 0}, 0x00cd }, // U00CD # LATIN CAPITAL LETTER I WITH ACUTE
+// /* broken */    { {0x0000, 0x0049, 0, 0, 0, 0}, 0x00cc }, // U00CC # LATIN CAPITAL LETTER I WITH GRAVE
+// /* broken */    { {0x0000, 0x0049, 0, 0, 0, 0}, 0x1ec8 }, // U1EC8 # LATIN CAPITAL LETTER I WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0049, 0, 0, 0, 0}, 0x0128 }, // U0128 # LATIN CAPITAL LETTER I WITH TILDE
+// /* broken */    { {0x0000, 0x0049, 0, 0, 0, 0}, 0x1eca }, // U1ECA # LATIN CAPITAL LETTER I WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004b, 0, 0, 0, 0}, 0x1e30 }, // U1E30 # LATIN CAPITAL LETTER K WITH ACUTE
+// /* broken */    { {0x0000, 0x004b, 0, 0, 0, 0}, 0x1e32 }, // U1E32 # LATIN CAPITAL LETTER K WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004c, 0, 0, 0, 0}, 0x0139 }, // U0139 # LATIN CAPITAL LETTER L WITH ACUTE
+// /* broken */    { {0x0000, 0x004c, 0, 0, 0, 0}, 0x1e36 }, // U1E36 # LATIN CAPITAL LETTER L WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004d, 0, 0, 0, 0}, 0x1e42 }, // U1E42 # LATIN CAPITAL LETTER M WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004d, 0, 0, 0, 0}, 0x1e3e }, // U1E3E # LATIN CAPITAL LETTER M WITH ACUTE
+// /* broken */    { {0x0000, 0x004e, 0, 0, 0, 0}, 0x1e46 }, // U1E46 # LATIN CAPITAL LETTER N WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004e, 0, 0, 0, 0}, 0x0143 }, // U0143 # LATIN CAPITAL LETTER N WITH ACUTE
+// /* broken */    { {0x0000, 0x004e, 0, 0, 0, 0}, 0x01f8 }, // U01F8 # LATIN CAPITAL LETTER N WITH GRAVE
+// /* broken */    { {0x0000, 0x004e, 0, 0, 0, 0}, 0x00d1 }, // U00D1 # LATIN CAPITAL LETTER N WITH TILDE
+// /* broken */    { {0x0000, 0x004f, 0, 0, 0, 0}, 0x00d5 }, // U00D5 # LATIN CAPITAL LETTER O WITH TILDE
+// /* broken */    { {0x0000, 0x004f, 0, 0, 0, 0}, 0x00d3 }, // U00D3 # LATIN CAPITAL LETTER O WITH ACUTE
+// /* broken */    { {0x0000, 0x004f, 0, 0, 0, 0}, 0x1ecc }, // U1ECC # LATIN CAPITAL LETTER O WITH DOT BELOW
+// /* broken */    { {0x0000, 0x004f, 0, 0, 0, 0}, 0x00d2 }, // U00D2 # LATIN CAPITAL LETTER O WITH GRAVE
+// /* broken */    { {0x0000, 0x004f, 0, 0, 0, 0}, 0x1ece }, // U1ECE # LATIN CAPITAL LETTER O WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0050, 0, 0, 0, 0}, 0x1e54 }, // U1E54 # LATIN CAPITAL LETTER P WITH ACUTE
+// /* broken */    { {0x0000, 0x0052, 0, 0, 0, 0}, 0x1e5a }, // U1E5A # LATIN CAPITAL LETTER R WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0052, 0, 0, 0, 0}, 0x0154 }, // U0154 # LATIN CAPITAL LETTER R WITH ACUTE
+// /* broken */    { {0x0000, 0x0053, 0, 0, 0, 0}, 0x015a }, // U015A # LATIN CAPITAL LETTER S WITH ACUTE
+// /* broken */    { {0x0000, 0x0053, 0, 0, 0, 0}, 0x1e62 }, // U1E62 # LATIN CAPITAL LETTER S WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0054, 0, 0, 0, 0}, 0x1e6c }, // U1E6C # LATIN CAPITAL LETTER T WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0055, 0, 0, 0, 0}, 0x00da }, // U00DA # LATIN CAPITAL LETTER U WITH ACUTE
+// /* broken */    { {0x0000, 0x0055, 0, 0, 0, 0}, 0x00d9 }, // U00D9 # LATIN CAPITAL LETTER U WITH GRAVE
+// /* broken */    { {0x0000, 0x0055, 0, 0, 0, 0}, 0x0168 }, // U0168 # LATIN CAPITAL LETTER U WITH TILDE
+// /* broken */    { {0x0000, 0x0055, 0, 0, 0, 0}, 0x1ee4 }, // U1EE4 # LATIN CAPITAL LETTER U WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0055, 0, 0, 0, 0}, 0x1ee6 }, // U1EE6 # LATIN CAPITAL LETTER U WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0056, 0, 0, 0, 0}, 0x1e7e }, // U1E7E # LATIN CAPITAL LETTER V WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0056, 0, 0, 0, 0}, 0x1e7c }, // U1E7C # LATIN CAPITAL LETTER V WITH TILDE
+// /* broken */    { {0x0000, 0x0057, 0, 0, 0, 0}, 0x1e82 }, // U1E82 # LATIN CAPITAL LETTER W WITH ACUTE
+// /* broken */    { {0x0000, 0x0057, 0, 0, 0, 0}, 0x1e88 }, // U1E88 # LATIN CAPITAL LETTER W WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0057, 0, 0, 0, 0}, 0x1e80 }, // U1E80 # LATIN CAPITAL LETTER W WITH GRAVE
+// /* broken */    { {0x0000, 0x0059, 0, 0, 0, 0}, 0x1ef8 }, // U1EF8 # LATIN CAPITAL LETTER Y WITH TILDE
+// /* broken */    { {0x0000, 0x0059, 0, 0, 0, 0}, 0x1ef2 }, // U1EF2 # LATIN CAPITAL LETTER Y WITH GRAVE
+// /* broken */    { {0x0000, 0x0059, 0, 0, 0, 0}, 0x00dd }, // U00DD # LATIN CAPITAL LETTER Y WITH ACUTE
+// /* broken */    { {0x0000, 0x0059, 0, 0, 0, 0}, 0x1ef6 }, // U1EF6 # LATIN CAPITAL LETTER Y WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0059, 0, 0, 0, 0}, 0x1ef4 }, // U1EF4 # LATIN CAPITAL LETTER Y WITH DOT BELOW
+// /* broken */    { {0x0000, 0x005a, 0, 0, 0, 0}, 0x0179 }, // U0179 # LATIN CAPITAL LETTER Z WITH ACUTE
+// /* broken */    { {0x0000, 0x005a, 0, 0, 0, 0}, 0x1e92 }, // U1E92 # LATIN CAPITAL LETTER Z WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0061, 0, 0, 0, 0}, 0x1ea1 }, // U1EA1 # LATIN SMALL LETTER A WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0061, 0, 0, 0, 0}, 0x1ea3 }, // U1EA3 # LATIN SMALL LETTER A WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0061, 0, 0, 0, 0}, 0x00e0 }, // U00E0 # LATIN SMALL LETTER A WITH GRAVE
+// /* broken */    { {0x0000, 0x0061, 0, 0, 0, 0}, 0x00e3 }, // U00E3 # LATIN SMALL LETTER A WITH TILDE
+// /* broken */    { {0x0000, 0x0061, 0, 0, 0, 0}, 0x00e1 }, // U00E1 # LATIN SMALL LETTER A WITH ACUTE
+// /* broken */    { {0x0000, 0x0062, 0, 0, 0, 0}, 0x1e05 }, // U1E05 # LATIN SMALL LETTER B WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0063, 0, 0, 0, 0}, 0x0107 }, // U0107 # LATIN SMALL LETTER C WITH ACUTE
+// /* broken */    { {0x0000, 0x0064, 0, 0, 0, 0}, 0x1e0d }, // U1E0D # LATIN SMALL LETTER D WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0065, 0, 0, 0, 0}, 0x00e8 }, // U00E8 # LATIN SMALL LETTER E WITH GRAVE
+// /* broken */    { {0x0000, 0x0065, 0, 0, 0, 0}, 0x1ebb }, // U1EBB # LATIN SMALL LETTER E WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0065, 0, 0, 0, 0}, 0x1eb9 }, // U1EB9 # LATIN SMALL LETTER E WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0065, 0, 0, 0, 0}, 0x00e9 }, // U00E9 # LATIN SMALL LETTER E WITH ACUTE
+// /* broken */    { {0x0000, 0x0065, 0, 0, 0, 0}, 0x1ebd }, // U1EBD # LATIN SMALL LETTER E WITH TILDE
+// /* broken */    { {0x0000, 0x0067, 0, 0, 0, 0}, 0x01f5 }, // U01F5 # LATIN SMALL LETTER G WITH ACUTE
+// /* broken */    { {0x0000, 0x0068, 0, 0, 0, 0}, 0x1e25 }, // U1E25 # LATIN SMALL LETTER H WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0069, 0, 0, 0, 0}, 0x00ec }, // U00EC # LATIN SMALL LETTER I WITH GRAVE
+// /* broken */    { {0x0000, 0x0069, 0, 0, 0, 0}, 0x0129 }, // U0129 # LATIN SMALL LETTER I WITH TILDE
+// /* broken */    { {0x0000, 0x0069, 0, 0, 0, 0}, 0x1ecb }, // U1ECB # LATIN SMALL LETTER I WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0069, 0, 0, 0, 0}, 0x00ed }, // U00ED # LATIN SMALL LETTER I WITH ACUTE
+// /* broken */    { {0x0000, 0x0069, 0, 0, 0, 0}, 0x1ec9 }, // U1EC9 # LATIN SMALL LETTER I WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x006b, 0, 0, 0, 0}, 0x1e33 }, // U1E33 # LATIN SMALL LETTER K WITH DOT BELOW
+// /* broken */    { {0x0000, 0x006b, 0, 0, 0, 0}, 0x1e31 }, // U1E31 # LATIN SMALL LETTER K WITH ACUTE
+// /* broken */    { {0x0000, 0x006c, 0, 0, 0, 0}, 0x1e37 }, // U1E37 # LATIN SMALL LETTER L WITH DOT BELOW
+// /* broken */    { {0x0000, 0x006c, 0, 0, 0, 0}, 0x013a }, // U013A # LATIN SMALL LETTER L WITH ACUTE
+// /* broken */    { {0x0000, 0x006d, 0, 0, 0, 0}, 0x1e43 }, // U1E43 # LATIN SMALL LETTER M WITH DOT BELOW
+// /* broken */    { {0x0000, 0x006d, 0, 0, 0, 0}, 0x1e3f }, // U1E3F # LATIN SMALL LETTER M WITH ACUTE
+// /* broken */    { {0x0000, 0x006e, 0, 0, 0, 0}, 0x00f1 }, // U00F1 # LATIN SMALL LETTER N WITH TILDE
+// /* broken */    { {0x0000, 0x006e, 0, 0, 0, 0}, 0x0144 }, // U0144 # LATIN SMALL LETTER N WITH ACUTE
+// /* broken */    { {0x0000, 0x006e, 0, 0, 0, 0}, 0x01f9 }, // U01F9 # LATIN SMALL LETTER N WITH GRAVE
+// /* broken */    { {0x0000, 0x006e, 0, 0, 0, 0}, 0x1e47 }, // U1E47 # LATIN SMALL LETTER N WITH DOT BELOW
+// /* broken */    { {0x0000, 0x006f, 0, 0, 0, 0}, 0x00f5 }, // U00F5 # LATIN SMALL LETTER O WITH TILDE
+// /* broken */    { {0x0000, 0x006f, 0, 0, 0, 0}, 0x00f2 }, // U00F2 # LATIN SMALL LETTER O WITH GRAVE
+// /* broken */    { {0x0000, 0x006f, 0, 0, 0, 0}, 0x1ecf }, // U1ECF # LATIN SMALL LETTER O WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x006f, 0, 0, 0, 0}, 0x00f3 }, // U00F3 # LATIN SMALL LETTER O WITH ACUTE
+// /* broken */    { {0x0000, 0x006f, 0, 0, 0, 0}, 0x1ecd }, // U1ECD # LATIN SMALL LETTER O WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0070, 0, 0, 0, 0}, 0x1e55 }, // U1E55 # LATIN SMALL LETTER P WITH ACUTE
+// /* broken */    { {0x0000, 0x0072, 0, 0, 0, 0}, 0x0155 }, // U0155 # LATIN SMALL LETTER R WITH ACUTE
+// /* broken */    { {0x0000, 0x0072, 0, 0, 0, 0}, 0x1e5b }, // U1E5B # LATIN SMALL LETTER R WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0073, 0, 0, 0, 0}, 0x1e63 }, // U1E63 # LATIN SMALL LETTER S WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0073, 0, 0, 0, 0}, 0x015b }, // U015B # LATIN SMALL LETTER S WITH ACUTE
+// /* broken */    { {0x0000, 0x0074, 0, 0, 0, 0}, 0x1e6d }, // U1E6D # LATIN SMALL LETTER T WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0075, 0, 0, 0, 0}, 0x0169 }, // U0169 # LATIN SMALL LETTER U WITH TILDE
+// /* broken */    { {0x0000, 0x0075, 0, 0, 0, 0}, 0x1ee7 }, // U1EE7 # LATIN SMALL LETTER U WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0075, 0, 0, 0, 0}, 0x00f9 }, // U00F9 # LATIN SMALL LETTER U WITH GRAVE
+// /* broken */    { {0x0000, 0x0075, 0, 0, 0, 0}, 0x00fa }, // U00FA # LATIN SMALL LETTER U WITH ACUTE
+// /* broken */    { {0x0000, 0x0075, 0, 0, 0, 0}, 0x1ee5 }, // U1EE5 # LATIN SMALL LETTER U WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0076, 0, 0, 0, 0}, 0x1e7d }, // U1E7D # LATIN SMALL LETTER V WITH TILDE
+// /* broken */    { {0x0000, 0x0076, 0, 0, 0, 0}, 0x1e7f }, // U1E7F # LATIN SMALL LETTER V WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0077, 0, 0, 0, 0}, 0x1e81 }, // U1E81 # LATIN SMALL LETTER W WITH GRAVE
+// /* broken */    { {0x0000, 0x0077, 0, 0, 0, 0}, 0x1e83 }, // U1E83 # LATIN SMALL LETTER W WITH ACUTE
+// /* broken */    { {0x0000, 0x0077, 0, 0, 0, 0}, 0x1e89 }, // U1E89 # LATIN SMALL LETTER W WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0079, 0, 0, 0, 0}, 0x1ef5 }, // U1EF5 # LATIN SMALL LETTER Y WITH DOT BELOW
+// /* broken */    { {0x0000, 0x0079, 0, 0, 0, 0}, 0x1ef9 }, // U1EF9 # LATIN SMALL LETTER Y WITH TILDE
+// /* broken */    { {0x0000, 0x0079, 0, 0, 0, 0}, 0x1ef7 }, // U1EF7 # LATIN SMALL LETTER Y WITH HOOK ABOVE
+// /* broken */    { {0x0000, 0x0079, 0, 0, 0, 0}, 0x1ef3 }, // U1EF3 # LATIN SMALL LETTER Y WITH GRAVE
+// /* broken */    { {0x0000, 0x0079, 0, 0, 0, 0}, 0x00fd }, // U00FD # LATIN SMALL LETTER Y WITH ACUTE
+// /* broken */    { {0x0000, 0x007a, 0, 0, 0, 0}, 0x1e93 }, // U1E93 # LATIN SMALL LETTER Z WITH DOT BELOW
+// /* broken */    { {0x0000, 0x007a, 0, 0, 0, 0}, 0x017a }, // U017A # LATIN SMALL LETTER Z WITH ACUTE
+// /* broken */    { {0x0000, 0x00c2, 0, 0, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00c2, 0, 0, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00c2, 0, 0, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00c2, 0, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00c5, 0, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, 0x00c6, 0, 0, 0, 0}, 0x01fc }, // U01FC # LATIN CAPITAL LETTER AE WITH ACUTE
+// /* broken */    { {0x0000, 0x00c7, 0, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, 0x00ca, 0, 0, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00ca, 0, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00ca, 0, 0, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00ca, 0, 0, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00cf, 0, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, 0x00d4, 0, 0, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00d4, 0, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00d4, 0, 0, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00d4, 0, 0, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00d5, 0, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x00d8, 0, 0, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, 0x00dc, 0, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, 0x00dc, 0, 0, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, 0x00e2, 0, 0, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00e2, 0, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00e2, 0, 0, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00e2, 0, 0, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00e5, 0, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, 0x00e6, 0, 0, 0, 0}, 0x01fd }, // U01FD # LATIN SMALL LETTER AE WITH ACUTE
+// /* broken */    { {0x0000, 0x00e7, 0, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, 0x00ea, 0, 0, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00ea, 0, 0, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00ea, 0, 0, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00ea, 0, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00ef, 0, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, 0x00f4, 0, 0, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, 0x00f4, 0, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, 0x00f4, 0, 0, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x00f4, 0, 0, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, 0x00f5, 0, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x00f8, 0, 0, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, 0x00fc, 0, 0, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, 0x00fc, 0, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, 0x0102, 0, 0, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, 0x0102, 0, 0, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, 0x0102, 0, 0, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0102, 0, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, 0x0103, 0, 0, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, 0x0103, 0, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, 0x0103, 0, 0, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, 0x0103, 0, 0, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, 0x0112, 0, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, 0x0112, 0, 0, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, 0x0113, 0, 0, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, 0x0113, 0, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, 0x014c, 0, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, 0x014c, 0, 0, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, 0x014d, 0, 0, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, 0x014d, 0, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, 0x0168, 0, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0169, 0, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, 0x0313, 0x0391, 0, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x0391, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x0395, 0, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x0395, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x0397, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x0397, 0, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x0399, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x0399, 0, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x039f, 0, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x039f, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03a9, 0, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03a9, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03b1, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03b1, 0, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03b5, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03b5, 0, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03b7, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03b7, 0, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03b9, 0, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03b9, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03bf, 0, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03bf, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03c5, 0, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03c5, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0313, 0x03c9, 0, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x0313, 0x03c9, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x0391, 0, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x0391, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x0395, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x0395, 0, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x0397, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x0397, 0, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x0399, 0, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x0399, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x039f, 0, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x039f, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03a5, 0, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03a5, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03a9, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03a9, 0, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03b1, 0, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03b1, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03b5, 0, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03b5, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03b7, 0, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03b7, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03b9, 0, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03b9, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03bf, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03bf, 0, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03c5, 0, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03c5, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0314, 0x03c9, 0, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x0314, 0x03c9, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x0391, 0, 0, 0, 0}, 0x0386 }, // U0386 # GREEK CAPITAL LETTER ALPHA WITH TONOS
+// /* broken */    { {0x0000, 0x0391, 0, 0, 0, 0}, 0x1fba }, // U1FBA # GREEK CAPITAL LETTER ALPHA WITH VARIA
+// /* broken */    { {0x0000, 0x0395, 0, 0, 0, 0}, 0x0388 }, // U0388 # GREEK CAPITAL LETTER EPSILON WITH TONOS
+// /* broken */    { {0x0000, 0x0395, 0, 0, 0, 0}, 0x1fc8 }, // U1FC8 # GREEK CAPITAL LETTER EPSILON WITH VARIA
+// /* broken */    { {0x0000, 0x0397, 0, 0, 0, 0}, 0x1fca }, // U1FCA # GREEK CAPITAL LETTER ETA WITH VARIA
+// /* broken */    { {0x0000, 0x0397, 0, 0, 0, 0}, 0x0389 }, // U0389 # GREEK CAPITAL LETTER ETA WITH TONOS
+// /* broken */    { {0x0000, 0x0399, 0, 0, 0, 0}, 0x038a }, // U038A # GREEK CAPITAL LETTER IOTA WITH TONOS
+// /* broken */    { {0x0000, 0x0399, 0, 0, 0, 0}, 0x1fda }, // U1FDA # GREEK CAPITAL LETTER IOTA WITH VARIA
+// /* broken */    { {0x0000, 0x039f, 0, 0, 0, 0}, 0x038c }, // U038C # GREEK CAPITAL LETTER OMICRON WITH TONOS
+// /* broken */    { {0x0000, 0x039f, 0, 0, 0, 0}, 0x1ff8 }, // U1FF8 # GREEK CAPITAL LETTER OMICRON WITH VARIA
+// /* broken */    { {0x0000, 0x03a5, 0, 0, 0, 0}, 0x038e }, // U038E # GREEK CAPITAL LETTER UPSILON WITH TONOS
+// /* broken */    { {0x0000, 0x03a5, 0, 0, 0, 0}, 0x1fea }, // U1FEA # GREEK CAPITAL LETTER UPSILON WITH VARIA
+// /* broken */    { {0x0000, 0x03a9, 0, 0, 0, 0}, 0x038f }, // U038F # GREEK CAPITAL LETTER OMEGA WITH TONOS
+// /* broken */    { {0x0000, 0x03a9, 0, 0, 0, 0}, 0x1ffa }, // U1FFA # GREEK CAPITAL LETTER OMEGA WITH VARIA
+// /* broken */    { {0x0000, 0x03b1, 0, 0, 0, 0}, 0x03ac }, // U03AC # GREEK SMALL LETTER ALPHA WITH TONOS
+// /* broken */    { {0x0000, 0x03b1, 0, 0, 0, 0}, 0x1f70 }, // U1F70 # GREEK SMALL LETTER ALPHA WITH VARIA
+// /* broken */    { {0x0000, 0x03b5, 0, 0, 0, 0}, 0x03ad }, // U03AD # GREEK SMALL LETTER EPSILON WITH TONOS
+// /* broken */    { {0x0000, 0x03b5, 0, 0, 0, 0}, 0x1f72 }, // U1F72 # GREEK SMALL LETTER EPSILON WITH VARIA
+// /* broken */    { {0x0000, 0x03b7, 0, 0, 0, 0}, 0x03ae }, // U03AE # GREEK SMALL LETTER ETA WITH TONOS
+// /* broken */    { {0x0000, 0x03b7, 0, 0, 0, 0}, 0x1f74 }, // U1F74 # GREEK SMALL LETTER ETA WITH VARIA
+// /* broken */    { {0x0000, 0x03b9, 0, 0, 0, 0}, 0x03af }, // U03AF # GREEK SMALL LETTER IOTA WITH TONOS
+// /* broken */    { {0x0000, 0x03b9, 0, 0, 0, 0}, 0x1f76 }, // U1F76 # GREEK SMALL LETTER IOTA WITH VARIA
+// /* broken */    { {0x0000, 0x03bf, 0, 0, 0, 0}, 0x03cc }, // U03CC # GREEK SMALL LETTER OMICRON WITH TONOS
+// /* broken */    { {0x0000, 0x03bf, 0, 0, 0, 0}, 0x1f78 }, // U1F78 # GREEK SMALL LETTER OMICRON WITH VARIA
+// /* broken */    { {0x0000, 0x03c5, 0, 0, 0, 0}, 0x03cd }, // U03CD # GREEK SMALL LETTER UPSILON WITH TONOS
+// /* broken */    { {0x0000, 0x03c5, 0, 0, 0, 0}, 0x1f7a }, // U1F7A # GREEK SMALL LETTER UPSILON WITH VARIA
+// /* broken */    { {0x0000, 0x03c9, 0, 0, 0, 0}, 0x03ce }, // U03CE # GREEK SMALL LETTER OMEGA WITH TONOS
+// /* broken */    { {0x0000, 0x03c9, 0, 0, 0, 0}, 0x1f7c }, // U1F7C # GREEK SMALL LETTER OMEGA WITH VARIA
+// /* broken */    { {0x0000, 0x03ca, 0, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, 0x03ca, 0, 0, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, 0x03cb, 0, 0, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, 0x03cb, 0, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, 0x0413, 0, 0, 0, 0}, 0x0403 }, // U0403 # CYRILLIC CAPITAL LETTER GJE
+// /* broken */    { {0x0000, 0x0415, 0, 0, 0, 0}, 0x0400 }, // U0400 # CYRILLIC CAPITAL LETTER IE WITH GRAVE
+// /* broken */    { {0x0000, 0x0418, 0, 0, 0, 0}, 0x040d }, // U040D # CYRILLIC CAPITAL LETTER I WITH GRAVE
+// /* broken */    { {0x0000, 0x041a, 0, 0, 0, 0}, 0x040c }, // U040C # CYRILLIC CAPITAL LETTER KJE
+// /* broken */    { {0x0000, 0x0433, 0, 0, 0, 0}, 0x0453 }, // U0453 # CYRILLIC SMALL LETTER GJE
+// /* broken */    { {0x0000, 0x0435, 0, 0, 0, 0}, 0x0450 }, // U0450 # CYRILLIC SMALL LETTER IE WITH GRAVE
+// /* broken */    { {0x0000, 0x0438, 0, 0, 0, 0}, 0x045d }, // U045D # CYRILLIC SMALL LETTER I WITH GRAVE
+// /* broken */    { {0x0000, 0x043a, 0, 0, 0, 0}, 0x045c }, // U045C # CYRILLIC SMALL LETTER KJE
+// /* broken */    { {0x0000, 0x1f00, 0, 0, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f00, 0, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f01, 0, 0, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f01, 0, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f08, 0, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f08, 0, 0, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f09, 0, 0, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f09, 0, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f10, 0, 0, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f10, 0, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f11, 0, 0, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f11, 0, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f18, 0, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f18, 0, 0, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f19, 0, 0, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f19, 0, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f20, 0, 0, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f20, 0, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f21, 0, 0, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f21, 0, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f28, 0, 0, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f28, 0, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f29, 0, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f29, 0, 0, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f30, 0, 0, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f30, 0, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f31, 0, 0, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f31, 0, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f38, 0, 0, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f38, 0, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f39, 0, 0, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f39, 0, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f40, 0, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f40, 0, 0, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f41, 0, 0, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f41, 0, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f48, 0, 0, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f48, 0, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f49, 0, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f49, 0, 0, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f50, 0, 0, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f50, 0, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f51, 0, 0, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f51, 0, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f59, 0, 0, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f59, 0, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f60, 0, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f60, 0, 0, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f61, 0, 0, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f61, 0, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, 0x1f68, 0, 0, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, 0x1f68, 0, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, 0x1f69, 0, 0, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, 0x1f69, 0, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0000, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0000, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0395, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x039f, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b5, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03bf, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0395, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x039f, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b5, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03bf, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002f, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x002f, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Multi_key), 0x00af, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Tilde), 0x0055, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Tilde), 0x0075, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0049, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0069, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Abovering), 0x0041, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Abovering), 0x0061, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Cedilla), 0x0043, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Cedilla), 0x0063, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {0x0000, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+    { {0x030f, 0x0041, 0, 0, 0, 0}, 0x0200 }, // U0200 # LATIN CAPITAL LETTER A WITH DOUBLE GRAVE
+    { {0x030f, 0x0045, 0, 0, 0, 0}, 0x0204 }, // U0204 # LATIN CAPITAL LETTER E WITH DOUBLE GRAVE
+    { {0x030f, 0x0049, 0, 0, 0, 0}, 0x0208 }, // U0208 # LATIN CAPITAL LETTER I WITH DOUBLE GRAVE
+    { {0x030f, 0x004f, 0, 0, 0, 0}, 0x020c }, // U020C # LATIN CAPITAL LETTER O WITH DOUBLE GRAVE
+    { {0x030f, 0x0052, 0, 0, 0, 0}, 0x0210 }, // U0210 # LATIN CAPITAL LETTER R WITH DOUBLE GRAVE
+    { {0x030f, 0x0055, 0, 0, 0, 0}, 0x0214 }, // U0214 # LATIN CAPITAL LETTER U WITH DOUBLE GRAVE
+    { {0x030f, 0x0061, 0, 0, 0, 0}, 0x0201 }, // U0201 # LATIN SMALL LETTER A WITH DOUBLE GRAVE
+    { {0x030f, 0x0065, 0, 0, 0, 0}, 0x0205 }, // U0205 # LATIN SMALL LETTER E WITH DOUBLE GRAVE
+    { {0x030f, 0x0069, 0, 0, 0, 0}, 0x0209 }, // U0209 # LATIN SMALL LETTER I WITH DOUBLE GRAVE
+    { {0x030f, 0x006f, 0, 0, 0, 0}, 0x020d }, // U020D # LATIN SMALL LETTER O WITH DOUBLE GRAVE
+    { {0x030f, 0x0072, 0, 0, 0, 0}, 0x0211 }, // U0211 # LATIN SMALL LETTER R WITH DOUBLE GRAVE
+    { {0x030f, 0x0075, 0, 0, 0, 0}, 0x0215 }, // U0215 # LATIN SMALL LETTER U WITH DOUBLE GRAVE
+    { {0x030f, 0x0474, 0, 0, 0, 0}, 0x0476 }, // U0476 # CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT
+    { {0x030f, 0x0475, 0, 0, 0, 0}, 0x0477 }, // U0477 # CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT
+    { {0x0311, 0x0041, 0, 0, 0, 0}, 0x0202 }, // U0202 # LATIN CAPITAL LETTER A WITH INVERTED BREVE
+    { {0x0311, 0x0045, 0, 0, 0, 0}, 0x0206 }, // U0206 # LATIN CAPITAL LETTER E WITH INVERTED BREVE
+    { {0x0311, 0x0049, 0, 0, 0, 0}, 0x020a }, // U020A # LATIN CAPITAL LETTER I WITH INVERTED BREVE
+    { {0x0311, 0x004f, 0, 0, 0, 0}, 0x020e }, // U020E # LATIN CAPITAL LETTER O WITH INVERTED BREVE
+    { {0x0311, 0x0052, 0, 0, 0, 0}, 0x0212 }, // U0212 # LATIN CAPITAL LETTER R WITH INVERTED BREVE
+    { {0x0311, 0x0055, 0, 0, 0, 0}, 0x0216 }, // U0216 # LATIN CAPITAL LETTER U WITH INVERTED BREVE
+    { {0x0311, 0x0061, 0, 0, 0, 0}, 0x0203 }, // U0203 # LATIN SMALL LETTER A WITH INVERTED BREVE
+    { {0x0311, 0x0065, 0, 0, 0, 0}, 0x0207 }, // U0207 # LATIN SMALL LETTER E WITH INVERTED BREVE
+    { {0x0311, 0x0069, 0, 0, 0, 0}, 0x020b }, // U020B # LATIN SMALL LETTER I WITH INVERTED BREVE
+    { {0x0311, 0x006f, 0, 0, 0, 0}, 0x020f }, // U020F # LATIN SMALL LETTER O WITH INVERTED BREVE
+    { {0x0311, 0x0072, 0, 0, 0, 0}, 0x0213 }, // U0213 # LATIN SMALL LETTER R WITH INVERTED BREVE
+    { {0x0311, 0x0075, 0, 0, 0, 0}, 0x0217 }, // U0217 # LATIN SMALL LETTER U WITH INVERTED BREVE
+    { {0x0313, 0x0391, 0, 0, 0, 0}, 0x1f08 }, // U1F08 # GREEK CAPITAL LETTER ALPHA WITH PSILI
+    { {0x0313, 0x0395, 0, 0, 0, 0}, 0x1f18 }, // U1F18 # GREEK CAPITAL LETTER EPSILON WITH PSILI
+    { {0x0313, 0x0397, 0, 0, 0, 0}, 0x1f28 }, // U1F28 # GREEK CAPITAL LETTER ETA WITH PSILI
+    { {0x0313, 0x0399, 0, 0, 0, 0}, 0x1f38 }, // U1F38 # GREEK CAPITAL LETTER IOTA WITH PSILI
+    { {0x0313, 0x039f, 0, 0, 0, 0}, 0x1f48 }, // U1F48 # GREEK CAPITAL LETTER OMICRON WITH PSILI
+    { {0x0313, 0x03a9, 0, 0, 0, 0}, 0x1f68 }, // U1F68 # GREEK CAPITAL LETTER OMEGA WITH PSILI
+    { {0x0313, 0x03b1, 0, 0, 0, 0}, 0x1f00 }, // U1F00 # GREEK SMALL LETTER ALPHA WITH PSILI
+    { {0x0313, 0x03b5, 0, 0, 0, 0}, 0x1f10 }, // U1F10 # GREEK SMALL LETTER EPSILON WITH PSILI
+    { {0x0313, 0x03b7, 0, 0, 0, 0}, 0x1f20 }, // U1F20 # GREEK SMALL LETTER ETA WITH PSILI
+    { {0x0313, 0x03b9, 0, 0, 0, 0}, 0x1f30 }, // U1F30 # GREEK SMALL LETTER IOTA WITH PSILI
+    { {0x0313, 0x03bf, 0, 0, 0, 0}, 0x1f40 }, // U1F40 # GREEK SMALL LETTER OMICRON WITH PSILI
+    { {0x0313, 0x03c1, 0, 0, 0, 0}, 0x1fe4 }, // U1FE4 # GREEK SMALL LETTER RHO WITH PSILI
+    { {0x0313, 0x03c5, 0, 0, 0, 0}, 0x1f50 }, // U1F50 # GREEK SMALL LETTER UPSILON WITH PSILI
+    { {0x0313, 0x03c9, 0, 0, 0, 0}, 0x1f60 }, // U1F60 # GREEK SMALL LETTER OMEGA WITH PSILI
+    { {0x0314, 0x0391, 0, 0, 0, 0}, 0x1f09 }, // U1F09 # GREEK CAPITAL LETTER ALPHA WITH DASIA
+    { {0x0314, 0x0395, 0, 0, 0, 0}, 0x1f19 }, // U1F19 # GREEK CAPITAL LETTER EPSILON WITH DASIA
+    { {0x0314, 0x0397, 0, 0, 0, 0}, 0x1f29 }, // U1F29 # GREEK CAPITAL LETTER ETA WITH DASIA
+    { {0x0314, 0x0399, 0, 0, 0, 0}, 0x1f39 }, // U1F39 # GREEK CAPITAL LETTER IOTA WITH DASIA
+    { {0x0314, 0x039f, 0, 0, 0, 0}, 0x1f49 }, // U1F49 # GREEK CAPITAL LETTER OMICRON WITH DASIA
+    { {0x0314, 0x03a1, 0, 0, 0, 0}, 0x1fec }, // U1FEC # GREEK CAPITAL LETTER RHO WITH DASIA
+    { {0x0314, 0x03a5, 0, 0, 0, 0}, 0x1f59 }, // U1F59 # GREEK CAPITAL LETTER UPSILON WITH DASIA
+    { {0x0314, 0x03a9, 0, 0, 0, 0}, 0x1f69 }, // U1F69 # GREEK CAPITAL LETTER OMEGA WITH DASIA
+    { {0x0314, 0x03b1, 0, 0, 0, 0}, 0x1f01 }, // U1F01 # GREEK SMALL LETTER ALPHA WITH DASIA
+    { {0x0314, 0x03b5, 0, 0, 0, 0}, 0x1f11 }, // U1F11 # GREEK SMALL LETTER EPSILON WITH DASIA
+    { {0x0314, 0x03b7, 0, 0, 0, 0}, 0x1f21 }, // U1F21 # GREEK SMALL LETTER ETA WITH DASIA
+    { {0x0314, 0x03b9, 0, 0, 0, 0}, 0x1f31 }, // U1F31 # GREEK SMALL LETTER IOTA WITH DASIA
+    { {0x0314, 0x03bf, 0, 0, 0, 0}, 0x1f41 }, // U1F41 # GREEK SMALL LETTER OMICRON WITH DASIA
+    { {0x0314, 0x03c1, 0, 0, 0, 0}, 0x1fe5 }, // U1FE5 # GREEK SMALL LETTER RHO WITH DASIA
+    { {0x0314, 0x03c5, 0, 0, 0, 0}, 0x1f51 }, // U1F51 # GREEK SMALL LETTER UPSILON WITH DASIA
+    { {0x0314, 0x03c9, 0, 0, 0, 0}, 0x1f61 }, // U1F61 # GREEK SMALL LETTER OMEGA WITH DASIA
+    { {0x0324, 0x0055, 0, 0, 0, 0}, 0x1e72 }, // U1E72 # LATIN CAPITAL LETTER U WITH DIAERESIS BELOW
+    { {0x0324, 0x0075, 0, 0, 0, 0}, 0x1e73 }, // U1E73 # LATIN SMALL LETTER U WITH DIAERESIS BELOW
+    { {0x0325, 0x0041, 0, 0, 0, 0}, 0x1e00 }, // U1E00 # LATIN CAPITAL LETTER A WITH RING BELOW
+    { {0x0325, 0x0061, 0, 0, 0, 0}, 0x1e01 }, // U1E01 # LATIN SMALL LETTER A WITH RING BELOW
+    { {0x0326, 0x0053, 0, 0, 0, 0}, 0x0218 }, // U0218 # LATIN CAPITAL LETTER S WITH COMMA BELOW
+    { {0x0326, 0x0054, 0, 0, 0, 0}, 0x021a }, // U021A # LATIN CAPITAL LETTER T WITH COMMA BELOW
+    { {0x0326, 0x0073, 0, 0, 0, 0}, 0x0219 }, // U0219 # LATIN SMALL LETTER S WITH COMMA BELOW
+    { {0x0326, 0x0074, 0, 0, 0, 0}, 0x021b }, // U021B # LATIN SMALL LETTER T WITH COMMA BELOW
+    { {0x032d, 0x0044, 0, 0, 0, 0}, 0x1e12 }, // U1E12 # LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0045, 0, 0, 0, 0}, 0x1e18 }, // U1E18 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x004c, 0, 0, 0, 0}, 0x1e3c }, // U1E3C # LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x004e, 0, 0, 0, 0}, 0x1e4a }, // U1E4A # LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0054, 0, 0, 0, 0}, 0x1e70 }, // U1E70 # LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0055, 0, 0, 0, 0}, 0x1e76 }, // U1E76 # LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0064, 0, 0, 0, 0}, 0x1e13 }, // U1E13 # LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0065, 0, 0, 0, 0}, 0x1e19 }, // U1E19 # LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x006c, 0, 0, 0, 0}, 0x1e3d }, // U1E3D # LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x006e, 0, 0, 0, 0}, 0x1e4b }, // U1E4B # LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0074, 0, 0, 0, 0}, 0x1e71 }, // U1E71 # LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW
+    { {0x032d, 0x0075, 0, 0, 0, 0}, 0x1e77 }, // U1E77 # LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW
+    { {0x032e, 0x0048, 0, 0, 0, 0}, 0x1e2a }, // U1E2A # LATIN CAPITAL LETTER H WITH BREVE BELOW
+    { {0x032e, 0x0068, 0, 0, 0, 0}, 0x1e2b }, // U1E2B # LATIN SMALL LETTER H WITH BREVE BELOW
+    { {0x0330, 0x0045, 0, 0, 0, 0}, 0x1e1a }, // U1E1A # LATIN CAPITAL LETTER E WITH TILDE BELOW
+    { {0x0330, 0x0049, 0, 0, 0, 0}, 0x1e2c }, // U1E2C # LATIN CAPITAL LETTER I WITH TILDE BELOW
+    { {0x0330, 0x0055, 0, 0, 0, 0}, 0x1e74 }, // U1E74 # LATIN CAPITAL LETTER U WITH TILDE BELOW
+    { {0x0330, 0x0065, 0, 0, 0, 0}, 0x1e1b }, // U1E1B # LATIN SMALL LETTER E WITH TILDE BELOW
+    { {0x0330, 0x0069, 0, 0, 0, 0}, 0x1e2d }, // U1E2D # LATIN SMALL LETTER I WITH TILDE BELOW
+    { {0x0330, 0x0075, 0, 0, 0, 0}, 0x1e75 }, // U1E75 # LATIN SMALL LETTER U WITH TILDE BELOW
+    { {0x0331, 0x0042, 0, 0, 0, 0}, 0x1e06 }, // U1E06 # LATIN CAPITAL LETTER B WITH LINE BELOW
+    { {0x0331, 0x0044, 0, 0, 0, 0}, 0x1e0e }, // U1E0E # LATIN CAPITAL LETTER D WITH LINE BELOW
+    { {0x0331, 0x004b, 0, 0, 0, 0}, 0x1e34 }, // U1E34 # LATIN CAPITAL LETTER K WITH LINE BELOW
+    { {0x0331, 0x004c, 0, 0, 0, 0}, 0x1e3a }, // U1E3A # LATIN CAPITAL LETTER L WITH LINE BELOW
+    { {0x0331, 0x004e, 0, 0, 0, 0}, 0x1e48 }, // U1E48 # LATIN CAPITAL LETTER N WITH LINE BELOW
+    { {0x0331, 0x0052, 0, 0, 0, 0}, 0x1e5e }, // U1E5E # LATIN CAPITAL LETTER R WITH LINE BELOW
+    { {0x0331, 0x0054, 0, 0, 0, 0}, 0x1e6e }, // U1E6E # LATIN CAPITAL LETTER T WITH LINE BELOW
+    { {0x0331, 0x005a, 0, 0, 0, 0}, 0x1e94 }, // U1E94 # LATIN CAPITAL LETTER Z WITH LINE BELOW
+    { {0x0331, 0x0062, 0, 0, 0, 0}, 0x1e07 }, // U1E07 # LATIN SMALL LETTER B WITH LINE BELOW
+    { {0x0331, 0x0064, 0, 0, 0, 0}, 0x1e0f }, // U1E0F # LATIN SMALL LETTER D WITH LINE BELOW
+    { {0x0331, 0x0068, 0, 0, 0, 0}, 0x1e96 }, // U1E96 # LATIN SMALL LETTER H WITH LINE BELOW
+    { {0x0331, 0x006b, 0, 0, 0, 0}, 0x1e35 }, // U1E35 # LATIN SMALL LETTER K WITH LINE BELOW
+    { {0x0331, 0x006c, 0, 0, 0, 0}, 0x1e3b }, // U1E3B # LATIN SMALL LETTER L WITH LINE BELOW
+    { {0x0331, 0x006e, 0, 0, 0, 0}, 0x1e49 }, // U1E49 # LATIN SMALL LETTER N WITH LINE BELOW
+    { {0x0331, 0x0072, 0, 0, 0, 0}, 0x1e5f }, // U1E5F # LATIN SMALL LETTER R WITH LINE BELOW
+    { {0x0331, 0x0074, 0, 0, 0, 0}, 0x1e6f }, // U1E6F # LATIN SMALL LETTER T WITH LINE BELOW
+    { {0x0331, 0x007a, 0, 0, 0, 0}, 0x1e95 }, // U1E95 # LATIN SMALL LETTER Z WITH LINE BELOW
+    { {0x0342, 0x0313, 0x0391, 0, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x0397, 0, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x0399, 0, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03a9, 0, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03b1, 0, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03b7, 0, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03b9, 0, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03c5, 0, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0313, 0x03c9, 0, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x0314, 0x0391, 0, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x0397, 0, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x0399, 0, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03a5, 0, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03a9, 0, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03b1, 0, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03b7, 0, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03b9, 0, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03c5, 0, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x0314, 0x03c9, 0, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x03b1, 0, 0, 0, 0}, 0x1fb6 }, // U1FB6 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI
+    { {0x0342, 0x03b7, 0, 0, 0, 0}, 0x1fc6 }, // U1FC6 # GREEK SMALL LETTER ETA WITH PERISPOMENI
+    { {0x0342, 0x03b9, 0, 0, 0, 0}, 0x1fd6 }, // U1FD6 # GREEK SMALL LETTER IOTA WITH PERISPOMENI
+    { {0x0342, 0x03c5, 0, 0, 0, 0}, 0x1fe6 }, // U1FE6 # GREEK SMALL LETTER UPSILON WITH PERISPOMENI
+    { {0x0342, 0x03c9, 0, 0, 0, 0}, 0x1ff6 }, // U1FF6 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI
+    { {0x0342, 0x03ca, 0, 0, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {0x0342, 0x03cb, 0, 0, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {0x0342, 0x1f00, 0, 0, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f01, 0, 0, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f08, 0, 0, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f09, 0, 0, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f20, 0, 0, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f21, 0, 0, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f28, 0, 0, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f29, 0, 0, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f30, 0, 0, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f31, 0, 0, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f38, 0, 0, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f39, 0, 0, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f50, 0, 0, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f51, 0, 0, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f59, 0, 0, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f60, 0, 0, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f61, 0, 0, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, 0x1f68, 0, 0, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, 0x1f69, 0, 0, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {0x0342, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0044, 0, 0, 0}, 0x0110 }, // U0110 # LATIN CAPITAL LETTER D WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0047, 0, 0, 0}, 0x01e4 }, // U01E4 # LATIN CAPITAL LETTER G WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0048, 0, 0, 0}, 0x0126 }, // U0126 # LATIN CAPITAL LETTER H WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0049, 0, 0, 0}, 0x0197 }, // U0197 # LATIN CAPITAL LETTER I WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x004c, 0, 0, 0}, 0x0141 }, // U0141 # LATIN CAPITAL LETTER L WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x004f, 0, 0, 0}, 0x00d8 }, // U00D8 # LATIN CAPITAL LETTER O WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0054, 0, 0, 0}, 0x0166 }, // U0166 # LATIN CAPITAL LETTER T WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x005a, 0, 0, 0}, 0x01b5 }, // U01B5 # LATIN CAPITAL LETTER Z WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0062, 0, 0, 0}, 0x0180 }, // U0180 # LATIN SMALL LETTER B WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0064, 0, 0, 0}, 0x0111 }, // U0111 # LATIN SMALL LETTER D WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0067, 0, 0, 0}, 0x01e5 }, // U01E5 # LATIN SMALL LETTER G WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0068, 0, 0, 0}, 0x0127 }, // U0127 # LATIN SMALL LETTER H WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0069, 0, 0, 0}, 0x0268 }, // U0268 # LATIN SMALL LETTER I WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x006c, 0, 0, 0}, 0x0142 }, // U0142 # LATIN SMALL LETTER L WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x006f, 0, 0, 0}, 0x00f8 }, // U00F8 # LATIN SMALL LETTER O WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0074, 0, 0, 0}, 0x0167 }, // U0167 # LATIN SMALL LETTER T WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x007a, 0, 0, 0}, 0x01b6 }, // U01B6 # LATIN SMALL LETTER Z WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0294, 0, 0, 0}, 0x02a1 }, // U02A1 # LATIN LETTER GLOTTAL STOP WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0338, 0, 0, 0}, 0x2260 }, // U2260 # NOT EQUAL TO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0413, 0, 0, 0}, 0x0492 }, // U0492 # CYRILLIC CAPITAL LETTER GHE WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x041a, 0, 0, 0}, 0x049e }, // U049E # CYRILLIC CAPITAL LETTER KA WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x0433, 0, 0, 0}, 0x0493 }, // U0493 # CYRILLIC SMALL LETTER GHE WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x043a, 0, 0, 0}, 0x049f }, // U049F # CYRILLIC SMALL LETTER KA WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x04ae, 0, 0, 0}, 0x04b0 }, // U04B0 # CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x04af, 0, 0, 0}, 0x04b1 }, // U04B1 # CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x2190, 0, 0, 0}, 0x219a }, // U219A # LEFTWARDS ARROW WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x2192, 0, 0, 0}, 0x219b }, // U219B # RIGHTWARDS ARROW WITH STROKE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0000, 0x2194, 0, 0, 0}, 0x21ae }, // U21AE # LEFT RIGHT ARROW WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x0020, 0, 0, 0}, 0x00a0 }, // nobreakspace # NO-BREAK SPACE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x0027, 0, 0, 0}, 0x0027 }, // apostrophe
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x002c, 0, 0, 0}, 0x00b8 }, // cedilla
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x002d, 0, 0, 0}, 0x007e }, // asciitilde
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x002e, 0, 0, 0}, 0x2008 }, // U2008 # PUNCTUATION SPACE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x003e, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x005e, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x0060, 0, 0, 0}, 0x0060 }, // grave
+    { {UNITIZE(Qt::Key_Multi_key), 0x0020, 0x007e, 0, 0, 0}, 0x007e }, // asciitilde
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0000, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0000, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0000, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0000, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0021, 0, 0, 0}, 0x00a1 }, // exclamdown
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x002b, 0x004f, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x002b, 0x0055, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x002b, 0x006f, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x002b, 0x0075, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0041, 0, 0, 0}, 0x1ea0 }, // U1EA0 # LATIN CAPITAL LETTER A WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0042, 0, 0, 0}, 0x1e04 }, // U1E04 # LATIN CAPITAL LETTER B WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0044, 0, 0, 0}, 0x1e0c }, // U1E0C # LATIN CAPITAL LETTER D WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0045, 0, 0, 0}, 0x1eb8 }, // U1EB8 # LATIN CAPITAL LETTER E WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0048, 0, 0, 0}, 0x1e24 }, // U1E24 # LATIN CAPITAL LETTER H WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0049, 0, 0, 0}, 0x1eca }, // U1ECA # LATIN CAPITAL LETTER I WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004b, 0, 0, 0}, 0x1e32 }, // U1E32 # LATIN CAPITAL LETTER K WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004c, 0, 0, 0}, 0x1e36 }, // U1E36 # LATIN CAPITAL LETTER L WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004d, 0, 0, 0}, 0x1e42 }, // U1E42 # LATIN CAPITAL LETTER M WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004e, 0, 0, 0}, 0x1e46 }, // U1E46 # LATIN CAPITAL LETTER N WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004f, 0, 0, 0}, 0x1ecc }, // U1ECC # LATIN CAPITAL LETTER O WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0052, 0, 0, 0}, 0x1e5a }, // U1E5A # LATIN CAPITAL LETTER R WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0053, 0, 0, 0}, 0x1e62 }, // U1E62 # LATIN CAPITAL LETTER S WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0054, 0, 0, 0}, 0x1e6c }, // U1E6C # LATIN CAPITAL LETTER T WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0055, 0, 0, 0}, 0x1ee4 }, // U1EE4 # LATIN CAPITAL LETTER U WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0056, 0, 0, 0}, 0x1e7e }, // U1E7E # LATIN CAPITAL LETTER V WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0057, 0, 0, 0}, 0x1e88 }, // U1E88 # LATIN CAPITAL LETTER W WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0059, 0, 0, 0}, 0x1ef4 }, // U1EF4 # LATIN CAPITAL LETTER Y WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x005a, 0, 0, 0}, 0x1e92 }, // U1E92 # LATIN CAPITAL LETTER Z WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x005e, 0, 0, 0}, 0x00a6 }, // brokenbar
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0061, 0, 0, 0}, 0x1ea1 }, // U1EA1 # LATIN SMALL LETTER A WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0062, 0, 0, 0}, 0x1e05 }, // U1E05 # LATIN SMALL LETTER B WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0064, 0, 0, 0}, 0x1e0d }, // U1E0D # LATIN SMALL LETTER D WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0065, 0, 0, 0}, 0x1eb9 }, // U1EB9 # LATIN SMALL LETTER E WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0068, 0, 0, 0}, 0x1e25 }, // U1E25 # LATIN SMALL LETTER H WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0069, 0, 0, 0}, 0x1ecb }, // U1ECB # LATIN SMALL LETTER I WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006b, 0, 0, 0}, 0x1e33 }, // U1E33 # LATIN SMALL LETTER K WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006c, 0, 0, 0}, 0x1e37 }, // U1E37 # LATIN SMALL LETTER L WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006d, 0, 0, 0}, 0x1e43 }, // U1E43 # LATIN SMALL LETTER M WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006e, 0, 0, 0}, 0x1e47 }, // U1E47 # LATIN SMALL LETTER N WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006f, 0, 0, 0}, 0x1ecd }, // U1ECD # LATIN SMALL LETTER O WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0072, 0, 0, 0}, 0x1e5b }, // U1E5B # LATIN SMALL LETTER R WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0073, 0, 0, 0}, 0x1e63 }, // U1E63 # LATIN SMALL LETTER S WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0074, 0, 0, 0}, 0x1e6d }, // U1E6D # LATIN SMALL LETTER T WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0075, 0, 0, 0}, 0x1ee5 }, // U1EE5 # LATIN SMALL LETTER U WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0076, 0, 0, 0}, 0x1e7f }, // U1E7F # LATIN SMALL LETTER V WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0077, 0, 0, 0}, 0x1e89 }, // U1E89 # LATIN SMALL LETTER W WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0079, 0, 0, 0}, 0x1ef5 }, // U1EF5 # LATIN SMALL LETTER Y WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, 0x007a, 0, 0, 0}, 0x1e93 }, // U1E93 # LATIN SMALL LETTER Z WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0021, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0000, 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0000, 0x004f, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0000, 0x006f, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0027, 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x002c, 0, 0, 0}, 0x201e }, // U201e # DOUBLE LOW-9 QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x002f, 0, 0, 0}, 0x301e }, // U301e # DOUBLE PRIME QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x003c, 0, 0, 0}, 0x201c }, // U201c # LEFT DOUBLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x003e, 0, 0, 0}, 0x201d }, // U201d # RIGHT DOUBLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0041, 0, 0, 0}, 0x00c4 }, // U00C4 # LATIN CAPITAL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0045, 0, 0, 0}, 0x00cb }, // U00CB # LATIN CAPITAL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0048, 0, 0, 0}, 0x1e26 }, // U1E26 # LATIN CAPITAL LETTER H WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0049, 0, 0, 0}, 0x00cf }, // U00CF # LATIN CAPITAL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x004f, 0, 0, 0}, 0x00d6 }, // U00D6 # LATIN CAPITAL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0, 0}, 0x00dc }, // U00DC # LATIN CAPITAL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0057, 0, 0, 0}, 0x1e84 }, // U1E84 # LATIN CAPITAL LETTER W WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0058, 0, 0, 0}, 0x1e8c }, // U1E8C # LATIN CAPITAL LETTER X WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0059, 0, 0, 0}, 0x0178 }, // U0178 # LATIN CAPITAL LETTER Y WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x005c, 0, 0, 0}, 0x301d }, // U301d # REVERSED DOUBLE PRIME QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x005f, 0x0055, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x005f, 0x0075, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0061, 0, 0, 0}, 0x00e4 }, // U00E4 # LATIN SMALL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0065, 0, 0, 0}, 0x00eb }, // U00EB # LATIN SMALL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0068, 0, 0, 0}, 0x1e27 }, // U1E27 # LATIN SMALL LETTER H WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0069, 0, 0, 0}, 0x00ef }, // U00EF # LATIN SMALL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x006f, 0, 0, 0}, 0x00f6 }, // U00F6 # LATIN SMALL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0074, 0, 0, 0}, 0x1e97 }, // U1E97 # LATIN SMALL LETTER T WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0, 0}, 0x00fc }, // U00FC # LATIN SMALL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0077, 0, 0, 0}, 0x1e85 }, // U1E85 # LATIN SMALL LETTER W WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0078, 0, 0, 0}, 0x1e8d }, // U1E8D # LATIN SMALL LETTER X WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0079, 0, 0, 0}, 0x00ff }, // U00FF # LATIN SMALL LETTER Y WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x007e, 0x004f, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x007e, 0x006f, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x00af, 0x0055, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x00af, 0x0075, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x00b4, 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x00d5, 0, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x00f5, 0, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x016a, 0, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x016b, 0, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0399, 0, 0, 0}, 0x03aa }, // U03AA # GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03a5, 0, 0, 0}, 0x03ab }, // U03AB # GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0, 0}, 0x03ca }, // U03CA # GREEK SMALL LETTER IOTA WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0, 0}, 0x03cb }, // U03CB # GREEK SMALL LETTER UPSILON WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03d2, 0, 0, 0}, 0x03d4 }, // U03D4 # GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0406, 0, 0, 0}, 0x0407 }, // U0407 # CYRILLIC CAPITAL LETTER YI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0410, 0, 0, 0}, 0x04d2 }, // U04D2 # CYRILLIC CAPITAL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0415, 0, 0, 0}, 0x0401 }, // U0401 # CYRILLIC CAPITAL LETTER IO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0416, 0, 0, 0}, 0x04dc }, // U04DC # CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0417, 0, 0, 0}, 0x04de }, // U04DE # CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0418, 0, 0, 0}, 0x04e4 }, // U04E4 # CYRILLIC CAPITAL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x041e, 0, 0, 0}, 0x04e6 }, // U04E6 # CYRILLIC CAPITAL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0423, 0, 0, 0}, 0x04f0 }, // U04F0 # CYRILLIC CAPITAL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0427, 0, 0, 0}, 0x04f4 }, // U04F4 # CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x042b, 0, 0, 0}, 0x04f8 }, // U04F8 # CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x042d, 0, 0, 0}, 0x04ec }, // U04EC # CYRILLIC CAPITAL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0430, 0, 0, 0}, 0x04d3 }, // U04D3 # CYRILLIC SMALL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0435, 0, 0, 0}, 0x0451 }, // U0451 # CYRILLIC SMALL LETTER IO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0436, 0, 0, 0}, 0x04dd }, // U04DD # CYRILLIC SMALL LETTER ZHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0437, 0, 0, 0}, 0x04df }, // U04DF # CYRILLIC SMALL LETTER ZE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0438, 0, 0, 0}, 0x04e5 }, // U04E5 # CYRILLIC SMALL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x043e, 0, 0, 0}, 0x04e7 }, // U04E7 # CYRILLIC SMALL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0443, 0, 0, 0}, 0x04f1 }, // U04F1 # CYRILLIC SMALL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0447, 0, 0, 0}, 0x04f5 }, // U04F5 # CYRILLIC SMALL LETTER CHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x044b, 0, 0, 0}, 0x04f9 }, // U04F9 # CYRILLIC SMALL LETTER YERU WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x044d, 0, 0, 0}, 0x04ed }, // U04ED # CYRILLIC SMALL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0456, 0, 0, 0}, 0x0457 }, // U0457 # CYRILLIC SMALL LETTER YI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x04d8, 0, 0, 0}, 0x04da }, // U04DA # CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x04d9, 0, 0, 0}, 0x04db }, // U04DB # CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x04e8, 0, 0, 0}, 0x04ea }, // U04EA # CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, 0x04e9, 0, 0, 0}, 0x04eb }, // U04EB # CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, UNITIZE(Qt::Key_Dead_Acute), 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, UNITIZE(Qt::Key_Dead_Macron), 0x0055, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0022, UNITIZE(Qt::Key_Dead_Macron), 0x0075, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0023, 0x0023, 0, 0, 0}, 0x266f }, // U266f # MUSIC SHARP SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0023, 0x0062, 0, 0, 0}, 0x266d }, // U266d # MUSIC FLAT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0023, 0x0066, 0, 0, 0}, 0x266e }, // U266e # MUSIC NATURAL SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0025, 0x006f, 0, 0, 0}, 0x2030 }, // U2030 # PER MILLE SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0000, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0020, 0, 0, 0}, 0x0027 }, // apostrophe
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0022, 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002b, 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002b, 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002b, 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002b, 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002c, 0, 0, 0}, 0x201a }, // U201a # SINGLE LOW-9 QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002c, 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002c, 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002f, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x002f, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x003c, 0, 0, 0}, 0x2018 }, // U2018 # LEFT SINGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x003e, 0, 0, 0}, 0x2019 }, // U2019 # RIGHT SINGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0041, 0, 0, 0}, 0x00c1 }, // U00C1 # LATIN CAPITAL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0043, 0, 0, 0}, 0x0106 }, // U0106 # LATIN CAPITAL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0045, 0, 0, 0}, 0x00c9 }, // U00C9 # LATIN CAPITAL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0047, 0, 0, 0}, 0x01f4 }, // U01F4 # LATIN CAPITAL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0049, 0, 0, 0}, 0x00cd }, // U00CD # LATIN CAPITAL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x004b, 0, 0, 0}, 0x1e30 }, // U1E30 # LATIN CAPITAL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x004c, 0, 0, 0}, 0x0139 }, // U0139 # LATIN CAPITAL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x004d, 0, 0, 0}, 0x1e3e }, // U1E3E # LATIN CAPITAL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x004e, 0, 0, 0}, 0x0143 }, // U0143 # LATIN CAPITAL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x004f, 0, 0, 0}, 0x00d3 }, // U00D3 # LATIN CAPITAL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0050, 0, 0, 0}, 0x1e54 }, // U1E54 # LATIN CAPITAL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0052, 0, 0, 0}, 0x0154 }, // U0154 # LATIN CAPITAL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0053, 0, 0, 0}, 0x015a }, // U015A # LATIN CAPITAL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0055, 0, 0, 0}, 0x00da }, // U00DA # LATIN CAPITAL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0055, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0055, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0057, 0, 0, 0}, 0x1e82 }, // U1E82 # LATIN CAPITAL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0059, 0, 0, 0}, 0x00dd }, // U00DD # LATIN CAPITAL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005a, 0, 0, 0}, 0x0179 }, // U0179 # LATIN CAPITAL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005e, 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005f, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005f, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005f, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x005f, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0061, 0, 0, 0}, 0x00e1 }, // U00E1 # LATIN SMALL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0062, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0062, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0063, 0, 0, 0}, 0x0107 }, // U0107 # LATIN SMALL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0065, 0, 0, 0}, 0x00e9 }, // U00E9 # LATIN SMALL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0067, 0, 0, 0}, 0x01f5 }, // U01F5 # LATIN SMALL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0069, 0, 0, 0}, 0x00ed }, // U00ED # LATIN SMALL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x006b, 0, 0, 0}, 0x1e31 }, // U1E31 # LATIN SMALL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x006c, 0, 0, 0}, 0x013a }, // U013A # LATIN SMALL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x006d, 0, 0, 0}, 0x1e3f }, // U1E3F # LATIN SMALL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x006e, 0, 0, 0}, 0x0144 }, // U0144 # LATIN SMALL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x006f, 0, 0, 0}, 0x00f3 }, // U00F3 # LATIN SMALL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0070, 0, 0, 0}, 0x1e55 }, // U1E55 # LATIN SMALL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0072, 0, 0, 0}, 0x0155 }, // U0155 # LATIN SMALL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0073, 0, 0, 0}, 0x015b }, // U015B # LATIN SMALL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0075, 0, 0, 0}, 0x00fa }, // U00FA # LATIN SMALL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0077, 0, 0, 0}, 0x1e83 }, // U1E83 # LATIN SMALL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0079, 0, 0, 0}, 0x00fd }, // U00FD # LATIN SMALL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x007a, 0, 0, 0}, 0x017a }, // U017A # LATIN SMALL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x007e, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x007e, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x007e, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x007e, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00af, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00af, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00af, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00af, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00c2, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00c5, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00c6, 0, 0, 0}, 0x01fc }, // U01FC # LATIN CAPITAL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00c7, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00ca, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00cf, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00d4, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00d5, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00d8, 0, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00dc, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00e2, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00e5, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00e6, 0, 0, 0}, 0x01fd }, // U01FD # LATIN SMALL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00e7, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00ea, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00ef, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00f4, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00f5, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00f8, 0, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x00fc, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0102, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0103, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0112, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0113, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x014c, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x014d, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0168, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0169, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0391, 0, 0, 0}, 0x0386 }, // U0386 # GREEK CAPITAL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0395, 0, 0, 0}, 0x0388 }, // U0388 # GREEK CAPITAL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0397, 0, 0, 0}, 0x0389 }, // U0389 # GREEK CAPITAL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0399, 0, 0, 0}, 0x038a }, // U038A # GREEK CAPITAL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x039f, 0, 0, 0}, 0x038c }, // U038C # GREEK CAPITAL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03a5, 0, 0, 0}, 0x038e }, // U038E # GREEK CAPITAL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03a9, 0, 0, 0}, 0x038f }, // U038F # GREEK CAPITAL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b1, 0, 0, 0}, 0x03ac }, // U03AC # GREEK SMALL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b5, 0, 0, 0}, 0x03ad }, // U03AD # GREEK SMALL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b7, 0, 0, 0}, 0x03ae }, // U03AE # GREEK SMALL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b9, 0, 0, 0}, 0x03af }, // U03AF # GREEK SMALL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03bf, 0, 0, 0}, 0x03cc }, // U03CC # GREEK SMALL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03c5, 0, 0, 0}, 0x03cd }, // U03CD # GREEK SMALL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03c9, 0, 0, 0}, 0x03ce }, // U03CE # GREEK SMALL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03ca, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03cb, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03d2, 0, 0, 0}, 0x03d3 }, // U03D3 # GREEK UPSILON WITH ACUTE AND HOOK SYMBOL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0413, 0, 0, 0}, 0x0403 }, // U0403 # CYRILLIC CAPITAL LETTER GJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x041a, 0, 0, 0}, 0x040c }, // U040C # CYRILLIC CAPITAL LETTER KJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0433, 0, 0, 0}, 0x0453 }, // U0453 # CYRILLIC SMALL LETTER GJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x043a, 0, 0, 0}, 0x045c }, // U045C # CYRILLIC SMALL LETTER KJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f00, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f01, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f08, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f09, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f10, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f11, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f18, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f19, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f20, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f21, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f28, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f29, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f30, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f31, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f38, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f39, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f40, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f41, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f48, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f49, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f50, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f51, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f59, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f60, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f61, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f68, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f69, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Tilde), 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Tilde), 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Abovering), 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Abovering), 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Cedilla), 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Cedilla), 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0027, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b2 }, // U32B2 # CIRCLED NUMBER THIRTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246d }, // U246D # CIRCLED NUMBER FOURTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32be }, // U32BE # CIRCLED NUMBER FORTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2470 }, // U2470 # CIRCLED NUMBER SEVENTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32bc }, // U32BC # CIRCLED NUMBER FORTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246f }, // U246F # CIRCLED NUMBER SIXTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32bb }, // U32BB # CIRCLED NUMBER FORTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b3 }, // U32B3 # CIRCLED NUMBER THIRTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b6 }, // U32B6 # CIRCLED NUMBER FORTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2469 }, // U2469 # CIRCLED NUMBER TEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325f }, // U325F # CIRCLED NUMBER THIRTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325e }, // U325E # CIRCLED NUMBER THIRTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b8 }, // U32B8 # CIRCLED NUMBER FORTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b1 }, // U32B1 # CIRCLED NUMBER THIRTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325d }, // U325D # CIRCLED NUMBER THIRTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2471 }, // U2471 # CIRCLED NUMBER EIGHTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325b }, // U325B # CIRCLED NUMBER THIRTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x2472 }, // U2472 # CIRCLED NUMBER NINETEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246c }, // U246C # CIRCLED NUMBER THIRTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b9 }, // U32B9 # CIRCLED NUMBER FORTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32ba }, // U32BA # CIRCLED NUMBER FORTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x325a }, // U325A # CIRCLED NUMBER THIRTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b5 }, // U32B5 # CIRCLED NUMBER FORTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32b4 }, // U32B4 # CIRCLED NUMBER THIRTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246a }, // U246A # CIRCLED NUMBER ELEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x246e }, // U246E # CIRCLED NUMBER FIFTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32bd }, // U32BD # CIRCLED NUMBER FORTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0000, 0x0029, 0}, 0x32bf }, // U32BF # CIRCLED NUMBER FIFTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2461 }, // U2461 # CIRCLED DIGIT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2461 }, // U2461 # CIRCLED DIGIT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2462 }, // U2462 # CIRCLED DIGIT THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2468 }, // U2468 # CIRCLED DIGIT NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2463 }, // U2463 # CIRCLED DIGIT FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2460 }, // U2460 # CIRCLED DIGIT ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2467 }, // U2467 # CIRCLED DIGIT EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x24ea }, // U24EA # CIRCLED DIGIT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2466 }, // U2466 # CIRCLED DIGIT SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2465 }, // U2465 # CIRCLED DIGIT SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0029, 0, 0}, 0x2464 }, // U2464 # CIRCLED DIGIT FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x32b5 }, // U32B5 # CIRCLED NUMBER FORTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x2469 }, // U2469 # CIRCLED NUMBER TEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x32bf }, // U32BF # CIRCLED NUMBER FIFTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x325a }, // U325A # CIRCLED NUMBER THIRTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0030, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0031, 0x0029, 0}, 0x32b6 }, // U32B6 # CIRCLED NUMBER FORTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0031, 0x0029, 0}, 0x246a }, // U246A # CIRCLED NUMBER ELEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0031, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0031, 0x0029, 0}, 0x325b }, // U325B # CIRCLED NUMBER THIRTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0031, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0032, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0032, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0032, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0032, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0032, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0033, 0x0029, 0}, 0x246c }, // U246C # CIRCLED NUMBER THIRTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0033, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0033, 0x0029, 0}, 0x325d }, // U325D # CIRCLED NUMBER THIRTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0033, 0x0029, 0}, 0x32b8 }, // U32B8 # CIRCLED NUMBER FORTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0033, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0034, 0x0029, 0}, 0x246d }, // U246D # CIRCLED NUMBER FOURTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0034, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0034, 0x0029, 0}, 0x32b9 }, // U32B9 # CIRCLED NUMBER FORTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0034, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0034, 0x0029, 0}, 0x325e }, // U325E # CIRCLED NUMBER THIRTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0035, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0035, 0x0029, 0}, 0x325f }, // U325F # CIRCLED NUMBER THIRTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0035, 0x0029, 0}, 0x32ba }, // U32BA # CIRCLED NUMBER FORTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0035, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0035, 0x0029, 0}, 0x246e }, // U246E # CIRCLED NUMBER FIFTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0036, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0036, 0x0029, 0}, 0x32bb }, // U32BB # CIRCLED NUMBER FORTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0036, 0x0029, 0}, 0x32b1 }, // U32B1 # CIRCLED NUMBER THIRTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0036, 0x0029, 0}, 0x246f }, // U246F # CIRCLED NUMBER SIXTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0036, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0037, 0x0029, 0}, 0x32bc }, // U32BC # CIRCLED NUMBER FORTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0037, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0037, 0x0029, 0}, 0x32b2 }, // U32B2 # CIRCLED NUMBER THIRTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0037, 0x0029, 0}, 0x2470 }, // U2470 # CIRCLED NUMBER SEVENTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0037, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0038, 0x0029, 0}, 0x2471 }, // U2471 # CIRCLED NUMBER EIGHTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0038, 0x0029, 0}, 0x32b3 }, // U32B3 # CIRCLED NUMBER THIRTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0038, 0x0029, 0}, 0x32bd }, // U32BD # CIRCLED NUMBER FORTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0038, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0038, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0039, 0x0029, 0}, 0x32b4 }, // U32B4 # CIRCLED NUMBER THIRTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0039, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0039, 0x0029, 0}, 0x32be }, // U32BE # CIRCLED NUMBER FORTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0039, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0000, 0x0039, 0x0029, 0}, 0x2472 }, // U2472 # CIRCLED NUMBER NINETEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0028, 0, 0, 0}, 0x005b }, // bracketleft
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x002d, 0, 0, 0}, 0x007b }, // braceleft
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0030, 0x0029, 0, 0}, 0x24ea }, // U24EA # CIRCLED DIGIT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x2472 }, // U2472 # CIRCLED NUMBER NINETEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246e }, // U246E # CIRCLED NUMBER FIFTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x2469 }, // U2469 # CIRCLED NUMBER TEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246c }, // U246C # CIRCLED NUMBER THIRTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x2470 }, // U2470 # CIRCLED NUMBER SEVENTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246a }, // U246A # CIRCLED NUMBER ELEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246d }, // U246D # CIRCLED NUMBER FOURTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x2471 }, // U2471 # CIRCLED NUMBER EIGHTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246f }, // U246F # CIRCLED NUMBER SIXTEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0000, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0029, 0, 0}, 0x2460 }, // U2460 # CIRCLED DIGIT ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0030, 0x0029, 0}, 0x2469 }, // U2469 # CIRCLED NUMBER TEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0031, 0x0029, 0}, 0x246a }, // U246A # CIRCLED NUMBER ELEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0032, 0x0029, 0}, 0x246b }, // U246B # CIRCLED NUMBER TWELVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0033, 0x0029, 0}, 0x246c }, // U246C # CIRCLED NUMBER THIRTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0034, 0x0029, 0}, 0x246d }, // U246D # CIRCLED NUMBER FOURTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0035, 0x0029, 0}, 0x246e }, // U246E # CIRCLED NUMBER FIFTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0036, 0x0029, 0}, 0x246f }, // U246F # CIRCLED NUMBER SIXTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0037, 0x0029, 0}, 0x2470 }, // U2470 # CIRCLED NUMBER SEVENTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0038, 0x0029, 0}, 0x2471 }, // U2471 # CIRCLED NUMBER EIGHTEEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0031, 0x0039, 0x0029, 0}, 0x2472 }, // U2472 # CIRCLED NUMBER NINETEEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0000, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0029, 0, 0}, 0x2461 }, // U2461 # CIRCLED DIGIT TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0030, 0x0029, 0}, 0x2473 }, // U2473 # CIRCLED NUMBER TWENTY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0031, 0x0029, 0}, 0x3251 }, // U3251 # CIRCLED NUMBER TWENTY ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0032, 0x0029, 0}, 0x3252 }, // U3252 # CIRCLED NUMBER TWENTY TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0033, 0x0029, 0}, 0x3253 }, // U3253 # CIRCLED NUMBER TWENTY THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0034, 0x0029, 0}, 0x3254 }, // U3254 # CIRCLED NUMBER TWENTY FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0035, 0x0029, 0}, 0x3255 }, // U3255 # CIRCLED NUMBER TWENTY FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0036, 0x0029, 0}, 0x3256 }, // U3256 # CIRCLED NUMBER TWENTY SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0037, 0x0029, 0}, 0x3257 }, // U3257 # CIRCLED NUMBER TWENTY SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0038, 0x0029, 0}, 0x3258 }, // U3258 # CIRCLED NUMBER TWENTY EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0032, 0x0039, 0x0029, 0}, 0x3259 }, // U3259 # CIRCLED NUMBER TWENTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x32b4 }, // U32B4 # CIRCLED NUMBER THIRTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325a }, // U325A # CIRCLED NUMBER THIRTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325b }, // U325B # CIRCLED NUMBER THIRTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x32b3 }, // U32B3 # CIRCLED NUMBER THIRTY EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x32b2 }, // U32B2 # CIRCLED NUMBER THIRTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325f }, // U325F # CIRCLED NUMBER THIRTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325e }, // U325E # CIRCLED NUMBER THIRTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x32b1 }, // U32B1 # CIRCLED NUMBER THIRTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0000, 0x0029, 0}, 0x325d }, // U325D # CIRCLED NUMBER THIRTY THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0029, 0, 0}, 0x2462 }, // U2462 # CIRCLED DIGIT THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0030, 0x0029, 0}, 0x325a }, // U325A # CIRCLED NUMBER THIRTY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0031, 0x0029, 0}, 0x325b }, // U325B # CIRCLED NUMBER THIRTY ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0032, 0x0029, 0}, 0x325c }, // U325C # CIRCLED NUMBER THIRTY TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0033, 0x0029, 0}, 0x325d }, // U325D # CIRCLED NUMBER THIRTY THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0034, 0x0029, 0}, 0x325e }, // U325E # CIRCLED NUMBER THIRTY FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0035, 0x0029, 0}, 0x325f }, // U325F # CIRCLED NUMBER THIRTY FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0036, 0x0029, 0}, 0x32b1 }, // U32B1 # CIRCLED NUMBER THIRTY SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0037, 0x0029, 0}, 0x32b2 }, // U32B2 # CIRCLED NUMBER THIRTY SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0038, 0x0029, 0}, 0x32b3 }, // U32B3 # CIRCLED NUMBER THIRTY EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0033, 0x0039, 0x0029, 0}, 0x32b4 }, // U32B4 # CIRCLED NUMBER THIRTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b5 }, // U32B5 # CIRCLED NUMBER FORTY
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b6 }, // U32B6 # CIRCLED NUMBER FORTY ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32bc }, // U32BC # CIRCLED NUMBER FORTY SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b9 }, // U32B9 # CIRCLED NUMBER FORTY FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32b8 }, // U32B8 # CIRCLED NUMBER FORTY THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32bb }, // U32BB # CIRCLED NUMBER FORTY SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32be }, // U32BE # CIRCLED NUMBER FORTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32ba }, // U32BA # CIRCLED NUMBER FORTY FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0000, 0x0029, 0}, 0x32bd }, // U32BD # CIRCLED NUMBER FORTY EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0029, 0, 0}, 0x2463 }, // U2463 # CIRCLED DIGIT FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0030, 0x0029, 0}, 0x32b5 }, // U32B5 # CIRCLED NUMBER FORTY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0031, 0x0029, 0}, 0x32b6 }, // U32B6 # CIRCLED NUMBER FORTY ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0032, 0x0029, 0}, 0x32b7 }, // U32B7 # CIRCLED NUMBER FORTY TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0033, 0x0029, 0}, 0x32b8 }, // U32B8 # CIRCLED NUMBER FORTY THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0034, 0x0029, 0}, 0x32b9 }, // U32B9 # CIRCLED NUMBER FORTY FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0035, 0x0029, 0}, 0x32ba }, // U32BA # CIRCLED NUMBER FORTY FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0036, 0x0029, 0}, 0x32bb }, // U32BB # CIRCLED NUMBER FORTY SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0037, 0x0029, 0}, 0x32bc }, // U32BC # CIRCLED NUMBER FORTY SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0038, 0x0029, 0}, 0x32bd }, // U32BD # CIRCLED NUMBER FORTY EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0034, 0x0039, 0x0029, 0}, 0x32be }, // U32BE # CIRCLED NUMBER FORTY NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0035, 0x0000, 0x0029, 0}, 0x32bf }, // U32BF # CIRCLED NUMBER FIFTY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0035, 0x0029, 0, 0}, 0x2464 }, // U2464 # CIRCLED DIGIT FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0035, 0x0030, 0x0029, 0}, 0x32bf }, // U32BF # CIRCLED NUMBER FIFTY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0036, 0x0029, 0, 0}, 0x2465 }, // U2465 # CIRCLED DIGIT SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0037, 0x0029, 0, 0}, 0x2466 }, // U2466 # CIRCLED DIGIT SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0038, 0x0029, 0, 0}, 0x2467 }, // U2467 # CIRCLED DIGIT EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0039, 0x0029, 0, 0}, 0x2468 }, // U2468 # CIRCLED DIGIT NINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0041, 0x0029, 0, 0}, 0x24b6 }, // U24B6 # CIRCLED LATIN CAPITAL LETTER A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0042, 0x0029, 0, 0}, 0x24b7 }, // U24B7 # CIRCLED LATIN CAPITAL LETTER B
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0043, 0x0029, 0, 0}, 0x24b8 }, // U24B8 # CIRCLED LATIN CAPITAL LETTER C
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0044, 0x0029, 0, 0}, 0x24b9 }, // U24B9 # CIRCLED LATIN CAPITAL LETTER D
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0045, 0x0029, 0, 0}, 0x24ba }, // U24BA # CIRCLED LATIN CAPITAL LETTER E
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0046, 0x0029, 0, 0}, 0x24bb }, // U24BB # CIRCLED LATIN CAPITAL LETTER F
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0047, 0x0029, 0, 0}, 0x24bc }, // U24BC # CIRCLED LATIN CAPITAL LETTER G
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0048, 0x0029, 0, 0}, 0x24bd }, // U24BD # CIRCLED LATIN CAPITAL LETTER H
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0049, 0x0029, 0, 0}, 0x24be }, // U24BE # CIRCLED LATIN CAPITAL LETTER I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004a, 0x0029, 0, 0}, 0x24bf }, // U24BF # CIRCLED LATIN CAPITAL LETTER J
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004b, 0x0029, 0, 0}, 0x24c0 }, // U24C0 # CIRCLED LATIN CAPITAL LETTER K
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004c, 0x0029, 0, 0}, 0x24c1 }, // U24C1 # CIRCLED LATIN CAPITAL LETTER L
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004d, 0x0029, 0, 0}, 0x24c2 }, // U24C2 # CIRCLED LATIN CAPITAL LETTER M
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004e, 0x0029, 0, 0}, 0x24c3 }, // U24C3 # CIRCLED LATIN CAPITAL LETTER N
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x004f, 0x0029, 0, 0}, 0x24c4 }, // U24C4 # CIRCLED LATIN CAPITAL LETTER O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0050, 0x0029, 0, 0}, 0x24c5 }, // U24C5 # CIRCLED LATIN CAPITAL LETTER P
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0051, 0x0029, 0, 0}, 0x24c6 }, // U24C6 # CIRCLED LATIN CAPITAL LETTER Q
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0052, 0x0029, 0, 0}, 0x24c7 }, // U24C7 # CIRCLED LATIN CAPITAL LETTER R
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0053, 0x0029, 0, 0}, 0x24c8 }, // U24C8 # CIRCLED LATIN CAPITAL LETTER S
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0054, 0x0029, 0, 0}, 0x24c9 }, // U24C9 # CIRCLED LATIN CAPITAL LETTER T
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0055, 0x0029, 0, 0}, 0x24ca }, // U24CA # CIRCLED LATIN CAPITAL LETTER U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0056, 0x0029, 0, 0}, 0x24cb }, // U24CB # CIRCLED LATIN CAPITAL LETTER V
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0057, 0x0029, 0, 0}, 0x24cc }, // U24CC # CIRCLED LATIN CAPITAL LETTER W
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0058, 0x0029, 0, 0}, 0x24cd }, // U24CD # CIRCLED LATIN CAPITAL LETTER X
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0059, 0x0029, 0, 0}, 0x24ce }, // U24CE # CIRCLED LATIN CAPITAL LETTER Y
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x005a, 0x0029, 0, 0}, 0x24cf }, // U24CF # CIRCLED LATIN CAPITAL LETTER Z
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0061, 0x0029, 0, 0}, 0x24d0 }, // U24D0 # CIRCLED LATIN SMALL LETTER A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0062, 0x0029, 0, 0}, 0x24d1 }, // U24D1 # CIRCLED LATIN SMALL LETTER B
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0063, 0x0029, 0, 0}, 0x24d2 }, // U24D2 # CIRCLED LATIN SMALL LETTER C
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0064, 0x0029, 0, 0}, 0x24d3 }, // U24D3 # CIRCLED LATIN SMALL LETTER D
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0065, 0x0029, 0, 0}, 0x24d4 }, // U24D4 # CIRCLED LATIN SMALL LETTER E
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0066, 0x0029, 0, 0}, 0x24d5 }, // U24D5 # CIRCLED LATIN SMALL LETTER F
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0067, 0x0029, 0, 0}, 0x24d6 }, // U24D6 # CIRCLED LATIN SMALL LETTER G
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0068, 0x0029, 0, 0}, 0x24d7 }, // U24D7 # CIRCLED LATIN SMALL LETTER H
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0069, 0x0029, 0, 0}, 0x24d8 }, // U24D8 # CIRCLED LATIN SMALL LETTER I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006a, 0x0029, 0, 0}, 0x24d9 }, // U24D9 # CIRCLED LATIN SMALL LETTER J
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006b, 0x0029, 0, 0}, 0x24da }, // U24DA # CIRCLED LATIN SMALL LETTER K
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006c, 0x0029, 0, 0}, 0x24db }, // U24DB # CIRCLED LATIN SMALL LETTER L
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006d, 0x0029, 0, 0}, 0x24dc }, // U24DC # CIRCLED LATIN SMALL LETTER M
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006e, 0x0029, 0, 0}, 0x24dd }, // U24DD # CIRCLED LATIN SMALL LETTER N
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x006f, 0x0029, 0, 0}, 0x24de }, // U24DE # CIRCLED LATIN SMALL LETTER O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0070, 0x0029, 0, 0}, 0x24df }, // U24DF # CIRCLED LATIN SMALL LETTER P
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0071, 0x0029, 0, 0}, 0x24e0 }, // U24E0 # CIRCLED LATIN SMALL LETTER Q
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0072, 0x0029, 0, 0}, 0x24e1 }, // U24E1 # CIRCLED LATIN SMALL LETTER R
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0073, 0x0029, 0, 0}, 0x24e2 }, // U24E2 # CIRCLED LATIN SMALL LETTER S
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0074, 0x0029, 0, 0}, 0x24e3 }, // U24E3 # CIRCLED LATIN SMALL LETTER T
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0075, 0x0029, 0, 0}, 0x24e4 }, // U24E4 # CIRCLED LATIN SMALL LETTER U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0076, 0x0029, 0, 0}, 0x24e5 }, // U24E5 # CIRCLED LATIN SMALL LETTER V
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0077, 0x0029, 0, 0}, 0x24e6 }, // U24E6 # CIRCLED LATIN SMALL LETTER W
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0078, 0x0029, 0, 0}, 0x24e7 }, // U24E7 # CIRCLED LATIN SMALL LETTER X
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0079, 0x0029, 0, 0}, 0x24e8 }, // U24E8 # CIRCLED LATIN SMALL LETTER Y
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x007a, 0x0029, 0, 0}, 0x24e9 }, // U24E9 # CIRCLED LATIN SMALL LETTER Z
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0, 0}, 0x1f09 }, // U1F09 # GREEK CAPITAL LETTER ALPHA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0395, 0, 0, 0}, 0x1f19 }, // U1F19 # GREEK CAPITAL LETTER EPSILON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0, 0}, 0x1f29 }, // U1F29 # GREEK CAPITAL LETTER ETA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0, 0}, 0x1f39 }, // U1F39 # GREEK CAPITAL LETTER IOTA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x039f, 0, 0, 0}, 0x1f49 }, // U1F49 # GREEK CAPITAL LETTER OMICRON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a1, 0, 0, 0}, 0x1fec }, // U1FEC # GREEK CAPITAL LETTER RHO WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0, 0}, 0x1f59 }, // U1F59 # GREEK CAPITAL LETTER UPSILON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0, 0}, 0x1f69 }, // U1F69 # GREEK CAPITAL LETTER OMEGA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0, 0}, 0x1f01 }, // U1F01 # GREEK SMALL LETTER ALPHA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b5, 0, 0, 0}, 0x1f11 }, // U1F11 # GREEK SMALL LETTER EPSILON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0, 0}, 0x1f21 }, // U1F21 # GREEK SMALL LETTER ETA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0, 0}, 0x1f31 }, // U1F31 # GREEK SMALL LETTER IOTA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03bf, 0, 0, 0}, 0x1f41 }, // U1F41 # GREEK SMALL LETTER OMICRON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c1, 0, 0, 0}, 0x1fe5 }, // U1FE5 # GREEK SMALL LETTER RHO WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0, 0}, 0x1f51 }, // U1F51 # GREEK SMALL LETTER UPSILON WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0, 0}, 0x1f61 }, // U1F61 # GREEK SMALL LETTER OMEGA WITH DASIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1100, 0x0029, 0, 0}, 0x3260 }, // U3260 # CIRCLED HANGUL KIYEOK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1100, 0x1161, 0x0029, 0}, 0x326e }, // U326E # CIRCLED HANGUL KIYEOK A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1102, 0x0029, 0, 0}, 0x3261 }, // U3261 # CIRCLED HANGUL NIEUN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1102, 0x1161, 0x0029, 0}, 0x326f }, // U326F # CIRCLED HANGUL NIEUN A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1103, 0x0029, 0, 0}, 0x3262 }, // U3262 # CIRCLED HANGUL TIKEUT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1103, 0x1161, 0x0029, 0}, 0x3270 }, // U3270 # CIRCLED HANGUL TIKEUT A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1105, 0x0029, 0, 0}, 0x3263 }, // U3263 # CIRCLED HANGUL RIEUL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1105, 0x1161, 0x0029, 0}, 0x3271 }, // U3271 # CIRCLED HANGUL RIEUL A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1106, 0x0029, 0, 0}, 0x3264 }, // U3264 # CIRCLED HANGUL MIEUM
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1106, 0x1161, 0x0029, 0}, 0x3272 }, // U3272 # CIRCLED HANGUL MIEUM A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1107, 0x0029, 0, 0}, 0x3265 }, // U3265 # CIRCLED HANGUL PIEUP
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1107, 0x1161, 0x0029, 0}, 0x3273 }, // U3273 # CIRCLED HANGUL PIEUP A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1109, 0x0029, 0, 0}, 0x3266 }, // U3266 # CIRCLED HANGUL SIOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1109, 0x1161, 0x0029, 0}, 0x3274 }, // U3274 # CIRCLED HANGUL SIOS A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110b, 0x0029, 0, 0}, 0x3267 }, // U3267 # CIRCLED HANGUL IEUNG
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110b, 0x1161, 0x0029, 0}, 0x3275 }, // U3275 # CIRCLED HANGUL IEUNG A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110c, 0x0029, 0, 0}, 0x3268 }, // U3268 # CIRCLED HANGUL CIEUC
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110c, 0x1161, 0x0029, 0}, 0x3276 }, // U3276 # CIRCLED HANGUL CIEUC A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110e, 0x0029, 0, 0}, 0x3269 }, // U3269 # CIRCLED HANGUL CHIEUCH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110e, 0x1161, 0x0029, 0}, 0x3277 }, // U3277 # CIRCLED HANGUL CHIEUCH A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110f, 0x0029, 0, 0}, 0x326a }, // U326A # CIRCLED HANGUL KHIEUKH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x110f, 0x1161, 0x0029, 0}, 0x3278 }, // U3278 # CIRCLED HANGUL KHIEUKH A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1110, 0x0029, 0, 0}, 0x326b }, // U326B # CIRCLED HANGUL THIEUTH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1110, 0x1161, 0x0029, 0}, 0x3279 }, // U3279 # CIRCLED HANGUL THIEUTH A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1111, 0x0029, 0, 0}, 0x326c }, // U326C # CIRCLED HANGUL PHIEUPH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1111, 0x1161, 0x0029, 0}, 0x327a }, // U327A # CIRCLED HANGUL PHIEUPH A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1112, 0x0029, 0, 0}, 0x326d }, // U326D # CIRCLED HANGUL HIEUH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x1112, 0x1161, 0x0029, 0}, 0x327b }, // U327B # CIRCLED HANGUL HIEUH A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30a2, 0x0029, 0, 0}, 0x32d0 }, // U32D0 # CIRCLED KATAKANA A
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30a4, 0x0029, 0, 0}, 0x32d1 }, // U32D1 # CIRCLED KATAKANA I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30a6, 0x0029, 0, 0}, 0x32d2 }, // U32D2 # CIRCLED KATAKANA U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30a8, 0x0029, 0, 0}, 0x32d3 }, // U32D3 # CIRCLED KATAKANA E
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30aa, 0x0029, 0, 0}, 0x32d4 }, // U32D4 # CIRCLED KATAKANA O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ab, 0x0029, 0, 0}, 0x32d5 }, // U32D5 # CIRCLED KATAKANA KA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ad, 0x0029, 0, 0}, 0x32d6 }, // U32D6 # CIRCLED KATAKANA KI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30af, 0x0029, 0, 0}, 0x32d7 }, // U32D7 # CIRCLED KATAKANA KU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30b1, 0x0029, 0, 0}, 0x32d8 }, // U32D8 # CIRCLED KATAKANA KE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30b3, 0x0029, 0, 0}, 0x32d9 }, // U32D9 # CIRCLED KATAKANA KO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30b5, 0x0029, 0, 0}, 0x32da }, // U32DA # CIRCLED KATAKANA SA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30b7, 0x0029, 0, 0}, 0x32db }, // U32DB # CIRCLED KATAKANA SI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30b9, 0x0029, 0, 0}, 0x32dc }, // U32DC # CIRCLED KATAKANA SU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30bb, 0x0029, 0, 0}, 0x32dd }, // U32DD # CIRCLED KATAKANA SE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30bd, 0x0029, 0, 0}, 0x32de }, // U32DE # CIRCLED KATAKANA SO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30bf, 0x0029, 0, 0}, 0x32df }, // U32DF # CIRCLED KATAKANA TA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30c1, 0x0029, 0, 0}, 0x32e0 }, // U32E0 # CIRCLED KATAKANA TI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30c4, 0x0029, 0, 0}, 0x32e1 }, // U32E1 # CIRCLED KATAKANA TU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30c6, 0x0029, 0, 0}, 0x32e2 }, // U32E2 # CIRCLED KATAKANA TE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30c8, 0x0029, 0, 0}, 0x32e3 }, // U32E3 # CIRCLED KATAKANA TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ca, 0x0029, 0, 0}, 0x32e4 }, // U32E4 # CIRCLED KATAKANA NA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30cb, 0x0029, 0, 0}, 0x32e5 }, // U32E5 # CIRCLED KATAKANA NI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30cc, 0x0029, 0, 0}, 0x32e6 }, // U32E6 # CIRCLED KATAKANA NU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30cd, 0x0029, 0, 0}, 0x32e7 }, // U32E7 # CIRCLED KATAKANA NE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ce, 0x0029, 0, 0}, 0x32e8 }, // U32E8 # CIRCLED KATAKANA NO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30cf, 0x0029, 0, 0}, 0x32e9 }, // U32E9 # CIRCLED KATAKANA HA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30d2, 0x0029, 0, 0}, 0x32ea }, // U32EA # CIRCLED KATAKANA HI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30d5, 0x0029, 0, 0}, 0x32eb }, // U32EB # CIRCLED KATAKANA HU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30d8, 0x0029, 0, 0}, 0x32ec }, // U32EC # CIRCLED KATAKANA HE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30db, 0x0029, 0, 0}, 0x32ed }, // U32ED # CIRCLED KATAKANA HO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30de, 0x0029, 0, 0}, 0x32ee }, // U32EE # CIRCLED KATAKANA MA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30df, 0x0029, 0, 0}, 0x32ef }, // U32EF # CIRCLED KATAKANA MI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e0, 0x0029, 0, 0}, 0x32f0 }, // U32F0 # CIRCLED KATAKANA MU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e1, 0x0029, 0, 0}, 0x32f1 }, // U32F1 # CIRCLED KATAKANA ME
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e2, 0x0029, 0, 0}, 0x32f2 }, // U32F2 # CIRCLED KATAKANA MO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e4, 0x0029, 0, 0}, 0x32f3 }, // U32F3 # CIRCLED KATAKANA YA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e6, 0x0029, 0, 0}, 0x32f4 }, // U32F4 # CIRCLED KATAKANA YU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e8, 0x0029, 0, 0}, 0x32f5 }, // U32F5 # CIRCLED KATAKANA YO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30e9, 0x0029, 0, 0}, 0x32f6 }, // U32F6 # CIRCLED KATAKANA RA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ea, 0x0029, 0, 0}, 0x32f7 }, // U32F7 # CIRCLED KATAKANA RI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30eb, 0x0029, 0, 0}, 0x32f8 }, // U32F8 # CIRCLED KATAKANA RU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ec, 0x0029, 0, 0}, 0x32f9 }, // U32F9 # CIRCLED KATAKANA RE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ed, 0x0029, 0, 0}, 0x32fa }, // U32FA # CIRCLED KATAKANA RO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30ef, 0x0029, 0, 0}, 0x32fb }, // U32FB # CIRCLED KATAKANA WA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30f0, 0x0029, 0, 0}, 0x32fc }, // U32FC # CIRCLED KATAKANA WI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30f1, 0x0029, 0, 0}, 0x32fd }, // U32FD # CIRCLED KATAKANA WE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x30f2, 0x0029, 0, 0}, 0x32fe }, // U32FE # CIRCLED KATAKANA WO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e00, 0x0029, 0, 0}, 0x3280 }, // U3280 # CIRCLED IDEOGRAPH ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e03, 0x0029, 0, 0}, 0x3286 }, // U3286 # CIRCLED IDEOGRAPH SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e09, 0x0029, 0, 0}, 0x3282 }, // U3282 # CIRCLED IDEOGRAPH THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e0a, 0x0029, 0, 0}, 0x32a4 }, // U32A4 # CIRCLED IDEOGRAPH HIGH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e0b, 0x0029, 0, 0}, 0x32a6 }, // U32A6 # CIRCLED IDEOGRAPH LOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e2d, 0x0029, 0, 0}, 0x32a5 }, // U32A5 # CIRCLED IDEOGRAPH CENTRE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e5d, 0x0029, 0, 0}, 0x3288 }, // U3288 # CIRCLED IDEOGRAPH NINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e8c, 0x0029, 0, 0}, 0x3281 }, // U3281 # CIRCLED IDEOGRAPH TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4e94, 0x0029, 0, 0}, 0x3284 }, // U3284 # CIRCLED IDEOGRAPH FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4f01, 0x0029, 0, 0}, 0x32ad }, // U32AD # CIRCLED IDEOGRAPH ENTERPRISE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x4f11, 0x0029, 0, 0}, 0x32a1 }, // U32A1 # CIRCLED IDEOGRAPH REST
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x512a, 0x0029, 0, 0}, 0x329d }, // U329D # CIRCLED IDEOGRAPH EXCELLENT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x516b, 0x0029, 0, 0}, 0x3287 }, // U3287 # CIRCLED IDEOGRAPH EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x516d, 0x0029, 0, 0}, 0x3285 }, // U3285 # CIRCLED IDEOGRAPH SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5199, 0x0029, 0, 0}, 0x32a2 }, // U32A2 # CIRCLED IDEOGRAPH COPY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x52b4, 0x0029, 0, 0}, 0x3298 }, // U3298 # CIRCLED IDEOGRAPH LABOR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x533b, 0x0029, 0, 0}, 0x32a9 }, // U32A9 # CIRCLED IDEOGRAPH MEDICINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5341, 0x0029, 0, 0}, 0x3289 }, // U3289 # CIRCLED IDEOGRAPH TEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5354, 0x0029, 0, 0}, 0x32af }, // U32AF # CIRCLED IDEOGRAPH ALLIANCE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5370, 0x0029, 0, 0}, 0x329e }, // U329E # CIRCLED IDEOGRAPH PRINT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x53f3, 0x0029, 0, 0}, 0x32a8 }, // U32A8 # CIRCLED IDEOGRAPH RIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x540d, 0x0029, 0, 0}, 0x3294 }, // U3294 # CIRCLED IDEOGRAPH NAME
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x56db, 0x0029, 0, 0}, 0x3283 }, // U3283 # CIRCLED IDEOGRAPH FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x571f, 0x0029, 0, 0}, 0x328f }, // U328F # CIRCLED IDEOGRAPH EARTH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x591c, 0x0029, 0, 0}, 0x32b0 }, // U32B0 # CIRCLED IDEOGRAPH NIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5973, 0x0029, 0, 0}, 0x329b }, // U329B # CIRCLED IDEOGRAPH FEMALE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5b66, 0x0029, 0, 0}, 0x32ab }, // U32AB # CIRCLED IDEOGRAPH STUDY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5b97, 0x0029, 0, 0}, 0x32aa }, // U32AA # CIRCLED IDEOGRAPH RELIGION
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x5de6, 0x0029, 0, 0}, 0x32a7 }, // U32A7 # CIRCLED IDEOGRAPH LEFT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x65e5, 0x0029, 0, 0}, 0x3290 }, // U3290 # CIRCLED IDEOGRAPH SUN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6708, 0x0029, 0, 0}, 0x328a }, // U328A # CIRCLED IDEOGRAPH MOON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6709, 0x0029, 0, 0}, 0x3292 }, // U3292 # CIRCLED IDEOGRAPH HAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6728, 0x0029, 0, 0}, 0x328d }, // U328D # CIRCLED IDEOGRAPH WOOD
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x682a, 0x0029, 0, 0}, 0x3291 }, // U3291 # CIRCLED IDEOGRAPH STOCK
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6b63, 0x0029, 0, 0}, 0x32a3 }, // U32A3 # CIRCLED IDEOGRAPH CORRECT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6c34, 0x0029, 0, 0}, 0x328c }, // U328C # CIRCLED IDEOGRAPH WATER
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x6ce8, 0x0029, 0, 0}, 0x329f }, // U329F # CIRCLED IDEOGRAPH ATTENTION
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x706b, 0x0029, 0, 0}, 0x328b }, // U328B # CIRCLED IDEOGRAPH FIRE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x7279, 0x0029, 0, 0}, 0x3295 }, // U3295 # CIRCLED IDEOGRAPH SPECIAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x7537, 0x0029, 0, 0}, 0x329a }, // U329A # CIRCLED IDEOGRAPH MALE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x76e3, 0x0029, 0, 0}, 0x32ac }, // U32AC # CIRCLED IDEOGRAPH SUPERVISE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x793e, 0x0029, 0, 0}, 0x3293 }, // U3293 # CIRCLED IDEOGRAPH SOCIETY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x795d, 0x0029, 0, 0}, 0x3297 }, // U3297 # CIRCLED IDEOGRAPH CONGRATULATION
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x79d8, 0x0029, 0, 0}, 0x3299 }, // U3299 # CIRCLED IDEOGRAPH SECRET
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x8ca1, 0x0029, 0, 0}, 0x3296 }, // U3296 # CIRCLED IDEOGRAPH FINANCIAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x8cc7, 0x0029, 0, 0}, 0x32ae }, // U32AE # CIRCLED IDEOGRAPH RESOURCE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x9069, 0x0029, 0, 0}, 0x329c }, // U329C # CIRCLED IDEOGRAPH SUITABLE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x91d1, 0x0029, 0, 0}, 0x328e }, // U328E # CIRCLED IDEOGRAPH METAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x0028, 0x9805, 0x0029, 0, 0}, 0x32a0 }, // U32A0 # CIRCLED IDEOGRAPH ITEM
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0029, 0, 0, 0}, 0x005d }, // bracketright
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x002d, 0, 0, 0}, 0x007d }, // braceright
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0, 0}, 0x1f08 }, // U1F08 # GREEK CAPITAL LETTER ALPHA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0395, 0, 0, 0}, 0x1f18 }, // U1F18 # GREEK CAPITAL LETTER EPSILON WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0, 0}, 0x1f28 }, // U1F28 # GREEK CAPITAL LETTER ETA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0, 0}, 0x1f38 }, // U1F38 # GREEK CAPITAL LETTER IOTA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x039f, 0, 0, 0}, 0x1f48 }, // U1F48 # GREEK CAPITAL LETTER OMICRON WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0, 0}, 0x1f68 }, // U1F68 # GREEK CAPITAL LETTER OMEGA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0, 0}, 0x1f00 }, // U1F00 # GREEK SMALL LETTER ALPHA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b5, 0, 0, 0}, 0x1f10 }, // U1F10 # GREEK SMALL LETTER EPSILON WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0, 0}, 0x1f20 }, // U1F20 # GREEK SMALL LETTER ETA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0, 0}, 0x1f30 }, // U1F30 # GREEK SMALL LETTER IOTA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03bf, 0, 0, 0}, 0x1f40 }, // U1F40 # GREEK SMALL LETTER OMICRON WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c1, 0, 0, 0}, 0x1fe4 }, // U1FE4 # GREEK SMALL LETTER RHO WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0, 0}, 0x1f50 }, // U1F50 # GREEK SMALL LETTER UPSILON WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0, 0}, 0x1f60 }, // U1F60 # GREEK SMALL LETTER OMEGA WITH PSILI
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x002b, 0, 0, 0}, 0x0023 }, // numbersign
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x002d, 0, 0, 0}, 0x00b1 }, // plusminus
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0, 0}, 0x01a0 }, // U01A0 # LATIN CAPITAL LETTER O WITH HORN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0, 0}, 0x01af }, // U01AF # LATIN CAPITAL LETTER U WITH HORN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0, 0}, 0x01a1 }, // U01A1 # LATIN SMALL LETTER O WITH HORN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0, 0}, 0x01b0 }, // U01B0 # LATIN SMALL LETTER U WITH HORN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0020, 0, 0, 0}, 0x00b8 }, // cedilla
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0022, 0, 0, 0}, 0x201e }, // U201e # DOUBLE LOW-9 QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0027, 0, 0, 0}, 0x201a }, // U201a # SINGLE LOW-9 QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x002d, 0, 0, 0}, 0x00ac }, // U00AC # NOT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0043, 0, 0, 0}, 0x00c7 }, // U00C7 # LATIN CAPITAL LETTER C WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0044, 0, 0, 0}, 0x1e10 }, // U1E10 # LATIN CAPITAL LETTER D WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0045, 0, 0, 0}, 0x0228 }, // U0228 # LATIN CAPITAL LETTER E WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0047, 0, 0, 0}, 0x0122 }, // U0122 # LATIN CAPITAL LETTER G WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0048, 0, 0, 0}, 0x1e28 }, // U1E28 # LATIN CAPITAL LETTER H WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x004b, 0, 0, 0}, 0x0136 }, // U0136 # LATIN CAPITAL LETTER K WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x004c, 0, 0, 0}, 0x013b }, // U013B # LATIN CAPITAL LETTER L WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x004e, 0, 0, 0}, 0x0145 }, // U0145 # LATIN CAPITAL LETTER N WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0052, 0, 0, 0}, 0x0156 }, // U0156 # LATIN CAPITAL LETTER R WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0053, 0, 0, 0}, 0x015e }, // U015E # LATIN CAPITAL LETTER S WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0054, 0, 0, 0}, 0x0162 }, // U0162 # LATIN CAPITAL LETTER T WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0063, 0, 0, 0}, 0x00e7 }, // U00E7 # LATIN SMALL LETTER C WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0064, 0, 0, 0}, 0x1e11 }, // U1E11 # LATIN SMALL LETTER D WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0065, 0, 0, 0}, 0x0229 }, // U0229 # LATIN SMALL LETTER E WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0067, 0, 0, 0}, 0x0123 }, // U0123 # LATIN SMALL LETTER G WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0068, 0, 0, 0}, 0x1e29 }, // U1E29 # LATIN SMALL LETTER H WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x006b, 0, 0, 0}, 0x0137 }, // U0137 # LATIN SMALL LETTER K WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x006c, 0, 0, 0}, 0x013c }, // U013C # LATIN SMALL LETTER L WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x006e, 0, 0, 0}, 0x0146 }, // U0146 # LATIN SMALL LETTER N WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0072, 0, 0, 0}, 0x0157 }, // U0157 # LATIN SMALL LETTER R WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0073, 0, 0, 0}, 0x015f }, // U015F # LATIN SMALL LETTER S WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0074, 0, 0, 0}, 0x0163 }, // U0163 # LATIN SMALL LETTER T WITH CEDILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x0020, 0, 0, 0}, 0x007e }, // asciitilde
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x0028, 0, 0, 0}, 0x007b }, // braceleft
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x0029, 0, 0, 0}, 0x007d }, // braceright
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x002c, 0, 0, 0}, 0x00ac }, // U00AC # NOT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x002d, 0x002d, 0, 0}, 0x2014 }, // U2014 # EM DASH
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x002d, 0x002e, 0, 0}, 0x2013 }, // U2013 # EN DASH
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x003a, 0, 0, 0}, 0x00f7 }, // U00F7 # DIVISION SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x0044, 0, 0, 0}, 0x0110 }, // Dstroke
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x004c, 0, 0, 0}, 0x00a3 }, // U00a3 # POUND SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002d, 0x0064, 0, 0, 0}, 0x0111 }, // dstroke
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0000, 0x0053, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0000, 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0000, 0x0073, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0000, 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0021, 0x0053, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0021, 0x0073, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0027, 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0027, 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x002e, 0, 0, 0}, 0x00b7 }, // U00B7
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x003c, 0, 0, 0}, 0x2039 }, // U2039
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x003e, 0, 0, 0}, 0x203a }, // U203a
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0041, 0, 0, 0}, 0x0226 }, // U0226 # LATIN CAPITAL LETTER A WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0042, 0, 0, 0}, 0x1e02 }, // U1E02 # LATIN CAPITAL LETTER B WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0043, 0, 0, 0}, 0x010a }, // U010A # LATIN CAPITAL LETTER C WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0044, 0, 0, 0}, 0x1e0a }, // U1E0A # LATIN CAPITAL LETTER D WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0045, 0, 0, 0}, 0x0116 }, // U0116 # LATIN CAPITAL LETTER E WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0046, 0, 0, 0}, 0x1e1e }, // U1E1E # LATIN CAPITAL LETTER F WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0047, 0, 0, 0}, 0x0120 }, // U0120 # LATIN CAPITAL LETTER G WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0048, 0, 0, 0}, 0x1e22 }, // U1E22 # LATIN CAPITAL LETTER H WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0049, 0, 0, 0}, 0x0130 }, // U0130 # LATIN CAPITAL LETTER I WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x004d, 0, 0, 0}, 0x1e40 }, // U1E40 # LATIN CAPITAL LETTER M WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x004e, 0, 0, 0}, 0x1e44 }, // U1E44 # LATIN CAPITAL LETTER N WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x004f, 0, 0, 0}, 0x022e }, // U022E # LATIN CAPITAL LETTER O WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0050, 0, 0, 0}, 0x1e56 }, // U1E56 # LATIN CAPITAL LETTER P WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0052, 0, 0, 0}, 0x1e58 }, // U1E58 # LATIN CAPITAL LETTER R WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0053, 0, 0, 0}, 0x1e60 }, // U1E60 # LATIN CAPITAL LETTER S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0054, 0, 0, 0}, 0x1e6a }, // U1E6A # LATIN CAPITAL LETTER T WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0057, 0, 0, 0}, 0x1e86 }, // U1E86 # LATIN CAPITAL LETTER W WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0058, 0, 0, 0}, 0x1e8a }, // U1E8A # LATIN CAPITAL LETTER X WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0059, 0, 0, 0}, 0x1e8e }, // U1E8E # LATIN CAPITAL LETTER Y WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x005a, 0, 0, 0}, 0x017b }, // U017B # LATIN CAPITAL LETTER Z WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0061, 0, 0, 0}, 0x0227 }, // U0227 # LATIN SMALL LETTER A WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0062, 0, 0, 0}, 0x1e03 }, // U1E03 # LATIN SMALL LETTER B WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0063, 0, 0, 0}, 0x010b }, // U010B # LATIN SMALL LETTER C WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0063, 0x0053, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0063, 0x0073, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0064, 0, 0, 0}, 0x1e0b }, // U1E0B # LATIN SMALL LETTER D WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0065, 0, 0, 0}, 0x0117 }, // U0117 # LATIN SMALL LETTER E WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0066, 0, 0, 0}, 0x1e1f }, // U1E1F # LATIN SMALL LETTER F WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0067, 0, 0, 0}, 0x0121 }, // U0121 # LATIN SMALL LETTER G WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0068, 0, 0, 0}, 0x1e23 }, // U1E23 # LATIN SMALL LETTER H WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x006d, 0, 0, 0}, 0x1e41 }, // U1E41 # LATIN SMALL LETTER M WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x006e, 0, 0, 0}, 0x1e45 }, // U1E45 # LATIN SMALL LETTER N WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x006f, 0, 0, 0}, 0x022f }, // U022F # LATIN SMALL LETTER O WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0070, 0, 0, 0}, 0x1e57 }, // U1E57 # LATIN SMALL LETTER P WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0072, 0, 0, 0}, 0x1e59 }, // U1E59 # LATIN SMALL LETTER R WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0073, 0, 0, 0}, 0x1e61 }, // U1E61 # LATIN SMALL LETTER S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0074, 0, 0, 0}, 0x1e6b }, // U1E6B # LATIN SMALL LETTER T WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0077, 0, 0, 0}, 0x1e87 }, // U1E87 # LATIN SMALL LETTER W WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0078, 0, 0, 0}, 0x1e8b }, // U1E8B # LATIN SMALL LETTER X WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0079, 0, 0, 0}, 0x1e8f }, // U1E8F # LATIN SMALL LETTER Y WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x007a, 0, 0, 0}, 0x017c }, // U017C # LATIN SMALL LETTER Z WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x00b4, 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x00b4, 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x015a, 0, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x015b, 0, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0160, 0, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0161, 0, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x017f, 0, 0, 0}, 0x1e9b }, // U1E9B # LATIN SMALL LETTER LONG S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x1e62, 0, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, 0x1e63, 0, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Acute), 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Acute), 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Caron), 0x0053, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Caron), 0x0073, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0053, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0073, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x002f, 0, 0, 0}, 0x005c }, // backslash
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x003c, 0, 0, 0}, 0x005c }, // backslash
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0043, 0, 0, 0}, 0x20a1 }, // U20a1 # COLON SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0043, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0044, 0, 0, 0}, 0x0110 }, // U0110 # LATIN CAPITAL LETTER D WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0047, 0, 0, 0}, 0x01e4 }, // U01E4 # LATIN CAPITAL LETTER G WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0048, 0, 0, 0}, 0x0126 }, // U0126 # LATIN CAPITAL LETTER H WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0049, 0, 0, 0}, 0x0197 }, // U0197 # LATIN CAPITAL LETTER I WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x004c, 0, 0, 0}, 0x0141 }, // U0141 # LATIN CAPITAL LETTER L WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x004f, 0, 0, 0}, 0x00d8 }, // U00D8 # LATIN CAPITAL LETTER O WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0054, 0, 0, 0}, 0x0166 }, // U0166 # LATIN CAPITAL LETTER T WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x005a, 0, 0, 0}, 0x01b5 }, // U01B5 # LATIN CAPITAL LETTER Z WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x005e, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0062, 0, 0, 0}, 0x0180 }, // U0180 # LATIN SMALL LETTER B WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0063, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0064, 0, 0, 0}, 0x0111 }, // U0111 # LATIN SMALL LETTER D WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0067, 0, 0, 0}, 0x01e5 }, // U01E5 # LATIN SMALL LETTER G WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0068, 0, 0, 0}, 0x0127 }, // U0127 # LATIN SMALL LETTER H WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0069, 0, 0, 0}, 0x0268 }, // U0268 # LATIN SMALL LETTER I WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x006c, 0, 0, 0}, 0x0142 }, // U0142 # LATIN SMALL LETTER L WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x006d, 0, 0, 0}, 0x20a5 }, // U20a5 # MILL SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x006f, 0, 0, 0}, 0x00f8 }, // U00F8 # LATIN SMALL LETTER O WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0074, 0, 0, 0}, 0x0167 }, // U0167 # LATIN SMALL LETTER T WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x007a, 0, 0, 0}, 0x01b6 }, // U01B6 # LATIN SMALL LETTER Z WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0294, 0, 0, 0}, 0x02a1 }, // U02A1 # LATIN LETTER GLOTTAL STOP WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0413, 0, 0, 0}, 0x0492 }, // U0492 # CYRILLIC CAPITAL LETTER GHE WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x041a, 0, 0, 0}, 0x049e }, // U049E # CYRILLIC CAPITAL LETTER KA WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x0433, 0, 0, 0}, 0x0493 }, // U0493 # CYRILLIC SMALL LETTER GHE WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x043a, 0, 0, 0}, 0x049f }, // U049F # CYRILLIC SMALL LETTER KA WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x04ae, 0, 0, 0}, 0x04b0 }, // U04B0 # CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x04af, 0, 0, 0}, 0x04b1 }, // U04B1 # CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x2190, 0, 0, 0}, 0x219a }, // U219A # LEFTWARDS ARROW WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x2192, 0, 0, 0}, 0x219b }, // U219B # RIGHTWARDS ARROW WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x002f, 0x2194, 0, 0, 0}, 0x21ae }, // U21AE # LEFT RIGHT ARROW WITH STROKE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0031, 0x0032, 0, 0, 0}, 0x00bd }, // U00BD # VULGAR FRACTION ONE HALF
+    { {UNITIZE(Qt::Key_Multi_key), 0x0031, 0x0034, 0, 0, 0}, 0x00bc }, // U00BC # VULGAR FRACTION ONE QUARTER
+    { {UNITIZE(Qt::Key_Multi_key), 0x0033, 0x0034, 0, 0, 0}, 0x00be }, // U00BE # VULGAR FRACTION THREE QUARTERS
+    { {UNITIZE(Qt::Key_Multi_key), 0x003a, 0x002d, 0, 0, 0}, 0x00f7 }, // U00F7 # DIVISION SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0041, 0, 0, 0}, 0x0104 }, // U0104 # LATIN CAPITAL LETTER A WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0045, 0, 0, 0}, 0x0118 }, // U0118 # LATIN CAPITAL LETTER E WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0049, 0, 0, 0}, 0x012e }, // U012E # LATIN CAPITAL LETTER I WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x004f, 0, 0, 0}, 0x01ea }, // U01EA # LATIN CAPITAL LETTER O WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0055, 0, 0, 0}, 0x0172 }, // U0172 # LATIN CAPITAL LETTER U WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0061, 0, 0, 0}, 0x0105 }, // U0105 # LATIN SMALL LETTER A WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0065, 0, 0, 0}, 0x0119 }, // U0119 # LATIN SMALL LETTER E WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0069, 0, 0, 0}, 0x012f }, // U012F # LATIN SMALL LETTER I WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x006f, 0, 0, 0}, 0x01eb }, // U01EB # LATIN SMALL LETTER O WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003b, 0x0075, 0, 0, 0}, 0x0173 }, // U0173 # LATIN SMALL LETTER U WITH OGONEK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x0022, 0, 0, 0}, 0x201c }, // U201c # LEFT DOUBLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x0027, 0, 0, 0}, 0x2018 }, // U2018 # LEFT SINGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x002f, 0, 0, 0}, 0x005c }, // backslash
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x003c, 0, 0, 0}, 0x00ab }, // guillemotleft # LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x0338, 0, 0, 0}, 0x226e }, // U226E # NOT LESS-THAN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003c, 0x0338, 0, 0, 0}, 0x226e }, // U226E # NOT LESS-THAN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0043, 0, 0, 0}, 0x20ac }, // EuroSign # EURO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0045, 0, 0, 0}, 0x20ac }, // EuroSign # EURO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x004c, 0, 0, 0}, 0x20a4 }, // U20a4 # LIRA SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x004e, 0, 0, 0}, 0x20a6 }, // U20a6 # NAIRA SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x004f, 0, 0, 0}, 0x0150 }, // U0150 # LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0055, 0, 0, 0}, 0x0170 }, // U0170 # LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0057, 0, 0, 0}, 0x20a9 }, // U20a9 # WON SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0059, 0, 0, 0}, 0x00a5 }, // yen
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x006f, 0, 0, 0}, 0x0151 }, // U0151 # LATIN SMALL LETTER O WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0075, 0, 0, 0}, 0x0171 }, // U0171 # LATIN SMALL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0338, 0, 0, 0}, 0x2260 }, // U2260 # NOT EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0423, 0, 0, 0}, 0x04f2 }, // U04F2 # CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003d, 0x0443, 0, 0, 0}, 0x04f3 }, // U04F3 # CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x0020, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x0022, 0, 0, 0}, 0x201d }, // U201d # RIGHT DOUBLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x0027, 0, 0, 0}, 0x2019 }, // U2019 # RIGHT SINGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x003e, 0, 0, 0}, 0x00bb }, // guillemotright # RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x0338, 0, 0, 0}, 0x226f }, // U226F # NOT GREATER-THAN
+    { {UNITIZE(Qt::Key_Multi_key), 0x003e, 0x0338, 0, 0, 0}, 0x226f }, // U226F # NOT GREATER-THAN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0000, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0000, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0000, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0000, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x002b, 0x004f, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x002b, 0x0055, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x002b, 0x006f, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x002b, 0x0075, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x003f, 0, 0, 0}, 0x00bf }, // questiondown
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0041, 0, 0, 0}, 0x1ea2 }, // U1EA2 # LATIN CAPITAL LETTER A WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0045, 0, 0, 0}, 0x1eba }, // U1EBA # LATIN CAPITAL LETTER E WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0049, 0, 0, 0}, 0x1ec8 }, // U1EC8 # LATIN CAPITAL LETTER I WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x004f, 0, 0, 0}, 0x1ece }, // U1ECE # LATIN CAPITAL LETTER O WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0055, 0, 0, 0}, 0x1ee6 }, // U1EE6 # LATIN CAPITAL LETTER U WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0055, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0055, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0059, 0, 0, 0}, 0x1ef6 }, // U1EF6 # LATIN CAPITAL LETTER Y WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x0041, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x0045, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x004f, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x0061, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x0065, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x005e, 0x006f, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0061, 0, 0, 0}, 0x1ea3 }, // U1EA3 # LATIN SMALL LETTER A WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0062, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0062, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0065, 0, 0, 0}, 0x1ebb }, // U1EBB # LATIN SMALL LETTER E WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0069, 0, 0, 0}, 0x1ec9 }, // U1EC9 # LATIN SMALL LETTER I WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x006f, 0, 0, 0}, 0x1ecf }, // U1ECF # LATIN SMALL LETTER O WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0075, 0, 0, 0}, 0x1ee7 }, // U1EE7 # LATIN SMALL LETTER U WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0079, 0, 0, 0}, 0x1ef7 }, // U1EF7 # LATIN SMALL LETTER Y WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00c2, 0, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00ca, 0, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00d4, 0, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00e2, 0, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00ea, 0, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x00f4, 0, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0102, 0, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, 0x0103, 0, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x003f, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0041, 0x0045, 0, 0, 0}, 0x00c6 }, // AE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0041, 0x0054, 0, 0, 0}, 0x0040 }, // at
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x002f, 0, 0, 0}, 0x20a1 }, // U20a1 # COLON SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x002f, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x003d, 0, 0, 0}, 0x20ac }, // EuroSign # EURO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x0045, 0, 0, 0}, 0x20a0 }, // U20a0 # EURO-CURRENCY SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x0072, 0, 0, 0}, 0x20a2 }, // U20a2 # CRUZEIRO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0043, 0x007c, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0044, 0x0048, 0, 0, 0}, 0x00d0 }, // U00D0 # LATIN CAPITAL LETTER ETH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0045, 0x003d, 0, 0, 0}, 0x20ac }, // EuroSign # EURO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0046, 0x0072, 0, 0, 0}, 0x20a3 }, // U20a3 # FRENCH FRANC SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x004c, 0x002d, 0, 0, 0}, 0x00a3 }, // U00a3 # POUND SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x004c, 0x003d, 0, 0, 0}, 0x20a4 }, // U20a4 # LIRA SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x004c, 0x0056, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x004e, 0x003d, 0, 0, 0}, 0x20a6 }, // U20a6 # NAIRA SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x004e, 0x0047, 0, 0, 0}, 0x014a }, // U014A # LATIN CAPITAL LETTER ENG
+    { {UNITIZE(Qt::Key_Multi_key), 0x004f, 0x0043, 0, 0, 0}, 0x00a9 }, // copyright
+    { {UNITIZE(Qt::Key_Multi_key), 0x004f, 0x0045, 0, 0, 0}, 0x0152 }, // OE
+    { {UNITIZE(Qt::Key_Multi_key), 0x004f, 0x0052, 0, 0, 0}, 0x00ae }, // registered
+    { {UNITIZE(Qt::Key_Multi_key), 0x004f, 0x0063, 0, 0, 0}, 0x00a9 }, // copyright
+    { {UNITIZE(Qt::Key_Multi_key), 0x004f, 0x0072, 0, 0, 0}, 0x00ae }, // registered
+    { {UNITIZE(Qt::Key_Multi_key), 0x0050, 0x0021, 0, 0, 0}, 0x00b6 }, // paragraph
+    { {UNITIZE(Qt::Key_Multi_key), 0x0050, 0x0050, 0, 0, 0}, 0x00b6 }, // paragraph # PILCROW SIGN (PARAGRAPH SIGN)
+    { {UNITIZE(Qt::Key_Multi_key), 0x0050, 0x0074, 0, 0, 0}, 0x20a7 }, // U20a7 # PESETA SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0052, 0x0073, 0, 0, 0}, 0x20a8 }, // U20a8 # RUPEE SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0054, 0x0048, 0, 0, 0}, 0x00de }, // U00DE # LATIN CAPITAL LETTER THORN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0000, 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0000, 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0021, 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0021, 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x002c, 0x0045, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x002c, 0x0065, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0, 0}, 0x0102 }, // U0102 # LATIN CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0045, 0, 0, 0}, 0x0114 }, // U0114 # LATIN CAPITAL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0047, 0, 0, 0}, 0x011e }, // U011E # LATIN CAPITAL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0049, 0, 0, 0}, 0x012c }, // U012C # LATIN CAPITAL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x004f, 0, 0, 0}, 0x014e }, // U014E # LATIN CAPITAL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0055, 0, 0, 0}, 0x016c }, // U016C # LATIN CAPITAL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0, 0}, 0x0103 }, // U0103 # LATIN SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0065, 0, 0, 0}, 0x0115 }, // U0115 # LATIN SMALL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0067, 0, 0, 0}, 0x011f }, // U011F # LATIN SMALL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0069, 0, 0, 0}, 0x012d }, // U012D # LATIN SMALL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x006f, 0, 0, 0}, 0x014f }, // U014F # LATIN SMALL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0075, 0, 0, 0}, 0x016d }, // U016D # LATIN SMALL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0228, 0, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0229, 0, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0391, 0, 0, 0}, 0x1fb8 }, // U1FB8 # GREEK CAPITAL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0399, 0, 0, 0}, 0x1fd8 }, // U1FD8 # GREEK CAPITAL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x03a5, 0, 0, 0}, 0x1fe8 }, // U1FE8 # GREEK CAPITAL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x03b1, 0, 0, 0}, 0x1fb0 }, // U1FB0 # GREEK SMALL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x03b9, 0, 0, 0}, 0x1fd0 }, // U1FD0 # GREEK SMALL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x03c5, 0, 0, 0}, 0x1fe0 }, // U1FE0 # GREEK SMALL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0410, 0, 0, 0}, 0x04d0 }, // U04D0 # CYRILLIC CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0415, 0, 0, 0}, 0x04d6 }, // U04D6 # CYRILLIC CAPITAL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0416, 0, 0, 0}, 0x04c1 }, // U04C1 # CYRILLIC CAPITAL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0418, 0, 0, 0}, 0x0419 }, // U0419 # CYRILLIC CAPITAL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0423, 0, 0, 0}, 0x040e }, // U040E # CYRILLIC CAPITAL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0430, 0, 0, 0}, 0x04d1 }, // U04D1 # CYRILLIC SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0435, 0, 0, 0}, 0x04d7 }, // U04D7 # CYRILLIC SMALL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0436, 0, 0, 0}, 0x04c2 }, // U04C2 # CYRILLIC SMALL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0438, 0, 0, 0}, 0x0439 }, // U0439 # CYRILLIC SMALL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0443, 0, 0, 0}, 0x045e }, // U045E # CYRILLIC SMALL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x1ea0, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, 0x1ea1, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, UNITIZE(Qt::Key_Dead_Cedilla), 0x0045, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, UNITIZE(Qt::Key_Dead_Cedilla), 0x0065, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0055, UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0056, 0x004c, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x0057, 0x003d, 0, 0, 0}, 0x20a9 }, // U20a9 # WON SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0059, 0x003d, 0, 0, 0}, 0x00a5 }, // yen
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2076 }, // U2076 # SUPERSCRIPT SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2070 }, // U2070 # SUPERSCRIPT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x00b9 }, // U00B9 # SUPERSCRIPT ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2078 }, // U2078 # SUPERSCRIPT EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2074 }, // U2074 # SUPERSCRIPT FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x00b3 }, // U00B3 # SUPERSCRIPT THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2077 }, // U2077 # SUPERSCRIPT SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x207c }, // U207C # SUPERSCRIPT EQUALS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x207a }, // U207A # SUPERSCRIPT PLUS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2079 }, // U2079 # SUPERSCRIPT NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0, 0, 0}, 0x2075 }, // U2075 # SUPERSCRIPT FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x0041, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x0045, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x004f, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x0061, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x0065, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0000, 0x006f, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0020, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x0041, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x0045, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x004f, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x0061, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x0065, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0021, 0x006f, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0028, 0, 0, 0}, 0x207d }, // U207D # SUPERSCRIPT LEFT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0029, 0, 0, 0}, 0x207e }, // U207E # SUPERSCRIPT RIGHT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x002b, 0, 0, 0}, 0x207a }, // U207A # SUPERSCRIPT PLUS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x002f, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0030, 0, 0, 0}, 0x2070 }, // U2070 # SUPERSCRIPT ZERO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0031, 0, 0, 0}, 0x00b9 }, // U00B9 # SUPERSCRIPT ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0032, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0033, 0, 0, 0}, 0x00b3 }, // U00B3 # SUPERSCRIPT THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0034, 0, 0, 0}, 0x2074 }, // U2074 # SUPERSCRIPT FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0035, 0, 0, 0}, 0x2075 }, // U2075 # SUPERSCRIPT FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0036, 0, 0, 0}, 0x2076 }, // U2076 # SUPERSCRIPT SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0037, 0, 0, 0}, 0x2077 }, // U2077 # SUPERSCRIPT SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0038, 0, 0, 0}, 0x2078 }, // U2078 # SUPERSCRIPT EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0039, 0, 0, 0}, 0x2079 }, // U2079 # SUPERSCRIPT NINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x003d, 0, 0, 0}, 0x207c }, // U207C # SUPERSCRIPT EQUALS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0, 0}, 0x00c2 }, // U00C2 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0043, 0, 0, 0}, 0x0108 }, // U0108 # LATIN CAPITAL LETTER C WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0, 0}, 0x00ca }, // U00CA # LATIN CAPITAL LETTER E WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0047, 0, 0, 0}, 0x011c }, // U011C # LATIN CAPITAL LETTER G WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0048, 0, 0, 0}, 0x0124 }, // U0124 # LATIN CAPITAL LETTER H WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0049, 0, 0, 0}, 0x00ce }, // U00CE # LATIN CAPITAL LETTER I WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004a, 0, 0, 0}, 0x0134 }, // U0134 # LATIN CAPITAL LETTER J WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0, 0}, 0x00d4 }, // U00D4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0053, 0, 0, 0}, 0x015c }, // U015C # LATIN CAPITAL LETTER S WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0053, 0x004d, 0, 0}, 0x2120 }, // U2120 # SERVICE MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0054, 0x004d, 0, 0}, 0x2122 }, // U2122 # TRADE MARK SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0055, 0, 0, 0}, 0x00db }, // U00DB # LATIN CAPITAL LETTER U WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0057, 0, 0, 0}, 0x0174 }, // U0174 # LATIN CAPITAL LETTER W WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0059, 0, 0, 0}, 0x0176 }, // U0176 # LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005a, 0, 0, 0}, 0x1e90 }, // U1E90 # LATIN CAPITAL LETTER Z WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0061, 0, 0}, 0x00aa }, // U00AA # FEMININE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0061, 0, 0}, 0x00aa }, // U00AA # FEMININE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0068, 0, 0}, 0x02b0 }, // U02B0 # MODIFIER LETTER SMALL H
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0068, 0, 0}, 0x02b0 }, // U02B0 # MODIFIER LETTER SMALL H
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0069, 0, 0}, 0x2071 }, // U2071 # SUPERSCRIPT LATIN SMALL LETTER I
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0069, 0, 0}, 0x2071 }, // U2071 # SUPERSCRIPT LATIN SMALL LETTER I
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006a, 0, 0}, 0x02b2 }, // U02B2 # MODIFIER LETTER SMALL J
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006a, 0, 0}, 0x02b2 }, // U02B2 # MODIFIER LETTER SMALL J
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006c, 0, 0}, 0x02e1 }, // U02E1 # MODIFIER LETTER SMALL L
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006c, 0, 0}, 0x02e1 }, // U02E1 # MODIFIER LETTER SMALL L
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006e, 0, 0}, 0x207f }, // U207F # SUPERSCRIPT LATIN SMALL LETTER N
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006e, 0, 0}, 0x207f }, // U207F # SUPERSCRIPT LATIN SMALL LETTER N
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006f, 0, 0}, 0x00ba }, // U00BA # MASCULINE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x006f, 0, 0}, 0x00ba }, // U00BA # MASCULINE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0072, 0, 0}, 0x02b3 }, // U02B3 # MODIFIER LETTER SMALL R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0072, 0, 0}, 0x02b3 }, // U02B3 # MODIFIER LETTER SMALL R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0073, 0, 0}, 0x02e2 }, // U02E2 # MODIFIER LETTER SMALL S
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0073, 0, 0}, 0x02e2 }, // U02E2 # MODIFIER LETTER SMALL S
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0077, 0, 0}, 0x02b7 }, // U02B7 # MODIFIER LETTER SMALL W
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0077, 0, 0}, 0x02b7 }, // U02B7 # MODIFIER LETTER SMALL W
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0078, 0, 0}, 0x02e3 }, // U02E3 # MODIFIER LETTER SMALL X
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0078, 0, 0}, 0x02e3 }, // U02E3 # MODIFIER LETTER SMALL X
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0079, 0, 0}, 0x02b8 }, // U02B8 # MODIFIER LETTER SMALL Y
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0079, 0, 0}, 0x02b8 }, // U02B8 # MODIFIER LETTER SMALL Y
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0263, 0, 0}, 0x02e0 }, // U02E0 # MODIFIER LETTER SMALL GAMMA
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0263, 0, 0}, 0x02e0 }, // U02E0 # MODIFIER LETTER SMALL GAMMA
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0266, 0, 0}, 0x02b1 }, // U02B1 # MODIFIER LETTER SMALL H WITH HOOK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0266, 0, 0}, 0x02b1 }, // U02B1 # MODIFIER LETTER SMALL H WITH HOOK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0279, 0, 0}, 0x02b4 }, // U02B4 # MODIFIER LETTER SMALL TURNED R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0279, 0, 0}, 0x02b4 }, // U02B4 # MODIFIER LETTER SMALL TURNED R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x027b, 0, 0}, 0x02b5 }, // U02B5 # MODIFIER LETTER SMALL TURNED R WITH HOOK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x027b, 0, 0}, 0x02b5 }, // U02B5 # MODIFIER LETTER SMALL TURNED R WITH HOOK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0281, 0, 0}, 0x02b6 }, // U02B6 # MODIFIER LETTER SMALL CAPITAL INVERTED R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0281, 0, 0}, 0x02b6 }, // U02B6 # MODIFIER LETTER SMALL CAPITAL INVERTED R
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0295, 0, 0}, 0x02e4 }, // U02E4 # MODIFIER LETTER SMALL REVERSED GLOTTAL STOP
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x005f, 0x0295, 0, 0}, 0x02e4 }, // U02E4 # MODIFIER LETTER SMALL REVERSED GLOTTAL STOP
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0, 0}, 0x00e2 }, // U00E2 # LATIN SMALL LETTER A WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0063, 0, 0, 0}, 0x0109 }, // U0109 # LATIN SMALL LETTER C WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0, 0}, 0x00ea }, // U00EA # LATIN SMALL LETTER E WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0067, 0, 0, 0}, 0x011d }, // U011D # LATIN SMALL LETTER G WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0068, 0, 0, 0}, 0x0125 }, // U0125 # LATIN SMALL LETTER H WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0069, 0, 0, 0}, 0x00ee }, // U00EE # LATIN SMALL LETTER I WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006a, 0, 0, 0}, 0x0135 }, // U0135 # LATIN SMALL LETTER J WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0, 0}, 0x00f4 }, // U00F4 # LATIN SMALL LETTER O WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0073, 0, 0, 0}, 0x015d }, // U015D # LATIN SMALL LETTER S WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0075, 0, 0, 0}, 0x00fb }, // U00FB # LATIN SMALL LETTER U WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0077, 0, 0, 0}, 0x0175 }, // U0175 # LATIN SMALL LETTER W WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0079, 0, 0, 0}, 0x0177 }, // U0177 # LATIN SMALL LETTER Y WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x007a, 0, 0, 0}, 0x1e91 }, // U1E91 # LATIN SMALL LETTER Z WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1ea0, 0, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1ea1, 0, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1eb8, 0, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1eb9, 0, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1ecc, 0, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x1ecd, 0, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x2212, 0, 0, 0}, 0x207b }, // U207B # SUPERSCRIPT MINUS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e00, 0, 0, 0}, 0x3192 }, // U3192 # IDEOGRAPHIC ANNOTATION ONE MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e01, 0, 0, 0}, 0x319c }, // U319C # IDEOGRAPHIC ANNOTATION FOURTH MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e09, 0, 0, 0}, 0x3194 }, // U3194 # IDEOGRAPHIC ANNOTATION THREE MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e0a, 0, 0, 0}, 0x3196 }, // U3196 # IDEOGRAPHIC ANNOTATION TOP MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e0b, 0, 0, 0}, 0x3198 }, // U3198 # IDEOGRAPHIC ANNOTATION BOTTOM MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e19, 0, 0, 0}, 0x319b }, // U319B # IDEOGRAPHIC ANNOTATION THIRD MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e2d, 0, 0, 0}, 0x3197 }, // U3197 # IDEOGRAPHIC ANNOTATION MIDDLE MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e59, 0, 0, 0}, 0x319a }, // U319A # IDEOGRAPHIC ANNOTATION SECOND MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4e8c, 0, 0, 0}, 0x3193 }, // U3193 # IDEOGRAPHIC ANNOTATION TWO MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x4eba, 0, 0, 0}, 0x319f }, // U319F # IDEOGRAPHIC ANNOTATION MAN MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x56db, 0, 0, 0}, 0x3195 }, // U3195 # IDEOGRAPHIC ANNOTATION FOUR MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x5730, 0, 0, 0}, 0x319e }, // U319E # IDEOGRAPHIC ANNOTATION EARTH MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x5929, 0, 0, 0}, 0x319d }, // U319D # IDEOGRAPHIC ANNOTATION HEAVEN MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, 0x7532, 0, 0, 0}, 0x3199 }, // U3199 # IDEOGRAPHIC ANNOTATION FIRST MARK
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0045, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x004f, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x0065, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x005e, UNITIZE(Qt::Key_Dead_Belowdot), 0x006f, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2085 }, // U2085 # SUBSCRIPT FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2087 }, // U2087 # SUBSCRIPT SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2085 }, // U2085 # SUBSCRIPT FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2084 }, // U2084 # SUBSCRIPT FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2084 }, // U2084 # SUBSCRIPT FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2086 }, // U2086 # SUBSCRIPT SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2081 }, // U2081 # SUBSCRIPT ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x208a }, // U208A # SUBSCRIPT PLUS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2088 }, // U2088 # SUBSCRIPT EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2087 }, // U2087 # SUBSCRIPT SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x208a }, // U208A # SUBSCRIPT PLUS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2080 }, // U2080 # SUBSCRIPT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2083 }, // U2083 # SUBSCRIPT THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2083 }, // U2083 # SUBSCRIPT THREE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2086 }, // U2086 # SUBSCRIPT SIX
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2088 }, // U2088 # SUBSCRIPT EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2089 }, // U2089 # SUBSCRIPT NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2089 }, // U2089 # SUBSCRIPT NINE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2080 }, // U2080 # SUBSCRIPT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2081 }, // U2081 # SUBSCRIPT ONE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x208c }, // U208C # SUBSCRIPT EQUALS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0, 0, 0}, 0x208c }, // U208C # SUBSCRIPT EQUALS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0000, 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0021, 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0021, 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0021, 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0021, 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x0041, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x004f, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x0055, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x0061, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x006f, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0022, 0x0075, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0028, 0, 0, 0}, 0x208d }, // U208D # SUBSCRIPT LEFT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0028, 0, 0, 0}, 0x208d }, // U208D # SUBSCRIPT LEFT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0029, 0, 0, 0}, 0x208e }, // U208E # SUBSCRIPT RIGHT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0029, 0, 0, 0}, 0x208e }, // U208E # SUBSCRIPT RIGHT PARENTHESIS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002b, 0, 0, 0}, 0x208a }, // U208A # SUBSCRIPT PLUS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002b, 0, 0, 0}, 0x208a }, // U208A # SUBSCRIPT PLUS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002e, 0x0041, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002e, 0x004f, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002e, 0x0061, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x002e, 0x006f, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0030, 0, 0, 0}, 0x2080 }, // U2080 # SUBSCRIPT ZERO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0030, 0, 0, 0}, 0x2080 }, // U2080 # SUBSCRIPT ZERO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0031, 0, 0, 0}, 0x2081 }, // U2081 # SUBSCRIPT ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0031, 0, 0, 0}, 0x2081 }, // U2081 # SUBSCRIPT ONE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0032, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0032, 0, 0, 0}, 0x2082 }, // U2082 # SUBSCRIPT TWO
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0033, 0, 0, 0}, 0x2083 }, // U2083 # SUBSCRIPT THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0033, 0, 0, 0}, 0x2083 }, // U2083 # SUBSCRIPT THREE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0034, 0, 0, 0}, 0x2084 }, // U2084 # SUBSCRIPT FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0034, 0, 0, 0}, 0x2084 }, // U2084 # SUBSCRIPT FOUR
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0035, 0, 0, 0}, 0x2085 }, // U2085 # SUBSCRIPT FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0035, 0, 0, 0}, 0x2085 }, // U2085 # SUBSCRIPT FIVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0036, 0, 0, 0}, 0x2086 }, // U2086 # SUBSCRIPT SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0036, 0, 0, 0}, 0x2086 }, // U2086 # SUBSCRIPT SIX
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0037, 0, 0, 0}, 0x2087 }, // U2087 # SUBSCRIPT SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0037, 0, 0, 0}, 0x2087 }, // U2087 # SUBSCRIPT SEVEN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0038, 0, 0, 0}, 0x2088 }, // U2088 # SUBSCRIPT EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0038, 0, 0, 0}, 0x2088 }, // U2088 # SUBSCRIPT EIGHT
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0039, 0, 0, 0}, 0x2089 }, // U2089 # SUBSCRIPT NINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0039, 0, 0, 0}, 0x2089 }, // U2089 # SUBSCRIPT NINE
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x003b, 0x004f, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x003b, 0x006f, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x003d, 0, 0, 0}, 0x208c }, // U208C # SUBSCRIPT EQUALS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x003d, 0, 0, 0}, 0x208c }, // U208C # SUBSCRIPT EQUALS SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0041, 0, 0, 0}, 0x0100 }, // U0100 # LATIN CAPITAL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0045, 0, 0, 0}, 0x0112 }, // U0112 # LATIN CAPITAL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0047, 0, 0, 0}, 0x1e20 }, // U1E20 # LATIN CAPITAL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0049, 0, 0, 0}, 0x012a }, // U012A # LATIN CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x004f, 0, 0, 0}, 0x014c }, // U014C # LATIN CAPITAL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0055, 0, 0, 0}, 0x016a }, // U016A # LATIN CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0059, 0, 0, 0}, 0x0232 }, // U0232 # LATIN CAPITAL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0061, 0, 0, 0}, 0x0101 }, // U0101 # LATIN SMALL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0065, 0, 0, 0}, 0x0113 }, // U0113 # LATIN SMALL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0067, 0, 0, 0}, 0x1e21 }, // U1E21 # LATIN SMALL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0069, 0, 0, 0}, 0x012b }, // U012B # LATIN SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0, 0}, 0x014d }, // U014D # LATIN SMALL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0075, 0, 0, 0}, 0x016b }, // U016B # LATIN SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0079, 0, 0, 0}, 0x0233 }, // U0233 # LATIN SMALL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x007e, 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x007e, 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00c4, 0, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00c6, 0, 0, 0}, 0x01e2 }, // U01E2 # LATIN CAPITAL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00d5, 0, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00d6, 0, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00dc, 0, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00e4, 0, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00e6, 0, 0, 0}, 0x01e3 }, // U01E3 # LATIN SMALL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00f5, 0, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00f6, 0, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x00fc, 0, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x01ea, 0, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x01eb, 0, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0226, 0, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0227, 0, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x022e, 0, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x022f, 0, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0391, 0, 0, 0}, 0x1fb9 }, // U1FB9 # GREEK CAPITAL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0399, 0, 0, 0}, 0x1fd9 }, // U1FD9 # GREEK CAPITAL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x03a5, 0, 0, 0}, 0x1fe9 }, // U1FE9 # GREEK CAPITAL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x03b1, 0, 0, 0}, 0x1fb1 }, // U1FB1 # GREEK SMALL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x03b9, 0, 0, 0}, 0x1fd1 }, // U1FD1 # GREEK SMALL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x03c5, 0, 0, 0}, 0x1fe1 }, // U1FE1 # GREEK SMALL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0418, 0, 0, 0}, 0x04e2 }, // U04E2 # CYRILLIC CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0423, 0, 0, 0}, 0x04ee }, // U04EE # CYRILLIC CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0438, 0, 0, 0}, 0x04e3 }, // U04E3 # CYRILLIC SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0443, 0, 0, 0}, 0x04ef }, // U04EF # CYRILLIC SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x1e36, 0, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x1e37, 0, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x1e5a, 0, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x1e5b, 0, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x2212, 0, 0, 0}, 0x208b }, // U208B # SUBSCRIPT MINUS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, 0x2212, 0, 0, 0}, 0x208b }, // U208B # SUBSCRIPT MINUS
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Abovedot), 0x0041, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Abovedot), 0x004f, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Abovedot), 0x0061, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Abovedot), 0x006f, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0041, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x004f, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0061, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x006f, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Ogonek), 0x004f, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Ogonek), 0x006f, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Belowdot), 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Belowdot), 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Belowdot), 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x005f, UNITIZE(Qt::Key_Dead_Belowdot), 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0000, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0000, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0000, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0000, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0020, 0, 0, 0}, 0x0060 }, // grave
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0022, 0x0055, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0022, 0x0075, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0022, 0x03b9, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0022, 0x03c5, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0391, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0395, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0397, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0399, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x039f, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03a5, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03a9, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b1, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b5, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b7, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b9, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03bf, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03c5, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03c9, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0391, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0395, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0397, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0399, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x039f, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03a9, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b1, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b5, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b7, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b9, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03bf, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03c5, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03c9, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x002b, 0x004f, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x002b, 0x0055, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x002b, 0x006f, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x002b, 0x0075, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0041, 0, 0, 0}, 0x00c0 }, // U00C0 # LATIN CAPITAL LETTER A WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0045, 0, 0, 0}, 0x00c8 }, // U00C8 # LATIN CAPITAL LETTER E WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0049, 0, 0, 0}, 0x00cc }, // U00CC # LATIN CAPITAL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x004e, 0, 0, 0}, 0x01f8 }, // U01F8 # LATIN CAPITAL LETTER N WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x004f, 0, 0, 0}, 0x00d2 }, // U00D2 # LATIN CAPITAL LETTER O WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0055, 0, 0, 0}, 0x00d9 }, // U00D9 # LATIN CAPITAL LETTER U WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0055, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0055, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0057, 0, 0, 0}, 0x1e80 }, // U1E80 # LATIN CAPITAL LETTER W WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0059, 0, 0, 0}, 0x1ef2 }, // U1EF2 # LATIN CAPITAL LETTER Y WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x0041, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x0045, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x004f, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x0061, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x0065, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005e, 0x006f, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005f, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005f, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005f, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x005f, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0061, 0, 0, 0}, 0x00e0 }, // U00E0 # LATIN SMALL LETTER A WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0062, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0062, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0065, 0, 0, 0}, 0x00e8 }, // U00E8 # LATIN SMALL LETTER E WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0069, 0, 0, 0}, 0x00ec }, // U00EC # LATIN SMALL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x006e, 0, 0, 0}, 0x01f9 }, // U01F9 # LATIN SMALL LETTER N WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x006f, 0, 0, 0}, 0x00f2 }, // U00F2 # LATIN SMALL LETTER O WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0075, 0, 0, 0}, 0x00f9 }, // U00F9 # LATIN SMALL LETTER U WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0077, 0, 0, 0}, 0x1e81 }, // U1E81 # LATIN SMALL LETTER W WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0079, 0, 0, 0}, 0x1ef3 }, // U1EF3 # LATIN SMALL LETTER Y WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00af, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00af, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00af, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00af, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00c2, 0, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00ca, 0, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00d4, 0, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00dc, 0, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00e2, 0, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00ea, 0, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00f4, 0, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x00fc, 0, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0102, 0, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0103, 0, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0112, 0, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0113, 0, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x014c, 0, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x014d, 0, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0391, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0395, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0397, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0399, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x039f, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03a9, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b1, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b5, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b7, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b9, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03bf, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03c5, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03c9, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0391, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0395, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0397, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0399, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x039f, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03a5, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03a9, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b1, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b5, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b7, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b9, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03bf, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03c5, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03c9, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0391, 0, 0, 0}, 0x1fba }, // U1FBA # GREEK CAPITAL LETTER ALPHA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0395, 0, 0, 0}, 0x1fc8 }, // U1FC8 # GREEK CAPITAL LETTER EPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0397, 0, 0, 0}, 0x1fca }, // U1FCA # GREEK CAPITAL LETTER ETA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0399, 0, 0, 0}, 0x1fda }, // U1FDA # GREEK CAPITAL LETTER IOTA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x039f, 0, 0, 0}, 0x1ff8 }, // U1FF8 # GREEK CAPITAL LETTER OMICRON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03a5, 0, 0, 0}, 0x1fea }, // U1FEA # GREEK CAPITAL LETTER UPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03a9, 0, 0, 0}, 0x1ffa }, // U1FFA # GREEK CAPITAL LETTER OMEGA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b1, 0, 0, 0}, 0x1f70 }, // U1F70 # GREEK SMALL LETTER ALPHA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b5, 0, 0, 0}, 0x1f72 }, // U1F72 # GREEK SMALL LETTER EPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b7, 0, 0, 0}, 0x1f74 }, // U1F74 # GREEK SMALL LETTER ETA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b9, 0, 0, 0}, 0x1f76 }, // U1F76 # GREEK SMALL LETTER IOTA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03bf, 0, 0, 0}, 0x1f78 }, // U1F78 # GREEK SMALL LETTER OMICRON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03c5, 0, 0, 0}, 0x1f7a }, // U1F7A # GREEK SMALL LETTER UPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03c9, 0, 0, 0}, 0x1f7c }, // U1F7C # GREEK SMALL LETTER OMEGA WITH VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03ca, 0, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03cb, 0, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0415, 0, 0, 0}, 0x0400 }, // U0400 # CYRILLIC CAPITAL LETTER IE WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0418, 0, 0, 0}, 0x040d }, // U040D # CYRILLIC CAPITAL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0435, 0, 0, 0}, 0x0450 }, // U0450 # CYRILLIC SMALL LETTER IE WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0438, 0, 0, 0}, 0x045d }, // U045D # CYRILLIC SMALL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f00, 0, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f01, 0, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f08, 0, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f09, 0, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f10, 0, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f11, 0, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f18, 0, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f19, 0, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f20, 0, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f21, 0, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f28, 0, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f29, 0, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f30, 0, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f31, 0, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f38, 0, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f39, 0, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f40, 0, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f41, 0, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f48, 0, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f49, 0, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f50, 0, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f51, 0, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f59, 0, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f60, 0, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f61, 0, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f68, 0, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f69, 0, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0060, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0061, 0x0065, 0, 0, 0}, 0x00e6 }, // ae
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0000, 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0000, 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0021, 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0021, 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x002c, 0x0045, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x002c, 0x0065, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0, 0}, 0x0102 }, // U0102 # LATIN CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0045, 0, 0, 0}, 0x0114 }, // U0114 # LATIN CAPITAL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0047, 0, 0, 0}, 0x011e }, // U011E # LATIN CAPITAL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0049, 0, 0, 0}, 0x012c }, // U012C # LATIN CAPITAL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x004f, 0, 0, 0}, 0x014e }, // U014E # LATIN CAPITAL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0055, 0, 0, 0}, 0x016c }, // U016C # LATIN CAPITAL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0, 0}, 0x0103 }, // U0103 # LATIN SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0065, 0, 0, 0}, 0x0115 }, // U0115 # LATIN SMALL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0067, 0, 0, 0}, 0x011f }, // U011F # LATIN SMALL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0069, 0, 0, 0}, 0x012d }, // U012D # LATIN SMALL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x006f, 0, 0, 0}, 0x014f }, // U014F # LATIN SMALL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0075, 0, 0, 0}, 0x016d }, // U016D # LATIN SMALL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0228, 0, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0229, 0, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0391, 0, 0, 0}, 0x1fb8 }, // U1FB8 # GREEK CAPITAL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0399, 0, 0, 0}, 0x1fd8 }, // U1FD8 # GREEK CAPITAL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x03a5, 0, 0, 0}, 0x1fe8 }, // U1FE8 # GREEK CAPITAL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x03b1, 0, 0, 0}, 0x1fb0 }, // U1FB0 # GREEK SMALL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x03b9, 0, 0, 0}, 0x1fd0 }, // U1FD0 # GREEK SMALL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x03c5, 0, 0, 0}, 0x1fe0 }, // U1FE0 # GREEK SMALL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0410, 0, 0, 0}, 0x04d0 }, // U04D0 # CYRILLIC CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0415, 0, 0, 0}, 0x04d6 }, // U04D6 # CYRILLIC CAPITAL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0416, 0, 0, 0}, 0x04c1 }, // U04C1 # CYRILLIC CAPITAL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0418, 0, 0, 0}, 0x0419 }, // U0419 # CYRILLIC CAPITAL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0423, 0, 0, 0}, 0x040e }, // U040E # CYRILLIC CAPITAL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0430, 0, 0, 0}, 0x04d1 }, // U04D1 # CYRILLIC SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0435, 0, 0, 0}, 0x04d7 }, // U04D7 # CYRILLIC SMALL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0436, 0, 0, 0}, 0x04c2 }, // U04C2 # CYRILLIC SMALL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0438, 0, 0, 0}, 0x0439 }, // U0439 # CYRILLIC SMALL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0443, 0, 0, 0}, 0x045e }, // U045E # CYRILLIC SMALL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x1ea0, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, 0x1ea1, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, UNITIZE(Qt::Key_Dead_Cedilla), 0x0045, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, UNITIZE(Qt::Key_Dead_Cedilla), 0x0065, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0062, UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0022, 0x0055, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0022, 0x0075, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x002f, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0041, 0, 0, 0}, 0x01cd }, // U01CD # LATIN CAPITAL LETTER A WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0043, 0, 0, 0}, 0x010c }, // U010C # LATIN CAPITAL LETTER C WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0044, 0, 0, 0}, 0x010e }, // U010E # LATIN CAPITAL LETTER D WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0045, 0, 0, 0}, 0x011a }, // U011A # LATIN CAPITAL LETTER E WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0047, 0, 0, 0}, 0x01e6 }, // U01E6 # LATIN CAPITAL LETTER G WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0048, 0, 0, 0}, 0x021e }, // U021E # LATIN CAPITAL LETTER H WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0049, 0, 0, 0}, 0x01cf }, // U01CF # LATIN CAPITAL LETTER I WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x004b, 0, 0, 0}, 0x01e8 }, // U01E8 # LATIN CAPITAL LETTER K WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x004c, 0, 0, 0}, 0x013d }, // U013D # LATIN CAPITAL LETTER L WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x004e, 0, 0, 0}, 0x0147 }, // U0147 # LATIN CAPITAL LETTER N WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x004f, 0, 0, 0}, 0x01d1 }, // U01D1 # LATIN CAPITAL LETTER O WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0052, 0, 0, 0}, 0x0158 }, // U0158 # LATIN CAPITAL LETTER R WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0053, 0, 0, 0}, 0x0160 }, // U0160 # LATIN CAPITAL LETTER S WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0054, 0, 0, 0}, 0x0164 }, // U0164 # LATIN CAPITAL LETTER T WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0055, 0, 0, 0}, 0x01d3 }, // U01D3 # LATIN CAPITAL LETTER U WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x005a, 0, 0, 0}, 0x017d }, // U017D # LATIN CAPITAL LETTER Z WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0061, 0, 0, 0}, 0x01ce }, // U01CE # LATIN SMALL LETTER A WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0063, 0, 0, 0}, 0x010d }, // U010D # LATIN SMALL LETTER C WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0064, 0, 0, 0}, 0x010f }, // U010F # LATIN SMALL LETTER D WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0065, 0, 0, 0}, 0x011b }, // U011B # LATIN SMALL LETTER E WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0067, 0, 0, 0}, 0x01e7 }, // U01E7 # LATIN SMALL LETTER G WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0068, 0, 0, 0}, 0x021f }, // U021F # LATIN SMALL LETTER H WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0069, 0, 0, 0}, 0x01d0 }, // U01D0 # LATIN SMALL LETTER I WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x006a, 0, 0, 0}, 0x01f0 }, // U01F0 # LATIN SMALL LETTER J WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x006b, 0, 0, 0}, 0x01e9 }, // U01E9 # LATIN SMALL LETTER K WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x006c, 0, 0, 0}, 0x013e }, // U013E # LATIN SMALL LETTER L WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x006e, 0, 0, 0}, 0x0148 }, // U0148 # LATIN SMALL LETTER N WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x006f, 0, 0, 0}, 0x01d2 }, // U01D2 # LATIN SMALL LETTER O WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0072, 0, 0, 0}, 0x0159 }, // U0159 # LATIN SMALL LETTER R WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0073, 0, 0, 0}, 0x0161 }, // U0161 # LATIN SMALL LETTER S WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0074, 0, 0, 0}, 0x0165 }, // U0165 # LATIN SMALL LETTER T WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0075, 0, 0, 0}, 0x01d4 }, // U01D4 # LATIN SMALL LETTER U WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x007a, 0, 0, 0}, 0x017e }, // U017E # LATIN SMALL LETTER Z WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x007c, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x00dc, 0, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x00fc, 0, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x01b7, 0, 0, 0}, 0x01ee }, // U01EE # LATIN CAPITAL LETTER EZH WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0292, 0, 0, 0}, 0x01ef }, // U01EF # LATIN SMALL LETTER EZH WITH CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0063, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Multi_key), 0x0064, 0x002d, 0, 0, 0}, 0x20ab }, // U20ab # DONG SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0064, 0x0068, 0, 0, 0}, 0x00f0 }, // U00F0 # LATIN SMALL LETTER ETH
+    { {UNITIZE(Qt::Key_Multi_key), 0x0065, 0x0065, 0, 0, 0}, 0x0259 }, // U0259 # LATIN SMALL LETTER SCHWA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0066, 0x0053, 0, 0, 0}, 0x017f }, // U017f # LONG S
+    { {UNITIZE(Qt::Key_Multi_key), 0x0066, 0x0073, 0, 0, 0}, 0x017f }, // U017f # LONG S
+    { {UNITIZE(Qt::Key_Multi_key), 0x0069, 0x002e, 0, 0, 0}, 0x0131 }, // U0131 # LATIN SMALL LETTER DOTLESS I
+    { {UNITIZE(Qt::Key_Multi_key), 0x006b, 0x006b, 0, 0, 0}, 0x0138 }, // U0138 # LATIN SMALL LETTER KRA
+    { {UNITIZE(Qt::Key_Multi_key), 0x006c, 0x0076, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x006d, 0x002f, 0, 0, 0}, 0x20a5 }, // U20a5 # MILL SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x006d, 0x0075, 0, 0, 0}, 0x00b5 }, // U00B5 # MICRO SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x006e, 0x0067, 0, 0, 0}, 0x014b }, // U014B # LATIN SMALL LETTER ENG
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0027, 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0027, 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0041, 0, 0, 0}, 0x00c5 }, // U00C5 # LATIN CAPITAL LETTER A WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0043, 0, 0, 0}, 0x00a9 }, // copyright
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0052, 0, 0, 0}, 0x00ae }, // registered
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0055, 0, 0, 0}, 0x016e }, // U016E # LATIN CAPITAL LETTER U WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0061, 0, 0, 0}, 0x00e5 }, // U00E5 # LATIN SMALL LETTER A WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0063, 0, 0, 0}, 0x00a9 }, // copyright
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0065, 0, 0, 0}, 0x0153 }, // oe
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x006f, 0, 0, 0}, 0x00b0 }, // degree # ^0 already taken
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0072, 0, 0, 0}, 0x00ae }, // registered
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0073, 0, 0, 0}, 0x00a7 }, // section # SECTION SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0075, 0, 0, 0}, 0x016f }, // U016F # LATIN SMALL LETTER U WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0077, 0, 0, 0}, 0x1e98 }, // U1E98 # LATIN SMALL LETTER W WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0078, 0, 0, 0}, 0x00a4 }, // currency
+    { {UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0079, 0, 0, 0}, 0x1e99 }, // U1E99 # LATIN SMALL LETTER Y WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0070, 0x0021, 0, 0, 0}, 0x00b6 }, // paragraph
+    { {UNITIZE(Qt::Key_Multi_key), 0x0073, 0x006f, 0, 0, 0}, 0x00a7 }, // section # SECTION SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0073, 0x0073, 0, 0, 0}, 0x00df }, // ssharp
+    { {UNITIZE(Qt::Key_Multi_key), 0x0074, 0x0068, 0, 0, 0}, 0x00fe }, // U00FE # LATIN SMALL LETTER THORN
+    { {UNITIZE(Qt::Key_Multi_key), 0x0076, 0x006c, 0, 0, 0}, 0x007c }, // bar
+    { {UNITIZE(Qt::Key_Multi_key), 0x0078, 0x006f, 0, 0, 0}, 0x00a4 }, // currency
+    { {UNITIZE(Qt::Key_Multi_key), 0x0078, 0x0078, 0, 0, 0}, 0x00d7 }, // U00D7 # MULTIPLICATION SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x007c, 0x0043, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+    { {UNITIZE(Qt::Key_Multi_key), 0x007c, 0x0063, 0, 0, 0}, 0x00a2 }, // U00A2 # CENT SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0000, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0000, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0000, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0000, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0020, 0, 0, 0}, 0x007e }, // asciitilde
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0022, 0x03b9, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0022, 0x03c5, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x0391, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x0397, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x0399, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03a5, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03a9, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03b1, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03b7, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03b9, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03c5, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03c9, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x0391, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x0397, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x0399, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03a9, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03b1, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03b7, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03b9, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03c5, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03c9, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x002b, 0x004f, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x002b, 0x0055, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x002b, 0x006f, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x002b, 0x0075, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0041, 0, 0, 0}, 0x00c3 }, // U00C3 # LATIN CAPITAL LETTER A WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0045, 0, 0, 0}, 0x1ebc }, // U1EBC # LATIN CAPITAL LETTER E WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0049, 0, 0, 0}, 0x0128 }, // U0128 # LATIN CAPITAL LETTER I WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004e, 0, 0, 0}, 0x00d1 }, // U00D1 # LATIN CAPITAL LETTER N WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004f, 0, 0, 0}, 0x00d5 }, // U00D5 # LATIN CAPITAL LETTER O WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0055, 0, 0, 0}, 0x0168 }, // U0168 # LATIN CAPITAL LETTER U WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0055, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0055, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0056, 0, 0, 0}, 0x1e7c }, // U1E7C # LATIN CAPITAL LETTER V WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0059, 0, 0, 0}, 0x1ef8 }, // U1EF8 # LATIN CAPITAL LETTER Y WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x0041, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x0045, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x004f, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x0061, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x0065, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x005e, 0x006f, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0061, 0, 0, 0}, 0x00e3 }, // U00E3 # LATIN SMALL LETTER A WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0062, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0062, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0065, 0, 0, 0}, 0x1ebd }, // U1EBD # LATIN SMALL LETTER E WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0069, 0, 0, 0}, 0x0129 }, // U0129 # LATIN SMALL LETTER I WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006e, 0, 0, 0}, 0x00f1 }, // U00F1 # LATIN SMALL LETTER N WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006f, 0, 0, 0}, 0x00f5 }, // U00F5 # LATIN SMALL LETTER O WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0075, 0, 0, 0}, 0x0169 }, // U0169 # LATIN SMALL LETTER U WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0076, 0, 0, 0}, 0x1e7d }, // U1E7D # LATIN SMALL LETTER V WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0079, 0, 0, 0}, 0x1ef9 }, // U1EF9 # LATIN SMALL LETTER Y WITH TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00c2, 0, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00ca, 0, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00d4, 0, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00e2, 0, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00ea, 0, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x00f4, 0, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0102, 0, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0103, 0, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x0391, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x0397, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x0399, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03a9, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03b1, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03b7, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03b9, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03c5, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03c9, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x0391, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x0397, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x0399, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03a5, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03a9, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03b1, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03b7, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03b9, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03c5, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03c9, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03b1, 0, 0, 0}, 0x1fb6 }, // U1FB6 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03b7, 0, 0, 0}, 0x1fc6 }, // U1FC6 # GREEK SMALL LETTER ETA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03b9, 0, 0, 0}, 0x1fd6 }, // U1FD6 # GREEK SMALL LETTER IOTA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03c5, 0, 0, 0}, 0x1fe6 }, // U1FE6 # GREEK SMALL LETTER UPSILON WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03c9, 0, 0, 0}, 0x1ff6 }, // U1FF6 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03ca, 0, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03cb, 0, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f00, 0, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f01, 0, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f08, 0, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f09, 0, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f20, 0, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f21, 0, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f28, 0, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f29, 0, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f30, 0, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f31, 0, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f38, 0, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f39, 0, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f50, 0, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f51, 0, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f59, 0, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f60, 0, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f61, 0, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f68, 0, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f69, 0, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x007e, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x0000, 0, 0, 0}, 0x0385 }, // U0385 # GREEK DIALYTIKA TONOS
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x0000, 0, 0, 0}, 0x1fed }, // U1FED # GREEK DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x0027, 0, 0, 0}, 0x0385 }, // U0385 # GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x0060, 0, 0, 0}, 0x1fed }, // U1FED # GREEK DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x007e, 0, 0, 0}, 0x1fc1 }, // U1FC1 # GREEK DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x00b4, 0, 0, 0}, 0x0385 }, // U0385 # GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, 0x0342, 0, 0, 0}, 0x1fc1 }, // U1FC1 # GREEK DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, UNITIZE(Qt::Key_Dead_Grave), 0, 0, 0}, 0x1fed }, // U1FED # GREEK DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, UNITIZE(Qt::Key_Dead_Acute), 0, 0, 0}, 0x0385 }, // U0385 # GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00a8, UNITIZE(Qt::Key_Dead_Tilde), 0, 0, 0}, 0x1fc1 }, // U1FC1 # GREEK DIALYTIKA AND PERISPOMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0000, 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0021, 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0021, 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0021, 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0021, 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x0041, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x004f, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x0055, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x0061, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x006f, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0022, 0x0075, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x002e, 0x0041, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x002e, 0x004f, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x002e, 0x0061, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x002e, 0x006f, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x003b, 0x004f, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x003b, 0x006f, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0041, 0, 0, 0}, 0x0100 }, // U0100 # LATIN CAPITAL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0045, 0, 0, 0}, 0x0112 }, // U0112 # LATIN CAPITAL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0047, 0, 0, 0}, 0x1e20 }, // U1E20 # LATIN CAPITAL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0049, 0, 0, 0}, 0x012a }, // U012A # LATIN CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x004f, 0, 0, 0}, 0x014c }, // U014C # LATIN CAPITAL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0055, 0, 0, 0}, 0x016a }, // U016A # LATIN CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0059, 0, 0, 0}, 0x0232 }, // U0232 # LATIN CAPITAL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0061, 0, 0, 0}, 0x0101 }, // U0101 # LATIN SMALL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0065, 0, 0, 0}, 0x0113 }, // U0113 # LATIN SMALL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0067, 0, 0, 0}, 0x1e21 }, // U1E21 # LATIN SMALL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0069, 0, 0, 0}, 0x012b }, // U012B # LATIN SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x006f, 0, 0, 0}, 0x014d }, // U014D # LATIN SMALL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0075, 0, 0, 0}, 0x016b }, // U016B # LATIN SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0079, 0, 0, 0}, 0x0233 }, // U0233 # LATIN SMALL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x007e, 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x007e, 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00c4, 0, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00c6, 0, 0, 0}, 0x01e2 }, // U01E2 # LATIN CAPITAL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00d5, 0, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00d6, 0, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00dc, 0, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00e4, 0, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00e6, 0, 0, 0}, 0x01e3 }, // U01E3 # LATIN SMALL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00f5, 0, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00f6, 0, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x00fc, 0, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x01ea, 0, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x01eb, 0, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0226, 0, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0227, 0, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x022e, 0, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x022f, 0, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0391, 0, 0, 0}, 0x1fb9 }, // U1FB9 # GREEK CAPITAL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0399, 0, 0, 0}, 0x1fd9 }, // U1FD9 # GREEK CAPITAL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x03a5, 0, 0, 0}, 0x1fe9 }, // U1FE9 # GREEK CAPITAL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x03b1, 0, 0, 0}, 0x1fb1 }, // U1FB1 # GREEK SMALL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x03b9, 0, 0, 0}, 0x1fd1 }, // U1FD1 # GREEK SMALL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x03c5, 0, 0, 0}, 0x1fe1 }, // U1FE1 # GREEK SMALL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0418, 0, 0, 0}, 0x04e2 }, // U04E2 # CYRILLIC CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0423, 0, 0, 0}, 0x04ee }, // U04EE # CYRILLIC CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0438, 0, 0, 0}, 0x04e3 }, // U04E3 # CYRILLIC SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0443, 0, 0, 0}, 0x04ef }, // U04EF # CYRILLIC SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x1e36, 0, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x1e37, 0, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x1e5a, 0, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, 0x1e5b, 0, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Abovedot), 0x0041, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Abovedot), 0x004f, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Abovedot), 0x0061, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Abovedot), 0x006f, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0041, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x004f, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0061, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x006f, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Ogonek), 0x004f, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Ogonek), 0x006f, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Belowdot), 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Belowdot), 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Belowdot), 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Multi_key), 0x00af, UNITIZE(Qt::Key_Dead_Belowdot), 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0000, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0022, 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002b, 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002b, 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002b, 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002b, 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002c, 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002c, 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002f, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x002f, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0041, 0, 0, 0}, 0x00c1 }, // U00C1 # LATIN CAPITAL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0043, 0, 0, 0}, 0x0106 }, // U0106 # LATIN CAPITAL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0045, 0, 0, 0}, 0x00c9 }, // U00C9 # LATIN CAPITAL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0047, 0, 0, 0}, 0x01f4 }, // U01F4 # LATIN CAPITAL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0049, 0, 0, 0}, 0x00cd }, // U00CD # LATIN CAPITAL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x004b, 0, 0, 0}, 0x1e30 }, // U1E30 # LATIN CAPITAL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x004c, 0, 0, 0}, 0x0139 }, // U0139 # LATIN CAPITAL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x004d, 0, 0, 0}, 0x1e3e }, // U1E3E # LATIN CAPITAL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x004e, 0, 0, 0}, 0x0143 }, // U0143 # LATIN CAPITAL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x004f, 0, 0, 0}, 0x00d3 }, // U00D3 # LATIN CAPITAL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0050, 0, 0, 0}, 0x1e54 }, // U1E54 # LATIN CAPITAL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0052, 0, 0, 0}, 0x0154 }, // U0154 # LATIN CAPITAL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0053, 0, 0, 0}, 0x015a }, // U015A # LATIN CAPITAL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0055, 0, 0, 0}, 0x00da }, // U00DA # LATIN CAPITAL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0055, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0055, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0057, 0, 0, 0}, 0x1e82 }, // U1E82 # LATIN CAPITAL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0059, 0, 0, 0}, 0x00dd }, // U00DD # LATIN CAPITAL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005a, 0, 0, 0}, 0x0179 }, // U0179 # LATIN CAPITAL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005e, 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005f, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005f, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005f, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x005f, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0061, 0, 0, 0}, 0x00e1 }, // U00E1 # LATIN SMALL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0062, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0062, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0063, 0, 0, 0}, 0x0107 }, // U0107 # LATIN SMALL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0065, 0, 0, 0}, 0x00e9 }, // U00E9 # LATIN SMALL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0067, 0, 0, 0}, 0x01f5 }, // U01F5 # LATIN SMALL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0069, 0, 0, 0}, 0x00ed }, // U00ED # LATIN SMALL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006b, 0, 0, 0}, 0x1e31 }, // U1E31 # LATIN SMALL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006c, 0, 0, 0}, 0x013a }, // U013A # LATIN SMALL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006d, 0, 0, 0}, 0x1e3f }, // U1E3F # LATIN SMALL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006e, 0, 0, 0}, 0x0144 }, // U0144 # LATIN SMALL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006f, 0, 0, 0}, 0x00f3 }, // U00F3 # LATIN SMALL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006f, 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x006f, 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0070, 0, 0, 0}, 0x1e55 }, // U1E55 # LATIN SMALL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0072, 0, 0, 0}, 0x0155 }, // U0155 # LATIN SMALL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0073, 0, 0, 0}, 0x015b }, // U015B # LATIN SMALL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0075, 0, 0, 0}, 0x00fa }, // U00FA # LATIN SMALL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0077, 0, 0, 0}, 0x1e83 }, // U1E83 # LATIN SMALL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0079, 0, 0, 0}, 0x00fd }, // U00FD # LATIN SMALL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x007a, 0, 0, 0}, 0x017a }, // U017A # LATIN SMALL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x007e, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x007e, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x007e, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x007e, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00af, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00af, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00af, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00af, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00c2, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00c5, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00c6, 0, 0, 0}, 0x01fc }, // U01FC # LATIN CAPITAL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00c7, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00ca, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00cf, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00d4, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00d5, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00d8, 0, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00dc, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00e2, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00e5, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00e6, 0, 0, 0}, 0x01fd }, // U01FD # LATIN SMALL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00e7, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00ea, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00ef, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00f4, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00f5, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00f8, 0, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x00fc, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0102, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0103, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0112, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0113, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x014c, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x014d, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0168, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0169, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0391, 0, 0, 0}, 0x0386 }, // U0386 # GREEK CAPITAL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0395, 0, 0, 0}, 0x0388 }, // U0388 # GREEK CAPITAL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0397, 0, 0, 0}, 0x0389 }, // U0389 # GREEK CAPITAL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0399, 0, 0, 0}, 0x038a }, // U038A # GREEK CAPITAL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x039f, 0, 0, 0}, 0x038c }, // U038C # GREEK CAPITAL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03a5, 0, 0, 0}, 0x038e }, // U038E # GREEK CAPITAL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03a9, 0, 0, 0}, 0x038f }, // U038F # GREEK CAPITAL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b1, 0, 0, 0}, 0x03ac }, // U03AC # GREEK SMALL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b5, 0, 0, 0}, 0x03ad }, // U03AD # GREEK SMALL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b7, 0, 0, 0}, 0x03ae }, // U03AE # GREEK SMALL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b9, 0, 0, 0}, 0x03af }, // U03AF # GREEK SMALL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03bf, 0, 0, 0}, 0x03cc }, // U03CC # GREEK SMALL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03c5, 0, 0, 0}, 0x03cd }, // U03CD # GREEK SMALL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03c9, 0, 0, 0}, 0x03ce }, // U03CE # GREEK SMALL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03ca, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03cb, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03d2, 0, 0, 0}, 0x03d3 }, // U03D3 # GREEK UPSILON WITH ACUTE AND HOOK SYMBOL
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0413, 0, 0, 0}, 0x0403 }, // U0403 # CYRILLIC CAPITAL LETTER GJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x041a, 0, 0, 0}, 0x040c }, // U040C # CYRILLIC CAPITAL LETTER KJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0433, 0, 0, 0}, 0x0453 }, // U0453 # CYRILLIC SMALL LETTER GJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x043a, 0, 0, 0}, 0x045c }, // U045C # CYRILLIC SMALL LETTER KJE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f00, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f01, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f08, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f09, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f10, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f11, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f18, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f19, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f20, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f21, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f28, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f29, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f30, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f31, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f38, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f39, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f40, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f41, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f48, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f49, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f50, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f51, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f59, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f60, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f61, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f68, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f69, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Tilde), 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Tilde), 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Abovering), 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Abovering), 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Cedilla), 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Cedilla), 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Multi_key), 0x00b4, UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0313, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x0314, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03b1, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03b7, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x03c9, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f00, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f01, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f08, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f09, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f20, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f21, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f28, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f29, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f60, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f61, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f68, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0000, 0x1f69, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0027, 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x0391, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x0397, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x03a9, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x03b1, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x03b7, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0028, 0x03c9, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x0391, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x0397, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x03a9, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x03b1, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x03b7, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0029, 0x03c9, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0313, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x0314, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x03b1, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x03b7, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x03c9, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f00, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f01, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f08, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f09, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f20, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f21, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f28, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f29, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f60, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f61, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f68, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0060, 0x1f69, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0313, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x0314, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x03b1, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x03b7, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x03c9, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f00, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f01, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f08, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f09, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f20, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f21, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f28, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f29, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f60, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f61, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f68, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x007e, 0x1f69, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x00b4, 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x0391, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x0397, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x03a9, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x03b1, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x03b7, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0313, 0x03c9, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x0391, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x0397, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x03a9, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x03b1, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x03b7, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0314, 0x03c9, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0313, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x0314, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x03b1, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x03b7, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x03c9, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f00, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f01, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f08, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f09, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f20, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f21, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f28, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f29, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f60, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f61, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f68, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0342, 0x1f69, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0391, 0, 0, 0}, 0x1fbc }, // U1FBC # GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x0397, 0, 0, 0}, 0x1fcc }, // U1FCC # GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03a9, 0, 0, 0}, 0x1ffc }, // U1FFC # GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03ac, 0, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03ae, 0, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03b1, 0, 0, 0}, 0x1fb3 }, // U1FB3 # GREEK SMALL LETTER ALPHA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03b7, 0, 0, 0}, 0x1fc3 }, // U1FC3 # GREEK SMALL LETTER ETA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03c9, 0, 0, 0}, 0x1ff3 }, // U1FF3 # GREEK SMALL LETTER OMEGA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x03ce, 0, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f00, 0, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f01, 0, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f02, 0, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f03, 0, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f04, 0, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f05, 0, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f06, 0, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f07, 0, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f08, 0, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f09, 0, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0a, 0, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0b, 0, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0c, 0, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0d, 0, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0e, 0, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f0f, 0, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f20, 0, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f21, 0, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f22, 0, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f23, 0, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f24, 0, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f25, 0, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f26, 0, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f27, 0, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f28, 0, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f29, 0, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2a, 0, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2b, 0, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2c, 0, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2d, 0, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2e, 0, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f2f, 0, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f60, 0, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f61, 0, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f62, 0, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f63, 0, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f64, 0, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f65, 0, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f66, 0, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f67, 0, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f68, 0, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f69, 0, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6a, 0, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6b, 0, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6c, 0, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6d, 0, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6e, 0, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f6f, 0, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f70, 0, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f74, 0, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1f7c, 0, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1fb6, 0, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1fc6, 0, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, 0x1ff6, 0, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x03b1, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x03b7, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x03c9, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f00, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f01, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f08, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f09, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f20, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f21, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f28, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f29, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f60, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f61, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f68, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Grave), 0x1f69, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Acute), 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x03b1, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x03b7, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x03c9, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f00, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f01, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f08, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f09, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f20, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f21, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f28, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f29, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f60, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f61, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f68, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x03b9, UNITIZE(Qt::Key_Dead_Tilde), 0x1f69, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x05b4, 0x05d9, 0, 0, 0}, 0xfb1d }, // UFB1D # HEBREW LETTER YOD WITH HIRIQ
+    { {UNITIZE(Qt::Key_Multi_key), 0x05b7, 0x05d0, 0, 0, 0}, 0xfb2e }, // UFB2E # HEBREW LETTER ALEF WITH PATAH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05b7, 0x05f2, 0, 0, 0}, 0xfb1f }, // UFB1F # HEBREW LIGATURE YIDDISH YOD YOD PATAH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05b8, 0x05d0, 0, 0, 0}, 0xfb2f }, // UFB2F # HEBREW LETTER ALEF WITH QAMATS
+    { {UNITIZE(Qt::Key_Multi_key), 0x05b9, 0x05d5, 0, 0, 0}, 0xfb4b }, // UFB4B # HEBREW LETTER VAV WITH HOLAM
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d0, 0, 0, 0}, 0xfb30 }, // UFB30 # HEBREW LETTER ALEF WITH MAPIQ
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d1, 0, 0, 0}, 0xfb31 }, // UFB31 # HEBREW LETTER BET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d1, 0, 0, 0}, 0xfb31 }, // UFB31 # HEBREW LETTER BET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d2, 0, 0, 0}, 0xfb32 }, // UFB32 # HEBREW LETTER GIMEL WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d2, 0, 0, 0}, 0xfb32 }, // UFB32 # HEBREW LETTER GIMEL WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d3, 0, 0, 0}, 0xfb33 }, // UFB33 # HEBREW LETTER DALET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d3, 0, 0, 0}, 0xfb33 }, // UFB33 # HEBREW LETTER DALET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d4, 0, 0, 0}, 0xfb34 }, // UFB34 # HEBREW LETTER HE WITH MAPIQ
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d5, 0, 0, 0}, 0xfb35 }, // UFB35 # HEBREW LETTER VAV WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d6, 0, 0, 0}, 0xfb36 }, // UFB36 # HEBREW LETTER ZAYIN WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d6, 0, 0, 0}, 0xfb36 }, // UFB36 # HEBREW LETTER ZAYIN WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d8, 0, 0, 0}, 0xfb38 }, // UFB38 # HEBREW LETTER TET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d8, 0, 0, 0}, 0xfb38 }, // UFB38 # HEBREW LETTER TET WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05d9, 0, 0, 0}, 0xfb39 }, // UFB39 # HEBREW LETTER YOD WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05da, 0, 0, 0}, 0xfb3a }, // UFB3A # HEBREW LETTER FINAL KAF WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05db, 0, 0, 0}, 0xfb3b }, // UFB3B # HEBREW LETTER KAF WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05dc, 0, 0, 0}, 0xfb3c }, // UFB3C # HEBREW LETTER LAMED WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05de, 0, 0, 0}, 0xfb3e }, // UFB3E # HEBREW LETTER MEM WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e0, 0, 0, 0}, 0xfb40 }, // UFB40 # HEBREW LETTER NUN WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e1, 0, 0, 0}, 0xfb41 }, // UFB41 # HEBREW LETTER SAMEKH WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e1, 0, 0, 0}, 0xfb41 }, // UFB41 # HEBREW LETTER SAMEKH WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e3, 0, 0, 0}, 0xfb43 }, // UFB43 # HEBREW LETTER FINAL PE WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e4, 0, 0, 0}, 0xfb44 }, // UFB44 # HEBREW LETTER PE WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e6, 0, 0, 0}, 0xfb46 }, // UFB46 # HEBREW LETTER TSADI WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e6, 0, 0, 0}, 0xfb46 }, // UFB46 # HEBREW LETTER TSADI WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e7, 0, 0, 0}, 0xfb47 }, // UFB47 # HEBREW LETTER QOF WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e7, 0, 0, 0}, 0xfb47 }, // UFB47 # HEBREW LETTER QOF WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e8, 0, 0, 0}, 0xfb48 }, // UFB48 # HEBREW LETTER RESH WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05e9, 0, 0, 0}, 0xfb49 }, // UFB49 # HEBREW LETTER SHIN WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05ea, 0, 0, 0}, 0xfb4a }, // UFB4A # HEBREW LETTER TAV WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bc, 0x05ea, 0, 0, 0}, 0xfb4a }, // UFB4A # HEBREW LETTER TAV WITH DAGESH
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bf, 0x05d1, 0, 0, 0}, 0xfb4c }, // UFB4C # HEBREW LETTER BET WITH RAFE
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bf, 0x05d1, 0, 0, 0}, 0xfb4c }, // UFB4C # HEBREW LETTER BET WITH RAFE
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bf, 0x05db, 0, 0, 0}, 0xfb4d }, // UFB4D # HEBREW LETTER KAF WITH RAFE
+    { {UNITIZE(Qt::Key_Multi_key), 0x05bf, 0x05e4, 0, 0, 0}, 0xfb4e }, // UFB4E # HEBREW LETTER PE WITH RAFE
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c1, 0x05bc, 0x05e9, 0, 0}, 0xfb2c }, // UFB2C # HEBREW LETTER SHIN WITH DAGESH AND SHIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c1, 0x05e9, 0, 0, 0}, 0xfb2a }, // UFB2A # HEBREW LETTER SHIN WITH SHIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c1, 0xfb49, 0, 0, 0}, 0xfb2c }, // UFB2C # HEBREW LETTER SHIN WITH DAGESH AND SHIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c2, 0x05bc, 0x05e9, 0, 0}, 0xfb2d }, // UFB2D # HEBREW LETTER SHIN WITH DAGESH AND SIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c2, 0x05e9, 0, 0, 0}, 0xfb2b }, // UFB2B # HEBREW LETTER SHIN WITH SIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x05c2, 0xfb49, 0, 0, 0}, 0xfb2d }, // UFB2D # HEBREW LETTER SHIN WITH DAGESH AND SIN DOT
+    { {UNITIZE(Qt::Key_Multi_key), 0x0653, 0x0627, 0, 0, 0}, 0x0622 }, // U0622 # ARABIC LETTER ALEF WITH MADDA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x0627, 0, 0, 0}, 0x0623 }, // U0623 # ARABIC LETTER ALEF WITH HAMZA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x0648, 0, 0, 0}, 0x0624 }, // U0624 # ARABIC LETTER WAW WITH HAMZA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x064a, 0, 0, 0}, 0x0626 }, // U0626 # ARABIC LETTER YEH WITH HAMZA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x06c1, 0, 0, 0}, 0x06c2 }, // U06C2 # ARABIC LETTER HEH GOAL WITH HAMZA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x06d2, 0, 0, 0}, 0x06d3 }, // U06D3 # ARABIC LETTER YEH BARREE WITH HAMZA ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0654, 0x06d5, 0, 0, 0}, 0x06c0 }, // U06C0 # ARABIC LETTER HEH WITH YEH ABOVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0655, 0x0627, 0, 0, 0}, 0x0625 }, // U0625 # ARABIC LETTER ALEF WITH HAMZA BELOW
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0915, 0, 0, 0}, 0x0958 }, // U0958 # DEVANAGARI LETTER QA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0916, 0, 0, 0}, 0x0959 }, // U0959 # DEVANAGARI LETTER KHHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0917, 0, 0, 0}, 0x095a }, // U095A # DEVANAGARI LETTER GHHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x091c, 0, 0, 0}, 0x095b }, // U095B # DEVANAGARI LETTER ZA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0921, 0, 0, 0}, 0x095c }, // U095C # DEVANAGARI LETTER DDDHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0922, 0, 0, 0}, 0x095d }, // U095D # DEVANAGARI LETTER RHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0928, 0, 0, 0}, 0x0929 }, // U0929 # DEVANAGARI LETTER NNNA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x092b, 0, 0, 0}, 0x095e }, // U095E # DEVANAGARI LETTER FA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x092f, 0, 0, 0}, 0x095f }, // U095F # DEVANAGARI LETTER YYA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0930, 0, 0, 0}, 0x0931 }, // U0931 # DEVANAGARI LETTER RRA
+    { {UNITIZE(Qt::Key_Multi_key), 0x093c, 0x0933, 0, 0, 0}, 0x0934 }, // U0934 # DEVANAGARI LETTER LLLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x09bc, 0x09a1, 0, 0, 0}, 0x09dc }, // U09DC # BENGALI LETTER RRA
+    { {UNITIZE(Qt::Key_Multi_key), 0x09bc, 0x09a2, 0, 0, 0}, 0x09dd }, // U09DD # BENGALI LETTER RHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x09bc, 0x09af, 0, 0, 0}, 0x09df }, // U09DF # BENGALI LETTER YYA
+    { {UNITIZE(Qt::Key_Multi_key), 0x09c7, 0x09be, 0, 0, 0}, 0x09cb }, // U09CB # BENGALI VOWEL SIGN O
+    { {UNITIZE(Qt::Key_Multi_key), 0x09c7, 0x09d7, 0, 0, 0}, 0x09cc }, // U09CC # BENGALI VOWEL SIGN AU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a16, 0, 0, 0}, 0x0a59 }, // U0A59 # GURMUKHI LETTER KHHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a17, 0, 0, 0}, 0x0a5a }, // U0A5A # GURMUKHI LETTER GHHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a1c, 0, 0, 0}, 0x0a5b }, // U0A5B # GURMUKHI LETTER ZA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a2b, 0, 0, 0}, 0x0a5e }, // U0A5E # GURMUKHI LETTER FA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a32, 0, 0, 0}, 0x0a33 }, // U0A33 # GURMUKHI LETTER LLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0a3c, 0x0a38, 0, 0, 0}, 0x0a36 }, // U0A36 # GURMUKHI LETTER SHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0b3c, 0x0b21, 0, 0, 0}, 0x0b5c }, // U0B5C # ORIYA LETTER RRA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0b3c, 0x0b22, 0, 0, 0}, 0x0b5d }, // U0B5D # ORIYA LETTER RHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0b47, 0x0b3e, 0, 0, 0}, 0x0b4b }, // U0B4B # ORIYA VOWEL SIGN O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0b47, 0x0b56, 0, 0, 0}, 0x0b48 }, // U0B48 # ORIYA VOWEL SIGN AI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0b47, 0x0b57, 0, 0, 0}, 0x0b4c }, // U0B4C # ORIYA VOWEL SIGN AU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0bc6, 0x0bbe, 0, 0, 0}, 0x0bca }, // U0BCA # TAMIL VOWEL SIGN O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0bc6, 0x0bd7, 0, 0, 0}, 0x0bcc }, // U0BCC # TAMIL VOWEL SIGN AU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0bc7, 0x0bbe, 0, 0, 0}, 0x0bcb }, // U0BCB # TAMIL VOWEL SIGN OO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0bd7, 0x0b92, 0, 0, 0}, 0x0b94 }, // U0B94 # TAMIL LETTER AU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0c46, 0x0c56, 0, 0, 0}, 0x0c48 }, // U0C48 # TELUGU VOWEL SIGN AI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cbf, 0x0cd5, 0, 0, 0}, 0x0cc0 }, // U0CC0 # KANNADA VOWEL SIGN II
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cc6, 0x0cc2, 0, 0, 0}, 0x0cca }, // U0CCA # KANNADA VOWEL SIGN O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cc6, 0x0cc2, 0x0cd5, 0, 0}, 0x0ccb }, // U0CCB # KANNADA VOWEL SIGN OO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cc6, 0x0cd5, 0, 0, 0}, 0x0cc7 }, // U0CC7 # KANNADA VOWEL SIGN EE
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cc6, 0x0cd6, 0, 0, 0}, 0x0cc8 }, // U0CC8 # KANNADA VOWEL SIGN AI
+    { {UNITIZE(Qt::Key_Multi_key), 0x0cca, 0x0cd5, 0, 0, 0}, 0x0ccb }, // U0CCB # KANNADA VOWEL SIGN OO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0d46, 0x0d3e, 0, 0, 0}, 0x0d4a }, // U0D4A # MALAYALAM VOWEL SIGN O
+    { {UNITIZE(Qt::Key_Multi_key), 0x0d46, 0x0d57, 0, 0, 0}, 0x0d4c }, // U0D4C # MALAYALAM VOWEL SIGN AU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0d47, 0x0d3e, 0, 0, 0}, 0x0d4b }, // U0D4B # MALAYALAM VOWEL SIGN OO
+    { {UNITIZE(Qt::Key_Multi_key), 0x0dd9, 0x0dca, 0, 0, 0}, 0x0dda }, // U0DDA # SINHALA VOWEL SIGN DIGA KOMBUVA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0dd9, 0x0dcf, 0, 0, 0}, 0x0ddc }, // U0DDC # SINHALA VOWEL SIGN KOMBUVA HAA AELA-PILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0dd9, 0x0dcf, 0x0dca, 0, 0}, 0x0ddd }, // U0DDD # SINHALA VOWEL SIGN KOMBUVA HAA DIGA AELA-PILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0dd9, 0x0ddf, 0, 0, 0}, 0x0dde }, // U0DDE # SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0ddc, 0x0dca, 0, 0, 0}, 0x0ddd }, // U0DDD # SINHALA VOWEL SIGN KOMBUVA HAA DIGA AELA-PILLA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f71, 0x0f72, 0, 0, 0}, 0x0f73 }, // U0F73 # TIBETAN VOWEL SIGN II
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f71, 0x0f74, 0, 0, 0}, 0x0f75 }, // U0F75 # TIBETAN VOWEL SIGN UU
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f71, 0x0f80, 0, 0, 0}, 0x0f81 }, // U0F81 # TIBETAN VOWEL SIGN REVERSED II
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f90, 0x0fb5, 0, 0, 0}, 0x0fb9 }, // U0FB9 # TIBETAN SUBJOINED LETTER KSSA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f92, 0x0fb7, 0, 0, 0}, 0x0f93 }, // U0F93 # TIBETAN SUBJOINED LETTER GHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0f9c, 0x0fb7, 0, 0, 0}, 0x0f9d }, // U0F9D # TIBETAN SUBJOINED LETTER DDHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fa1, 0x0fb7, 0, 0, 0}, 0x0fa2 }, // U0FA2 # TIBETAN SUBJOINED LETTER DHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fa6, 0x0fb7, 0, 0, 0}, 0x0fa7 }, // U0FA7 # TIBETAN SUBJOINED LETTER BHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fab, 0x0fb7, 0, 0, 0}, 0x0fac }, // U0FAC # TIBETAN SUBJOINED LETTER DZHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb2, 0x0f80, 0, 0, 0}, 0x0f76 }, // U0F76 # TIBETAN VOWEL SIGN VOCALIC R
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb3, 0x0f80, 0, 0, 0}, 0x0f78 }, // U0F78 # TIBETAN VOWEL SIGN VOCALIC L
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb5, 0x0f40, 0, 0, 0}, 0x0f69 }, // U0F69 # TIBETAN LETTER KSSA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb7, 0x0f42, 0, 0, 0}, 0x0f43 }, // U0F43 # TIBETAN LETTER GHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb7, 0x0f4c, 0, 0, 0}, 0x0f4d }, // U0F4D # TIBETAN LETTER DDHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb7, 0x0f51, 0, 0, 0}, 0x0f52 }, // U0F52 # TIBETAN LETTER DHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb7, 0x0f56, 0, 0, 0}, 0x0f57 }, // U0F57 # TIBETAN LETTER BHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x0fb7, 0x0f5b, 0, 0, 0}, 0x0f5c }, // U0F5C # TIBETAN LETTER DZHA
+    { {UNITIZE(Qt::Key_Multi_key), 0x102e, 0x1025, 0, 0, 0}, 0x1026 }, // U1026 # MYANMAR LETTER UU
+    { {UNITIZE(Qt::Key_Multi_key), 0x1100, 0x1100, 0, 0, 0}, 0x1101 }, // U1101	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1102, 0x1100, 0, 0, 0}, 0x1113 }, // U1113	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1102, 0x1102, 0, 0, 0}, 0x1114 }, // U1114	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1102, 0x1103, 0, 0, 0}, 0x1115 }, // U1115	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1102, 0x1107, 0, 0, 0}, 0x1116 }, // U1116	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1103, 0x1100, 0, 0, 0}, 0x1117 }, // U1117	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1103, 0x1103, 0, 0, 0}, 0x1104 }, // U1104	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1105, 0x1102, 0, 0, 0}, 0x1118 }, // U1118	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1105, 0x1105, 0, 0, 0}, 0x1119 }, // U1119	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1105, 0x110b, 0, 0, 0}, 0x111b }, // U111b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1105, 0x1112, 0, 0, 0}, 0x111a }, // U111a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1106, 0x1107, 0, 0, 0}, 0x111c }, // U111c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1106, 0x110b, 0, 0, 0}, 0x111d }, // U111d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1100, 0, 0, 0}, 0x111e }, // U111e	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1102, 0, 0, 0}, 0x111f }, // U111f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1103, 0, 0, 0}, 0x1120 }, // U1120	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1107, 0, 0, 0}, 0x1108 }, // U1108	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1107, 0x110b, 0, 0}, 0x112c }, // U112c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0, 0, 0}, 0x1121 }, // U1121	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0x1100, 0, 0}, 0x1122 }, // U1122	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0x1103, 0, 0}, 0x1123 }, // U1123	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0x1107, 0, 0}, 0x1124 }, // U1124	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0x1109, 0, 0}, 0x1125 }, // U1125	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1109, 0x110c, 0, 0}, 0x1126 }, // U1126	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x110a, 0, 0, 0}, 0x1125 }, // U1125	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x110b, 0, 0, 0}, 0x112b }, // U112b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x110c, 0, 0, 0}, 0x1127 }, // U1127	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x110e, 0, 0, 0}, 0x1128 }, // U1128	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1110, 0, 0, 0}, 0x1129 }, // U1129	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1111, 0, 0, 0}, 0x112a }, // U112a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x112b, 0, 0, 0}, 0x112c }, // U112c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x112d, 0, 0, 0}, 0x1122 }, // U1122	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x112f, 0, 0, 0}, 0x1123 }, // U1123	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1132, 0, 0, 0}, 0x1124 }, // U1124	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1107, 0x1136, 0, 0, 0}, 0x1126 }, // U1126	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1108, 0x110b, 0, 0, 0}, 0x112c }, // U112c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1100, 0, 0, 0}, 0x112d }, // U112d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1102, 0, 0, 0}, 0x112e }, // U112e	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1103, 0, 0, 0}, 0x112f }, // U112f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1105, 0, 0, 0}, 0x1130 }, // U1130	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1106, 0, 0, 0}, 0x1131 }, // U1131	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1107, 0, 0, 0}, 0x1132 }, // U1132	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1107, 0x1100, 0, 0}, 0x1133 }, // U1133	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1109, 0, 0, 0}, 0x110a }, // U110a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1109, 0x1109, 0, 0}, 0x1134 }, // U1134	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x110a, 0, 0, 0}, 0x1134 }, // U1134	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x110b, 0, 0, 0}, 0x1135 }, // U1135	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x110c, 0, 0, 0}, 0x1136 }, // U1136	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x110e, 0, 0, 0}, 0x1137 }, // U1137	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x110f, 0, 0, 0}, 0x1138 }, // U1138	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1110, 0, 0, 0}, 0x1139 }, // U1139	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1111, 0, 0, 0}, 0x113a }, // U113a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x1112, 0, 0, 0}, 0x113b }, // U113b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1109, 0x111e, 0, 0, 0}, 0x1133 }, // U1133	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110a, 0x1109, 0, 0, 0}, 0x1134 }, // U1134	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1100, 0, 0, 0}, 0x1141 }, // U1141	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1103, 0, 0, 0}, 0x1142 }, // U1142	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1106, 0, 0, 0}, 0x1143 }, // U1143	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1107, 0, 0, 0}, 0x1144 }, // U1144	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1109, 0, 0, 0}, 0x1145 }, // U1145	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x110b, 0, 0, 0}, 0x1147 }, // U1147	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x110c, 0, 0, 0}, 0x1148 }, // U1148	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x110e, 0, 0, 0}, 0x1149 }, // U1149	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1110, 0, 0, 0}, 0x114a }, // U114a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1111, 0, 0, 0}, 0x114b }, // U114b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110b, 0x1140, 0, 0, 0}, 0x1146 }, // U1146	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110c, 0x110b, 0, 0, 0}, 0x114d }, // U114d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110c, 0x110c, 0, 0, 0}, 0x110d }, // U110d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110e, 0x110f, 0, 0, 0}, 0x1152 }, // U1152	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x110e, 0x1112, 0, 0, 0}, 0x1153 }, // U1153	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1111, 0x1107, 0, 0, 0}, 0x1156 }, // U1156	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1111, 0x110b, 0, 0, 0}, 0x1157 }, // U1157	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1112, 0x1112, 0, 0, 0}, 0x1158 }, // U1158	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1121, 0x1100, 0, 0, 0}, 0x1122 }, // U1122	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1121, 0x1103, 0, 0, 0}, 0x1123 }, // U1123	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1121, 0x1107, 0, 0, 0}, 0x1124 }, // U1124	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1121, 0x1109, 0, 0, 0}, 0x1125 }, // U1125	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1121, 0x110c, 0, 0, 0}, 0x1126 }, // U1126	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1132, 0x1100, 0, 0, 0}, 0x1133 }, // U1133	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x113c, 0x113c, 0, 0, 0}, 0x113d }, // U113d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x113e, 0x113e, 0, 0, 0}, 0x113f }, // U113f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x114e, 0x114e, 0, 0, 0}, 0x114f }, // U114f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1150, 0x1150, 0, 0, 0}, 0x1151 }, // U1151	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1161, 0x1169, 0, 0, 0}, 0x1176 }, // U1176	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1161, 0x116e, 0, 0, 0}, 0x1177 }, // U1177	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1161, 0x1175, 0, 0, 0}, 0x1162 }, // U1162	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1163, 0x1169, 0, 0, 0}, 0x1178 }, // U1178	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1163, 0x116d, 0, 0, 0}, 0x1179 }, // U1179	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1163, 0x1175, 0, 0, 0}, 0x1164 }, // U1164	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1165, 0x1169, 0, 0, 0}, 0x117a }, // U117a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1165, 0x116e, 0, 0, 0}, 0x117b }, // U117b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1165, 0x1173, 0, 0, 0}, 0x117c }, // U117c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1165, 0x1175, 0, 0, 0}, 0x1166 }, // U1166	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1167, 0x1169, 0, 0, 0}, 0x117d }, // U117d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1167, 0x116e, 0, 0, 0}, 0x117e }, // U117e	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1167, 0x1175, 0, 0, 0}, 0x1168 }, // U1168	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1161, 0, 0, 0}, 0x116a }, // U116a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1161, 0x1175, 0, 0}, 0x116b }, // U116b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1162, 0, 0, 0}, 0x116b }, // U116b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1165, 0, 0, 0}, 0x117f }, // U117f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1166, 0, 0, 0}, 0x1180 }, // U1180	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1168, 0, 0, 0}, 0x1181 }, // U1181	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1169, 0, 0, 0}, 0x1182 }, // U1182	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x116e, 0, 0, 0}, 0x1183 }, // U1183	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1169, 0x1175, 0, 0, 0}, 0x116c }, // U116c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116a, 0x1175, 0, 0, 0}, 0x116b }, // U116b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116d, 0x1163, 0, 0, 0}, 0x1184 }, // U1184	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116d, 0x1164, 0, 0, 0}, 0x1185 }, // U1185	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116d, 0x1167, 0, 0, 0}, 0x1186 }, // U1186	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116d, 0x1169, 0, 0, 0}, 0x1187 }, // U1187	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116d, 0x1175, 0, 0, 0}, 0x1188 }, // U1188	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1161, 0, 0, 0}, 0x1189 }, // U1189	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1162, 0, 0, 0}, 0x118a }, // U118a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1165, 0, 0, 0}, 0x116f }, // U116f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1165, 0x1173, 0, 0}, 0x118b }, // U118b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1165, 0x1175, 0, 0}, 0x1170 }, // U1170	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1166, 0, 0, 0}, 0x1170 }, // U1170	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1168, 0, 0, 0}, 0x118c }, // U118c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x116e, 0, 0, 0}, 0x118d }, // U118d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x1175, 0, 0, 0}, 0x1171 }, // U1171	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116e, 0x117c, 0, 0, 0}, 0x118b }, // U118b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116f, 0x1173, 0, 0, 0}, 0x118b }, // U118b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x116f, 0x1175, 0, 0, 0}, 0x1170 }, // U1170	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1161, 0, 0, 0}, 0x118e }, // U118e	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1165, 0, 0, 0}, 0x118f }, // U118f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1166, 0, 0, 0}, 0x1190 }, // U1190	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1167, 0, 0, 0}, 0x1191 }, // U1191	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1168, 0, 0, 0}, 0x1192 }, // U1192	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x116e, 0, 0, 0}, 0x1193 }, // U1193	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1172, 0x1175, 0, 0, 0}, 0x1194 }, // U1194	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1173, 0x116e, 0, 0, 0}, 0x1195 }, // U1195	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1173, 0x1173, 0, 0, 0}, 0x1196 }, // U1196	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1173, 0x1175, 0, 0, 0}, 0x1174 }, // U1174	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1174, 0x116e, 0, 0, 0}, 0x1197 }, // U1197	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x1161, 0, 0, 0}, 0x1198 }, // U1198	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x1163, 0, 0, 0}, 0x1199 }, // U1199	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x1169, 0, 0, 0}, 0x119a }, // U119a	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x116e, 0, 0, 0}, 0x119b }, // U119b	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x1173, 0, 0, 0}, 0x119c }, // U119c	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x1175, 0x119e, 0, 0, 0}, 0x119d }, // U119d	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x119e, 0x1165, 0, 0, 0}, 0x119f }, // U119f	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x119e, 0x116e, 0, 0, 0}, 0x11a0 }, // U11a0	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x119e, 0x1175, 0, 0, 0}, 0x11a1 }, // U11a1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x119e, 0x119e, 0, 0, 0}, 0x11a2 }, // U11a2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11a8, 0x11a8, 0, 0, 0}, 0x11a9 }, // U11a9	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11a8, 0x11af, 0, 0, 0}, 0x11c3 }, // U11c3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11a8, 0x11ba, 0, 0, 0}, 0x11aa }, // U11aa	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11a8, 0x11ba, 0x11a8, 0, 0}, 0x11c4 }, // U11c4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11a8, 0x11e7, 0, 0, 0}, 0x11c4 }, // U11c4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11aa, 0x11a8, 0, 0, 0}, 0x11c4 }, // U11c4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11a8, 0, 0, 0}, 0x11c5 }, // U11c5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11ae, 0, 0, 0}, 0x11c6 }, // U11c6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11ba, 0, 0, 0}, 0x11c7 }, // U11c7	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11bd, 0, 0, 0}, 0x11ac }, // U11ac	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11c0, 0, 0, 0}, 0x11c9 }, // U11c9	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11c2, 0, 0, 0}, 0x11ad }, // U11ad	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ab, 0x11eb, 0, 0, 0}, 0x11c8 }, // U11c8	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ae, 0x11a8, 0, 0, 0}, 0x11ca }, // U11ca	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ae, 0x11af, 0, 0, 0}, 0x11cb }, // U11cb	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11a8, 0, 0, 0}, 0x11b0 }, // U11b0	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11a8, 0x11ba, 0, 0}, 0x11cc }, // U11cc	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11aa, 0, 0, 0}, 0x11cc }, // U11cc	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11ab, 0, 0, 0}, 0x11cd }, // U11cd	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11ae, 0, 0, 0}, 0x11ce }, // U11ce	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11ae, 0x11c2, 0, 0}, 0x11cf }, // U11cf	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11af, 0, 0, 0}, 0x11d0 }, // U11d0	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b7, 0, 0, 0}, 0x11b1 }, // U11b1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b7, 0x11a8, 0, 0}, 0x11d1 }, // U11d1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b7, 0x11ba, 0, 0}, 0x11d2 }, // U11d2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b8, 0, 0, 0}, 0x11b2 }, // U11b2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b8, 0x11ba, 0, 0}, 0x11d3 }, // U11d3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b8, 0x11bc, 0, 0}, 0x11d5 }, // U11d5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b8, 0x11c2, 0, 0}, 0x11d4 }, // U11d4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11b9, 0, 0, 0}, 0x11d3 }, // U11d3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11ba, 0, 0, 0}, 0x11b3 }, // U11b3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11ba, 0x11ba, 0, 0}, 0x11d6 }, // U11d6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11bb, 0, 0, 0}, 0x11d6 }, // U11d6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11bf, 0, 0, 0}, 0x11d8 }, // U11d8	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11c0, 0, 0, 0}, 0x11b4 }, // U11b4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11c1, 0, 0, 0}, 0x11b5 }, // U11b5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11c2, 0, 0, 0}, 0x11b6 }, // U11b6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11da, 0, 0, 0}, 0x11d1 }, // U11d1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11dd, 0, 0, 0}, 0x11d2 }, // U11d2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11e5, 0, 0, 0}, 0x11d4 }, // U11d4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11e6, 0, 0, 0}, 0x11d5 }, // U11d5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11eb, 0, 0, 0}, 0x11d7 }, // U11d7	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11af, 0x11f9, 0, 0, 0}, 0x11d9 }, // U11d9	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b0, 0x11ba, 0, 0, 0}, 0x11cc }, // U11cc	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b1, 0x11a8, 0, 0, 0}, 0x11d1 }, // U11d1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b1, 0x11ba, 0, 0, 0}, 0x11d2 }, // U11d2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b2, 0x11ba, 0, 0, 0}, 0x11d3 }, // U11d3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b2, 0x11bc, 0, 0, 0}, 0x11d5 }, // U11d5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b2, 0x11c2, 0, 0, 0}, 0x11d4 }, // U11d4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b3, 0x11ba, 0, 0, 0}, 0x11d6 }, // U11d6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11a8, 0, 0, 0}, 0x11da }, // U11da	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11af, 0, 0, 0}, 0x11db }, // U11db	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11b8, 0, 0, 0}, 0x11dc }, // U11dc	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11ba, 0, 0, 0}, 0x11dd }, // U11dd	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11ba, 0x11ba, 0, 0}, 0x11de }, // U11de	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11bb, 0, 0, 0}, 0x11de }, // U11de	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11bc, 0, 0, 0}, 0x11e2 }, // U11e2	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11be, 0, 0, 0}, 0x11e0 }, // U11e0	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11c2, 0, 0, 0}, 0x11e1 }, // U11e1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b7, 0x11eb, 0, 0, 0}, 0x11df }, // U11df	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b8, 0x11af, 0, 0, 0}, 0x11e3 }, // U11e3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b8, 0x11ba, 0, 0, 0}, 0x11b9 }, // U11b9	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b8, 0x11bc, 0, 0, 0}, 0x11e6 }, // U11e6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b8, 0x11c1, 0, 0, 0}, 0x11e4 }, // U11e4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11b8, 0x11c2, 0, 0, 0}, 0x11e5 }, // U11e5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ba, 0x11a8, 0, 0, 0}, 0x11e7 }, // U11e7	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ba, 0x11ae, 0, 0, 0}, 0x11e8 }, // U11e8	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ba, 0x11af, 0, 0, 0}, 0x11e9 }, // U11e9	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ba, 0x11b8, 0, 0, 0}, 0x11ea }, // U11ea	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ba, 0x11ba, 0, 0, 0}, 0x11bb }, // U11bb	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11bc, 0x11a8, 0, 0, 0}, 0x11ec }, // U11ec	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11bc, 0x11a8, 0x11a8, 0, 0}, 0x11ed }, // U11ed	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11bc, 0x11a9, 0, 0, 0}, 0x11ed }, // U11ed	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11bc, 0x11bc, 0, 0, 0}, 0x11ee }, // U11ee	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11bc, 0x11bf, 0, 0, 0}, 0x11ef }, // U11ef	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c1, 0x11b8, 0, 0, 0}, 0x11f3 }, // U11f3	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c1, 0x11bc, 0, 0, 0}, 0x11f4 }, // U11f4	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c2, 0x11ab, 0, 0, 0}, 0x11f5 }, // U11f5	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c2, 0x11af, 0, 0, 0}, 0x11f6 }, // U11f6	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c2, 0x11b7, 0, 0, 0}, 0x11f7 }, // U11f7	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11c2, 0x11b8, 0, 0, 0}, 0x11f8 }, // U11f8	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ce, 0x11c2, 0, 0, 0}, 0x11cf }, // U11cf	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11dd, 0x11ba, 0, 0, 0}, 0x11de }, // U11de	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11ec, 0x11a8, 0, 0, 0}, 0x11ed }, // U11ed	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11f0, 0x11ba, 0, 0, 0}, 0x11f1 }, // U11f1	 #     = 
+    { {UNITIZE(Qt::Key_Multi_key), 0x11f0, 0x11eb, 0, 0, 0}, 0x11f2 }, // U11f2	 #     = 
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d157, 0x1d165, 0, 0, 0}, 0xd15e }, // U1D15E # MUSICAL SYMBOL HALF NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0, 0, 0}, 0xd15f }, // U1D15F # MUSICAL SYMBOL QUARTER NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0x1d16e, 0, 0}, 0xd160 }, // U1D160 # MUSICAL SYMBOL EIGHTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0x1d16f, 0, 0}, 0xd161 }, // U1D161 # MUSICAL SYMBOL SIXTEENTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0x1d170, 0, 0}, 0xd162 }, // U1D162 # MUSICAL SYMBOL THIRTY-SECOND NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0x1d171, 0, 0}, 0xd163 }, // U1D163 # MUSICAL SYMBOL SIXTY-FOURTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d158, 0x1d165, 0x1d172, 0, 0}, 0xd164 }, // U1D164 # MUSICAL SYMBOL ONE HUNDRED TWENTY-EIGHTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d15f, 0x1d16e, 0, 0, 0}, 0xd160 }, // U1D160 # MUSICAL SYMBOL EIGHTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d15f, 0x1d16f, 0, 0, 0}, 0xd161 }, // U1D161 # MUSICAL SYMBOL SIXTEENTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d15f, 0x1d170, 0, 0, 0}, 0xd162 }, // U1D162 # MUSICAL SYMBOL THIRTY-SECOND NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d15f, 0x1d171, 0, 0, 0}, 0xd163 }, // U1D163 # MUSICAL SYMBOL SIXTY-FOURTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d15f, 0x1d172, 0, 0, 0}, 0xd164 }, // U1D164 # MUSICAL SYMBOL ONE HUNDRED TWENTY-EIGHTH NOTE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1b9, 0x1d165, 0, 0, 0}, 0xd1bb }, // U1D1BB # MUSICAL SYMBOL MINIMA
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1b9, 0x1d165, 0x1d16e, 0, 0}, 0xd1bd }, // U1D1BD # MUSICAL SYMBOL SEMIMINIMA WHITE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1b9, 0x1d165, 0x1d16f, 0, 0}, 0xd1bf }, // U1D1BF # MUSICAL SYMBOL FUSA WHITE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1ba, 0x1d165, 0, 0, 0}, 0xd1bc }, // U1D1BC # MUSICAL SYMBOL MINIMA BLACK
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1ba, 0x1d165, 0x1d16e, 0, 0}, 0xd1be }, // U1D1BE # MUSICAL SYMBOL SEMIMINIMA BLACK
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1ba, 0x1d165, 0x1d16f, 0, 0}, 0xd1c0 }, // U1D1C0 # MUSICAL SYMBOL FUSA BLACK
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1bb, 0x1d16e, 0, 0, 0}, 0xd1bd }, // U1D1BD # MUSICAL SYMBOL SEMIMINIMA WHITE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1bb, 0x1d16f, 0, 0, 0}, 0xd1bf }, // U1D1BF # MUSICAL SYMBOL FUSA WHITE
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1bc, 0x1d16e, 0, 0, 0}, 0xd1be }, // U1D1BE # MUSICAL SYMBOL SEMIMINIMA BLACK
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1d1bc, 0x1d16f, 0, 0, 0}, 0xd1c0 }, // U1D1C0 # MUSICAL SYMBOL FUSA BLACK
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x0000, 0, 0, 0}, 0x1fcd }, // U1FCD # GREEK PSILI AND VARIA
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x0000, 0, 0, 0}, 0x1fce }, // U1FCE # GREEK PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x0027, 0, 0, 0}, 0x1fce }, // U1FCE # GREEK PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x0060, 0, 0, 0}, 0x1fcd }, // U1FCD # GREEK PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x007e, 0, 0, 0}, 0x1fcf }, // U1FCF # GREEK PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x00b4, 0, 0, 0}, 0x1fce }, // U1FCE # GREEK PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, 0x0342, 0, 0, 0}, 0x1fcf }, // U1FCF # GREEK PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, UNITIZE(Qt::Key_Dead_Grave), 0, 0, 0}, 0x1fcd }, // U1FCD # GREEK PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, UNITIZE(Qt::Key_Dead_Acute), 0, 0, 0}, 0x1fce }, // U1FCE # GREEK PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1fbf, UNITIZE(Qt::Key_Dead_Tilde), 0, 0, 0}, 0x1fcf }, // U1FCF # GREEK PSILI AND PERISPOMENI
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x0000, 0, 0, 0}, 0x1fdd }, // U1FDD # GREEK DASIA AND VARIA
+// /* broken */    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x0000, 0, 0, 0}, 0x1fde }, // U1FDE # GREEK DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x0027, 0, 0, 0}, 0x1fde }, // U1FDE # GREEK DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x0060, 0, 0, 0}, 0x1fdd }, // U1FDD # GREEK DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x007e, 0, 0, 0}, 0x1fdf }, // U1FDF # GREEK DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x00b4, 0, 0, 0}, 0x1fde }, // U1FDE # GREEK DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, 0x0342, 0, 0, 0}, 0x1fdf }, // U1FDF # GREEK DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, UNITIZE(Qt::Key_Dead_Grave), 0, 0, 0}, 0x1fdd }, // U1FDD # GREEK DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, UNITIZE(Qt::Key_Dead_Acute), 0, 0, 0}, 0x1fde }, // U1FDE # GREEK DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Multi_key), 0x1ffe, UNITIZE(Qt::Key_Dead_Tilde), 0, 0, 0}, 0x1fdf }, // U1FDF # GREEK DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Multi_key), 0x2203, 0x0338, 0, 0, 0}, 0x2204 }, // U2204 # THERE DOES NOT EXIST
+    { {UNITIZE(Qt::Key_Multi_key), 0x2208, 0x0338, 0, 0, 0}, 0x2209 }, // U2209 # NOT AN ELEMENT OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x220b, 0x0338, 0, 0, 0}, 0x220c }, // U220C # DOES NOT CONTAIN AS MEMBER
+    { {UNITIZE(Qt::Key_Multi_key), 0x2223, 0x0338, 0, 0, 0}, 0x2224 }, // U2224 # DOES NOT DIVIDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x2225, 0x0338, 0, 0, 0}, 0x2226 }, // U2226 # NOT PARALLEL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x223c, 0x0338, 0, 0, 0}, 0x2241 }, // U2241 # NOT TILDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x223c, 0x0338, 0, 0, 0}, 0x2247 }, // U2247 # NEITHER APPROXIMATELY NOR ACTUALLY EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2243, 0x0338, 0, 0, 0}, 0x2244 }, // U2244 # NOT ASYMPTOTICALLY EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2248, 0x0338, 0, 0, 0}, 0x2249 }, // U2249 # NOT ALMOST EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x224d, 0x0338, 0, 0, 0}, 0x226d }, // U226D # NOT EQUIVALENT TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2261, 0x0338, 0, 0, 0}, 0x2262 }, // U2262 # NOT IDENTICAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2264, 0x0338, 0, 0, 0}, 0x2270 }, // U2270 # NEITHER LESS-THAN NOR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2265, 0x0338, 0, 0, 0}, 0x2271 }, // U2271 # NEITHER GREATER-THAN NOR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2272, 0x0338, 0, 0, 0}, 0x2274 }, // U2274 # NEITHER LESS-THAN NOR EQUIVALENT TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2273, 0x0338, 0, 0, 0}, 0x2275 }, // U2275 # NEITHER GREATER-THAN NOR EQUIVALENT TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2276, 0x0338, 0, 0, 0}, 0x2278 }, // U2278 # NEITHER LESS-THAN NOR GREATER-THAN
+    { {UNITIZE(Qt::Key_Multi_key), 0x2277, 0x0338, 0, 0, 0}, 0x2279 }, // U2279 # NEITHER GREATER-THAN NOR LESS-THAN
+    { {UNITIZE(Qt::Key_Multi_key), 0x227a, 0x0338, 0, 0, 0}, 0x2280 }, // U2280 # DOES NOT PRECEDE
+    { {UNITIZE(Qt::Key_Multi_key), 0x227b, 0x0338, 0, 0, 0}, 0x2281 }, // U2281 # DOES NOT SUCCEED
+    { {UNITIZE(Qt::Key_Multi_key), 0x227c, 0x0338, 0, 0, 0}, 0x22e0 }, // U22E0 # DOES NOT PRECEDE OR EQUAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x227d, 0x0338, 0, 0, 0}, 0x22e1 }, // U22E1 # DOES NOT SUCCEED OR EQUAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x2282, 0x0338, 0, 0, 0}, 0x2284 }, // U2284 # NOT A SUBSET OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x2282, 0x0338, 0, 0, 0}, 0x2284 }, // U2284 # NOT A SUBSET OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x2283, 0x0338, 0, 0, 0}, 0x2285 }, // U2285 # NOT A SUPERSET OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x2283, 0x0338, 0, 0, 0}, 0x2285 }, // U2285 # NOT A SUPERSET OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x2286, 0x0338, 0, 0, 0}, 0x2288 }, // U2288 # NEITHER A SUBSET OF NOR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2287, 0x0338, 0, 0, 0}, 0x2289 }, // U2289 # NEITHER A SUPERSET OF NOR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2291, 0x0338, 0, 0, 0}, 0x22e2 }, // U22E2 # NOT SQUARE IMAGE OF OR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x2292, 0x0338, 0, 0, 0}, 0x22e3 }, // U22E3 # NOT SQUARE ORIGINAL OF OR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x22a3, 0x0338, 0, 0, 0}, 0x22ac }, // U22AC # DOES NOT PROVE
+    { {UNITIZE(Qt::Key_Multi_key), 0x22a8, 0x0338, 0, 0, 0}, 0x22ad }, // U22AD # NOT TRUE
+    { {UNITIZE(Qt::Key_Multi_key), 0x22a9, 0x0338, 0, 0, 0}, 0x22ae }, // U22AE # DOES NOT FORCE
+    { {UNITIZE(Qt::Key_Multi_key), 0x22ab, 0x0338, 0, 0, 0}, 0x22af }, // U22AF # NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
+    { {UNITIZE(Qt::Key_Multi_key), 0x22b2, 0x0338, 0, 0, 0}, 0x22ea }, // U22EA # NOT NORMAL SUBGROUP OF
+    { {UNITIZE(Qt::Key_Multi_key), 0x22b3, 0x0338, 0, 0, 0}, 0x22eb }, // U22EB # DOES NOT CONTAIN AS NORMAL SUBGROUP
+    { {UNITIZE(Qt::Key_Multi_key), 0x22b4, 0x0338, 0, 0, 0}, 0x22ec }, // U22EC # NOT NORMAL SUBGROUP OF OR EQUAL TO
+    { {UNITIZE(Qt::Key_Multi_key), 0x22b5, 0x0338, 0, 0, 0}, 0x22ed }, // U22ED # DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
+    { {UNITIZE(Qt::Key_Multi_key), 0x2add, 0x0338, 0, 0, 0}, 0x2adc }, // U2ADC # FORKING
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Grave), 0x0000, 0, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Grave), 0x0000, 0, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Grave), 0x0000, 0, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Grave), 0x0000, 0, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0020, 0, 0, 0, 0}, 0x0060 }, // grave
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0041, 0, 0, 0, 0}, 0x00c0 }, // U00C0 # LATIN CAPITAL LETTER A WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0045, 0, 0, 0, 0}, 0x00c8 }, // U00C8 # LATIN CAPITAL LETTER E WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0049, 0, 0, 0, 0}, 0x00cc }, // U00CC # LATIN CAPITAL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x004e, 0, 0, 0, 0}, 0x01f8 }, // U01F8 # LATIN CAPITAL LETTER N WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x004f, 0, 0, 0, 0}, 0x00d2 }, // U00D2 # LATIN CAPITAL LETTER O WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0055, 0, 0, 0, 0}, 0x00d9 }, // U00D9 # LATIN CAPITAL LETTER U WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0057, 0, 0, 0, 0}, 0x1e80 }, // U1E80 # LATIN CAPITAL LETTER W WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0059, 0, 0, 0, 0}, 0x1ef2 }, // U1EF2 # LATIN CAPITAL LETTER Y WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0061, 0, 0, 0, 0}, 0x00e0 }, // U00E0 # LATIN SMALL LETTER A WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0065, 0, 0, 0, 0}, 0x00e8 }, // U00E8 # LATIN SMALL LETTER E WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0069, 0, 0, 0, 0}, 0x00ec }, // U00EC # LATIN SMALL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x006e, 0, 0, 0, 0}, 0x01f9 }, // U01F9 # LATIN SMALL LETTER N WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x006f, 0, 0, 0, 0}, 0x00f2 }, // U00F2 # LATIN SMALL LETTER O WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0075, 0, 0, 0, 0}, 0x00f9 }, // U00F9 # LATIN SMALL LETTER U WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0077, 0, 0, 0, 0}, 0x1e81 }, // U1E81 # LATIN SMALL LETTER W WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0079, 0, 0, 0, 0}, 0x1ef3 }, // U1EF3 # LATIN SMALL LETTER Y WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00c2, 0, 0, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00ca, 0, 0, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00d4, 0, 0, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00dc, 0, 0, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00e2, 0, 0, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00ea, 0, 0, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00f4, 0, 0, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x00fc, 0, 0, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0102, 0, 0, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0103, 0, 0, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0112, 0, 0, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0113, 0, 0, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x014c, 0, 0, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x014d, 0, 0, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x01A0, 0, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x01A1, 0, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x01AF, 0, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x01B0, 0, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0391, 0, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0395, 0, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0397, 0, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0399, 0, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x039f, 0, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03a9, 0, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b1, 0, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b5, 0, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b7, 0, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b9, 0, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03bf, 0, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03c5, 0, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03c9, 0, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0391, 0, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0395, 0, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0397, 0, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0399, 0, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x039f, 0, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03a5, 0, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03a9, 0, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b1, 0, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b5, 0, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b7, 0, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b9, 0, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03bf, 0, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03c5, 0, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03c9, 0, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0391, 0, 0, 0, 0}, 0x1fba }, // U1FBA # GREEK CAPITAL LETTER ALPHA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0395, 0, 0, 0, 0}, 0x1fc8 }, // U1FC8 # GREEK CAPITAL LETTER EPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0397, 0, 0, 0, 0}, 0x1fca }, // U1FCA # GREEK CAPITAL LETTER ETA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0399, 0, 0, 0, 0}, 0x1fda }, // U1FDA # GREEK CAPITAL LETTER IOTA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x039f, 0, 0, 0, 0}, 0x1ff8 }, // U1FF8 # GREEK CAPITAL LETTER OMICRON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03a5, 0, 0, 0, 0}, 0x1fea }, // U1FEA # GREEK CAPITAL LETTER UPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03a9, 0, 0, 0, 0}, 0x1ffa }, // U1FFA # GREEK CAPITAL LETTER OMEGA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03b1, 0, 0, 0, 0}, 0x1f70 }, // U1F70 # GREEK SMALL LETTER ALPHA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03b5, 0, 0, 0, 0}, 0x1f72 }, // U1F72 # GREEK SMALL LETTER EPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03b7, 0, 0, 0, 0}, 0x1f74 }, // U1F74 # GREEK SMALL LETTER ETA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03b9, 0, 0, 0, 0}, 0x1f76 }, // U1F76 # GREEK SMALL LETTER IOTA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03bf, 0, 0, 0, 0}, 0x1f78 }, // U1F78 # GREEK SMALL LETTER OMICRON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03c5, 0, 0, 0, 0}, 0x1f7a }, // U1F7A # GREEK SMALL LETTER UPSILON WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03c9, 0, 0, 0, 0}, 0x1f7c }, // U1F7C # GREEK SMALL LETTER OMEGA WITH VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03ca, 0, 0, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x03cb, 0, 0, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0415, 0, 0, 0, 0}, 0x0400 }, // U0400 # CYRILLIC CAPITAL LETTER IE WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0418, 0, 0, 0, 0}, 0x040d }, // U040D # CYRILLIC CAPITAL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0435, 0, 0, 0, 0}, 0x0450 }, // U0450 # CYRILLIC SMALL LETTER IE WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x0438, 0, 0, 0, 0}, 0x045d }, // U045D # CYRILLIC SMALL LETTER I WITH GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f00, 0, 0, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f01, 0, 0, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f08, 0, 0, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f09, 0, 0, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f10, 0, 0, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f11, 0, 0, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f18, 0, 0, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f19, 0, 0, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f20, 0, 0, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f21, 0, 0, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f28, 0, 0, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f29, 0, 0, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f30, 0, 0, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f31, 0, 0, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f38, 0, 0, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f39, 0, 0, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f40, 0, 0, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f41, 0, 0, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f48, 0, 0, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f49, 0, 0, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f50, 0, 0, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f51, 0, 0, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f59, 0, 0, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f60, 0, 0, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f61, 0, 0, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f68, 0, 0, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), 0x1f69, 0, 0, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0b }, // U1F0B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0395, 0, 0}, 0x1f1b }, // U1F1B # GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2b }, // U1F2B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3b }, // U1F3B # GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x039f, 0, 0}, 0x1f4b }, // U1F4B # GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5b }, // U1F5B # GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6b }, // U1F6B # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f03 }, // U1F03 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b5, 0, 0}, 0x1f13 }, // U1F13 # GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f23 }, // U1F23 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f33 }, // U1F33 # GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03bf, 0, 0}, 0x1f43 }, // U1F43 # GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f53 }, // U1F53 # GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f63 }, // U1F63 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0a }, // U1F0A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0395, 0, 0}, 0x1f1a }, // U1F1A # GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2a }, // U1F2A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3a }, // U1F3A # GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x039f, 0, 0}, 0x1f4a }, // U1F4A # GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6a }, // U1F6A # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f02 }, // U1F02 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b5, 0, 0}, 0x1f12 }, // U1F12 # GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f22 }, // U1F22 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f32 }, // U1F32 # GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03bf, 0, 0}, 0x1f42 }, // U1F42 # GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f52 }, // U1F52 # GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f62 }, // U1F62 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0045, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x004f, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0065, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x006f, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Grave), 0, 0, 0, 0}, 0x0060 }, // grave
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea6 }, // U1EA6 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec0 }, // U1EC0 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed2 }, // U1ED2 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea7 }, // U1EA7 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec1 }, // U1EC1 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed3 }, // U1ED3 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0, 0}, 0x1e14 }, // U1E14 # LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0, 0}, 0x1e50 }, // U1E50 # LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0, 0}, 0x1e15 }, // U1E15 # LATIN SMALL LETTER E WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0, 0}, 0x1e51 }, // U1E51 # LATIN SMALL LETTER O WITH MACRON AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb0 }, // U1EB0 # LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb1 }, // U1EB1 # LATIN SMALL LETTER A WITH BREVE AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01db }, // U01DB # LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01dc }, // U01DC # LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x1fd2 }, // U1FD2 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x1fe2 }, // U1FE2 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1edc }, // U1EDC # LATIN CAPITAL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eea }, // U1EEA # LATIN CAPITAL LETTER U WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edd }, // U1EDD # LATIN SMALL LETTER O WITH HORN AND GRAVE
+    { {UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eeb }, // U1EEB # LATIN SMALL LETTER U WITH HORN AND GRAVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0x004f, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0x0055, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0x006f, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), 0x0000, 0x0075, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0020, 0, 0, 0, 0}, 0x0027 }, // apostrophe
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0041, 0, 0, 0, 0}, 0x00c1 }, // U00C1 # LATIN CAPITAL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0043, 0, 0, 0, 0}, 0x0106 }, // U0106 # LATIN CAPITAL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0045, 0, 0, 0, 0}, 0x00c9 }, // U00C9 # LATIN CAPITAL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0047, 0, 0, 0, 0}, 0x01f4 }, // U01F4 # LATIN CAPITAL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0049, 0, 0, 0, 0}, 0x00cd }, // U00CD # LATIN CAPITAL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x004b, 0, 0, 0, 0}, 0x1e30 }, // U1E30 # LATIN CAPITAL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x004c, 0, 0, 0, 0}, 0x0139 }, // U0139 # LATIN CAPITAL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x004d, 0, 0, 0, 0}, 0x1e3e }, // U1E3E # LATIN CAPITAL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x004e, 0, 0, 0, 0}, 0x0143 }, // U0143 # LATIN CAPITAL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x004f, 0, 0, 0, 0}, 0x00d3 }, // U00D3 # LATIN CAPITAL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0050, 0, 0, 0, 0}, 0x1e54 }, // U1E54 # LATIN CAPITAL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0052, 0, 0, 0, 0}, 0x0154 }, // U0154 # LATIN CAPITAL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0053, 0, 0, 0, 0}, 0x015a }, // U015A # LATIN CAPITAL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0055, 0, 0, 0, 0}, 0x00da }, // U00DA # LATIN CAPITAL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0057, 0, 0, 0, 0}, 0x1e82 }, // U1E82 # LATIN CAPITAL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0059, 0, 0, 0, 0}, 0x00dd }, // U00DD # LATIN CAPITAL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x005a, 0, 0, 0, 0}, 0x0179 }, // U0179 # LATIN CAPITAL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0061, 0, 0, 0, 0}, 0x00e1 }, // U00E1 # LATIN SMALL LETTER A WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0063, 0, 0, 0, 0}, 0x0107 }, // U0107 # LATIN SMALL LETTER C WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0065, 0, 0, 0, 0}, 0x00e9 }, // U00E9 # LATIN SMALL LETTER E WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0067, 0, 0, 0, 0}, 0x01f5 }, // U01F5 # LATIN SMALL LETTER G WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0069, 0, 0, 0, 0}, 0x00ed }, // U00ED # LATIN SMALL LETTER I WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x006b, 0, 0, 0, 0}, 0x1e31 }, // U1E31 # LATIN SMALL LETTER K WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x006c, 0, 0, 0, 0}, 0x013a }, // U013A # LATIN SMALL LETTER L WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x006d, 0, 0, 0, 0}, 0x1e3f }, // U1E3F # LATIN SMALL LETTER M WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x006e, 0, 0, 0, 0}, 0x0144 }, // U0144 # LATIN SMALL LETTER N WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x006f, 0, 0, 0, 0}, 0x00f3 }, // U00F3 # LATIN SMALL LETTER O WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0070, 0, 0, 0, 0}, 0x1e55 }, // U1E55 # LATIN SMALL LETTER P WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0072, 0, 0, 0, 0}, 0x0155 }, // U0155 # LATIN SMALL LETTER R WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0073, 0, 0, 0, 0}, 0x015b }, // U015B # LATIN SMALL LETTER S WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0075, 0, 0, 0, 0}, 0x00fa }, // U00FA # LATIN SMALL LETTER U WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0077, 0, 0, 0, 0}, 0x1e83 }, // U1E83 # LATIN SMALL LETTER W WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0079, 0, 0, 0, 0}, 0x00fd }, // U00FD # LATIN SMALL LETTER Y WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x007a, 0, 0, 0, 0}, 0x017a }, // U017A # LATIN SMALL LETTER Z WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00c2, 0, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00c5, 0, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00c6, 0, 0, 0, 0}, 0x01fc }, // U01FC # LATIN CAPITAL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00c7, 0, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00ca, 0, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00cf, 0, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00d4, 0, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00d5, 0, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00d8, 0, 0, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00dc, 0, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00e2, 0, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00e5, 0, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00e6, 0, 0, 0, 0}, 0x01fd }, // U01FD # LATIN SMALL LETTER AE WITH ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00e7, 0, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00ea, 0, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00ef, 0, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00f4, 0, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00f5, 0, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00f8, 0, 0, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x00fc, 0, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0102, 0, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0103, 0, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0112, 0, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0113, 0, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x014c, 0, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x014d, 0, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0168, 0, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0169, 0, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x01A0, 0, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x01A1, 0, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x01AF, 0, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x01B0, 0, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0391, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0395, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0397, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0399, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x039f, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03a9, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b1, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b5, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b7, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b9, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03bf, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03c5, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03c9, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0391, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0395, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0397, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0399, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x039f, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03a5, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03a9, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b1, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b5, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b7, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b9, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03bf, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03c5, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03c9, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0391, 0, 0, 0, 0}, 0x0386 }, // U0386 # GREEK CAPITAL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0395, 0, 0, 0, 0}, 0x0388 }, // U0388 # GREEK CAPITAL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0397, 0, 0, 0, 0}, 0x0389 }, // U0389 # GREEK CAPITAL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0399, 0, 0, 0, 0}, 0x038a }, // U038A # GREEK CAPITAL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x039f, 0, 0, 0, 0}, 0x038c }, // U038C # GREEK CAPITAL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03a5, 0, 0, 0, 0}, 0x038e }, // U038E # GREEK CAPITAL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03a9, 0, 0, 0, 0}, 0x038f }, // U038F # GREEK CAPITAL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03b1, 0, 0, 0, 0}, 0x03ac }, // U03AC # GREEK SMALL LETTER ALPHA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03b5, 0, 0, 0, 0}, 0x03ad }, // U03AD # GREEK SMALL LETTER EPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03b7, 0, 0, 0, 0}, 0x03ae }, // U03AE # GREEK SMALL LETTER ETA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03b9, 0, 0, 0, 0}, 0x03af }, // U03AF # GREEK SMALL LETTER IOTA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03bf, 0, 0, 0, 0}, 0x03cc }, // U03CC # GREEK SMALL LETTER OMICRON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03c5, 0, 0, 0, 0}, 0x03cd }, // U03CD # GREEK SMALL LETTER UPSILON WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03c9, 0, 0, 0, 0}, 0x03ce }, // U03CE # GREEK SMALL LETTER OMEGA WITH TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03ca, 0, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x03cb, 0, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0413, 0, 0, 0, 0}, 0x0403 }, // U0403 # CYRILLIC CAPITAL LETTER GJE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x041a, 0, 0, 0, 0}, 0x040c }, // U040C # CYRILLIC CAPITAL LETTER KJE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x0433, 0, 0, 0, 0}, 0x0453 }, // U0453 # CYRILLIC SMALL LETTER GJE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x043a, 0, 0, 0, 0}, 0x045c }, // U045C # CYRILLIC SMALL LETTER KJE
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f00, 0, 0, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f01, 0, 0, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f08, 0, 0, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f09, 0, 0, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f10, 0, 0, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f11, 0, 0, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f18, 0, 0, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f19, 0, 0, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f20, 0, 0, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f21, 0, 0, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f28, 0, 0, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f29, 0, 0, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f30, 0, 0, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f31, 0, 0, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f38, 0, 0, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f39, 0, 0, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f40, 0, 0, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f41, 0, 0, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f48, 0, 0, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f49, 0, 0, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f50, 0, 0, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f51, 0, 0, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f59, 0, 0, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f60, 0, 0, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f61, 0, 0, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f68, 0, 0, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), 0x1f69, 0, 0, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0000, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0000, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0049, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0069, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0d }, // U1F0D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0395, 0, 0}, 0x1f1d }, // U1F1D # GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2d }, // U1F2D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3d }, // U1F3D # GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x039f, 0, 0}, 0x1f4d }, // U1F4D # GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5d }, // U1F5D # GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6d }, // U1F6D # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f05 }, // U1F05 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b5, 0, 0}, 0x1f15 }, // U1F15 # GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f25 }, // U1F25 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f35 }, // U1F35 # GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03bf, 0, 0}, 0x1f45 }, // U1F45 # GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f55 }, // U1F55 # GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f65 }, // U1F65 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0c }, // U1F0C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0395, 0, 0}, 0x1f1c }, // U1F1C # GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2c }, // U1F2C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3c }, // U1F3C # GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x039f, 0, 0}, 0x1f4c }, // U1F4C # GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6c }, // U1F6C # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f04 }, // U1F04 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b5, 0, 0}, 0x1f14 }, // U1F14 # GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f24 }, // U1F24 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f34 }, // U1F34 # GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03bf, 0, 0}, 0x1f44 }, // U1F44 # GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f54 }, // U1F54 # GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f64 }, // U1F64 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0043, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0063, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002f, 0x004f, 0, 0}, 0x01fe }, // U01FE # LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x002f, 0x006f, 0, 0}, 0x01ff }, // U01FF # LATIN SMALL LETTER O WITH STROKE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0041, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x006f, 0x0061, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004f, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0055, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006f, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0075, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0045, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x004f, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0065, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x006f, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Acute), 0, 0, 0, 0}, 0x00b4 }, // acute
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea4 }, // U1EA4 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ebe }, // U1EBE # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed0 }, // U1ED0 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea5 }, // U1EA5 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ebf }, // U1EBF # LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed1 }, // U1ED1 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0, 0}, 0x1e4c }, // U1E4C # LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Tilde), 0x0055, 0, 0, 0}, 0x1e78 }, // U1E78 # LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0, 0}, 0x1e4d }, // U1E4D # LATIN SMALL LETTER O WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Tilde), 0x0075, 0, 0, 0}, 0x1e79 }, // U1E79 # LATIN SMALL LETTER U WITH TILDE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0, 0}, 0x1e16 }, // U1E16 # LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0, 0}, 0x1e52 }, // U1E52 # LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0, 0}, 0x1e17 }, // U1E17 # LATIN SMALL LETTER E WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0, 0}, 0x1e53 }, // U1E53 # LATIN SMALL LETTER O WITH MACRON AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eae }, // U1EAE # LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eaf }, // U1EAF # LATIN SMALL LETTER A WITH BREVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0049, 0, 0, 0}, 0x1e2e }, // U1E2E # LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01d7 }, // U01D7 # LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0069, 0, 0, 0}, 0x1e2f }, // U1E2F # LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01d8 }, // U01D8 # LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x0390 }, // U0390 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x03b0 }, // U03B0 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Abovering), 0x0041, 0, 0, 0}, 0x01fa }, // U01FA # LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Abovering), 0x0061, 0, 0, 0}, 0x01fb }, // U01FB # LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Cedilla), 0x0043, 0, 0, 0}, 0x1e08 }, // U1E08 # LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Cedilla), 0x0063, 0, 0, 0}, 0x1e09 }, // U1E09 # LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1eda }, // U1EDA # LATIN CAPITAL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1ee8 }, // U1EE8 # LATIN CAPITAL LETTER U WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edb }, // U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
+    { {UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1ee9 }, // U1EE9 # LATIN SMALL LETTER U WITH HORN AND ACUTE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x207a }, // U207A # SUPERSCRIPT PLUS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x207c }, // U207C # SUPERSCRIPT EQUALS SIGN
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2079 }, // U2079 # SUPERSCRIPT NINE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x00b3 }, // U00B3 # SUPERSCRIPT THREE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x00b9 }, // U00B9 # SUPERSCRIPT ONE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2070 }, // U2070 # SUPERSCRIPT ZERO
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2078 }, // U2078 # SUPERSCRIPT EIGHT
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2074 }, // U2074 # SUPERSCRIPT FOUR
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2075 }, // U2075 # SUPERSCRIPT FIVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2077 }, // U2077 # SUPERSCRIPT SEVEN
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0, 0, 0, 0}, 0x2076 }, // U2076 # SUPERSCRIPT SIX
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x0041, 0, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x0045, 0, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x004f, 0, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x0061, 0, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x0065, 0, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0000, 0x006f, 0, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0020, 0, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0028, 0, 0, 0, 0}, 0x207d }, // U207D # SUPERSCRIPT LEFT PARENTHESIS
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0029, 0, 0, 0, 0}, 0x207e }, // U207E # SUPERSCRIPT RIGHT PARENTHESIS
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x002b, 0, 0, 0, 0}, 0x207a }, // U207A # SUPERSCRIPT PLUS SIGN
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0030, 0, 0, 0, 0}, 0x2070 }, // U2070 # SUPERSCRIPT ZERO
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0031, 0, 0, 0, 0}, 0x00b9 }, // U00B9 # SUPERSCRIPT ONE
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0032, 0, 0, 0, 0}, 0x00b2 }, // U00B2 # SUPERSCRIPT TWO
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0033, 0, 0, 0, 0}, 0x00b3 }, // U00B3 # SUPERSCRIPT THREE
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0034, 0, 0, 0, 0}, 0x2074 }, // U2074 # SUPERSCRIPT FOUR
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0035, 0, 0, 0, 0}, 0x2075 }, // U2075 # SUPERSCRIPT FIVE
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0036, 0, 0, 0, 0}, 0x2076 }, // U2076 # SUPERSCRIPT SIX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0037, 0, 0, 0, 0}, 0x2077 }, // U2077 # SUPERSCRIPT SEVEN
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0038, 0, 0, 0, 0}, 0x2078 }, // U2078 # SUPERSCRIPT EIGHT
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0039, 0, 0, 0, 0}, 0x2079 }, // U2079 # SUPERSCRIPT NINE
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x003d, 0, 0, 0, 0}, 0x207c }, // U207C # SUPERSCRIPT EQUALS SIGN
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0, 0}, 0x00c2 }, // U00C2 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0043, 0, 0, 0, 0}, 0x0108 }, // U0108 # LATIN CAPITAL LETTER C WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0, 0}, 0x00ca }, // U00CA # LATIN CAPITAL LETTER E WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0047, 0, 0, 0, 0}, 0x011c }, // U011C # LATIN CAPITAL LETTER G WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0048, 0, 0, 0, 0}, 0x0124 }, // U0124 # LATIN CAPITAL LETTER H WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0049, 0, 0, 0, 0}, 0x00ce }, // U00CE # LATIN CAPITAL LETTER I WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x004a, 0, 0, 0, 0}, 0x0134 }, // U0134 # LATIN CAPITAL LETTER J WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0, 0}, 0x00d4 }, // U00D4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0053, 0, 0, 0, 0}, 0x015c }, // U015C # LATIN CAPITAL LETTER S WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0055, 0, 0, 0, 0}, 0x00db }, // U00DB # LATIN CAPITAL LETTER U WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0057, 0, 0, 0, 0}, 0x0174 }, // U0174 # LATIN CAPITAL LETTER W WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0059, 0, 0, 0, 0}, 0x0176 }, // U0176 # LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x005a, 0, 0, 0, 0}, 0x1e90 }, // U1E90 # LATIN CAPITAL LETTER Z WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0, 0}, 0x00e2 }, // U00E2 # LATIN SMALL LETTER A WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0063, 0, 0, 0, 0}, 0x0109 }, // U0109 # LATIN SMALL LETTER C WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0, 0}, 0x00ea }, // U00EA # LATIN SMALL LETTER E WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0067, 0, 0, 0, 0}, 0x011d }, // U011D # LATIN SMALL LETTER G WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0068, 0, 0, 0, 0}, 0x0125 }, // U0125 # LATIN SMALL LETTER H WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0069, 0, 0, 0, 0}, 0x00ee }, // U00EE # LATIN SMALL LETTER I WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x006a, 0, 0, 0, 0}, 0x0135 }, // U0135 # LATIN SMALL LETTER J WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0, 0}, 0x00f4 }, // U00F4 # LATIN SMALL LETTER O WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0073, 0, 0, 0, 0}, 0x015d }, // U015D # LATIN SMALL LETTER S WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0075, 0, 0, 0, 0}, 0x00fb }, // U00FB # LATIN SMALL LETTER U WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0077, 0, 0, 0, 0}, 0x0175 }, // U0175 # LATIN SMALL LETTER W WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x0079, 0, 0, 0, 0}, 0x0177 }, // U0177 # LATIN SMALL LETTER Y WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x007a, 0, 0, 0, 0}, 0x1e91 }, // U1E91 # LATIN SMALL LETTER Z WITH CIRCUMFLEX
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1ea0, 0, 0, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1ea1, 0, 0, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1eb8, 0, 0, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1eb9, 0, 0, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1ecc, 0, 0, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x1ecd, 0, 0, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x2212, 0, 0, 0, 0}, 0x207b }, // U207B # SUPERSCRIPT MINUS
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e00, 0, 0, 0, 0}, 0x3192 }, // U3192 # IDEOGRAPHIC ANNOTATION ONE MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e01, 0, 0, 0, 0}, 0x319c }, // U319C # IDEOGRAPHIC ANNOTATION FOURTH MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e09, 0, 0, 0, 0}, 0x3194 }, // U3194 # IDEOGRAPHIC ANNOTATION THREE MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e0a, 0, 0, 0, 0}, 0x3196 }, // U3196 # IDEOGRAPHIC ANNOTATION TOP MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e0b, 0, 0, 0, 0}, 0x3198 }, // U3198 # IDEOGRAPHIC ANNOTATION BOTTOM MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e19, 0, 0, 0, 0}, 0x319b }, // U319B # IDEOGRAPHIC ANNOTATION THIRD MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e2d, 0, 0, 0, 0}, 0x3197 }, // U3197 # IDEOGRAPHIC ANNOTATION MIDDLE MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e59, 0, 0, 0, 0}, 0x319a }, // U319A # IDEOGRAPHIC ANNOTATION SECOND MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4e8c, 0, 0, 0, 0}, 0x3193 }, // U3193 # IDEOGRAPHIC ANNOTATION TWO MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x4eba, 0, 0, 0, 0}, 0x319f }, // U319F # IDEOGRAPHIC ANNOTATION MAN MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x56db, 0, 0, 0, 0}, 0x3195 }, // U3195 # IDEOGRAPHIC ANNOTATION FOUR MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x5730, 0, 0, 0, 0}, 0x319e }, // U319E # IDEOGRAPHIC ANNOTATION EARTH MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x5929, 0, 0, 0, 0}, 0x319d }, // U319D # IDEOGRAPHIC ANNOTATION HEAVEN MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), 0x7532, 0, 0, 0, 0}, 0x3199 }, // U3199 # IDEOGRAPHIC ANNOTATION FIRST MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0041, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0045, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004f, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0061, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0065, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006f, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0053, 0x004d, 0, 0}, 0x2120 }, // U2120 # SERVICE MARK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x0054, 0x004d, 0, 0}, 0x2122 }, // U2122 # TRADE MARK SIGN
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0061, 0, 0}, 0x00aa }, // U00AA # FEMININE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0061, 0, 0}, 0x00aa }, // U00AA # FEMININE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0068, 0, 0}, 0x02b0 }, // U02B0 # MODIFIER LETTER SMALL H
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0068, 0, 0}, 0x02b0 }, // U02B0 # MODIFIER LETTER SMALL H
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0069, 0, 0}, 0x2071 }, // U2071 # SUPERSCRIPT LATIN SMALL LETTER I
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0069, 0, 0}, 0x2071 }, // U2071 # SUPERSCRIPT LATIN SMALL LETTER I
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006a, 0, 0}, 0x02b2 }, // U02B2 # MODIFIER LETTER SMALL J
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006a, 0, 0}, 0x02b2 }, // U02B2 # MODIFIER LETTER SMALL J
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006c, 0, 0}, 0x02e1 }, // U02E1 # MODIFIER LETTER SMALL L
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006c, 0, 0}, 0x02e1 }, // U02E1 # MODIFIER LETTER SMALL L
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006e, 0, 0}, 0x207f }, // U207F # SUPERSCRIPT LATIN SMALL LETTER N
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006e, 0, 0}, 0x207f }, // U207F # SUPERSCRIPT LATIN SMALL LETTER N
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x00ba }, // U00BA # MASCULINE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x006f, 0, 0}, 0x00ba }, // U00BA # MASCULINE ORDINAL INDICATOR
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0072, 0, 0}, 0x02b3 }, // U02B3 # MODIFIER LETTER SMALL R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0072, 0, 0}, 0x02b3 }, // U02B3 # MODIFIER LETTER SMALL R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0073, 0, 0}, 0x02e2 }, // U02E2 # MODIFIER LETTER SMALL S
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0073, 0, 0}, 0x02e2 }, // U02E2 # MODIFIER LETTER SMALL S
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0077, 0, 0}, 0x02b7 }, // U02B7 # MODIFIER LETTER SMALL W
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0077, 0, 0}, 0x02b7 }, // U02B7 # MODIFIER LETTER SMALL W
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0078, 0, 0}, 0x02e3 }, // U02E3 # MODIFIER LETTER SMALL X
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0078, 0, 0}, 0x02e3 }, // U02E3 # MODIFIER LETTER SMALL X
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0079, 0, 0}, 0x02b8 }, // U02B8 # MODIFIER LETTER SMALL Y
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0079, 0, 0}, 0x02b8 }, // U02B8 # MODIFIER LETTER SMALL Y
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0263, 0, 0}, 0x02e0 }, // U02E0 # MODIFIER LETTER SMALL GAMMA
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0263, 0, 0}, 0x02e0 }, // U02E0 # MODIFIER LETTER SMALL GAMMA
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0266, 0, 0}, 0x02b1 }, // U02B1 # MODIFIER LETTER SMALL H WITH HOOK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0266, 0, 0}, 0x02b1 }, // U02B1 # MODIFIER LETTER SMALL H WITH HOOK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0279, 0, 0}, 0x02b4 }, // U02B4 # MODIFIER LETTER SMALL TURNED R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0279, 0, 0}, 0x02b4 }, // U02B4 # MODIFIER LETTER SMALL TURNED R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x027b, 0, 0}, 0x02b5 }, // U02B5 # MODIFIER LETTER SMALL TURNED R WITH HOOK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x027b, 0, 0}, 0x02b5 }, // U02B5 # MODIFIER LETTER SMALL TURNED R WITH HOOK
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0281, 0, 0}, 0x02b6 }, // U02B6 # MODIFIER LETTER SMALL CAPITAL INVERTED R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0281, 0, 0}, 0x02b6 }, // U02B6 # MODIFIER LETTER SMALL CAPITAL INVERTED R
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0295, 0, 0}, 0x02e4 }, // U02E4 # MODIFIER LETTER SMALL REVERSED GLOTTAL STOP
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0295, 0, 0}, 0x02e4 }, // U02E4 # MODIFIER LETTER SMALL REVERSED GLOTTAL STOP
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Circumflex), 0, 0, 0, 0}, 0x005e }, // asciicircum
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x0045, 0, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x004f, 0, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x0065, 0, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Circumflex), UNITIZE(Qt::Key_Dead_Belowdot), 0x006f, 0, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0000, 0, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0000, 0, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0000, 0, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0000, 0, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0020, 0, 0, 0, 0}, 0x007e }, // asciitilde
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0041, 0, 0, 0, 0}, 0x00c3 }, // U00C3 # LATIN CAPITAL LETTER A WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0045, 0, 0, 0, 0}, 0x1ebc }, // U1EBC # LATIN CAPITAL LETTER E WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0049, 0, 0, 0, 0}, 0x0128 }, // U0128 # LATIN CAPITAL LETTER I WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x004e, 0, 0, 0, 0}, 0x00d1 }, // U00D1 # LATIN CAPITAL LETTER N WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0, 0, 0}, 0x00d5 }, // U00D5 # LATIN CAPITAL LETTER O WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0055, 0, 0, 0, 0}, 0x0168 }, // U0168 # LATIN CAPITAL LETTER U WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0056, 0, 0, 0, 0}, 0x1e7c }, // U1E7C # LATIN CAPITAL LETTER V WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0059, 0, 0, 0, 0}, 0x1ef8 }, // U1EF8 # LATIN CAPITAL LETTER Y WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0061, 0, 0, 0, 0}, 0x00e3 }, // U00E3 # LATIN SMALL LETTER A WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0065, 0, 0, 0, 0}, 0x1ebd }, // U1EBD # LATIN SMALL LETTER E WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0069, 0, 0, 0, 0}, 0x0129 }, // U0129 # LATIN SMALL LETTER I WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x006e, 0, 0, 0, 0}, 0x00f1 }, // U00F1 # LATIN SMALL LETTER N WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0, 0, 0}, 0x00f5 }, // U00F5 # LATIN SMALL LETTER O WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0075, 0, 0, 0, 0}, 0x0169 }, // U0169 # LATIN SMALL LETTER U WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0076, 0, 0, 0, 0}, 0x1e7d }, // U1E7D # LATIN SMALL LETTER V WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0079, 0, 0, 0, 0}, 0x1ef9 }, // U1EF9 # LATIN SMALL LETTER Y WITH TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00c2, 0, 0, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00ca, 0, 0, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00d4, 0, 0, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00e2, 0, 0, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00ea, 0, 0, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x00f4, 0, 0, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0102, 0, 0, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0103, 0, 0, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x01A0, 0, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x01A1, 0, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x01AF, 0, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x01B0, 0, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0391, 0, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0397, 0, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0399, 0, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03a9, 0, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b1, 0, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b7, 0, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b9, 0, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03c5, 0, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03c9, 0, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0391, 0, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0397, 0, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0399, 0, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03a5, 0, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03a9, 0, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b1, 0, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b7, 0, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b9, 0, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03c5, 0, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03c9, 0, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03b1, 0, 0, 0, 0}, 0x1fb6 }, // U1FB6 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03b7, 0, 0, 0, 0}, 0x1fc6 }, // U1FC6 # GREEK SMALL LETTER ETA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03b9, 0, 0, 0, 0}, 0x1fd6 }, // U1FD6 # GREEK SMALL LETTER IOTA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03c5, 0, 0, 0, 0}, 0x1fe6 }, // U1FE6 # GREEK SMALL LETTER UPSILON WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03c9, 0, 0, 0, 0}, 0x1ff6 }, // U1FF6 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03ca, 0, 0, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x03cb, 0, 0, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f00, 0, 0, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f01, 0, 0, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f08, 0, 0, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f09, 0, 0, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f20, 0, 0, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f21, 0, 0, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f28, 0, 0, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f29, 0, 0, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f30, 0, 0, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f31, 0, 0, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f38, 0, 0, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f39, 0, 0, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f50, 0, 0, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f51, 0, 0, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f59, 0, 0, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f60, 0, 0, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f61, 0, 0, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f68, 0, 0, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), 0x1f69, 0, 0, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03b9, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x03c5, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f0f }, // U1F0F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f2f }, // U1F2F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0399, 0, 0}, 0x1f3f }, // U1F3F # GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a5, 0, 0}, 0x1f5f }, // U1F5F # GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1f6f }, // U1F6F # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f07 }, // U1F07 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f27 }, // U1F27 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b9, 0, 0}, 0x1f37 }, // U1F37 # GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c5, 0, 0}, 0x1f57 }, // U1F57 # GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1f67 }, // U1F67 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f0e }, // U1F0E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f2e }, // U1F2E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0399, 0, 0}, 0x1f3e }, // U1F3E # GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1f6e }, // U1F6E # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f06 }, // U1F06 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f26 }, // U1F26 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b9, 0, 0}, 0x1f36 }, // U1F36 # GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c5, 0, 0}, 0x1f56 }, // U1F56 # GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1f66 }, // U1F66 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1eaa }, // U1EAA # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec4 }, // U1EC4 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed6 }, // U1ED6 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1eab }, // U1EAB # LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec5 }, // U1EC5 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed7 }, // U1ED7 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Tilde), 0, 0, 0, 0}, 0x007e }, // asciitilde
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb4 }, // U1EB4 # LATIN CAPITAL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb5 }, // U1EB5 # LATIN SMALL LETTER A WITH BREVE AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0}, 0x1fd7 }, // U1FD7 # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0}, 0x1fe7 }, // U1FE7 # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ee0 }, // U1EE0 # LATIN CAPITAL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eee }, // U1EEE # LATIN CAPITAL LETTER U WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1ee1 }, // U1EE1 # LATIN SMALL LETTER O WITH HORN AND TILDE
+    { {UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eef }, // U1EEF # LATIN SMALL LETTER U WITH HORN AND TILDE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x004c, 0, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x004f, 0, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x0052, 0, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x006c, 0, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x006f, 0, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Macron), 0x0000, 0x0072, 0, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0020, 0, 0, 0, 0}, 0x00af }, // macron
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0041, 0, 0, 0, 0}, 0x0100 }, // U0100 # LATIN CAPITAL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0045, 0, 0, 0, 0}, 0x0112 }, // U0112 # LATIN CAPITAL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0047, 0, 0, 0, 0}, 0x1e20 }, // U1E20 # LATIN CAPITAL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0049, 0, 0, 0, 0}, 0x012a }, // U012A # LATIN CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x004f, 0, 0, 0, 0}, 0x014c }, // U014C # LATIN CAPITAL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0055, 0, 0, 0, 0}, 0x016a }, // U016A # LATIN CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0059, 0, 0, 0, 0}, 0x0232 }, // U0232 # LATIN CAPITAL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0061, 0, 0, 0, 0}, 0x0101 }, // U0101 # LATIN SMALL LETTER A WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0065, 0, 0, 0, 0}, 0x0113 }, // U0113 # LATIN SMALL LETTER E WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0067, 0, 0, 0, 0}, 0x1e21 }, // U1E21 # LATIN SMALL LETTER G WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0069, 0, 0, 0, 0}, 0x012b }, // U012B # LATIN SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x006f, 0, 0, 0, 0}, 0x014d }, // U014D # LATIN SMALL LETTER O WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0075, 0, 0, 0, 0}, 0x016b }, // U016B # LATIN SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0079, 0, 0, 0, 0}, 0x0233 }, // U0233 # LATIN SMALL LETTER Y WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00c4, 0, 0, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00c6, 0, 0, 0, 0}, 0x01e2 }, // U01E2 # LATIN CAPITAL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00d5, 0, 0, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00d6, 0, 0, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00dc, 0, 0, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00e4, 0, 0, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00e6, 0, 0, 0, 0}, 0x01e3 }, // U01E3 # LATIN SMALL LETTER AE WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00f5, 0, 0, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00f6, 0, 0, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x00fc, 0, 0, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x01ea, 0, 0, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x01eb, 0, 0, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0226, 0, 0, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0227, 0, 0, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x022e, 0, 0, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x022f, 0, 0, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0391, 0, 0, 0, 0}, 0x1fb9 }, // U1FB9 # GREEK CAPITAL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0399, 0, 0, 0, 0}, 0x1fd9 }, // U1FD9 # GREEK CAPITAL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x03a5, 0, 0, 0, 0}, 0x1fe9 }, // U1FE9 # GREEK CAPITAL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x03b1, 0, 0, 0, 0}, 0x1fb1 }, // U1FB1 # GREEK SMALL LETTER ALPHA WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x03b9, 0, 0, 0, 0}, 0x1fd1 }, // U1FD1 # GREEK SMALL LETTER IOTA WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x03c5, 0, 0, 0, 0}, 0x1fe1 }, // U1FE1 # GREEK SMALL LETTER UPSILON WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0418, 0, 0, 0, 0}, 0x04e2 }, // U04E2 # CYRILLIC CAPITAL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0423, 0, 0, 0, 0}, 0x04ee }, // U04EE # CYRILLIC CAPITAL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0438, 0, 0, 0, 0}, 0x04e3 }, // U04E3 # CYRILLIC SMALL LETTER I WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x0443, 0, 0, 0, 0}, 0x04ef }, // U04EF # CYRILLIC SMALL LETTER U WITH MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x1e36, 0, 0, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x1e37, 0, 0, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x1e5a, 0, 0, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), 0x1e5b, 0, 0, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x004c, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0052, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x006c, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0072, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0041, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x004f, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0061, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x006f, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0041, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x002e, 0x004f, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x002e, 0x0061, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x002e, 0x006f, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x003b, 0x004f, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x003b, 0x006f, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004f, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006f, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0, 0}, 0x022c }, // U022C # LATIN CAPITAL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0, 0}, 0x022d }, // U022D # LATIN SMALL LETTER O WITH TILDE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Macron), 0, 0, 0, 0}, 0x00af }, // macron
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Abovedot), 0x0041, 0, 0, 0}, 0x01e0 }, // U01E0 # LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Abovedot), 0x004f, 0, 0, 0}, 0x0230 }, // U0230 # LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Abovedot), 0x0061, 0, 0, 0}, 0x01e1 }, // U01E1 # LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Abovedot), 0x006f, 0, 0, 0}, 0x0231 }, // U0231 # LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0041, 0, 0, 0}, 0x01de }, // U01DE # LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x004f, 0, 0, 0}, 0x022a }, // U022A # LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01d5 }, // U01D5 # LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0061, 0, 0, 0}, 0x01df }, // U01DF # LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x006f, 0, 0, 0}, 0x022b }, // U022B # LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01d6 }, // U01D6 # LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Ogonek), 0x004f, 0, 0, 0}, 0x01ec }, // U01EC # LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Ogonek), 0x006f, 0, 0, 0}, 0x01ed }, // U01ED # LATIN SMALL LETTER O WITH OGONEK AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Belowdot), 0x004c, 0, 0, 0}, 0x1e38 }, // U1E38 # LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Belowdot), 0x0052, 0, 0, 0}, 0x1e5c }, // U1E5C # LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Belowdot), 0x006c, 0, 0, 0}, 0x1e39 }, // U1E39 # LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
+    { {UNITIZE(Qt::Key_Dead_Macron), UNITIZE(Qt::Key_Dead_Belowdot), 0x0072, 0, 0, 0}, 0x1e5d }, // U1E5D # LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Breve), 0x0000, 0x0041, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Breve), 0x0000, 0x0061, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0020, 0, 0, 0, 0}, 0x02d8 }, // breve
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0, 0}, 0x0102 }, // U0102 # LATIN CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0045, 0, 0, 0, 0}, 0x0114 }, // U0114 # LATIN CAPITAL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0047, 0, 0, 0, 0}, 0x011e }, // U011E # LATIN CAPITAL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0049, 0, 0, 0, 0}, 0x012c }, // U012C # LATIN CAPITAL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x004f, 0, 0, 0, 0}, 0x014e }, // U014E # LATIN CAPITAL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0055, 0, 0, 0, 0}, 0x016c }, // U016C # LATIN CAPITAL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0, 0}, 0x0103 }, // U0103 # LATIN SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0065, 0, 0, 0, 0}, 0x0115 }, // U0115 # LATIN SMALL LETTER E WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0067, 0, 0, 0, 0}, 0x011f }, // U011F # LATIN SMALL LETTER G WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0069, 0, 0, 0, 0}, 0x012d }, // U012D # LATIN SMALL LETTER I WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x006f, 0, 0, 0, 0}, 0x014f }, // U014F # LATIN SMALL LETTER O WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0075, 0, 0, 0, 0}, 0x016d }, // U016D # LATIN SMALL LETTER U WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0228, 0, 0, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0229, 0, 0, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0391, 0, 0, 0, 0}, 0x1fb8 }, // U1FB8 # GREEK CAPITAL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0399, 0, 0, 0, 0}, 0x1fd8 }, // U1FD8 # GREEK CAPITAL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x03a5, 0, 0, 0, 0}, 0x1fe8 }, // U1FE8 # GREEK CAPITAL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x03b1, 0, 0, 0, 0}, 0x1fb0 }, // U1FB0 # GREEK SMALL LETTER ALPHA WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x03b9, 0, 0, 0, 0}, 0x1fd0 }, // U1FD0 # GREEK SMALL LETTER IOTA WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x03c5, 0, 0, 0, 0}, 0x1fe0 }, // U1FE0 # GREEK SMALL LETTER UPSILON WITH VRACHY
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0410, 0, 0, 0, 0}, 0x04d0 }, // U04D0 # CYRILLIC CAPITAL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0415, 0, 0, 0, 0}, 0x04d6 }, // U04D6 # CYRILLIC CAPITAL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0416, 0, 0, 0, 0}, 0x04c1 }, // U04C1 # CYRILLIC CAPITAL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0418, 0, 0, 0, 0}, 0x0419 }, // U0419 # CYRILLIC CAPITAL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0423, 0, 0, 0, 0}, 0x040e }, // U040E # CYRILLIC CAPITAL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0430, 0, 0, 0, 0}, 0x04d1 }, // U04D1 # CYRILLIC SMALL LETTER A WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0435, 0, 0, 0, 0}, 0x04d7 }, // U04D7 # CYRILLIC SMALL LETTER IE WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0436, 0, 0, 0, 0}, 0x04c2 }, // U04C2 # CYRILLIC SMALL LETTER ZHE WITH BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0438, 0, 0, 0, 0}, 0x0439 }, // U0439 # CYRILLIC SMALL LETTER SHORT I
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x0443, 0, 0, 0, 0}, 0x045e }, // U045E # CYRILLIC SMALL LETTER SHORT U
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x1ea0, 0, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), 0x1ea1, 0, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0041, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0061, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0045, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Multi_key), 0x002c, 0x0065, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Dead_Breve), 0, 0, 0, 0}, 0x02d8 }, // breve
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Dead_Cedilla), 0x0045, 0, 0, 0}, 0x1e1c }, // U1E1C # LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Dead_Cedilla), 0x0065, 0, 0, 0}, 0x1e1d }, // U1E1D # LATIN SMALL LETTER E WITH CEDILLA AND BREVE
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Breve), UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0000, 0x0053, 0, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0000, 0x0053, 0, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0000, 0x0073, 0, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0000, 0x0073, 0, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0020, 0, 0, 0, 0}, 0x02d9 }, // abovedot
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0041, 0, 0, 0, 0}, 0x0226 }, // U0226 # LATIN CAPITAL LETTER A WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0042, 0, 0, 0, 0}, 0x1e02 }, // U1E02 # LATIN CAPITAL LETTER B WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0043, 0, 0, 0, 0}, 0x010a }, // U010A # LATIN CAPITAL LETTER C WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0044, 0, 0, 0, 0}, 0x1e0a }, // U1E0A # LATIN CAPITAL LETTER D WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0045, 0, 0, 0, 0}, 0x0116 }, // U0116 # LATIN CAPITAL LETTER E WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0046, 0, 0, 0, 0}, 0x1e1e }, // U1E1E # LATIN CAPITAL LETTER F WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0047, 0, 0, 0, 0}, 0x0120 }, // U0120 # LATIN CAPITAL LETTER G WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0048, 0, 0, 0, 0}, 0x1e22 }, // U1E22 # LATIN CAPITAL LETTER H WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0049, 0, 0, 0, 0}, 0x0130 }, // U0130 # LATIN CAPITAL LETTER I WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x004d, 0, 0, 0, 0}, 0x1e40 }, // U1E40 # LATIN CAPITAL LETTER M WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x004e, 0, 0, 0, 0}, 0x1e44 }, // U1E44 # LATIN CAPITAL LETTER N WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x004f, 0, 0, 0, 0}, 0x022e }, // U022E # LATIN CAPITAL LETTER O WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0050, 0, 0, 0, 0}, 0x1e56 }, // U1E56 # LATIN CAPITAL LETTER P WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0052, 0, 0, 0, 0}, 0x1e58 }, // U1E58 # LATIN CAPITAL LETTER R WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0053, 0, 0, 0, 0}, 0x1e60 }, // U1E60 # LATIN CAPITAL LETTER S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0054, 0, 0, 0, 0}, 0x1e6a }, // U1E6A # LATIN CAPITAL LETTER T WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0057, 0, 0, 0, 0}, 0x1e86 }, // U1E86 # LATIN CAPITAL LETTER W WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0058, 0, 0, 0, 0}, 0x1e8a }, // U1E8A # LATIN CAPITAL LETTER X WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0059, 0, 0, 0, 0}, 0x1e8e }, // U1E8E # LATIN CAPITAL LETTER Y WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x005a, 0, 0, 0, 0}, 0x017b }, // U017B # LATIN CAPITAL LETTER Z WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0061, 0, 0, 0, 0}, 0x0227 }, // U0227 # LATIN SMALL LETTER A WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0062, 0, 0, 0, 0}, 0x1e03 }, // U1E03 # LATIN SMALL LETTER B WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0063, 0, 0, 0, 0}, 0x010b }, // U010B # LATIN SMALL LETTER C WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0064, 0, 0, 0, 0}, 0x1e0b }, // U1E0B # LATIN SMALL LETTER D WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0065, 0, 0, 0, 0}, 0x0117 }, // U0117 # LATIN SMALL LETTER E WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0066, 0, 0, 0, 0}, 0x1e1f }, // U1E1F # LATIN SMALL LETTER F WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0067, 0, 0, 0, 0}, 0x0121 }, // U0121 # LATIN SMALL LETTER G WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0068, 0, 0, 0, 0}, 0x1e23 }, // U1E23 # LATIN SMALL LETTER H WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0069, 0, 0, 0, 0}, 0x0131 }, // U0131 # LATIN SMALL LETTER DOTLESS I
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x006d, 0, 0, 0, 0}, 0x1e41 }, // U1E41 # LATIN SMALL LETTER M WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x006e, 0, 0, 0, 0}, 0x1e45 }, // U1E45 # LATIN SMALL LETTER N WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x006f, 0, 0, 0, 0}, 0x022f }, // U022F # LATIN SMALL LETTER O WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0070, 0, 0, 0, 0}, 0x1e57 }, // U1E57 # LATIN SMALL LETTER P WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0072, 0, 0, 0, 0}, 0x1e59 }, // U1E59 # LATIN SMALL LETTER R WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0073, 0, 0, 0, 0}, 0x1e61 }, // U1E61 # LATIN SMALL LETTER S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0074, 0, 0, 0, 0}, 0x1e6b }, // U1E6B # LATIN SMALL LETTER T WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0077, 0, 0, 0, 0}, 0x1e87 }, // U1E87 # LATIN SMALL LETTER W WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0078, 0, 0, 0, 0}, 0x1e8b }, // U1E8B # LATIN SMALL LETTER X WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0079, 0, 0, 0, 0}, 0x1e8f }, // U1E8F # LATIN SMALL LETTER Y WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x007a, 0, 0, 0, 0}, 0x017c }, // U017C # LATIN SMALL LETTER Z WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x015a, 0, 0, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x015b, 0, 0, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0160, 0, 0, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x0161, 0, 0, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x017f, 0, 0, 0, 0}, 0x1e9b }, // U1E9B # LATIN SMALL LETTER LONG S WITH DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x1e62, 0, 0, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), 0x1e63, 0, 0, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0053, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0021, 0x0073, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0053, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x0063, 0x0073, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0053, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0073, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Acute), 0x0053, 0, 0, 0}, 0x1e64 }, // U1E64 # LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Acute), 0x0073, 0, 0, 0}, 0x1e65 }, // U1E65 # LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Abovedot), 0, 0, 0, 0}, 0x02d9 }, // abovedot
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Caron), 0x0053, 0, 0, 0}, 0x1e66 }, // U1E66 # LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Caron), 0x0073, 0, 0, 0}, 0x1e67 }, // U1E67 # LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Belowdot), 0x0053, 0, 0, 0}, 0x1e68 }, // U1E68 # LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovedot), UNITIZE(Qt::Key_Dead_Belowdot), 0x0073, 0, 0, 0}, 0x1e69 }, // U1E69 # LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0000, 0x004f, 0, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0000, 0x006f, 0, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0020, 0, 0, 0, 0}, 0x005c }, // quotedbl
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0027, 0, 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0041, 0, 0, 0, 0}, 0x00c4 }, // U00C4 # LATIN CAPITAL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0045, 0, 0, 0, 0}, 0x00cb }, // U00CB # LATIN CAPITAL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0048, 0, 0, 0, 0}, 0x1e26 }, // U1E26 # LATIN CAPITAL LETTER H WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0049, 0, 0, 0, 0}, 0x00cf }, // U00CF # LATIN CAPITAL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x004f, 0, 0, 0, 0}, 0x00d6 }, // U00D6 # LATIN CAPITAL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0, 0}, 0x00dc }, // U00DC # LATIN CAPITAL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0057, 0, 0, 0, 0}, 0x1e84 }, // U1E84 # LATIN CAPITAL LETTER W WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0058, 0, 0, 0, 0}, 0x1e8c }, // U1E8C # LATIN CAPITAL LETTER X WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0059, 0, 0, 0, 0}, 0x0178 }, // U0178 # LATIN CAPITAL LETTER Y WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0061, 0, 0, 0, 0}, 0x00e4 }, // U00E4 # LATIN SMALL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0065, 0, 0, 0, 0}, 0x00eb }, // U00EB # LATIN SMALL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0068, 0, 0, 0, 0}, 0x1e27 }, // U1E27 # LATIN SMALL LETTER H WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0069, 0, 0, 0, 0}, 0x00ef }, // U00EF # LATIN SMALL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x006f, 0, 0, 0, 0}, 0x00f6 }, // U00F6 # LATIN SMALL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0074, 0, 0, 0, 0}, 0x1e97 }, // U1E97 # LATIN SMALL LETTER T WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0, 0}, 0x00fc }, // U00FC # LATIN SMALL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0077, 0, 0, 0, 0}, 0x1e85 }, // U1E85 # LATIN SMALL LETTER W WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0078, 0, 0, 0, 0}, 0x1e8d }, // U1E8D # LATIN SMALL LETTER X WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0079, 0, 0, 0, 0}, 0x00ff }, // U00FF # LATIN SMALL LETTER Y WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x00b4, 0, 0, 0, 0}, 0x0344 }, // U0344 # COMBINING GREEK DIALYTIKA TONOS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x00d5, 0, 0, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x00f5, 0, 0, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x016a, 0, 0, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x016b, 0, 0, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0399, 0, 0, 0, 0}, 0x03aa }, // U03AA # GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x03a5, 0, 0, 0, 0}, 0x03ab }, // U03AB # GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x03b9, 0, 0, 0, 0}, 0x03ca }, // U03CA # GREEK SMALL LETTER IOTA WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x03c5, 0, 0, 0, 0}, 0x03cb }, // U03CB # GREEK SMALL LETTER UPSILON WITH DIALYTIKA
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0406, 0, 0, 0, 0}, 0x0407 }, // U0407 # CYRILLIC CAPITAL LETTER YI
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0410, 0, 0, 0, 0}, 0x04d2 }, // U04D2 # CYRILLIC CAPITAL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0415, 0, 0, 0, 0}, 0x0401 }, // U0401 # CYRILLIC CAPITAL LETTER IO
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0416, 0, 0, 0, 0}, 0x04dc }, // U04DC # CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0417, 0, 0, 0, 0}, 0x04de }, // U04DE # CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0418, 0, 0, 0, 0}, 0x04e4 }, // U04E4 # CYRILLIC CAPITAL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x041e, 0, 0, 0, 0}, 0x04e6 }, // U04E6 # CYRILLIC CAPITAL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0423, 0, 0, 0, 0}, 0x04f0 }, // U04F0 # CYRILLIC CAPITAL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0427, 0, 0, 0, 0}, 0x04f4 }, // U04F4 # CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x042b, 0, 0, 0, 0}, 0x04f8 }, // U04F8 # CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x042d, 0, 0, 0, 0}, 0x04ec }, // U04EC # CYRILLIC CAPITAL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0430, 0, 0, 0, 0}, 0x04d3 }, // U04D3 # CYRILLIC SMALL LETTER A WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0435, 0, 0, 0, 0}, 0x0451 }, // U0451 # CYRILLIC SMALL LETTER IO
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0436, 0, 0, 0, 0}, 0x04dd }, // U04DD # CYRILLIC SMALL LETTER ZHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0437, 0, 0, 0, 0}, 0x04df }, // U04DF # CYRILLIC SMALL LETTER ZE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0438, 0, 0, 0, 0}, 0x04e5 }, // U04E5 # CYRILLIC SMALL LETTER I WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x043e, 0, 0, 0, 0}, 0x04e7 }, // U04E7 # CYRILLIC SMALL LETTER O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0443, 0, 0, 0, 0}, 0x04f1 }, // U04F1 # CYRILLIC SMALL LETTER U WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0447, 0, 0, 0, 0}, 0x04f5 }, // U04F5 # CYRILLIC SMALL LETTER CHE WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x044b, 0, 0, 0, 0}, 0x04f9 }, // U04F9 # CYRILLIC SMALL LETTER YERU WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x044d, 0, 0, 0, 0}, 0x04ed }, // U04ED # CYRILLIC SMALL LETTER E WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x0456, 0, 0, 0, 0}, 0x0457 }, // U0457 # CYRILLIC SMALL LETTER YI
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x04d8, 0, 0, 0, 0}, 0x04da }, // U04DA # CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x04d9, 0, 0, 0, 0}, 0x04db }, // U04DB # CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x04e8, 0, 0, 0, 0}, 0x04ea }, // U04EA # CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), 0x04e9, 0, 0, 0, 0}, 0x04eb }, // U04EB # CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0055, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x005f, 0x0075, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x004f, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x006f, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0055, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Multi_key), 0x00af, 0x0075, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Dead_Tilde), 0x004f, 0, 0, 0}, 0x1e4e }, // U1E4E # LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Dead_Tilde), 0x006f, 0, 0, 0}, 0x1e4f }, // U1E4F # LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Dead_Macron), 0x0055, 0, 0, 0}, 0x1e7a }, // U1E7A # LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Dead_Macron), 0x0075, 0, 0, 0}, 0x1e7b }, // U1E7B # LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
+    { {UNITIZE(Qt::Key_Dead_Diaeresis), UNITIZE(Qt::Key_Dead_Diaeresis), 0, 0, 0, 0}, 0x00a8 }, // diaeresis
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0020, 0, 0, 0, 0}, 0x00b0 }, // degree
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0041, 0, 0, 0, 0}, 0x00c5 }, // U00C5 # LATIN CAPITAL LETTER A WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0055, 0, 0, 0, 0}, 0x016e }, // U016E # LATIN CAPITAL LETTER U WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0061, 0, 0, 0, 0}, 0x00e5 }, // U00E5 # LATIN SMALL LETTER A WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0075, 0, 0, 0, 0}, 0x016f }, // U016F # LATIN SMALL LETTER U WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0077, 0, 0, 0, 0}, 0x1e98 }, // U1E98 # LATIN SMALL LETTER W WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), 0x0079, 0, 0, 0, 0}, 0x1e99 }, // U1E99 # LATIN SMALL LETTER Y WITH RING ABOVE
+    { {UNITIZE(Qt::Key_Dead_Abovering), UNITIZE(Qt::Key_Dead_Abovering), 0, 0, 0, 0}, 0x00b0 }, // degree
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x0020, 0, 0, 0, 0}, 0x02dd }, // U2dd
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x004f, 0, 0, 0, 0}, 0x0150 }, // U0150 # LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x0055, 0, 0, 0, 0}, 0x0170 }, // U0170 # LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x006f, 0, 0, 0, 0}, 0x0151 }, // U0151 # LATIN SMALL LETTER O WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x0075, 0, 0, 0, 0}, 0x0171 }, // U0171 # LATIN SMALL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x0423, 0, 0, 0, 0}, 0x04f2 }, // U04F2 # CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), 0x0443, 0, 0, 0, 0}, 0x04f3 }, // U04F3 # CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE
+    { {UNITIZE(Qt::Key_Dead_Doubleacute), UNITIZE(Qt::Key_Dead_Doubleacute), 0, 0, 0, 0}, 0x02dd }, // U2dd
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0020, 0, 0, 0, 0}, 0x02c7 }, // caron
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0041, 0, 0, 0, 0}, 0x01cd }, // U01CD # LATIN CAPITAL LETTER A WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0043, 0, 0, 0, 0}, 0x010c }, // U010C # LATIN CAPITAL LETTER C WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0044, 0, 0, 0, 0}, 0x010e }, // U010E # LATIN CAPITAL LETTER D WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0045, 0, 0, 0, 0}, 0x011a }, // U011A # LATIN CAPITAL LETTER E WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0047, 0, 0, 0, 0}, 0x01e6 }, // U01E6 # LATIN CAPITAL LETTER G WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0048, 0, 0, 0, 0}, 0x021e }, // U021E # LATIN CAPITAL LETTER H WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0049, 0, 0, 0, 0}, 0x01cf }, // U01CF # LATIN CAPITAL LETTER I WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x004b, 0, 0, 0, 0}, 0x01e8 }, // U01E8 # LATIN CAPITAL LETTER K WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x004c, 0, 0, 0, 0}, 0x013d }, // U013D # LATIN CAPITAL LETTER L WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x004e, 0, 0, 0, 0}, 0x0147 }, // U0147 # LATIN CAPITAL LETTER N WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x004f, 0, 0, 0, 0}, 0x01d1 }, // U01D1 # LATIN CAPITAL LETTER O WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0052, 0, 0, 0, 0}, 0x0158 }, // U0158 # LATIN CAPITAL LETTER R WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0053, 0, 0, 0, 0}, 0x0160 }, // U0160 # LATIN CAPITAL LETTER S WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0054, 0, 0, 0, 0}, 0x0164 }, // U0164 # LATIN CAPITAL LETTER T WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0055, 0, 0, 0, 0}, 0x01d3 }, // U01D3 # LATIN CAPITAL LETTER U WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x005a, 0, 0, 0, 0}, 0x017d }, // U017D # LATIN CAPITAL LETTER Z WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0061, 0, 0, 0, 0}, 0x01ce }, // U01CE # LATIN SMALL LETTER A WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0063, 0, 0, 0, 0}, 0x010d }, // U010D # LATIN SMALL LETTER C WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0064, 0, 0, 0, 0}, 0x010f }, // U010F # LATIN SMALL LETTER D WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0065, 0, 0, 0, 0}, 0x011b }, // U011B # LATIN SMALL LETTER E WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0067, 0, 0, 0, 0}, 0x01e7 }, // U01E7 # LATIN SMALL LETTER G WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0068, 0, 0, 0, 0}, 0x021f }, // U021F # LATIN SMALL LETTER H WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0069, 0, 0, 0, 0}, 0x01d0 }, // U01D0 # LATIN SMALL LETTER I WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x006a, 0, 0, 0, 0}, 0x01f0 }, // U01F0 # LATIN SMALL LETTER J WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x006b, 0, 0, 0, 0}, 0x01e9 }, // U01E9 # LATIN SMALL LETTER K WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x006c, 0, 0, 0, 0}, 0x013e }, // U013E # LATIN SMALL LETTER L WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x006e, 0, 0, 0, 0}, 0x0148 }, // U0148 # LATIN SMALL LETTER N WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x006f, 0, 0, 0, 0}, 0x01d2 }, // U01D2 # LATIN SMALL LETTER O WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0072, 0, 0, 0, 0}, 0x0159 }, // U0159 # LATIN SMALL LETTER R WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0073, 0, 0, 0, 0}, 0x0161 }, // U0161 # LATIN SMALL LETTER S WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0074, 0, 0, 0, 0}, 0x0165 }, // U0165 # LATIN SMALL LETTER T WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0075, 0, 0, 0, 0}, 0x01d4 }, // U01D4 # LATIN SMALL LETTER U WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x007a, 0, 0, 0, 0}, 0x017e }, // U017E # LATIN SMALL LETTER Z WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x00dc, 0, 0, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x00fc, 0, 0, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x01b7, 0, 0, 0, 0}, 0x01ee }, // U01EE # LATIN CAPITAL LETTER EZH WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), 0x0292, 0, 0, 0, 0}, 0x01ef }, // U01EF # LATIN SMALL LETTER EZH WITH CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0055, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), UNITIZE(Qt::Key_Multi_key), 0x0022, 0x0075, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0055, 0, 0, 0}, 0x01d9 }, // U01D9 # LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), UNITIZE(Qt::Key_Dead_Diaeresis), 0x0075, 0, 0, 0}, 0x01da }, // U01DA # LATIN SMALL LETTER U WITH DIAERESIS AND CARON
+    { {UNITIZE(Qt::Key_Dead_Caron), UNITIZE(Qt::Key_Dead_Caron), 0, 0, 0, 0}, 0x02c7 }, // caron
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0020, 0, 0, 0, 0}, 0x00b8 }, // cedilla
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0043, 0, 0, 0, 0}, 0x00c7 }, // U00C7 # LATIN CAPITAL LETTER C WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0044, 0, 0, 0, 0}, 0x1e10 }, // U1E10 # LATIN CAPITAL LETTER D WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0045, 0, 0, 0, 0}, 0x0228 }, // U0228 # LATIN CAPITAL LETTER E WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0047, 0, 0, 0, 0}, 0x0122 }, // U0122 # LATIN CAPITAL LETTER G WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0048, 0, 0, 0, 0}, 0x1e28 }, // U1E28 # LATIN CAPITAL LETTER H WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x004b, 0, 0, 0, 0}, 0x0136 }, // U0136 # LATIN CAPITAL LETTER K WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x004c, 0, 0, 0, 0}, 0x013b }, // U013B # LATIN CAPITAL LETTER L WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x004e, 0, 0, 0, 0}, 0x0145 }, // U0145 # LATIN CAPITAL LETTER N WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0052, 0, 0, 0, 0}, 0x0156 }, // U0156 # LATIN CAPITAL LETTER R WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0053, 0, 0, 0, 0}, 0x015e }, // U015E # LATIN CAPITAL LETTER S WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0054, 0, 0, 0, 0}, 0x0162 }, // U0162 # LATIN CAPITAL LETTER T WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0063, 0, 0, 0, 0}, 0x00e7 }, // U00E7 # LATIN SMALL LETTER C WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0064, 0, 0, 0, 0}, 0x1e11 }, // U1E11 # LATIN SMALL LETTER D WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0065, 0, 0, 0, 0}, 0x0229 }, // U0229 # LATIN SMALL LETTER E WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0067, 0, 0, 0, 0}, 0x0123 }, // U0123 # LATIN SMALL LETTER G WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0068, 0, 0, 0, 0}, 0x1e29 }, // U1E29 # LATIN SMALL LETTER H WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x006b, 0, 0, 0, 0}, 0x0137 }, // U0137 # LATIN SMALL LETTER K WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x006c, 0, 0, 0, 0}, 0x013c }, // U013C # LATIN SMALL LETTER L WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x006e, 0, 0, 0, 0}, 0x0146 }, // U0146 # LATIN SMALL LETTER N WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0072, 0, 0, 0, 0}, 0x0157 }, // U0157 # LATIN SMALL LETTER R WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0073, 0, 0, 0, 0}, 0x015f }, // U015F # LATIN SMALL LETTER S WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), 0x0074, 0, 0, 0, 0}, 0x0163 }, // U0163 # LATIN SMALL LETTER T WITH CEDILLA
+    { {UNITIZE(Qt::Key_Dead_Cedilla), UNITIZE(Qt::Key_Dead_Cedilla), 0, 0, 0, 0}, 0x00b8 }, // cedilla
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0041, 0, 0, 0, 0}, 0x0104 }, // U0104 # LATIN CAPITAL LETTER A WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0045, 0, 0, 0, 0}, 0x0118 }, // U0118 # LATIN CAPITAL LETTER E WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0049, 0, 0, 0, 0}, 0x012e }, // U012E # LATIN CAPITAL LETTER I WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x004f, 0, 0, 0, 0}, 0x01ea }, // U01EA # LATIN CAPITAL LETTER O WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0055, 0, 0, 0, 0}, 0x0172 }, // U0172 # LATIN CAPITAL LETTER U WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0061, 0, 0, 0, 0}, 0x0105 }, // U0105 # LATIN SMALL LETTER A WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0065, 0, 0, 0, 0}, 0x0119 }, // U0119 # LATIN SMALL LETTER E WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0069, 0, 0, 0, 0}, 0x012f }, // U012F # LATIN SMALL LETTER I WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x006f, 0, 0, 0, 0}, 0x01eb }, // U01EB # LATIN SMALL LETTER O WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), 0x0075, 0, 0, 0, 0}, 0x0173 }, // U0173 # LATIN SMALL LETTER U WITH OGONEK
+    { {UNITIZE(Qt::Key_Dead_Ogonek), UNITIZE(Qt::Key_Dead_Ogonek), 0, 0, 0, 0}, 0x02db }, // ogonek
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Ogonek), dead_space, 0, 0, 0, 0}, 0x02db }, // ogonek
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x0391, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x0391, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x0397, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x0397, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03a9, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03a9, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03b1, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03b1, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03b7, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03b7, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03c9, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0313, 0x03c9, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x0391, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x0391, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x0397, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x0397, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03a9, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03a9, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03b1, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03b1, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03b7, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03b7, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03c9, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x0314, 0x03c9, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03b1, 0, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03b1, 0, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03b7, 0, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03b7, 0, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03c9, 0, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x03c9, 0, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f00, 0, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f00, 0, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f01, 0, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f01, 0, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f08, 0, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f08, 0, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f09, 0, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f09, 0, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f20, 0, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f20, 0, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f21, 0, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f21, 0, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f28, 0, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f28, 0, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f29, 0, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f29, 0, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f60, 0, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f60, 0, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f61, 0, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f61, 0, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f68, 0, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f68, 0, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f69, 0, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, 0x1f69, 0, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), 0x0000, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x0391, 0, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x0397, 0, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x03a9, 0, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x03b1, 0, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x03b7, 0, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0313, 0x03c9, 0, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x0391, 0, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x0397, 0, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x03a9, 0, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x03b1, 0, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x03b7, 0, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0314, 0x03c9, 0, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x0391, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x0397, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x03a9, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x03b1, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x03b7, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0313, 0x03c9, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x0391, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x0397, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x03a9, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x03b1, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x03b7, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x0314, 0x03c9, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x03b1, 0, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x03b7, 0, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x03c9, 0, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f00, 0, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f01, 0, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f08, 0, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f09, 0, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f20, 0, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f21, 0, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f28, 0, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f29, 0, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f60, 0, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f61, 0, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f68, 0, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, 0x1f69, 0, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0342, UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0391, 0, 0, 0, 0}, 0x1fbc }, // U1FBC # GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x0397, 0, 0, 0, 0}, 0x1fcc }, // U1FCC # GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03a9, 0, 0, 0, 0}, 0x1ffc }, // U1FFC # GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03ac, 0, 0, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03ae, 0, 0, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03b1, 0, 0, 0, 0}, 0x1fb3 }, // U1FB3 # GREEK SMALL LETTER ALPHA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03b7, 0, 0, 0, 0}, 0x1fc3 }, // U1FC3 # GREEK SMALL LETTER ETA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03c9, 0, 0, 0, 0}, 0x1ff3 }, // U1FF3 # GREEK SMALL LETTER OMEGA WITH YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x03ce, 0, 0, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f00, 0, 0, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f01, 0, 0, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f02, 0, 0, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f03, 0, 0, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f04, 0, 0, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f05, 0, 0, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f06, 0, 0, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f07, 0, 0, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f08, 0, 0, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f09, 0, 0, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0a, 0, 0, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0b, 0, 0, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0c, 0, 0, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0d, 0, 0, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0e, 0, 0, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f0f, 0, 0, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f20, 0, 0, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f21, 0, 0, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f22, 0, 0, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f23, 0, 0, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f24, 0, 0, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f25, 0, 0, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f26, 0, 0, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f27, 0, 0, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f28, 0, 0, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f29, 0, 0, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2a, 0, 0, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2b, 0, 0, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2c, 0, 0, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2d, 0, 0, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2e, 0, 0, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f2f, 0, 0, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f60, 0, 0, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f61, 0, 0, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f62, 0, 0, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f63, 0, 0, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f64, 0, 0, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f65, 0, 0, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f66, 0, 0, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f67, 0, 0, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f68, 0, 0, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f69, 0, 0, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6a, 0, 0, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6b, 0, 0, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6c, 0, 0, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6d, 0, 0, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6e, 0, 0, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f6f, 0, 0, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f70, 0, 0, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f74, 0, 0, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1f7c, 0, 0, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1fb6, 0, 0, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1fc6, 0, 0, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), 0x1ff6, 0, 0, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0027, 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0, 0}, 0x1f89 }, // U1F89 # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0, 0}, 0x1f99 }, // U1F99 # GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0, 0}, 0x1fa9 }, // U1FA9 # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0, 0}, 0x1f81 }, // U1F81 # GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0, 0}, 0x1f91 }, // U1F91 # GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0, 0}, 0x1fa1 }, // U1FA1 # GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0, 0}, 0x1f88 }, // U1F88 # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0, 0}, 0x1f98 }, // U1F98 # GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0, 0}, 0x1fa8 }, // U1FA8 # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0, 0}, 0x1f80 }, // U1F80 # GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0, 0}, 0x1f90 }, // U1F90 # GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0, 0}, 0x1fa0 }, // U1FA0 # GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0313, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x0314, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b1, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03b7, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x03c9, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f00, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f01, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f08, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f09, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f20, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f21, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f28, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f29, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f60, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f61, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f68, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x0060, 0x1f69, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0313, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x0314, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03b1, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03b7, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x03c9, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f00, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f01, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f08, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f09, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f20, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f21, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f28, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f29, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f60, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f61, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f68, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x007e, 0x1f69, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0313, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x0314, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b1, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03b7, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x03c9, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f00, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f01, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f08, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f09, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f20, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f21, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f28, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f29, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f60, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f61, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f68, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Multi_key), 0x00b4, 0x1f69, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0391, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x0397, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03a9, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b1, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03b7, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0313, 0x03c9, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0391, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x0397, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03a9, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b1, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03b7, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x0314, 0x03c9, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x03b1, 0, 0, 0}, 0x1fb2 }, // U1FB2 # GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x03b7, 0, 0, 0}, 0x1fc2 }, // U1FC2 # GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x03c9, 0, 0, 0}, 0x1ff2 }, // U1FF2 # GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f00, 0, 0, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f01, 0, 0, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f08, 0, 0, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f09, 0, 0, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f20, 0, 0, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f21, 0, 0, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f28, 0, 0, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f29, 0, 0, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f60, 0, 0, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f61, 0, 0, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f68, 0, 0, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), 0x1f69, 0, 0, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8b }, // U1F8B # GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9b }, // U1F9B # GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1fab }, // U1FAB # GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f83 }, // U1F83 # GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f93 }, // U1F93 # GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa3 }, // U1FA3 # GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8a }, // U1F8A # GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9a }, // U1F9A # GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1faa }, // U1FAA # GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f82 }, // U1F82 # GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f92 }, // U1F92 # GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Grave), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa2 }, // U1FA2 # GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0391, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x0397, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03a9, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b1, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03b7, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0313, 0x03c9, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0391, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x0397, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03a9, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b1, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03b7, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x0314, 0x03c9, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x03b1, 0, 0, 0}, 0x1fb4 }, // U1FB4 # GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x03b7, 0, 0, 0}, 0x1fc4 }, // U1FC4 # GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x03c9, 0, 0, 0}, 0x1ff4 }, // U1FF4 # GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f00, 0, 0, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f01, 0, 0, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f08, 0, 0, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f09, 0, 0, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f20, 0, 0, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f21, 0, 0, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f28, 0, 0, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f29, 0, 0, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f60, 0, 0, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f61, 0, 0, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f68, 0, 0, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), 0x1f69, 0, 0, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8d }, // U1F8D # GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9d }, // U1F9D # GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1fad }, // U1FAD # GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f85 }, // U1F85 # GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f95 }, // U1F95 # GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa5 }, // U1FA5 # GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8c }, // U1F8C # GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9c }, // U1F9C # GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1fac }, // U1FAC # GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f84 }, // U1F84 # GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f94 }, // U1F94 # GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Acute), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa4 }, // U1FA4 # GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0391, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x0397, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03a9, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b1, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03b7, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0313, 0x03c9, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0391, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x0397, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03a9, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b1, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03b7, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x0314, 0x03c9, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x03b1, 0, 0, 0}, 0x1fb7 }, // U1FB7 # GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x03b7, 0, 0, 0}, 0x1fc7 }, // U1FC7 # GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x03c9, 0, 0, 0}, 0x1ff7 }, // U1FF7 # GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f00, 0, 0, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f01, 0, 0, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f08, 0, 0, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f09, 0, 0, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f20, 0, 0, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f21, 0, 0, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f28, 0, 0, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f29, 0, 0, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f60, 0, 0, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f61, 0, 0, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f68, 0, 0, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), 0x1f69, 0, 0, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0391, 0}, 0x1f8f }, // U1F8F # GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x0397, 0}, 0x1f9f }, // U1F9F # GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03a9, 0}, 0x1faf }, // U1FAF # GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b1, 0}, 0x1f87 }, // U1F87 # GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03b7, 0}, 0x1f97 }, // U1F97 # GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0028, 0x03c9, 0}, 0x1fa7 }, // U1FA7 # GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0391, 0}, 0x1f8e }, // U1F8E # GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x0397, 0}, 0x1f9e }, // U1F9E # GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03a9, 0}, 0x1fae }, // U1FAE # GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b1, 0}, 0x1f86 }, // U1F86 # GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03b7, 0}, 0x1f96 }, // U1F96 # GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Tilde), UNITIZE(Qt::Key_Multi_key), 0x0029, 0x03c9, 0}, 0x1fa6 }, // U1FA6 # GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
+    { {UNITIZE(Qt::Key_Dead_Iota), UNITIZE(Qt::Key_Dead_Iota), 0, 0, 0, 0}, 0x037a }, // U37a
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Iota), dead_space, 0, 0, 0, 0}, 0x037a }, // U37a
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3046, 0, 0, 0, 0}, 0x3094 }, // U3094 # HIRAGANA LETTER VU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x304b, 0, 0, 0, 0}, 0x304c }, // U304C # HIRAGANA LETTER GA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x304d, 0, 0, 0, 0}, 0x304e }, // U304E # HIRAGANA LETTER GI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x304f, 0, 0, 0, 0}, 0x3050 }, // U3050 # HIRAGANA LETTER GU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3051, 0, 0, 0, 0}, 0x3052 }, // U3052 # HIRAGANA LETTER GE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3053, 0, 0, 0, 0}, 0x3054 }, // U3054 # HIRAGANA LETTER GO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3055, 0, 0, 0, 0}, 0x3056 }, // U3056 # HIRAGANA LETTER ZA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3057, 0, 0, 0, 0}, 0x3058 }, // U3058 # HIRAGANA LETTER ZI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3059, 0, 0, 0, 0}, 0x305a }, // U305A # HIRAGANA LETTER ZU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x305b, 0, 0, 0, 0}, 0x305c }, // U305C # HIRAGANA LETTER ZE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x305d, 0, 0, 0, 0}, 0x305e }, // U305E # HIRAGANA LETTER ZO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x305f, 0, 0, 0, 0}, 0x3060 }, // U3060 # HIRAGANA LETTER DA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3061, 0, 0, 0, 0}, 0x3062 }, // U3062 # HIRAGANA LETTER DI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3064, 0, 0, 0, 0}, 0x3065 }, // U3065 # HIRAGANA LETTER DU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3066, 0, 0, 0, 0}, 0x3067 }, // U3067 # HIRAGANA LETTER DE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3068, 0, 0, 0, 0}, 0x3069 }, // U3069 # HIRAGANA LETTER DO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x306f, 0, 0, 0, 0}, 0x3070 }, // U3070 # HIRAGANA LETTER BA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3072, 0, 0, 0, 0}, 0x3073 }, // U3073 # HIRAGANA LETTER BI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3075, 0, 0, 0, 0}, 0x3076 }, // U3076 # HIRAGANA LETTER BU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x3078, 0, 0, 0, 0}, 0x3079 }, // U3079 # HIRAGANA LETTER BE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x307b, 0, 0, 0, 0}, 0x307c }, // U307C # HIRAGANA LETTER BO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x309d, 0, 0, 0, 0}, 0x309e }, // U309E # HIRAGANA VOICED ITERATION MARK
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30a6, 0, 0, 0, 0}, 0x30f4 }, // U30F4 # KATAKANA LETTER VU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30ab, 0, 0, 0, 0}, 0x30ac }, // U30AC # KATAKANA LETTER GA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30ad, 0, 0, 0, 0}, 0x30ae }, // U30AE # KATAKANA LETTER GI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30af, 0, 0, 0, 0}, 0x30b0 }, // U30B0 # KATAKANA LETTER GU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30b1, 0, 0, 0, 0}, 0x30b2 }, // U30B2 # KATAKANA LETTER GE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30b3, 0, 0, 0, 0}, 0x30b4 }, // U30B4 # KATAKANA LETTER GO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30b5, 0, 0, 0, 0}, 0x30b6 }, // U30B6 # KATAKANA LETTER ZA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30b7, 0, 0, 0, 0}, 0x30b8 }, // U30B8 # KATAKANA LETTER ZI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30b9, 0, 0, 0, 0}, 0x30ba }, // U30BA # KATAKANA LETTER ZU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30bb, 0, 0, 0, 0}, 0x30bc }, // U30BC # KATAKANA LETTER ZE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30bd, 0, 0, 0, 0}, 0x30be }, // U30BE # KATAKANA LETTER ZO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30bf, 0, 0, 0, 0}, 0x30c0 }, // U30C0 # KATAKANA LETTER DA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30c1, 0, 0, 0, 0}, 0x30c2 }, // U30C2 # KATAKANA LETTER DI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30c4, 0, 0, 0, 0}, 0x30c5 }, // U30C5 # KATAKANA LETTER DU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30c6, 0, 0, 0, 0}, 0x30c7 }, // U30C7 # KATAKANA LETTER DE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30c8, 0, 0, 0, 0}, 0x30c9 }, // U30C9 # KATAKANA LETTER DO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30cf, 0, 0, 0, 0}, 0x30d0 }, // U30D0 # KATAKANA LETTER BA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30d2, 0, 0, 0, 0}, 0x30d3 }, // U30D3 # KATAKANA LETTER BI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30d5, 0, 0, 0, 0}, 0x30d6 }, // U30D6 # KATAKANA LETTER BU
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30d8, 0, 0, 0, 0}, 0x30d9 }, // U30D9 # KATAKANA LETTER BE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30db, 0, 0, 0, 0}, 0x30dc }, // U30DC # KATAKANA LETTER BO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30ef, 0, 0, 0, 0}, 0x30f7 }, // U30F7 # KATAKANA LETTER VA
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30f0, 0, 0, 0, 0}, 0x30f8 }, // U30F8 # KATAKANA LETTER VI
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30f1, 0, 0, 0, 0}, 0x30f9 }, // U30F9 # KATAKANA LETTER VE
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30f2, 0, 0, 0, 0}, 0x30fa }, // U30FA # KATAKANA LETTER VO
+    { {UNITIZE(Qt::Key_Dead_Voiced_Sound), 0x30fd, 0, 0, 0, 0}, 0x30fe }, // U30FE # KATAKANA VOICED ITERATION MARK
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x306f, 0, 0, 0, 0}, 0x3071 }, // U3071 # HIRAGANA LETTER PA
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x3072, 0, 0, 0, 0}, 0x3074 }, // U3074 # HIRAGANA LETTER PI
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x3075, 0, 0, 0, 0}, 0x3077 }, // U3077 # HIRAGANA LETTER PU
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x3078, 0, 0, 0, 0}, 0x307a }, // U307A # HIRAGANA LETTER PE
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x307b, 0, 0, 0, 0}, 0x307d }, // U307D # HIRAGANA LETTER PO
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x30cf, 0, 0, 0, 0}, 0x30d1 }, // U30D1 # KATAKANA LETTER PA
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x30d2, 0, 0, 0, 0}, 0x30d4 }, // U30D4 # KATAKANA LETTER PI
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x30d5, 0, 0, 0, 0}, 0x30d7 }, // U30D7 # KATAKANA LETTER PU
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x30d8, 0, 0, 0, 0}, 0x30da }, // U30DA # KATAKANA LETTER PE
+    { {UNITIZE(Qt::Key_Dead_Semivoiced_Sound), 0x30db, 0, 0, 0, 0}, 0x30dd }, // U30DD # KATAKANA LETTER PO
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0000, 0, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0000, 0, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0000, 0, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0000, 0, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0041, 0, 0, 0, 0}, 0x1ea0 }, // U1EA0 # LATIN CAPITAL LETTER A WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0042, 0, 0, 0, 0}, 0x1e04 }, // U1E04 # LATIN CAPITAL LETTER B WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0044, 0, 0, 0, 0}, 0x1e0c }, // U1E0C # LATIN CAPITAL LETTER D WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0045, 0, 0, 0, 0}, 0x1eb8 }, // U1EB8 # LATIN CAPITAL LETTER E WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0048, 0, 0, 0, 0}, 0x1e24 }, // U1E24 # LATIN CAPITAL LETTER H WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0049, 0, 0, 0, 0}, 0x1eca }, // U1ECA # LATIN CAPITAL LETTER I WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x004b, 0, 0, 0, 0}, 0x1e32 }, // U1E32 # LATIN CAPITAL LETTER K WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x004c, 0, 0, 0, 0}, 0x1e36 }, // U1E36 # LATIN CAPITAL LETTER L WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x004d, 0, 0, 0, 0}, 0x1e42 }, // U1E42 # LATIN CAPITAL LETTER M WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x004e, 0, 0, 0, 0}, 0x1e46 }, // U1E46 # LATIN CAPITAL LETTER N WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x004f, 0, 0, 0, 0}, 0x1ecc }, // U1ECC # LATIN CAPITAL LETTER O WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0052, 0, 0, 0, 0}, 0x1e5a }, // U1E5A # LATIN CAPITAL LETTER R WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0053, 0, 0, 0, 0}, 0x1e62 }, // U1E62 # LATIN CAPITAL LETTER S WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0054, 0, 0, 0, 0}, 0x1e6c }, // U1E6C # LATIN CAPITAL LETTER T WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0055, 0, 0, 0, 0}, 0x1ee4 }, // U1EE4 # LATIN CAPITAL LETTER U WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0056, 0, 0, 0, 0}, 0x1e7e }, // U1E7E # LATIN CAPITAL LETTER V WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0057, 0, 0, 0, 0}, 0x1e88 }, // U1E88 # LATIN CAPITAL LETTER W WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0059, 0, 0, 0, 0}, 0x1ef4 }, // U1EF4 # LATIN CAPITAL LETTER Y WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x005a, 0, 0, 0, 0}, 0x1e92 }, // U1E92 # LATIN CAPITAL LETTER Z WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0061, 0, 0, 0, 0}, 0x1ea1 }, // U1EA1 # LATIN SMALL LETTER A WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0062, 0, 0, 0, 0}, 0x1e05 }, // U1E05 # LATIN SMALL LETTER B WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0064, 0, 0, 0, 0}, 0x1e0d }, // U1E0D # LATIN SMALL LETTER D WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0065, 0, 0, 0, 0}, 0x1eb9 }, // U1EB9 # LATIN SMALL LETTER E WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0068, 0, 0, 0, 0}, 0x1e25 }, // U1E25 # LATIN SMALL LETTER H WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0069, 0, 0, 0, 0}, 0x1ecb }, // U1ECB # LATIN SMALL LETTER I WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x006b, 0, 0, 0, 0}, 0x1e33 }, // U1E33 # LATIN SMALL LETTER K WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x006c, 0, 0, 0, 0}, 0x1e37 }, // U1E37 # LATIN SMALL LETTER L WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x006d, 0, 0, 0, 0}, 0x1e43 }, // U1E43 # LATIN SMALL LETTER M WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x006e, 0, 0, 0, 0}, 0x1e47 }, // U1E47 # LATIN SMALL LETTER N WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x006f, 0, 0, 0, 0}, 0x1ecd }, // U1ECD # LATIN SMALL LETTER O WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0072, 0, 0, 0, 0}, 0x1e5b }, // U1E5B # LATIN SMALL LETTER R WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0073, 0, 0, 0, 0}, 0x1e63 }, // U1E63 # LATIN SMALL LETTER S WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0074, 0, 0, 0, 0}, 0x1e6d }, // U1E6D # LATIN SMALL LETTER T WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0075, 0, 0, 0, 0}, 0x1ee5 }, // U1EE5 # LATIN SMALL LETTER U WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0076, 0, 0, 0, 0}, 0x1e7f }, // U1E7F # LATIN SMALL LETTER V WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0077, 0, 0, 0, 0}, 0x1e89 }, // U1E89 # LATIN SMALL LETTER W WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0079, 0, 0, 0, 0}, 0x1ef5 }, // U1EF5 # LATIN SMALL LETTER Y WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x007a, 0, 0, 0, 0}, 0x1e93 }, // U1E93 # LATIN SMALL LETTER Z WITH DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00c2, 0, 0, 0, 0}, 0x1eac }, // U1EAC # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00ca, 0, 0, 0, 0}, 0x1ec6 }, // U1EC6 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00d4, 0, 0, 0, 0}, 0x1ed8 }, // U1ED8 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00e2, 0, 0, 0, 0}, 0x1ead }, // U1EAD # LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00ea, 0, 0, 0, 0}, 0x1ec7 }, // U1EC7 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x00f4, 0, 0, 0, 0}, 0x1ed9 }, // U1ED9 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0102, 0, 0, 0, 0}, 0x1eb6 }, // U1EB6 # LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x0103, 0, 0, 0, 0}, 0x1eb7 }, // U1EB7 # LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x01A0, 0, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x01A1, 0, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x01AF, 0, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), 0x01B0, 0, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ee2 }, // U1EE2 # LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1ef0 }, // U1EF0 # LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1ee3 }, // U1EE3 # LATIN SMALL LETTER O WITH HORN AND DOT BELOW
+    { {UNITIZE(Qt::Key_Dead_Belowdot), UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1ef1 }, // U1EF1 # LATIN SMALL LETTER U WITH HORN AND DOT BELOW
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Hook), 0x0000, 0, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Hook), 0x0000, 0, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Hook), 0x0000, 0, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+// /* broken */    { {UNITIZE(Qt::Key_Dead_Hook), 0x0000, 0, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0041, 0, 0, 0, 0}, 0x1ea2 }, // U1EA2 # LATIN CAPITAL LETTER A WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0045, 0, 0, 0, 0}, 0x1eba }, // U1EBA # LATIN CAPITAL LETTER E WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0049, 0, 0, 0, 0}, 0x1ec8 }, // U1EC8 # LATIN CAPITAL LETTER I WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x004f, 0, 0, 0, 0}, 0x1ece }, // U1ECE # LATIN CAPITAL LETTER O WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0055, 0, 0, 0, 0}, 0x1ee6 }, // U1EE6 # LATIN CAPITAL LETTER U WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0059, 0, 0, 0, 0}, 0x1ef6 }, // U1EF6 # LATIN CAPITAL LETTER Y WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0061, 0, 0, 0, 0}, 0x1ea3 }, // U1EA3 # LATIN SMALL LETTER A WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0065, 0, 0, 0, 0}, 0x1ebb }, // U1EBB # LATIN SMALL LETTER E WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0069, 0, 0, 0, 0}, 0x1ec9 }, // U1EC9 # LATIN SMALL LETTER I WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x006f, 0, 0, 0, 0}, 0x1ecf }, // U1ECF # LATIN SMALL LETTER O WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0075, 0, 0, 0, 0}, 0x1ee7 }, // U1EE7 # LATIN SMALL LETTER U WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0079, 0, 0, 0, 0}, 0x1ef7 }, // U1EF7 # LATIN SMALL LETTER Y WITH HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00c2, 0, 0, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00ca, 0, 0, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00d4, 0, 0, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00e2, 0, 0, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00ea, 0, 0, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x00f4, 0, 0, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0102, 0, 0, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x0103, 0, 0, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x01A0, 0, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x01A1, 0, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x01AF, 0, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), 0x01B0, 0, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x004f, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0055, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x006f, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x002b, 0x0075, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x0055, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0041, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0045, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x004f, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0061, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x0065, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x005e, 0x006f, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0041, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Multi_key), 0x0062, 0x0061, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x0041, 0, 0, 0}, 0x1ea8 }, // U1EA8 # LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x0045, 0, 0, 0}, 0x1ec2 }, // U1EC2 # LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x004f, 0, 0, 0}, 0x1ed4 }, // U1ED4 # LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x0061, 0, 0, 0}, 0x1ea9 }, // U1EA9 # LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x0065, 0, 0, 0}, 0x1ec3 }, // U1EC3 # LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Circumflex), 0x006f, 0, 0, 0}, 0x1ed5 }, // U1ED5 # LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Breve), 0x0041, 0, 0, 0}, 0x1eb2 }, // U1EB2 # LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Breve), 0x0061, 0, 0, 0}, 0x1eb3 }, // U1EB3 # LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0}, 0x1ede }, // U1EDE # LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0}, 0x1eec }, // U1EEC # LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0}, 0x1edf }, // U1EDF # LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Hook), UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0}, 0x1eed }, // U1EED # LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
+    { {UNITIZE(Qt::Key_Dead_Horn), 0x004f, 0, 0, 0, 0}, 0x01a0 }, // U01A0 # LATIN CAPITAL LETTER O WITH HORN
+    { {UNITIZE(Qt::Key_Dead_Horn), 0x0055, 0, 0, 0, 0}, 0x01af }, // U01AF # LATIN CAPITAL LETTER U WITH HORN
+    { {UNITIZE(Qt::Key_Dead_Horn), 0x006f, 0, 0, 0, 0}, 0x01a1 }, // U01A1 # LATIN SMALL LETTER O WITH HORN
+    { {UNITIZE(Qt::Key_Dead_Horn), 0x0075, 0, 0, 0, 0}, 0x01b0 }  // U01B0 # LATIN SMALL LETTER U WITH HORN
+};
+
+const QComposeTable QSimpleInputContext::defaultComposeTable = {
+    defaultTable,
+    ( sizeof(defaultTable) / sizeof(QComposeTableElement) )
+};
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.cpp	2009-10-18 14:41:57.755186182 -0700
@@ -0,0 +1,286 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QSimpleInputContext class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include <algorithm>
+
+#include "qsimpleinputcontext.h"
+
+#include <qnamespace.h>
+#include <qevent.h>
+#include <qglobal.h>
+
+static const int ignoreKeys[] = {
+    Qt::Key_Shift,
+    Qt::Key_Control,
+    Qt::Key_Meta,
+    Qt::Key_Alt,
+    Qt::Key_CapsLock,
+    Qt::Key_Super_L,
+    Qt::Key_Super_R,
+    Qt::Key_Hyper_L,
+    Qt::Key_Hyper_R,
+    Qt::Key_Mode_switch
+};
+
+static const int composingKeys[] = {
+    Qt::Key_Multi_key,
+    Qt::Key_Dead_Grave,
+    Qt::Key_Dead_Acute,
+    Qt::Key_Dead_Circumflex,
+    Qt::Key_Dead_Tilde,
+    Qt::Key_Dead_Macron,
+    Qt::Key_Dead_Breve,
+    Qt::Key_Dead_Abovedot,
+    Qt::Key_Dead_Diaeresis,
+    Qt::Key_Dead_Abovering,
+    Qt::Key_Dead_Doubleacute,
+    Qt::Key_Dead_Caron,
+    Qt::Key_Dead_Cedilla,
+    Qt::Key_Dead_Ogonek,
+    Qt::Key_Dead_Iota,
+    Qt::Key_Dead_Voiced_Sound,
+    Qt::Key_Dead_Semivoiced_Sound,
+    Qt::Key_Dead_Belowdot,
+    Qt::Key_Dead_Hook,
+    Qt::Key_Dead_Horn
+};
+
+class Cmp
+{
+public:
+    bool operator () (const QComposeTableElement &lhs, const QComposeTableElement &rhs) const {
+        for ( size_t i=0; i < QT_KEYSEQUENCE_MAX_LEN; i++ ) {
+            if ( lhs.keys[i] < rhs.keys[i] ) return TRUE;
+            else
+            if ( lhs.keys[i] > rhs.keys[i] ) return FALSE;
+        }
+        return FALSE;
+    }
+
+    bool operator () (const QComposeTableElement &lhs, const uint rhs[QT_KEYSEQUENCE_MAX_LEN]) const {
+        for ( size_t i=0; i < QT_KEYSEQUENCE_MAX_LEN; i++ ) {
+            if ( lhs.keys[i] < rhs[i] ) return TRUE;
+            else
+            if ( lhs.keys[i] > rhs[i] ) return FALSE;
+        }
+        return FALSE;
+    }
+};
+
+QSimpleInputContext::QSimpleInputContext()
+    : QInputContext()
+{
+    clearComposeBuffer();
+}
+
+QSimpleInputContext::~QSimpleInputContext()
+{
+    clearComposeBuffer();
+}
+
+bool QSimpleInputContext::filterEvent( const QEvent *event )
+{
+    if ( event->type() != QEvent::KeyPress )
+        return FALSE;
+
+    QKeyEvent *keyevent = (QKeyEvent *)event;
+    int keyval = keyevent->key();
+    int val = 0;
+
+    if ( isIgnoreKeys( keyval ) )
+        return FALSE;
+
+    if ( isComposingKeys( keyval ) ) {
+        // If composing keys are pressed, use keyval directly
+        val = UNITIZE( keyval );
+    } else {
+        QString text = keyevent->text();
+        if ( text.isEmpty() )
+            return FALSE;
+        
+        // If not composing keys are pressed, use the character's unicode value
+        // NOTE : The contents of QKeyEvent::text() is restricted to
+        // only one character. See description of
+        // QInputContext::filterEvent() about key compression.
+        val = text[0].unicode();
+        qDebug( "str = %s", (const char*)keyevent->text().local8Bit() );
+    }
+
+    // Store value
+    int nCompose = 0;
+    while ( composeBuffer[nCompose] != 0 && nCompose < QT_KEYSEQUENCE_MAX_LEN )
+        nCompose++;
+
+    if ( nCompose == QT_KEYSEQUENCE_MAX_LEN ) {
+        clearComposeBuffer();
+        nCompose = 0;
+    }
+
+    composeBuffer[nCompose] = val;
+
+    // check sequence
+    if( checkComposeTable( composeBuffer, &defaultComposeTable ) )
+        return TRUE;
+
+    return FALSE;
+}
+
+void QSimpleInputContext::setFocus()
+{
+    qDebug( "QSimpleInputContext: %p->setFocus(), focusWidget()=%p",
+            this, focusWidget() );
+}
+
+void QSimpleInputContext::unsetFocus()
+{
+    qDebug( "QSimpleInputContext: %p->unsetFocus(), focusWidget()=%p",
+            this, focusWidget() );
+    reset();
+}
+
+void QSimpleInputContext::setMicroFocus( int x, int y, int w, int h, QFont *f )
+{
+}
+
+void QSimpleInputContext::mouseHandler( int x, QEvent::Type type,
+				     Qt::ButtonState button,
+				     Qt::ButtonState state )
+{
+    switch ( type ) {
+    case QEvent::MouseButtonPress:
+    case QEvent::MouseButtonRelease:
+    case QEvent::MouseButtonDblClick:
+    case QEvent::MouseMove:
+        qDebug( "QSimpleInputContext::mouseHandler: "
+                "x=%d, type=%d, button=%d, state=%d", x, type, button, state );
+        break;
+    default:
+        break;
+    }
+}
+
+
+void QSimpleInputContext::reset()
+{
+    clearComposeBuffer();
+    QInputContext::reset();
+}
+
+QString QSimpleInputContext::identifierName()
+{
+    return "simple";
+}
+
+QString QSimpleInputContext::language()
+{
+    return "";  // FIXME
+}
+
+bool QSimpleInputContext::isIgnoreKeys( int keyval )
+{
+    for ( uint i = 0; i < (sizeof(ignoreKeys)/sizeof(ignoreKeys[0])); i++ )
+        if ( keyval == ignoreKeys[i] )
+            return TRUE;
+
+    return FALSE;
+}
+
+bool QSimpleInputContext::isComposingKeys( int keyval )
+{
+    for ( uint i = 0; i < (sizeof(composingKeys)/sizeof(composingKeys[0])); i++ )
+        if ( keyval == composingKeys[i] )
+            return TRUE;
+
+    return FALSE;
+}
+
+bool QSimpleInputContext::checkComposeTable( uint* composeBuffer, const QComposeTable *composeTable )
+{
+    const QComposeTableElement *p = std::lower_bound( composeTable->data,
+						      composeTable->data + composeTable->size,
+						      composeBuffer,
+						      Cmp() );
+
+    // no entries were found
+    if ( p == composeTable->data + composeTable->size ) {
+        qDebug( "no match" );
+        clearComposeBuffer();
+        return FALSE;
+    }
+
+    // check if compose buffer is matched
+    for ( int i=0; i < QT_KEYSEQUENCE_MAX_LEN; i++ ) {
+
+        // check if partial match
+        if ( composeBuffer[i] == 0 && p->keys[i] ) {
+            qDebug("partial match");
+            return TRUE;
+        }
+
+        if ( composeBuffer[i] != p->keys[i] ) {
+            qDebug("different entry");
+            clearComposeBuffer();
+            return i!=0;
+        }
+    }
+
+    qDebug("match exactly");
+
+    // match exactly
+    commitChar( p->value );
+    clearComposeBuffer();
+
+    return TRUE;
+}
+
+void QSimpleInputContext::commitChar( uint c )
+{
+    sendIMEvent( QEvent::IMStart );
+    sendIMEvent( QEvent::IMEnd, QString(QChar(c)) );
+}
+
+void QSimpleInputContext::clearComposeBuffer(void)
+{
+    for ( uint i=0; i < (sizeof(composeBuffer)/sizeof(int)); i++ )
+        composeBuffer[i] = 0;
+}
+
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.h qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontext.h	2009-10-18 14:38:38.965199826 -0700
@@ -0,0 +1,93 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QSimpleInputContext class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QSIMPLEINPUT_CONTEXT_H
+#define QSIMPLEINPUT_CONTEXT_H
+
+#include <qinputcontext.h>
+#include <qnamespace.h>
+
+#define QT_KEYSEQUENCE_MAX_LEN 6
+#define UNITIZE(qkey) (0x02000000|qkey)
+
+struct QComposeTableElement {
+    uint keys[QT_KEYSEQUENCE_MAX_LEN];
+    uint value;
+};
+
+struct QComposeTable {
+    const QComposeTableElement *data;
+    uint size;
+};
+
+
+class QSimpleInputContext : public QInputContext {
+    Q_OBJECT
+public:
+    QSimpleInputContext();
+    ~QSimpleInputContext();
+
+    virtual QString identifierName();
+    virtual QString language();
+
+    virtual bool filterEvent( const QEvent *event );
+    virtual void reset();
+    virtual void setFocus();
+    virtual void unsetFocus();
+    virtual void setMicroFocus( int x, int y, int w, int h, QFont *f = 0 );
+    virtual void mouseHandler( int x, QEvent::Type type,
+			       Qt::ButtonState button, Qt::ButtonState state );
+
+protected:
+    bool isIgnoreKeys(int keyval );
+    bool isComposingKeys( int keyval );
+    bool checkComposeTable( uint composeBuffer[], const QComposeTable *composeTable );
+    void commitChar( uint c );
+
+    void clearComposeBuffer(void);
+
+protected:
+    uint composeBuffer[QT_KEYSEQUENCE_MAX_LEN + 1];
+    static const QComposeTable defaultComposeTable;
+};
+
+#endif // QSIMPLEINPUT_CONTEXT_H
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.cpp	2009-10-18 14:38:38.965199826 -0700
@@ -0,0 +1,86 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QSimpleInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qsimpleinputcontext.h"
+#include "qsimpleinputcontextplugin.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+QSimpleInputContextPlugin::QSimpleInputContextPlugin()
+{
+}
+
+QSimpleInputContextPlugin::~QSimpleInputContextPlugin()
+{
+}
+
+QStringList QSimpleInputContextPlugin::keys() const
+{
+    return QStringList( "simple" );
+}
+
+QInputContext *QSimpleInputContextPlugin::create( const QString & )
+{
+    return new QSimpleInputContext;
+}
+
+QStringList QSimpleInputContextPlugin::languages( const QString & )
+{
+    return QStringList( "" );
+}
+
+QString QSimpleInputContextPlugin::displayName( const QString & )
+{
+    return tr( "Simple Composing Input Method" );
+}
+
+QString QSimpleInputContextPlugin::description( const QString & )
+{
+    return tr( "Simple composing input method" );
+}
+
+
+Q_EXPORT_PLUGIN( QSimpleInputContextPlugin )
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/qsimpleinputcontextplugin.h	2009-10-18 14:38:38.965199826 -0700
@@ -0,0 +1,63 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QSimpleInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qsimpleinputcontext.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+class QSimpleInputContextPlugin : public QInputContextPlugin
+{
+    Q_OBJECT
+public:
+    QSimpleInputContextPlugin();
+    ~QSimpleInputContextPlugin();
+
+    QStringList keys() const;
+    QInputContext *create( const QString &key );
+    QStringList languages( const QString &key );
+    QString displayName( const QString &key );
+    QString description( const QString &key );
+};
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/simple.pro qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/simple.pro
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/simple.pro	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/simple.pro	2009-10-18 14:38:38.968533943 -0700
@@ -0,0 +1,15 @@
+TEMPLATE = lib
+TARGET = qsimple
+DESTDIR  = ../../../inputmethods
+
+INCLUDEPATH += .
+CONFIG      += qt warn_on debug plugin
+target.path += $$plugins.path/inputmethods
+INSTALLS    += target
+
+# Input
+HEADERS += qsimpleinputcontext.h \
+           qsimpleinputcontextplugin.h
+SOURCES += qsimpleinputcontext.cpp \
+           qsimpleinputcontextplugin.cpp \
+           composetable.cpp
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/xcompose2q.rb qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/xcompose2q.rb
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/xcompose2q.rb	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/simple/xcompose2q.rb	2009-10-18 14:38:38.968533943 -0700
@@ -0,0 +1,450 @@
+#!/usr/bin/env ruby
+
+# xcompose2q.rb: X Compose table to QSimpleInputContext table translator
+# Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+#
+# This file is written to contribute to Trolltech AS under their own
+# licence. You may use this file under your Qt license. Following
+# description is copied from their original file headers. Contact
+# immodule-qt@freedesktop.org if any conditions of this licensing are
+# not clear to you.
+
+# This file may be distributed under the terms of the Q Public License
+# as defined by Trolltech AS of Norway and appearing in the file
+# LICENSE.QPL included in the packaging of this file.
+#
+# This file may be distributed and/or modified under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation and appearing in the file LICENSE.GPL included in the
+# packaging of this file.
+#
+# Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+# licenses may use this file in accordance with the Qt Commercial License
+# Agreement provided with the Software.
+#
+# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+#   information about Qt Commercial License Agreements.
+# See http://www.trolltech.com/qpl/ for QPL licensing information.
+# See http://www.trolltech.com/gpl/ for GPL licensing information.
+#
+# Contact info@trolltech.com if any conditions of this licensing are
+# not clear to you.
+
+
+# Usage:
+#   xcompose2q.rb /usr/X11R6/lib/X11/locale/en_US.UTF-8/Compose
+
+require 'uconv'
+
+# translation table for lazy sorting
+raw2key = {
+  "0y1120" => "UNITIZE(Qt::Key_Multi_key)",
+  "0y1250" => "UNITIZE(Qt::Key_Dead_Grave)",
+  "0y1251" => "UNITIZE(Qt::Key_Dead_Acute)",
+  "0y1252" => "UNITIZE(Qt::Key_Dead_Circumflex)",
+  "0y1253" => "UNITIZE(Qt::Key_Dead_Tilde)",
+  "0y1254" => "UNITIZE(Qt::Key_Dead_Macron)",
+  "0y1255" => "UNITIZE(Qt::Key_Dead_Breve)",
+  "0y1256" => "UNITIZE(Qt::Key_Dead_Abovedot)",
+  "0y1257" => "UNITIZE(Qt::Key_Dead_Diaeresis)",
+  "0y1258" => "UNITIZE(Qt::Key_Dead_Abovering)",
+  "0y1259" => "UNITIZE(Qt::Key_Dead_Doubleacute)",
+  "0y125a" => "UNITIZE(Qt::Key_Dead_Caron)",
+  "0y125b" => "UNITIZE(Qt::Key_Dead_Cedilla)",
+  "0y125c" => "UNITIZE(Qt::Key_Dead_Ogonek)",
+  "0y125d" => "UNITIZE(Qt::Key_Dead_Iota)",
+  "0y125e" => "UNITIZE(Qt::Key_Dead_Voiced_Sound)",
+  "0y125f" => "UNITIZE(Qt::Key_Dead_Semivoiced_Sound)",
+  "0y1260" => "UNITIZE(Qt::Key_Dead_Belowdot)",
+  "0y1261" => "UNITIZE(Qt::Key_Dead_Hook)",
+  "0y1262" => "UNITIZE(Qt::Key_Dead_Horn)",
+}
+
+# X's KeySym to Unicode translation table. The unicode value is
+# extracted from
+# QETWidget::translateKeyEventInternal(). Translation for some
+# keys are not available
+x2q = {
+  "Multi_key"              => "0y1120",
+  "dead_grave"             => "0y1250",
+  "dead_acute"             => "0y1251",
+  "dead_circumflex"        => "0y1252",
+  "dead_tilde"             => "0y1253",
+  "dead_macron"            => "0y1254",
+  "dead_breve"             => "0y1255",
+  "dead_abovedot"          => "0y1256",
+  "dead_diaeresis"         => "0y1257",
+  "dead_abovering"         => "0y1258",
+  "dead_doubleacute"       => "0y1259",
+  "dead_caron"             => "0y125a",
+  "dead_cedilla"           => "0y125b",
+  "dead_ogonek"            => "0y125c",
+  "dead_iota"              => "0y125d",
+  "dead_voiced_sound"      => "0y125e",
+  "dead_semivoiced_sound"  => "0y125f",
+  "dead_belowdot"          => "0y1260",
+  "dead_hook"              => "0y1261",
+  "dead_horn"              => "0y1262",
+  
+  "0" => "0x0030",
+  "1" => "0x0031",
+  "2" => "0x0032",
+  "3" => "0x0033",
+  "4" => "0x0034",
+  "5" => "0x0035",
+  "6" => "0x0036",
+  "7" => "0x0037",
+  "8" => "0x0038",
+  "9" => "0x0039",
+  "A" => "0x0041",
+  "AE" => "0x00c6",
+  "Abreve" => "0x0102",
+  "Acircumflex" => "0x00c2",
+  "Adiaeresis" => "0x00c4",
+  "Arabic_alef" => "0x0627",
+  "Arabic_waw" => "0x0648",
+  "Arabic_yeh" => "0x064a",
+  "Aring" => "0x00c5",
+  "B" => "0x0042",
+  "C" => "0x0043",
+  "Ccedilla" => "0x00c7",
+  "Cyrillic_A" => "0x0410",
+  "Cyrillic_CHE" => "0x0427",
+  "Cyrillic_E" => "0x042d",
+  "Cyrillic_GHE" => "0x0413",
+  "Cyrillic_I" => "0x0418",
+  "Cyrillic_IE" => "0x0415",
+  "Cyrillic_KA" => "0x041a",
+  "Cyrillic_O" => "0x041e",
+  "Cyrillic_U" => "0x0423",
+  "Cyrillic_YERU" => "0x042b",
+  "Cyrillic_ZE" => "0x0417",
+  "Cyrillic_ZHE" => "0x0416",
+  "Cyrillic_a" => "0x0430",
+  "Cyrillic_che" => "0x0447",
+  "Cyrillic_e" => "0x044d",
+  "Cyrillic_ghe" => "0x0433",
+  "Cyrillic_i" => "0x0438",
+  "Cyrillic_ie" => "0x0435",
+  "Cyrillic_ka" => "0x043a",
+  "Cyrillic_o" => "0x043e",
+  "Cyrillic_u" => "0x0443",
+  "Cyrillic_yeru" => "0x044b",
+  "Cyrillic_ze" => "0x0437",
+  "Cyrillic_zhe" => "0x0436",
+  "D" => "0x0044",
+  "E" => "0x0045",
+  "Ecircumflex" => "0x00ca",
+  "Emacron" => "0x0112",
+  "F" => "0x0046",
+  "G" => "0x0047",
+  "Greek_ALPHA" => "0x0391",
+  "Greek_EPSILON" => "0x0395",
+  "Greek_ETA" => "0x0397",
+  "Greek_IOTA" => "0x0399",
+  "Greek_OMEGA" => "0x03a9",
+  "Greek_OMICRON" => "0x039f",
+  "Greek_RHO" => "0x03a1",
+  "Greek_UPSILON" => "0x03a5",
+  "Greek_alpha" => "0x03b1",
+  "Greek_alphaaccent" => "0x03ac",
+  "Greek_epsilon" => "0x03b5",
+  "Greek_eta" => "0x03b7",
+  "Greek_etaaccent" => "0x03ae",
+  "Greek_iota" => "0x03b9",
+  "Greek_iotadieresis" => "0x03ca",
+  "Greek_omega" => "0x03c9",
+  "Greek_omegaaccent" => "0x03ce",
+  "Greek_omicron" => "0x03bf",
+  "Greek_rho" => "0x03c1",
+  "Greek_upsilon" => "0x03c5",
+  "Greek_upsilondieresis" => "0x03cb",
+  "H" => "0x0048",
+  "I" => "0x0049",
+  "Idiaeresis" => "0x00cf",
+  "J" => "0x004a",
+  "K" => "0x004b",
+  "KP_0" => "0x0000",
+  "KP_1" => "0x0000",
+  "KP_2" => "0x0000",
+  "KP_3" => "0x0000",
+  "KP_4" => "0x0000",
+  "KP_5" => "0x0000",
+  "KP_6" => "0x0000",
+  "KP_7" => "0x0000",
+  "KP_8" => "0x0000",
+  "KP_9" => "0x0000",
+  "KP_Add" => "0x0000",
+  "KP_Divide" => "0x0000",
+  "KP_Equal" => "0x0000",
+  "KP_Space" => "0x0000",
+  "L" => "0x004c",
+  "M" => "0x004d",
+  "N" => "0x004e",
+  "O" => "0x004f",
+  "Ocircumflex" => "0x00d4",
+  "Odiaeresis" => "0x00d6",
+  "Ohorn" => "0x0000",
+  "Omacron" => "0x014c",
+  "Ooblique" => "0x00d8",
+  "Otilde" => "0x00d5",
+  "P" => "0x0050",
+  "Q" => "0x0051",
+  "R" => "0x0052",
+  "S" => "0x0053",
+  "Sacute" => "0x015a",
+  "Scaron" => "0x0160",
+  "T" => "0x0054",
+  "U" => "0x0055",
+  "Udiaeresis" => "0x00dc",
+  "Uhorn" => "0x0000",
+  "Ukrainian_I" => "0x0406",
+  "Ukrainian_i" => "0x0456",
+  "Umacron" => "0x016a",
+  "Utilde" => "0x0168",
+  "V" => "0x0056",
+  "W" => "0x0057",
+  "X" => "0x0058",
+  "Y" => "0x0059",
+  "Z" => "0x005a",
+  "a" => "0x0061",
+  "abreve" => "0x0103",
+  "acircumflex" => "0x00e2",
+  "acute" => "0x00b4",
+  "adiaeresis" => "0x00e4",
+  "ae" => "0x00e6",
+  "ampersand" => "0x0026",
+  "apostrophe" => "0x0027",
+  "approximate" => "0x223c",
+  "aring" => "0x00e5",
+  "asciicircum" => "0x005e",
+  "asciitilde" => "0x007e",
+  "asterisk" => "0x002a",
+  "at" => "0x0040",
+  "b" => "0x0062",
+  "backslash" => "0x005c",
+  "bar" => "0x007c",
+  "braceleft" => "0x007b",
+  "braceright" => "0x007d",
+  "bracketleft" => "0x005b",
+  "bracketright" => "0x005d",
+  "c" => "0x0063",
+  "ccedilla" => "0x00e7",
+  "colon" => "0x003a",
+  "combining_acute" => "0x0000",
+  "combining_belowdot" => "0x0000",
+  "combining_grave" => "0x0000",
+  "combining_hook" => "0x0000",
+  "combining_tilde" => "0x0000",
+  "comma" => "0x002c",
+  "d" => "0x0064",
+  "diaeresis" => "0x00a8",
+  "dollar" => "0x0024",
+  "e" => "0x0065",
+  "ecircumflex" => "0x00ea",
+  "emacron" => "0x0113",
+  "equal" => "0x003d",
+  "exclam" => "0x0021",
+  "f" => "0x0066",
+  "g" => "0x0067",
+  "grave" => "0x0060",
+  "greater" => "0x003e",
+  "greaterthanequal" => "0x2265",
+  "h" => "0x0068",
+  "hebrew_aleph" => "0x05d0",
+  "hebrew_bet" => "0x05d1",
+  "hebrew_beth" => "0x05d1",
+  "hebrew_dalet" => "0x05d3",
+  "hebrew_daleth" => "0x05d3",
+  "hebrew_finalkaph" => "0x05da",
+  "hebrew_finalpe" => "0x05e3",
+  "hebrew_gimel" => "0x05d2",
+  "hebrew_gimmel" => "0x05d2",
+  "hebrew_he" => "0x05d4",
+  "hebrew_kaph" => "0x05db",
+  "hebrew_kuf" => "0x05e7",
+  "hebrew_lamed" => "0x05dc",
+  "hebrew_mem" => "0x05de",
+  "hebrew_nun" => "0x05e0",
+  "hebrew_pe" => "0x05e4",
+  "hebrew_qoph" => "0x05e7",
+  "hebrew_resh" => "0x05e8",
+  "hebrew_samech" => "0x05e1",
+  "hebrew_samekh" => "0x05e1",
+  "hebrew_shin" => "0x05e9",
+  "hebrew_taf" => "0x05ea",
+  "hebrew_taw" => "0x05ea",
+  "hebrew_tet" => "0x05d8",
+  "hebrew_teth" => "0x05d8",
+  "hebrew_waw" => "0x05d5",
+  "hebrew_yod" => "0x05d9",
+  "hebrew_zade" => "0x05e6",
+  "hebrew_zadi" => "0x05e6",
+  "hebrew_zain" => "0x05d6",
+  "hebrew_zayin" => "0x05d6",
+  "i" => "0x0069",
+  "identical" => "0x2261",
+  "idiaeresis" => "0x00ef",
+  "includedin" => "0x2282",
+  "includes" => "0x2283",
+  "j" => "0x006a",
+  "k" => "0x006b",
+  "kana_A" => "0x30a2",
+  "kana_CHI" => "0x30c1",
+  "kana_E" => "0x30a8",
+  "kana_FU" => "0x30d5",
+  "kana_HA" => "0x30cf",
+  "kana_HE" => "0x30d8",
+  "kana_HI" => "0x30d2",
+  "kana_HO" => "0x30db",
+  "kana_I" => "0x30a4",
+  "kana_KA" => "0x30ab",
+  "kana_KE" => "0x30b1",
+  "kana_KI" => "0x30ad",
+  "kana_KO" => "0x30b3",
+  "kana_KU" => "0x30af",
+  "kana_MA" => "0x30de",
+  "kana_ME" => "0x30e1",
+  "kana_MI" => "0x30df",
+  "kana_MO" => "0x30e2",
+  "kana_MU" => "0x30e0",
+  "kana_NA" => "0x30ca",
+  "kana_NE" => "0x30cd",
+  "kana_NI" => "0x30cb",
+  "kana_NO" => "0x30ce",
+  "kana_NU" => "0x30cc",
+  "kana_O" => "0x30aa",
+  "kana_RA" => "0x30e9",
+  "kana_RE" => "0x30ec",
+  "kana_RI" => "0x30ea",
+  "kana_RO" => "0x30ed",
+  "kana_RU" => "0x30eb",
+  "kana_SA" => "0x30b5",
+  "kana_SE" => "0x30bb",
+  "kana_SHI" => "0x30b7",
+  "kana_SO" => "0x30bd",
+  "kana_SU" => "0x30b9",
+  "kana_TA" => "0x30bf",
+  "kana_TE" => "0x30c6",
+  "kana_TO" => "0x30c8",
+  "kana_TSU" => "0x30c4",
+  "kana_U" => "0x30a6",
+  "kana_WA" => "0x30ef",
+  "kana_WO" => "0x30f2",
+  "kana_YA" => "0x30e4",
+  "kana_YO" => "0x30e8",
+  "kana_YU" => "0x30e6",
+  "l" => "0x006c",
+  "leftarrow" => "0x2190",
+  "leftcaret" => "0x003c",
+  "leftshoe" => "0x2282",
+  "less" => "0x003c",
+  "lessthanequal" => "0x2264",
+  "m" => "0x006d",
+  "macron" => "0x00af",
+  "minus" => "0x002d",
+  "n" => "0x006e",
+  "numbersign" => "0x0023",
+  "o" => "0x006f",
+  "ocircumflex" => "0x00f4",
+  "odiaeresis" => "0x00f6",
+  "ohorn" => "0x0000",
+  "omacron" => "0x014d",
+  "oslash" => "0x00f8",
+  "otilde" => "0x00f5",
+  "p" => "0x0070",
+  "parenleft" => "0x0028",
+  "parenright" => "0x0029",
+  "percent" => "0x0025",
+  "period" => "0x002e",
+  "plus" => "0x002b",
+  "q" => "0x0071",
+  "question" => "0x003f",
+  "quotedbl" => "0x0022",
+  "r" => "0x0072",
+  "rightarrow" => "0x2192",
+  "rightcaret" => "0x003e",
+  "rightshoe" => "0x2283",
+  "righttack" => "0x22a3",
+  "s" => "0x0073",
+  "sacute" => "0x015b",
+  "scaron" => "0x0161",
+  "semicolon" => "0x003b",
+  "slash" => "0x002f",
+  "space" => "0x0020",
+  "t" => "0x0074",
+  "u" => "0x0075",
+  "udiaeresis" => "0x00fc",
+  "uhorn" => "0x0000",
+  "umacron" => "0x016b",
+  "underbar" => "0x005f",
+  "underscore" => "0x005f",
+  "utilde" => "0x0169",
+  "v" => "0x0076",
+  "w" => "0x0077",
+  "x" => "0x0078",
+  "y" => "0x0079",
+  "z" => "0x007a",
+}
+
+readlines.collect {
+  |line|
+
+  broken = ""
+  seq = ["0", "0", "0", "0", "0", "0"]
+  index = 0
+  rhs = "0x0000"
+  comment = ""
+
+  case line
+  when /^(#|XCOMM)(.*)$/
+    comment = "// #{$2}\n"
+    rhs = :isCommentLine
+  when /^$/
+    comment = "\n"
+    rhs = :isCommentLine
+  else
+    line.scan(/<([^>]+)>/) {
+      |args|
+      keysym = args[0]
+      unit = x2q[keysym] || keysym.sub(/^U([\da-fA-F]{4,5})$/, "0x\\1")
+      if (/^(0x(0000|[\da-fA-F]{5,})|dead_space)$/ =~ unit)
+	broken = "// /* broken */"
+      end
+      seq[index] = unit
+      index += 1
+    }
+
+    Regexp.new(':\s+"(.+)"\s+(.+)$', nil, 'u') =~ line
+    rhs = Uconv::u8tou16($1).unpack('v')[0]
+    rhs = format("0x%04x", rhs)
+    comment = $2
+  end
+
+  entry = {
+    :broken => broken,
+    :seq => seq,
+    :rhs => rhs,
+    :comment => comment
+  }
+}.sort {
+  |entry_a, entry_b|
+
+  entry_a[:seq] <=> entry_b[:seq]
+}.each {
+  |entry|
+
+  broken, seq, rhs, comment = entry.values_at(:broken, :seq, :rhs, :comment)
+  if (rhs == :isCommentLine)
+    print comment
+  else
+    seq = seq.collect {
+      |unit|
+      raw2key[unit] || unit
+    }
+    print "#{broken}    { {#{seq.join(", ")}}, #{rhs} }, // #{comment}\n"
+  end
+}
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext.h qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext.h	2009-10-18 14:38:38.985207198 -0700
@@ -0,0 +1,130 @@
+/****************************************************************************
+** $Id: qximinputcontext_p.h,v 1.6 2004/06/22 06:47:27 daisuke Exp $
+**
+** Definition of QXIMInputContext
+**
+** Copyright (C) 1992-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QXIMINPUTCONTEXT_H
+#define QXIMINPUTCONTEXT_H
+
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of internal files.  This header file may change from version to version
+// without notice, or even be removed.
+//
+// We mean it.
+//
+//
+
+#if !defined(Q_NO_IM)
+
+#include "qglobal.h"
+#include <qinputcontext.h>
+#include <qfont.h>
+#include <qcstring.h>
+
+class QKeyEvent;
+class QWidget;
+class QFont;
+class QString;
+
+
+#ifdef Q_WS_X11
+#include "qarray.h"
+#include "qwindowdefs.h"
+#include <private/qt_x11_p.h>
+#endif
+
+class QXIMInputContext : public QInputContext
+{
+    Q_OBJECT
+public:
+#ifdef Q_WS_X11
+    QXIMInputContext();
+    ~QXIMInputContext();
+
+    QString identifierName();
+    QString language();
+
+    bool x11FilterEvent( QWidget *keywidget, XEvent *event );
+    void reset();
+
+    void setFocus();
+    void unsetFocus();
+    void setMicroFocus( int x, int y, int w, int h, QFont *f = 0 );
+    void mouseHandler( int x, QEvent::Type type,
+		       Qt::ButtonState button, Qt::ButtonState state );
+    bool isPreeditRelocationEnabled();
+
+    void setHolderWidget( QWidget *widget );
+
+    bool hasFocus() const;
+    void resetClientState();
+    void close( const QString &errMsg );
+
+    void sendIMEvent( QEvent::Type type,
+		      const QString &text = QString::null,
+		      int cursorPosition = -1, int selLength = 0 );
+
+    static void init_xim();
+    static void create_xim();
+    static void close_xim();
+
+    void *ic;
+    QString composingText;
+    QFont font;
+    XFontSet fontset;
+    QMemArray<bool> selectedChars;
+
+protected:
+    virtual bool isPreeditPreservationEnabled();  // not a QInputContext func
+
+    QCString _language;
+
+private:
+    void setComposePosition(int, int);
+    void setComposeArea(int, int, int, int);
+    void setXFontSet(const QFont &);
+
+    int lookupString(XKeyEvent *, QCString &, KeySym *, Status *) const;
+
+#endif // Q_WS_X11
+};
+
+
+#endif //Q_NO_IM
+
+#endif // QXIMINPUTCONTEXT_H
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.cpp	2009-10-18 14:38:38.988538116 -0700
@@ -0,0 +1,86 @@
+/****************************************************************************
+** $Id$
+**
+** Implementation of QXIMInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qximinputcontext.h"
+#include "qximinputcontextplugin.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+QXIMInputContextPlugin::QXIMInputContextPlugin()
+{
+}
+
+QXIMInputContextPlugin::~QXIMInputContextPlugin()
+{
+}
+
+QStringList QXIMInputContextPlugin::keys() const
+{
+    return QStringList( "xim" );
+}
+
+QInputContext *QXIMInputContextPlugin::create( const QString & )
+{
+    return new QXIMInputContext;
+}
+
+QStringList QXIMInputContextPlugin::languages( const QString & )
+{
+    return QStringList( "" );
+}
+
+QString QXIMInputContextPlugin::displayName( const QString & )
+{
+    return tr( "XIM" );
+}
+
+QString QXIMInputContextPlugin::description( const QString & )
+{
+    return tr( "XIM input method" );
+}
+
+
+Q_EXPORT_PLUGIN( QXIMInputContextPlugin )
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.h qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.h
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontextplugin.h	2009-10-18 14:38:39.015195390 -0700
@@ -0,0 +1,63 @@
+/****************************************************************************
+** $Id$
+**
+** Definition of QXIMInputContextPlugin class
+**
+** Copyright (C) 2004 immodule for Qt Project.  All rights reserved.
+**
+** This file is written to contribute to Trolltech AS under their own
+** licence. You may use this file under your Qt license. Following
+** description is copied from their original file headers. Contact
+** immodule-qt@freedesktop.org if any conditions of this licensing are
+** not clear to you.
+**
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QT_NO_IM
+#include "qximinputcontext.h"
+#include <qinputcontextplugin.h>
+#include <qstringlist.h>
+
+
+class QXIMInputContextPlugin : public QInputContextPlugin
+{
+    Q_OBJECT
+public:
+    QXIMInputContextPlugin();
+    ~QXIMInputContextPlugin();
+
+    QStringList keys() const;
+    QInputContext *create( const QString &key );
+    QStringList languages( const QString &key );
+    QString displayName( const QString &key );
+    QString description( const QString &key );
+};
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext_x11.cpp qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext_x11.cpp
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext_x11.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/qximinputcontext_x11.cpp	2009-10-18 14:38:38.988538116 -0700
@@ -0,0 +1,930 @@
+/****************************************************************************
+** $Id: qximinputcontext_x11.cpp,v 1.10 2004/06/22 06:47:27 daisuke Exp $
+**
+** Implementation of QXIMInputContext class
+**
+** Copyright (C) 2000-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the input method module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses for Unix/X11 may use this file in accordance with the Qt Commercial
+** License Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+
+#include "qximinputcontext.h"
+
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
+#undef KeyPress
+#undef KeyRelease
+
+#if !defined(QT_NO_IM)
+
+#include "qplatformdefs.h"
+
+#include "qapplication.h"
+#include "qwidget.h"
+#include "qstring.h"
+#include "qptrlist.h"
+#include "qintdict.h"
+#include "qtextcodec.h"
+
+#include <stdlib.h>
+#include <limits.h>
+
+#if !defined(QT_NO_XIM)
+
+#define XK_MISCELLANY
+#define XK_LATIN1
+#include <X11/keysymdef.h>
+
+// #define QT_XIM_DEBUG
+
+// from qapplication_x11.cpp
+static XIM	qt_xim = 0;
+extern XIMStyle	qt_xim_style;
+extern XIMStyle	qt_xim_preferred_style;
+extern char    *qt_ximServer;
+static bool isInitXIM = FALSE;
+static QPtrList<QXIMInputContext> *ximContextList = 0;
+#endif
+extern int qt_ximComposingKeycode;
+extern QTextCodec * qt_input_mapper;
+
+
+#if !defined(QT_NO_XIM)
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif // Q_C_CALLBACKS
+
+#ifdef USE_X11R6_XIM
+    static void xim_create_callback(XIM /*im*/,
+				    XPointer /*client_data*/,
+				    XPointer /*call_data*/)
+    {
+	// qDebug("xim_create_callback");
+	QXIMInputContext::create_xim();
+    }
+
+    static void xim_destroy_callback(XIM /*im*/,
+				     XPointer /*client_data*/,
+				     XPointer /*call_data*/)
+    {
+	// qDebug("xim_destroy_callback");
+	QXIMInputContext::close_xim();
+	Display *dpy = QPaintDevice::x11AppDisplay();
+	XRegisterIMInstantiateCallback(dpy, 0, 0, 0,
+				       (XIMProc) xim_create_callback, 0);
+    }
+
+#endif // USE_X11R6_XIM
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif // Q_C_CALLBACKS
+
+#endif // QT_NO_XIM
+
+#ifndef QT_NO_XIM
+
+/* The cache here is needed, as X11 leaks a few kb for every
+   XFreeFontSet call, so we avoid creating and deletion of fontsets as
+   much as possible
+*/
+static XFontSet fontsetCache[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+static int fontsetRefCount = 0;
+
+static const char * const fontsetnames[] = {
+    "-*-fixed-medium-r-*-*-16-*,-*-*-medium-r-*-*-16-*",
+    "-*-fixed-medium-i-*-*-16-*,-*-*-medium-i-*-*-16-*",
+    "-*-fixed-bold-r-*-*-16-*,-*-*-bold-r-*-*-16-*",
+    "-*-fixed-bold-i-*-*-16-*,-*-*-bold-i-*-*-16-*",
+    "-*-fixed-medium-r-*-*-24-*,-*-*-medium-r-*-*-24-*",
+    "-*-fixed-medium-i-*-*-24-*,-*-*-medium-i-*-*-24-*",
+    "-*-fixed-bold-r-*-*-24-*,-*-*-bold-r-*-*-24-*",
+    "-*-fixed-bold-i-*-*-24-*,-*-*-bold-i-*-*-24-*"
+};
+
+static XFontSet getFontSet( const QFont &f )
+{
+    int i = 0;
+    if (f.italic())
+	i |= 1;
+    if (f.bold())
+	i |= 2;
+
+    if ( f.pointSize() > 20 )
+	i += 4;
+
+    if ( !fontsetCache[i] ) {
+	Display* dpy = QPaintDevice::x11AppDisplay();
+	int missCount;
+	char** missList;
+	fontsetCache[i] = XCreateFontSet(dpy, fontsetnames[i], &missList, &missCount, 0);
+	if(missCount > 0)
+	    XFreeStringList(missList);
+	if ( !fontsetCache[i] ) {
+	    fontsetCache[i] = XCreateFontSet(dpy,  "-*-fixed-*-*-*-*-16-*", &missList, &missCount, 0);
+	    if(missCount > 0)
+		XFreeStringList(missList);
+	    if ( !fontsetCache[i] )
+		fontsetCache[i] = (XFontSet)-1;
+	}
+    }
+    return (fontsetCache[i] == (XFontSet)-1) ? 0 : fontsetCache[i];
+}
+
+
+#ifdef Q_C_CALLBACKS
+extern "C" {
+#endif // Q_C_CALLBACKS
+
+    // These static functions should be rewritten as member of
+    // QXIMInputContext
+
+    static int xic_start_callback(XIC, XPointer client_data, XPointer) {
+	QXIMInputContext *qic = (QXIMInputContext *) client_data;
+	if (! qic) {
+#ifdef QT_XIM_DEBUG
+	    qDebug("compose start: no qic");
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	qic->resetClientState();
+	qic->sendIMEvent( QEvent::IMStart );
+
+#ifdef QT_XIM_DEBUG
+	qDebug("compose start");
+#endif // QT_XIM_DEBUG
+
+	return 0;
+    }
+
+    static int xic_draw_callback(XIC, XPointer client_data, XPointer call_data) {
+	QXIMInputContext *qic = (QXIMInputContext *) client_data;
+	if (! qic) {
+#ifdef QT_XIM_DEBUG
+	    qDebug("compose event: invalid compose event %p", qic);
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	bool send_imstart = FALSE;
+	if( ! qic->isComposing() && qic->hasFocus() ) {
+	    qic->resetClientState();
+	    send_imstart = TRUE;
+	} else if ( ! qic->isComposing() || ! qic->hasFocus() ) {
+#ifdef QT_XIM_DEBUG
+	    qDebug( "compose event: invalid compose event composing=%d hasFocus=%d",
+		    qic->isComposing(), qic->hasFocus() );
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	if ( send_imstart )
+	    qic->sendIMEvent( QEvent::IMStart );
+
+	XIMPreeditDrawCallbackStruct *drawstruct =
+	    (XIMPreeditDrawCallbackStruct *) call_data;
+	XIMText *text = (XIMText *) drawstruct->text;
+	int cursor = drawstruct->caret, sellen = 0;
+
+	if ( ! drawstruct->caret && ! drawstruct->chg_first &&
+	     ! drawstruct->chg_length && ! text ) {
+	    if( qic->composingText.isEmpty() ) {
+#ifdef QT_XIM_DEBUG
+		qDebug( "compose emptied" );
+#endif // QT_XIM_DEBUG
+		// if the composition string has been emptied, we need
+		// to send an IMEnd event
+		qic->sendIMEvent( QEvent::IMEnd );
+		qic->resetClientState();
+		// if the commit string has coming after here, IMStart
+		// will be sent dynamically
+	    }
+	    return 0;
+	}
+
+	if (text) {
+	    char *str = 0;
+	    if (text->encoding_is_wchar) {
+		int l = wcstombs(NULL, text->string.wide_char, text->length);
+		if (l != -1) {
+		    str = new char[l + 1];
+		    wcstombs(str, text->string.wide_char, l);
+		    str[l] = 0;
+		}
+	    } else
+		str = text->string.multi_byte;
+
+	    if (! str)
+		return 0;
+
+	    QString s = QString::fromLocal8Bit(str);
+
+	    if (text->encoding_is_wchar)
+		delete [] str;
+
+	    if (drawstruct->chg_length < 0)
+		qic->composingText.replace(drawstruct->chg_first, UINT_MAX, s);
+	    else
+		qic->composingText.replace(drawstruct->chg_first, drawstruct->chg_length, s);
+
+	    if ( qic->selectedChars.size() < qic->composingText.length() ) {
+		// expand the selectedChars array if the compose string is longer
+		uint from = qic->selectedChars.size();
+		qic->selectedChars.resize( qic->composingText.length() );
+		for ( uint x = from; from < qic->selectedChars.size(); ++x )
+		    qic->selectedChars[x] = 0;
+	    }
+
+	    uint x;
+	    bool *p = qic->selectedChars.data() + drawstruct->chg_first;
+	    // determine if the changed chars are selected based on text->feedback
+	    for ( x = 0; x < s.length(); ++x )
+		*p++ = ( text->feedback ? ( text->feedback[x] & XIMReverse ) : 0 );
+
+	    // figure out where the selection starts, and how long it is
+	    p = qic->selectedChars.data();
+	    bool started = FALSE;
+	    for ( x = 0; x < QMIN(qic->composingText.length(), qic->selectedChars.size()); ++x ) {
+		if ( started ) {
+		    if ( *p ) ++sellen;
+		    else break;
+		} else {
+		    if ( *p ) {
+			cursor = x;
+			started = TRUE;
+			sellen = 1;
+		    }
+		}
+		++p;
+	    }
+	} else {
+	    if (drawstruct->chg_length == 0)
+		drawstruct->chg_length = -1;
+
+	    qic->composingText.remove(drawstruct->chg_first, drawstruct->chg_length);
+	    bool qt_compose_emptied = qic->composingText.isEmpty();
+	    if ( qt_compose_emptied ) {
+#ifdef QT_XIM_DEBUG
+		qDebug( "compose emptied" );
+#endif // QT_XIM_DEBUG
+		// if the composition string has been emptied, we need
+		// to send an IMEnd event
+		qic->sendIMEvent( QEvent::IMEnd );
+		qic->resetClientState();
+		// if the commit string has coming after here, IMStart
+		// will be sent dynamically
+		return 0;
+	    }
+	}
+
+	qic->sendIMEvent( QEvent::IMCompose,
+			  qic->composingText, cursor, sellen );
+
+	return 0;
+    }
+
+    static int xic_done_callback(XIC, XPointer client_data, XPointer) {
+	QXIMInputContext *qic = (QXIMInputContext *) client_data;
+	if (! qic)
+	    return 0;
+
+	// Don't send IMEnd here. QXIMInputContext::x11FilterEvent()
+	// handles IMEnd with commit string.
+#if 0
+	if ( qic->isComposing() )
+	    qic->sendIMEvent( QEvent::IMEnd );
+	qic->resetClientState();
+#endif
+
+	return 0;
+    }
+
+#ifdef Q_C_CALLBACKS
+}
+#endif // Q_C_CALLBACKS
+
+#endif // !QT_NO_XIM
+
+
+
+QXIMInputContext::QXIMInputContext()
+    : QInputContext(), ic(0), fontset(0)
+{
+    if(!isInitXIM)
+	QXIMInputContext::init_xim();
+}
+
+
+void QXIMInputContext::setHolderWidget( QWidget *widget )
+{
+    if ( ! widget )
+	return;
+
+    QInputContext::setHolderWidget( widget );
+
+#if !defined(QT_NO_XIM)
+    fontsetRefCount++;
+    if (! qt_xim) {
+	qWarning("QInputContext: no input method context available");
+	return;
+    }
+
+    if (! widget->isTopLevel()) {
+	qWarning("QInputContext: cannot create input context for non-toplevel widgets");
+	return;
+    }
+
+    XPoint spot;
+    XRectangle rect;
+    XVaNestedList preedit_attr = 0;
+    XIMCallback startcallback, drawcallback, donecallback;
+
+    font = widget->font();
+    fontset = getFontSet( font );
+
+    if (qt_xim_style & XIMPreeditArea) {
+	rect.x = 0;
+	rect.y = 0;
+	rect.width = widget->width();
+	rect.height = widget->height();
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNArea, &rect,
+					   XNFontSet, fontset,
+					   (char *) 0);
+    } else if (qt_xim_style & XIMPreeditPosition) {
+	spot.x = 1;
+	spot.y = 1;
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNSpotLocation, &spot,
+					   XNFontSet, fontset,
+					   (char *) 0);
+    } else if (qt_xim_style & XIMPreeditCallbacks) {
+	startcallback.client_data = (XPointer) this;
+	startcallback.callback = (XIMProc) xic_start_callback;
+	drawcallback.client_data = (XPointer) this;
+	drawcallback.callback = (XIMProc)xic_draw_callback;
+	donecallback.client_data = (XPointer) this;
+	donecallback.callback = (XIMProc) xic_done_callback;
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNPreeditStartCallback, &startcallback,
+					   XNPreeditDrawCallback, &drawcallback,
+					   XNPreeditDoneCallback, &donecallback,
+					   (char *) 0);
+    }
+
+    if (preedit_attr) {
+	ic = XCreateIC(qt_xim,
+		       XNInputStyle, qt_xim_style,
+		       XNClientWindow, widget->winId(),
+		       XNPreeditAttributes, preedit_attr,
+		       (char *) 0);
+	XFree(preedit_attr);
+    } else
+	ic = XCreateIC(qt_xim,
+		       XNInputStyle, qt_xim_style,
+		       XNClientWindow, widget->winId(),
+		       (char *) 0);
+
+    if (! ic)
+	qFatal("Failed to create XIM input context!");
+
+    // when resetting the input context, preserve the input state
+    (void) XSetICValues((XIC) ic, XNResetState, XIMPreserveState, (char *) 0);
+
+    if( ! ximContextList )
+	ximContextList = new QPtrList<QXIMInputContext>;
+    ximContextList->append( this );
+#endif // !QT_NO_XIM
+}
+
+
+QXIMInputContext::~QXIMInputContext()
+{
+
+#if !defined(QT_NO_XIM)
+    if (ic)
+	XDestroyIC((XIC) ic);
+
+    if ( --fontsetRefCount == 0 ) {
+	Display *dpy = QPaintDevice::x11AppDisplay();
+	for ( int i = 0; i < 8; i++ ) {
+	    if ( fontsetCache[i] && fontsetCache[i] != (XFontSet)-1 ) {
+		XFreeFontSet(dpy, fontsetCache[i]);
+		fontsetCache[i] = 0;
+	    }
+	}
+    }
+
+    if( ximContextList ) {
+	ximContextList->remove( this );
+	if(ximContextList->isEmpty()) {
+	    // Calling XCloseIM gives a Purify FMR error
+	    // XCloseIM( qt_xim );
+	    // We prefer a less serious memory leak
+	    if( qt_xim ) {
+		qt_xim = 0;
+		isInitXIM = FALSE;
+	    }
+
+	    delete ximContextList;
+	    ximContextList = 0;
+	}
+    }
+#endif // !QT_NO_XIM
+
+    ic = 0;
+}
+
+void QXIMInputContext::init_xim()
+{
+#ifndef QT_NO_XIM
+    if(!isInitXIM)
+	isInitXIM = TRUE;
+
+    qt_xim = 0;
+    QString ximServerName(qt_ximServer);
+    if (qt_ximServer)
+	ximServerName.prepend("@im=");
+    else
+	ximServerName = "";
+
+    if ( !XSupportsLocale() )
+	qWarning("Qt: Locales not supported on X server");
+
+#ifdef USE_X11R6_XIM
+    else if ( XSetLocaleModifiers (ximServerName.ascii()) == 0 )
+	qWarning( "Qt: Cannot set locale modifiers: %s",
+		  ximServerName.ascii());
+    else {
+	Display *dpy = QPaintDevice::x11AppDisplay();
+	XWindowAttributes attr; // XIM unselects all events on the root window
+	XGetWindowAttributes( dpy, QPaintDevice::x11AppRootWindow(),&attr );
+	XRegisterIMInstantiateCallback(dpy, 0, 0, 0,
+				       (XIMProc) xim_create_callback, 0);
+	XSelectInput( dpy, QPaintDevice::x11AppRootWindow(), attr.your_event_mask );
+    }
+#else // !USE_X11R6_XIM
+    else if ( XSetLocaleModifiers ("") == 0 )
+	qWarning("Qt: Cannot set locale modifiers");
+    else
+	QXIMInputContext::create_xim();
+#endif // USE_X11R6_XIM
+#endif // QT_NO_XIM
+}
+
+
+/*! \internal
+  Creates the application input method.
+ */
+void QXIMInputContext::create_xim()
+{
+#ifndef QT_NO_XIM
+    Display *appDpy = QPaintDevice::x11AppDisplay();
+    qt_xim = XOpenIM( appDpy, 0, 0, 0 );
+    if ( qt_xim ) {
+
+#ifdef USE_X11R6_XIM
+	XIMCallback destroy;
+	destroy.callback = (XIMProc) xim_destroy_callback;
+	destroy.client_data = 0;
+	if ( XSetIMValues( qt_xim, XNDestroyCallback, &destroy, (char *) 0 ) != 0 )
+	    qWarning( "Xlib doesn't support destroy callback");
+#endif // USE_X11R6_XIM
+
+	XIMStyles *styles = 0;
+	XGetIMValues(qt_xim, XNQueryInputStyle, &styles, (char *) 0, (char *) 0);
+	if ( styles ) {
+	    int i;
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == qt_xim_preferred_style ) {
+		    qt_xim_style = qt_xim_preferred_style;
+		    break;
+		}
+	    }
+	    // if the preferred input style couldn't be found, look for
+	    // Nothing
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNothing |
+						     XIMStatusNothing) ) {
+		    qt_xim_style = XIMPreeditNothing | XIMStatusNothing;
+		    break;
+		}
+	    }
+	    // ... and failing that, None.
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNone |
+						     XIMStatusNone) ) {
+		    qt_xim_style = XIMPreeditNone | XIMStatusNone;
+		    break;
+		}
+	    }
+
+	    // qDebug("QApplication: using im style %lx", qt_xim_style);
+	    XFree( (char *)styles );
+	}
+
+	if ( qt_xim_style ) {
+
+#ifdef USE_X11R6_XIM
+	    XUnregisterIMInstantiateCallback(appDpy, 0, 0, 0,
+					     (XIMProc) xim_create_callback, 0);
+#endif // USE_X11R6_XIM
+
+	} else {
+	    // Give up
+	    qWarning( "No supported input style found."
+		      "  See InputMethod documentation.");
+	    QXIMInputContext::close_xim();
+	}
+    }
+#endif // QT_NO_XIM
+}
+
+
+/*! \internal
+  Closes the application input method.
+*/
+void QXIMInputContext::close_xim()
+{
+#ifndef QT_NO_XIM
+    QString errMsg( "QXIMInputContext::close_xim() has been called" );
+
+    // Calling XCloseIM gives a Purify FMR error
+    // XCloseIM( qt_xim );
+    // We prefer a less serious memory leak
+
+    qt_xim = 0;
+    if( ximContextList ) {
+	QPtrList<QXIMInputContext> contexts( *ximContextList );
+	QPtrList<QXIMInputContext>::Iterator it = contexts.begin();
+	while( it != contexts.end() ) {
+	    (*it)->close( errMsg );
+	    ++it;
+	}
+	// ximContextList will be deleted in ~QXIMInputContext
+    }
+#endif // QT_NO_XIM
+}
+
+
+bool QXIMInputContext::x11FilterEvent( QWidget *keywidget, XEvent *event )
+{
+#ifndef QT_NO_XIM
+    int xkey_keycode = event->xkey.keycode;
+    if ( XFilterEvent( event, keywidget->topLevelWidget()->winId() ) ) {
+	qt_ximComposingKeycode = xkey_keycode; // ### not documented in xlib
+
+	// Cancel of the composition is realizable even if
+	// follwing codes don't exist
+#if 0
+	if ( event->type != XKeyPress || ! (qt_xim_style & XIMPreeditCallbacks) )
+	    return TRUE;
+
+	/*
+	 * The Solaris htt input method will transform a ClientMessage
+	 * event into a filtered KeyPress event, in which case our
+	 * keywidget is still zero.
+	 */
+	QETWidget *widget = (QETWidget*)QWidget::find( (WId)event->xany.window );
+        if ( ! keywidget ) {
+ 	    keywidget = (QETWidget*)QWidget::keyboardGrabber();
+	    if ( keywidget ) {
+	        grabbed = TRUE;
+	    } else {
+	        if ( focus_widget )
+		    keywidget = (QETWidget*)focus_widget;
+	        if ( !keywidget ) {
+		    if ( qApp->inPopupMode() ) // no focus widget, see if we have a popup
+		        keywidget = (QETWidget*) qApp->activePopupWidget();
+		    else if ( widget )
+		        keywidget = (QETWidget*)widget->topLevelWidget();
+	        }
+	    }
+        }
+
+	/*
+	  if the composition string has been emptied, we need to send
+	  an IMEnd event.  however, we have no way to tell if the user
+	  has cancelled input, or if the user has accepted the
+	  composition.
+
+	  so, we have to look for the next keypress and see if it is
+	  the 'commit' key press (keycode == 0).  if it is, we deliver
+	  an IMEnd event with the final text, otherwise we deliver an
+	  IMEnd with empty text (meaning the user has cancelled the
+	  input).
+	*/
+	if ( composing && focusWidget && qt_compose_emptied ) {
+	    XEvent event2;
+	    bool found = FALSE;
+	    if ( XCheckTypedEvent( QPaintDevice::x11AppDisplay(),
+				   XKeyPress, &event2 ) ) {
+		if ( event2.xkey.keycode == 0 ) {
+		    // found a key event with the 'commit' string
+		    found = TRUE;
+		    XPutBackEvent( QPaintDevice::x11AppDisplay(), &event2 );
+		}
+	    }
+
+	    if ( !found ) {
+		// no key event, so the user must have cancelled the composition
+		QIMEvent endevent( QEvent::IMEnd, QString::null, -1 );
+		QApplication::sendEvent( focusWidget, &endevent );
+
+		focusWidget = 0;
+	    }
+
+	    qt_compose_emptied = FALSE;
+	}
+#endif
+	return TRUE;
+    } else if ( focusWidget() ) {
+        if ( event->type == XKeyPress && event->xkey.keycode == 0 ) {
+	    // input method has sent us a commit string
+	    QCString data(513);
+	    KeySym sym;    // unused
+	    Status status; // unused
+	    QString inputText;
+	    int count = lookupString( &(event->xkey), data, &sym, &status );
+	    if ( count > 0 )
+	        inputText = qt_input_mapper->toUnicode( data, count );
+
+	    if ( ! ( qt_xim_style & XIMPreeditCallbacks ) || ! isComposing() ) {
+		// there is no composing state
+		sendIMEvent( QEvent::IMStart );
+	    }
+
+	    sendIMEvent( QEvent::IMEnd, inputText );
+	    resetClientState();
+
+	    return TRUE;
+	}
+    }
+#endif // !QT_NO_XIM
+
+    return FALSE;
+}
+
+
+void QXIMInputContext::sendIMEvent( QEvent::Type type, const QString &text,
+				    int cursorPosition, int selLength )
+{
+    QInputContext::sendIMEvent( type, text, cursorPosition, selLength );
+    if ( type == QEvent::IMCompose )
+	composingText = text;
+}
+
+
+void QXIMInputContext::reset()
+{
+#if !defined(QT_NO_XIM)
+    if ( focusWidget() && isComposing() && ! composingText.isNull() ) {
+#ifdef QT_XIM_DEBUG
+	qDebug("QXIMInputContext::reset: composing - sending IMEnd (empty) to %p",
+	       focusWidget() );
+#endif // QT_XIM_DEBUG
+
+	QInputContext::reset();
+	resetClientState();
+
+	char *mb = XmbResetIC((XIC) ic);
+	if (mb)
+	    XFree(mb);
+    }
+#endif // !QT_NO_XIM
+}
+
+
+void QXIMInputContext::resetClientState()
+{
+#if !defined(QT_NO_XIM)
+    composingText = QString::null;
+    if ( selectedChars.size() < 128 )
+	selectedChars.resize( 128 );
+    selectedChars.fill( 0 );
+#endif // !QT_NO_XIM
+}
+
+
+void QXIMInputContext::close( const QString &errMsg )
+{
+    qDebug( errMsg );
+    emit deletionRequested();
+}
+
+
+bool QXIMInputContext::hasFocus() const
+{
+    return ( focusWidget() != 0 );
+}
+
+
+void QXIMInputContext::setMicroFocus(int x, int y, int, int h, QFont *f)
+{
+    QWidget *widget = focusWidget();
+    if ( qt_xim && widget ) {
+	QPoint p( x, y );
+	QPoint p2 = widget->mapTo( widget->topLevelWidget(), QPoint( 0, 0 ) );
+	p = widget->topLevelWidget()->mapFromGlobal( p );
+	setXFontSet( f ? *f : widget->font() );
+	setComposePosition(p.x(), p.y() + h);
+	setComposeArea(p2.x(), p2.y(), widget->width(), widget->height());
+    }
+
+}
+
+void QXIMInputContext::mouseHandler( int , QEvent::Type type,
+				     Qt::ButtonState button,
+				     Qt::ButtonState)
+{
+    if ( type == QEvent::MouseButtonPress ||
+	 type == QEvent::MouseButtonDblClick ) {
+	// Don't reset Japanese input context here. Japanese input
+	// context sometimes contains a whole paragraph and has
+	// minutes of lifetime different to ephemeral one in other
+	// languages. The input context should be survived until
+	// focused again.
+	if ( ! isPreeditPreservationEnabled() )
+	    reset();
+    }
+}
+
+void QXIMInputContext::setComposePosition(int x, int y)
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	XPoint point;
+	point.x = x;
+	point.y = y;
+
+	XVaNestedList preedit_attr =
+	    XVaCreateNestedList(0,
+				XNSpotLocation, &point,
+
+				(char *) 0);
+	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+	XFree(preedit_attr);
+    }
+#endif // !QT_NO_XIM
+}
+
+
+void QXIMInputContext::setComposeArea(int x, int y, int w, int h)
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	XRectangle rect;
+	rect.x = x;
+	rect.y = y;
+	rect.width = w;
+	rect.height = h;
+
+	XVaNestedList preedit_attr = XVaCreateNestedList(0,
+							 XNArea, &rect,
+
+							 (char *) 0);
+	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+	XFree(preedit_attr);
+    }
+#endif
+}
+
+
+void QXIMInputContext::setXFontSet(const QFont &f)
+{
+#if !defined(QT_NO_XIM)
+    if (font == f) return; // nothing to do
+    font = f;
+
+    XFontSet fs = getFontSet(font);
+    if (fontset == fs) return; // nothing to do
+    fontset = fs;
+
+    XVaNestedList preedit_attr = XVaCreateNestedList(0, XNFontSet, fontset, (char *) 0);
+    XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+    XFree(preedit_attr);
+#else
+    Q_UNUSED( f );
+#endif
+}
+
+
+int QXIMInputContext::lookupString(XKeyEvent *event, QCString &chars,
+				KeySym *key, Status *status) const
+{
+    int count = 0;
+
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	count = XmbLookupString((XIC) ic, event, chars.data(),
+				chars.size(), key, status);
+
+	if ((*status) == XBufferOverflow ) {
+	    chars.resize(count + 1);
+	    count = XmbLookupString((XIC) ic, event, chars.data(),
+				    chars.size(), key, status);
+	}
+    }
+
+#endif // QT_NO_XIM
+
+    return count;
+}
+
+void QXIMInputContext::setFocus()
+{
+#if !defined(QT_NO_XIM)
+    if ( qt_xim && ic )
+	XSetICFocus((XIC) ic);
+#endif // !QT_NO_XIM
+}
+
+void QXIMInputContext::unsetFocus()
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic)
+	XUnsetICFocus((XIC) ic);
+#endif // !QT_NO_XIM
+
+    // Don't reset Japanese input context here. Japanese input context
+    // sometimes contains a whole paragraph and has minutes of
+    // lifetime different to ephemeral one in other languages. The
+    // input context should be survived until focused again.
+    if ( ! isPreeditPreservationEnabled() )
+	reset();
+}
+
+
+bool QXIMInputContext::isPreeditRelocationEnabled()
+{
+    return ( language() == "ja" );
+}
+
+
+bool QXIMInputContext::isPreeditPreservationEnabled()
+{
+    return ( language() == "ja" );
+}
+
+
+QString QXIMInputContext::identifierName()
+{
+    // the name should be "xim" rather than "XIM" to be consistent
+    // with corresponding immodule of GTK+
+    return "xim";
+}
+
+
+QString QXIMInputContext::language()
+{
+#if !defined(QT_NO_XIM)
+    if ( qt_xim ) {
+	QString locale( XLocaleOfIM( qt_xim ) );
+
+	if ( locale.startsWith( "zh" ) ) {
+	    // Chinese language should be formed as "zh_CN", "zh_TW", "zh_HK"
+	    _language = locale.left( 5 );
+	} else {
+	    // other languages should be two-letter ISO 639 language code
+	    _language = locale.left( 2 );
+	}
+    }
+#endif
+    return _language;
+}
+
+#endif //QT_NO_IM
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/xim.pro qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/xim.pro
--- qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/xim.pro	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/inputmethods/xim/xim.pro	2009-10-18 14:38:39.015195390 -0700
@@ -0,0 +1,14 @@
+TEMPLATE = lib
+TARGET = qxim
+DESTDIR  = ../../../inputmethods
+
+INCLUDEPATH += .
+CONFIG      += qt warn_on debug plugin
+target.path += $$plugins.path/inputmethods
+INSTALLS    += target
+
+# Input
+HEADERS += qximinputcontext.h \
+           qximinputcontextplugin.h
+SOURCES += qximinputcontext_x11.cpp \
+           qximinputcontextplugin.cpp
diff -r -U2 -N qt-x11-free-3.3.8b/plugins/src/src.pro qt-x11-free-3.3.8b/plugins/src/src.pro
--- qt-x11-free-3.3.8b/plugins/src/src.pro	2008-01-15 12:09:17.000000000 -0700
+++ qt-x11-free-3.3.8b/plugins/src/src.pro	2009-10-18 14:38:39.015195390 -0700
@@ -2,9 +2,9 @@
 
 shared {
-	SUBDIRS	*= accessible codecs imageformats sqldrivers styles
+	SUBDIRS	*= accessible codecs imageformats inputmethods sqldrivers styles
 	embedded:SUBDIRS *=  gfxdrivers
 }
 dll {
-	SUBDIRS	*= accessible codecs imageformats sqldrivers styles
+	SUBDIRS	*= accessible codecs imageformats inputmethods sqldrivers styles
 	embedded:SUBDIRS *=  gfxdrivers
 }
diff -r -U2 -N qt-x11-free-3.3.8b/README.immodule qt-x11-free-3.3.8b/README.immodule
--- qt-x11-free-3.3.8b/README.immodule	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/README.immodule	2009-10-18 14:38:38.725205556 -0700
@@ -0,0 +1,107 @@
+immodule for Qt
+
+
+* What is this?
+
+  immodule for Qt is a modular, extensible input method subsystem for
+  Qt.
+
+  This project brings functionality similar to the immodule for GTK+
+  to the Qt library. The main goal of the project is to extend and
+  enhance the input method support in the Qt library, in order to
+  provide a modern and powerful multi-language input system. Our short
+  term goal is to make Qt (especially Qt/X11) "up-to-date" with other
+  X11-based toolkits such as GTK+. We are also focusing on what the
+  input method API should be for future Qt versions.
+
+  See our webpage for further information.
+
+  http://immodule-qt.freedesktop.org/
+
+
+* About this release
+
+  qt-x11-immodule-unified-qt3.3.3-20040910 is a stable release. Since
+  it breaks backward compatibility (source and binary) about immodule
+  with our previous releases qt-x11-immodule-unified-qt3.3.3-20040819
+  and qt-x11-immodule-bc-qt3.3.2-20040623, optional immodule plugins
+  must be updated to proper version. See 'Optional immodule plugins'
+  section of our download page.
+
+  http://immodule-qt.freedesktop.org/Software/ImmoduleQtDownload
+
+  However, backward compatibility (source and binary) with normal Qt
+  3.3.3 is kept in 'Binary Compatible' mode.
+
+
+* How to install
+
+  After extract the Qt archive, perform following instructions
+
+    cd qt-x11-free-3.3.3
+    patch -p0 < qt-x11-immodule-unified-qt3.3.3-20040910.diff
+    ./make-symlinks.sh
+    ./configure
+
+  Our patch provides following two configure options. Choose 'Binary
+  Compatible' for normal use.
+
+  Build Qt with 'Binary Compatible' immodule support (default)
+
+    configure -inputmethod
+
+  Build Qt without binary compatibility, but supports more advanced
+  immodule extensions. It cannot be used with ordinary application
+  binaries (i.e. the option is for developers)
+
+    configure -inputmethod -inputmethod-ext
+
+
+* How to use
+
+  - See users manual of each input method plugins
+
+  - Run qtconfig to choose your favorite XIM input style
+
+
+* Environment variables
+
+  Some environment variables are available for expert users and system
+  integrators. The specification is preliminary and may be changed
+  without notification. Be careful.
+
+  See following examples to use the variables.
+
+
+  - set "xim" input method as default
+
+    export QT_IM_MODULE=xim
+
+
+  - set "simple" composing input method as default
+
+    export QT_IM_MODULE=simple
+
+
+  - set "xim" input method as default, and disable input method
+    selection menu in the context menu
+
+    export QT_IM_SWITCHER=imsw-none
+    export QT_IM_MODULE=xim
+
+
+  - set "xim" input method as default, and enable input method
+    selection menu in the context menu (default configuration)
+
+    export QT_IM_SWITCHER=imsw-multi
+    export QT_IM_MODULE=xim
+
+
+  - set "iiimqcf" that has its own input method switching framework as
+    default, and disable input method selection menu in the context
+    menu. Such configuration is required by some system integrators to
+    provide unified user interface for global input method switching
+    over the desktop
+
+    export QT_IM_SWITCHER=imsw-none
+    export QT_IM_MODULE=iiimqcf
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.cpp qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.cpp
--- qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.cpp	2009-10-18 14:38:39.018533866 -0700
@@ -0,0 +1,186 @@
+/****************************************************************************
+** $Id: qinputcontextfactory.cpp,v 1.2 2004/06/20 18:43:11 daisuke Exp $
+**
+** Implementation of QInputContextFactory class
+**
+** Created : 001103
+**
+** Copyright (C) 1992-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition licenses may use this
+** file in accordance with the Qt Commercial License Agreement provided
+** with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qinputcontextinterface_p.h" // up here for GCC 2.7.* compatibility
+#include "qinputcontextfactory.h"
+#include "qinputcontext.h"
+
+#ifndef QT_NO_IM
+
+#include "qapplication.h"
+
+#ifdef QT_THREAD_SUPPORT
+#include <private/qmutexpool_p.h>
+#endif // QT_THREAD_SUPPORT
+
+#include <stdlib.h>
+
+#include "qcleanuphandler.h"
+#include <private/qpluginmanager_p.h>
+#ifndef QT_NO_COMPONENT
+
+
+static QPluginManager<QInputContextFactoryInterface> *manager = 0;
+static QSingleCleanupHandler< QPluginManager<QInputContextFactoryInterface> > cleanup_manager;
+
+static void create_manager()
+{
+    if( manager ) // already created
+	return;
+
+#ifdef QT_THREAD_SUPPORT
+    // protect manager creation
+    QMutexLocker locker( qt_global_mutexpool ?
+			 qt_global_mutexpool->get( &manager ) : 0);
+
+    // we check the manager pointer again to make sure that another thread
+    // has not created the manager before us.
+
+    if ( manager ) // already created
+        return;
+#endif
+
+    manager = new QPluginManager<QInputContextFactoryInterface>( IID_QInputContextFactory, QApplication::libraryPaths(), "/inputmethods", FALSE );
+
+    Q_CHECK_PTR( manager );
+    cleanup_manager.set( &manager );
+}
+
+#endif //QT_NO_COMPONENT
+
+
+/*!
+    This function generates the input context that has the identifier
+    name which is in agreement with \a key. \a widget is the client
+    widget of QInputContext. \a widget may be null.
+*/
+QInputContext *QInputContextFactory::create( const QString& key, QWidget *widget )
+{
+    QInputContext *ret = 0;
+    QString inputcontext = key;
+#ifndef QT_NO_COMPONENT
+    // make sure the manager is created
+    create_manager();
+
+    QInterfacePtr<QInputContextFactoryInterface> iface;
+    manager->queryInterface( inputcontext, &iface );
+
+    if ( iface ) {
+	ret = iface->create( inputcontext );
+#ifdef Q_WS_X11
+	if ( ret )
+	    ret->setHolderWidget( widget );
+#endif
+    }
+#endif
+    return ret;
+}
+
+
+/*!
+    This function returns the list of the names input methods.
+    Only input methods included in default and placed under
+    $QTDIR/plugins/inputmethods are listed.
+*/
+QStringList QInputContextFactory::keys()
+{
+    QStringList list;
+#ifndef QT_NO_COMPONENT
+    // make sure the manager is created
+    create_manager();
+
+    list = manager->featureList();
+#endif //QT_NO_COMPONENT
+
+    return list;
+}
+
+
+QStringList QInputContextFactory::languages( const QString &key )
+{
+    QStringList result;
+#ifndef QT_NO_COMPONENT
+    // make sure the manager is created
+    create_manager();
+
+    QInterfacePtr<QInputContextFactoryInterface> iface;
+    manager->queryInterface( key, &iface );
+
+    if ( iface )
+	result = iface->languages( key );
+#endif //QT_NO_COMPONENT
+
+    return result;
+}
+
+
+QString QInputContextFactory::displayName( const QString &key )
+{
+    QString result( "" );
+#ifndef QT_NO_COMPONENT
+    // make sure the manager is created
+    create_manager();
+
+    QInterfacePtr<QInputContextFactoryInterface> iface;
+    manager->queryInterface( key, &iface );
+
+    if ( iface )
+	result = iface->displayName( key );
+#endif //QT_NO_COMPONENT
+
+    return result;
+}
+
+
+QString QInputContextFactory::description( const QString &key )
+{
+    QString result( "" );
+#ifndef QT_NO_COMPONENT
+    // make sure the manager is created
+    create_manager();
+
+    QInterfacePtr<QInputContextFactoryInterface> iface;
+    manager->queryInterface( key, &iface );
+
+    if ( iface )
+	result = iface->description( key );
+#endif //QT_NO_COMPONENT
+
+    return result;
+}
+
+#endif // QT_NO_IM
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.h qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.h
--- qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qinputcontextfactory.h	2009-10-18 14:38:39.018533866 -0700
@@ -0,0 +1,59 @@
+/****************************************************************************
+** $Id: qinputcontextfactory.h,v 1.1.1.1 2004/05/11 11:16:49 daisuke Exp $
+**
+** Definition of QInputContextFactory class
+**
+** Copyright (C) 2000-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QINPUTCONTEXTFACTORY_H
+#define QINPUTCONTEXTFACTORY_H
+
+#ifndef QT_H
+#include "qstringlist.h"
+#endif // QT_H
+
+#ifndef QT_NO_IM
+
+class QInputContext;
+class QWidget;
+
+class Q_EXPORT QInputContextFactory
+{
+public:
+    static QStringList keys();
+    static QInputContext *create( const QString &key, QWidget *widget ); // should be a toplevel widget
+    static QStringList languages( const QString &key );
+    static QString displayName( const QString &key );
+    static QString description( const QString &key );
+};
+#endif //QT_NO_IM
+
+#endif //QINPUTCONTEXTFACTORY_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qinputcontextinterface_p.h qt-x11-free-3.3.8b/src/inputmethod/qinputcontextinterface_p.h
--- qt-x11-free-3.3.8b/src/inputmethod/qinputcontextinterface_p.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qinputcontextinterface_p.h	2009-10-18 14:38:39.018533866 -0700
@@ -0,0 +1,87 @@
+/****************************************************************************
+** $Id: qinputcontextinterface_p.h,v 1.2 2004/06/20 18:43:11 daisuke Exp $
+**
+** ...
+**
+** Copyright (C) 2000-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QINPUTCONTEXTINTERFACE_P_H
+#define QINPUTCONTEXTINTERFACE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  This header file may
+// change from version to version without notice, or even be
+// removed.
+//
+// We mean it.
+//
+//
+
+#ifndef QT_H
+#include <private/qcom_p.h>
+#endif // QT_H
+
+#ifndef QT_NO_IM
+#ifndef QT_NO_COMPONENT
+
+class QWidget;
+class QInputContext;
+
+// old version interface in qt-x11-immodule-bc-qt3.3.2-20040623.diff:
+// {6C2B9EDE-B63C-14c9-A729-3C7643739C4C}
+// 
+// new version interface:
+// {a5f5c63d-e044-11d8-9718-000d6077a78d}
+// {b0bf3e59-e526-11d8-80da-000d6077a78d}
+// {9ef05c7f-0272-11d9-846c-000d6077a78d}
+
+#ifndef IID_QInputContextFactory
+//#define IID_QInputContextFactory QUuid(0x6c2b9ede, 0xb63c, 0x14c9, 0xa7, 0x29, 0x3c, 0x76, 0x43, 0x73, 0x9c, 0x4c)
+//#define IID_QInputContextFactory QUuid(0xa5f5c63d, 0xe044, 0x11d8, 0x97, 0x18, 0x00, 0x0d, 0x60, 0x77, 0xa7, 0x8d)
+//#define IID_QInputContextFactory QUuid(0xb0bf3e59, 0xe526, 0x11d8, 0x80, 0xda, 0x00, 0x0d, 0x60, 0x77, 0xa7, 0x8d)
+#define IID_QInputContextFactory QUuid(0x9ef05c7f, 0x0272, 0x11d9, 0x84, 0x6c, 0x00, 0x0d, 0x60, 0x77, 0xa7, 0x8d)
+#endif
+
+struct Q_EXPORT QInputContextFactoryInterface : public QFeatureListInterface
+{
+    virtual QInputContext *create( const QString &key ) = 0;
+    virtual QStringList languages( const QString &key ) = 0;
+    virtual QString displayName( const QString &key ) = 0;
+    virtual QString description( const QString &key ) = 0;
+};
+
+#endif //QT_NO_COMPONENT
+#endif //QT_NO_IM
+
+#endif //QINPUTCONTEXTINTERFACE_P_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.cpp qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.cpp
--- qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.cpp	2009-10-18 14:38:39.025198775 -0700
@@ -0,0 +1,231 @@
+/****************************************************************************
+** $Id: qinputcontextplugin.cpp,v 1.2 2004/06/20 18:43:11 daisuke Exp $
+**
+** Implementation of QInputContextPlugin class
+**
+** Created : 010920
+**
+** Copyright (C) 2001 Trolltech AS.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qinputcontextplugin.h"
+
+#ifndef QT_NO_IM
+#ifndef QT_NO_COMPONENT
+
+#include "qinputcontextinterface_p.h"
+
+/*!
+    \class QInputContextPlugin qinputcontextplugin.h
+    \brief The QInputContextPlugin class provides an abstract base for custom QInputContext plugins.
+    \reentrant
+    \ingroup plugins
+
+    The input context plugin is a simple plugin interface that makes it
+    easy to create custom input contexts that can be loaded dynamically
+    into applications.
+
+    Writing a input context plugin is achieved by subclassing this
+    base class, reimplementing the pure virtual functions keys(),
+    create(), languages(), displayName() description() and exporting
+    the class with the \c Q_EXPORT_PLUGIN macro.  See the \link
+    plugins-howto.html Qt Plugins documentation \endlink for details.
+
+    \sa QInputContext
+*/
+
+/*!
+    \fn QStringList QInputContextPlugin::keys() const
+
+    Returns the list of QInputContext keys this plugin provides.
+
+    These keys are usually the class names of the custom input context
+    that are implemented in the plugin.
+
+    Return value is the names to identify and specify input methods
+    for the input method switching mechanism and so on. The names have
+    to be consistent with QInputContext::identifierName(). The names
+    have to consist of ASCII characters only. See also
+    QInputContext::identifierName() for further information.
+
+    \sa create(), displayName(), QInputContext::identifierName()
+*/
+
+/*!
+    \fn QInputContext* QInputContextPlugin::create( const QString& key )
+
+    Creates and returns a QInputContext instance for the input context key \a key.
+    The input context key is usually the class name of the required input method.
+
+    \sa keys()
+*/
+
+/*!
+    \fn QStringList languages( const QString &key )
+
+    Returns what languages are supported by the QInputContext instance
+    specified by \a key.
+
+    The languages are expressed as language code (e.g. "zh_CN",
+    "zh_TW", "zh_HK", "ja", "ko", ...). An input context that suports
+    multiple languages can return all supported languages as
+    QStringList. The name has to be consistent with
+    QInputContextPlugin::language().
+
+    This information may be used to optimize user interface.
+
+    \sa QInputContext::language()
+*/
+
+/*!
+    \fn QString displayName( const QString &key )
+
+    Returns a user friendly i18n-ized name of the QInputContext
+    instance specified by \a key. This string may be appeared in a
+    menu and so on for users.
+
+    There are two different names with different responsibility in the
+    input method domain. This function returns one of them. Another
+    name is called 'identifier name' to identify and specify input
+    methods for the input method switching mechanism and so on.
+
+    Although tr( identifierName ) can provide user friendly i18n-ized
+    name without this function, the message catalog have to be managed
+    by Qt in the case. However, some sophisticated input method
+    framework manages their own message catalogs to provide this
+    i18n-ized name string. So we need this function rather than just
+    call tr() for identifier name.
+
+    \sa keys(), QInputContext::identifierName()
+*/
+
+/*!
+    \fn QString description( const QString &key )
+
+    Returns a i18n-ized brief description of the QInputContext
+    instance specified by \a key. This string may be appeared in some
+    user interfaces.
+*/
+
+
+
+class QInputContextPluginPrivate : public QInputContextFactoryInterface
+{
+public:
+    QInputContextPluginPrivate( QInputContextPlugin *p )
+	: plugin( p )
+    {
+    }
+
+    virtual ~QInputContextPluginPrivate();
+
+    QRESULT queryInterface( const QUuid &iid, QUnknownInterface **iface );
+    Q_REFCOUNT;
+
+    QStringList featureList() const;
+    QInputContext *create( const QString &key );
+    QStringList languages( const QString &key );
+    QString displayName( const QString &key );
+    QString description( const QString &key );
+
+private:
+    QInputContextPlugin *plugin;
+};
+
+QRESULT QInputContextPluginPrivate::queryInterface( const QUuid &iid, QUnknownInterface **iface )
+{
+    *iface = 0;
+
+    if ( iid == IID_QUnknown )
+	*iface = this;
+    else if ( iid == IID_QFeatureList )
+	*iface = this;
+    else if ( iid == IID_QInputContextFactory )
+	*iface = this;
+    else
+	return QE_NOINTERFACE;
+
+    (*iface)->addRef();
+    return QS_OK;
+}
+
+QInputContextPluginPrivate::~QInputContextPluginPrivate()
+{
+    delete plugin;
+}
+
+QStringList QInputContextPluginPrivate::featureList() const
+{
+    return plugin->keys();
+}
+
+QInputContext *QInputContextPluginPrivate::create( const QString &key )
+{
+    return plugin->create( key );
+}
+
+QStringList QInputContextPluginPrivate::languages( const QString &key )
+{
+    return plugin->languages( key );
+}
+
+QString QInputContextPluginPrivate::displayName( const QString &key )
+{
+    return plugin->displayName( key );
+}
+
+QString QInputContextPluginPrivate::description( const QString &key )
+{
+    return plugin->description( key );
+}
+
+
+/*!
+    Constructs a input context plugin. This is invoked automatically by the
+    \c Q_EXPORT_PLUGIN macro.
+*/
+QInputContextPlugin::QInputContextPlugin()
+    : QGPlugin( d = new QInputContextPluginPrivate( this ) )
+{
+}
+
+/*!
+    Destroys the input context plugin.
+
+    You never have to call this explicitly. Qt destroys a plugin
+    automatically when it is no longer used.
+*/
+QInputContextPlugin::~QInputContextPlugin()
+{
+    // don't delete d, as this is deleted by d
+}
+
+#endif // QT_NO_COMPONENT
+#endif // QT_NO_IM
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.h qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.h
--- qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qinputcontextplugin.h	2009-10-18 14:38:39.025198775 -0700
@@ -0,0 +1,67 @@
+/****************************************************************************
+** $Id: qinputcontextplugin.h,v 1.2 2004/06/20 18:43:11 daisuke Exp $
+**
+** Definition of QInputContextPlugin class
+**
+** Created : 010920
+**
+** Copyright (C) 2001 Trolltech AS.  All rights reserved.
+**
+** This file is part of the tools module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QINPUTCONTEXTPLUGIN_H
+#define QINPUTCONTEXTPLUGIN_H
+
+#ifndef QT_H
+#include "qgplugin.h"
+#include "qstringlist.h"
+#endif // QT_H
+
+#ifndef QT_NO_IM
+class QInputContext;
+class QInputContextPluginPrivate;
+
+class Q_EXPORT QInputContextPlugin : public QGPlugin
+{
+    Q_OBJECT
+public:
+    QInputContextPlugin();
+    ~QInputContextPlugin();
+
+    virtual QStringList keys() const = 0;
+    virtual QInputContext *create( const QString &key ) = 0;
+    virtual QStringList languages( const QString &key ) = 0;
+    virtual QString displayName( const QString &key ) = 0;
+    virtual QString description( const QString &key ) = 0;
+
+private:
+    QInputContextPluginPrivate *d;
+};
+#endif // QT_NO_IM
+#endif // QINPUTCONTEXTPLUGIN_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/inputmethod/qt_inputmethod.pri qt-x11-free-3.3.8b/src/inputmethod/qt_inputmethod.pri
--- qt-x11-free-3.3.8b/src/inputmethod/qt_inputmethod.pri	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/inputmethod/qt_inputmethod.pri	2009-10-18 14:38:39.025198775 -0700
@@ -0,0 +1,10 @@
+# Qt inputmetod module
+
+inputmethod {
+	INPUTMETHOD_P = inputmethod
+	HEADERS +=$$INPUTMETHOD_H/qinputcontextfactory.h \
+		  $$INPUTMETHOD_P/qinputcontextinterface_p.h \
+		  $$INPUTMETHOD_H/qinputcontextplugin.h
+	SOURCES +=$$INPUTMETHOD_CPP/qinputcontextfactory.cpp \
+		  $$INPUTMETHOD_CPP/qinputcontextplugin.cpp
+}
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication.cpp qt-x11-free-3.3.8b/src/kernel/qapplication.cpp
--- qt-x11-free-3.3.8b/src/kernel/qapplication.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication.cpp	2009-10-18 14:38:39.068534121 -0700
@@ -3165,4 +3165,33 @@
     }
 
+#if !defined(QT_NO_IM)
+    // if this is one of the compressible IM events, do compression
+    else if ( event->type() == QEvent::IMCompose ) {
+	l->last();
+	QPostEvent * cur = 0;
+	for ( ;; ) {
+	    while ( (cur=l->current()) != 0 &&
+		    ( cur->receiver != receiver ||
+		      cur->event == 0 ||
+		      cur->event->type() != event->type() || 
+		      cur->event->type() != QEvent::IMStart ) )
+		l->prev();
+	    if ( l->current() != 0 ) {
+		// IMCompose must not be compressed with another one
+		// beyond its IMStart boundary
+		if ( cur->event->type() == QEvent::IMStart ) {
+		    break;
+		} else if ( cur->event->type() == QEvent::IMCompose ) {
+		    QIMComposeEvent * e = (QIMComposeEvent *)(cur->event);
+		    *e = *(QIMComposeEvent *)event;
+		    delete event;
+		    return;
+		}
+	    }
+	    break;
+	};
+    }
+#endif
+
     // if no compression could be done, just append something
     event->posted = TRUE;
@@ -3311,4 +3340,21 @@
 void QApplication::removePostedEvents( QObject *receiver )
 {
+    removePostedEvents( receiver, 0 );
+}
+
+/*!
+  Removes all events that have the event type \a event_type posted
+  using postEvent() for \a receiver.
+
+  The events are \e not dispatched, instead they are removed from the
+  queue.
+
+  If \a event_type is 0, all the events are removed from the queue.
+
+  \threadsafe
+*/
+
+void QApplication::removePostedEvents( QObject *receiver, int event_type )
+{
     if ( !receiver )
 	return;
@@ -3329,16 +3375,22 @@
     // sendPostedEvents().
     QPostEventList * l = receiver->postedEvents;
-    receiver->postedEvents = 0;
     l->first();
     QPostEvent * pe;
     while( (pe=l->current()) != 0 ) {
-	if ( pe->event ) {
-	    pe->event->posted = FALSE;
-	    delete pe->event;
-	    pe->event = 0;
+	if ( !event_type || pe->event->type() == event_type ) {
+	    if ( pe->event ) {
+		pe->event->posted = FALSE;
+		delete pe->event;
+		pe->event = 0;
+	    }
+	    l->remove();
+	} else {
+	    l->next();
 	}
-	l->remove();
     }
-    delete l;
+    if ( !event_type || !l->count() ) {
+	receiver->postedEvents = 0;
+	delete l;
+    }
 }
 
@@ -3525,4 +3577,6 @@
 #ifdef Q_WS_WIN
 	QInputContext::accept( tmp );
+#elif defined(Q_WS_X11)
+	tmp->unfocusInputContext();
 #endif
 	QApplication::sendSpontaneousEvent( tmp, &out );
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication.cpp.orig qt-x11-free-3.3.8b/src/kernel/qapplication.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qapplication.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,4548 @@
+/****************************************************************************
+**
+** Implementation of QApplication class
+**
+** Created : 931107
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qobjectlist.h"
+#include "qapplication.h"
+#include "qeventloop.h"
+#include "qeventloop_p.h"
+#include "qwidget.h"
+#include "qwidgetlist.h"
+#include "qwidgetintdict.h"
+#include "qptrdict.h"
+#include "qcleanuphandler.h"
+
+#include "qtranslator.h"
+#include "qtextcodec.h"
+#include "qsessionmanager.h"
+#include "qdragobject.h"
+#include "qclipboard.h"
+#include "qcursor.h"
+#include "qstyle.h"
+#include "qstylefactory.h"
+#include "qfile.h"
+#include "qmessagebox.h"
+#include "qdir.h"
+#include "qfileinfo.h"
+#ifdef Q_WS_WIN
+#include "qinputcontext_p.h"
+#endif
+#include "qfontdata_p.h"
+
+#if defined(QT_THREAD_SUPPORT)
+#  include "qmutex.h"
+#  include "qthread.h"
+#endif // QT_THREAD_SUPPORT
+
+#include <stdlib.h>
+
+#ifdef truncate
+# undef truncate
+#endif
+
+/*!
+  \class QApplication qapplication.h
+  \brief The QApplication class manages the GUI application's control
+  flow and main settings.
+
+  \ingroup application
+  \mainclass
+
+  It contains the main event loop, where all events from the window
+  system and other sources are processed and dispatched. It also
+  handles the application's initialization and finalization, and
+  provides session management. It also handles most system-wide and
+  application-wide settings.
+
+  For any GUI application that uses Qt, there is precisely one
+  QApplication object, no matter whether the application has 0, 1, 2
+  or more windows at any time.
+
+  The QApplication object is accessible through the global pointer \c
+  qApp. Its main areas of responsibility are:
+  \list
+
+  \i It initializes the application with the user's desktop settings
+  such as palette(), font() and doubleClickInterval(). It keeps track
+  of these properties in case the user changes the desktop globally, for
+  example through some kind of control panel.
+
+  \i It performs event handling, meaning that it receives events
+  from the underlying window system and dispatches them to the relevant
+  widgets. By using sendEvent() and postEvent() you can send your own
+  events to widgets.
+
+  \i It parses common command line arguments and sets its internal
+  state accordingly. See the \link QApplication::QApplication()
+  constructor documentation\endlink below for more details about this.
+
+  \i It defines the application's look and feel, which is
+  encapsulated in a QStyle object. This can be changed at runtime
+  with setStyle().
+
+  \i It specifies how the application is to allocate colors.
+  See setColorSpec() for details.
+
+  \i It provides localization of strings that are visible to the user
+  via translate().
+
+  \i It provides some magical objects like the desktop() and the
+  clipboard().
+
+  \i It knows about the application's windows. You can ask which
+  widget is at a certain position using widgetAt(), get a list of
+  topLevelWidgets() and closeAllWindows(), etc.
+
+  \i It manages the application's mouse cursor handling,
+  see setOverrideCursor() and setGlobalMouseTracking().
+
+  \i On the X window system, it provides functions to flush and sync
+  the communication stream, see flushX() and syncX().
+
+  \i It provides support for sophisticated \link
+  session.html session management \endlink. This makes it possible
+  for applications to terminate gracefully when the user logs out, to
+  cancel a shutdown process if termination isn't possible and even to
+  preserve the entire application's state for a future session. See
+  isSessionRestored(), sessionId() and commitData() and saveState()
+  for details.
+
+  \endlist
+
+  The <a href="simple-application.html">Application walk-through
+  example</a> contains a typical complete main() that does the usual
+  things with QApplication.
+
+  Since the QApplication object does so much initialization, it
+  <b>must</b> be created before any other objects related to the user
+  interface are created.
+
+  Since it also deals with common command line arguments, it is
+  usually a good idea to create it \e before any interpretation or
+  modification of \c argv is done in the application itself. (Note
+  also that for X11, setMainWidget() may change the main widget
+  according to the \c -geometry option. To preserve this
+  functionality, you must set your defaults before setMainWidget() and
+  any overrides after.)
+
+  \table
+    \header \i21 Groups of functions
+    \row
+     \i System settings
+     \i
+	desktopSettingsAware(),
+	setDesktopSettingsAware(),
+	cursorFlashTime(),
+	setCursorFlashTime(),
+	doubleClickInterval(),
+	setDoubleClickInterval(),
+	wheelScrollLines(),
+	setWheelScrollLines(),
+	palette(),
+	setPalette(),
+	font(),
+	setFont(),
+	fontMetrics().
+
+    \row
+     \i Event handling
+     \i
+	exec(),
+	processEvents(),
+	enter_loop(),
+	exit_loop(),
+	exit(),
+	quit().
+	sendEvent(),
+	postEvent(),
+	sendPostedEvents(),
+	removePostedEvents(),
+	hasPendingEvents(),
+	notify(),
+	macEventFilter(),
+	qwsEventFilter(),
+	x11EventFilter(),
+	x11ProcessEvent(),
+	winEventFilter().
+
+    \row
+     \i GUI Styles
+     \i
+	style(),
+	setStyle(),
+	polish().
+
+    \row
+     \i Color usage
+     \i
+	colorSpec(),
+	setColorSpec(),
+	qwsSetCustomColors().
+
+    \row
+     \i Text handling
+     \i
+	installTranslator(),
+	removeTranslator()
+	translate().
+
+    \row
+     \i Widgets
+     \i
+	mainWidget(),
+	setMainWidget(),
+	allWidgets(),
+	topLevelWidgets(),
+	desktop(),
+	activePopupWidget(),
+	activeModalWidget(),
+	clipboard(),
+	focusWidget(),
+	winFocus(),
+	activeWindow(),
+	widgetAt().
+
+    \row
+     \i Advanced cursor handling
+     \i
+	hasGlobalMouseTracking(),
+	setGlobalMouseTracking(),
+	overrideCursor(),
+	setOverrideCursor(),
+	restoreOverrideCursor().
+
+    \row
+     \i X Window System synchronization
+     \i
+	flushX(),
+	syncX().
+
+    \row
+     \i Session management
+     \i
+	isSessionRestored(),
+	sessionId(),
+	commitData(),
+	saveState().
+
+    \row
+    \i Threading
+    \i
+	lock(), unlock(), locked(), tryLock(),
+	wakeUpGuiThread()
+
+    \row
+     \i Miscellaneous
+     \i
+	closeAllWindows(),
+	startingUp(),
+	closingDown(),
+	type().
+  \endtable
+
+  \e {Non-GUI programs:} While Qt is not optimized or
+  designed for writing non-GUI programs, it's possible to use
+  \link tools.html some of its classes \endlink without creating a
+  QApplication. This can be useful if you wish to share code between
+  a non-GUI server and a GUI client.
+
+  \headerfile qnamespace.h
+  \headerfile qwindowdefs.h
+  \headerfile qglobal.h
+*/
+
+/*! \enum Qt::HANDLE
+    \internal
+*/
+
+/*!
+    \enum QApplication::Type
+
+    \value Tty a console application
+    \value GuiClient a GUI client application
+    \value GuiServer a GUI server application
+*/
+
+/*!
+    \enum QApplication::ColorSpec
+
+    \value NormalColor the default color allocation policy
+    \value CustomColor the same as NormalColor for X11; allocates colors
+    to a palette on demand under Windows
+    \value ManyColor the right choice for applications that use thousands of
+    colors
+
+    See setColorSpec() for full details.
+*/
+
+/*
+  The qt_init() and qt_cleanup() functions are implemented in the
+  qapplication_xyz.cpp file.
+*/
+
+void qt_init( int *, char **, QApplication::Type );
+void qt_cleanup();
+#if defined(Q_WS_X11)
+void qt_init( Display* dpy, Qt::HANDLE, Qt::HANDLE );
+#endif
+Q_EXPORT bool qt_tryModalHelper( QWidget *widget, QWidget **rettop );
+
+QApplication *qApp = 0;			// global application object
+
+QStyle   *QApplication::app_style      = 0;	// default application style
+bool      qt_explicit_app_style	       = FALSE; // style explicitly set by programmer
+
+int	  QApplication::app_cspec      = QApplication::NormalColor;
+#ifndef QT_NO_PALETTE
+QPalette *QApplication::app_pal	       = 0;	// default application palette
+#endif
+QFont	 *QApplication::app_font       = 0;	// default application font
+bool	  qt_app_has_font	       = FALSE;
+#ifndef QT_NO_CURSOR
+QCursor	 *QApplication::app_cursor     = 0;	// default application cursor
+#endif
+int	  QApplication::app_tracking   = 0;	// global mouse tracking
+bool	  QApplication::is_app_running = FALSE;	// app starting up if FALSE
+bool	  QApplication::is_app_closing = FALSE;	// app closing down if TRUE
+int	  QApplication::loop_level     = 0;	// event loop level
+QWidget	 *QApplication::main_widget    = 0;	// main application widget
+QWidget	 *QApplication::focus_widget   = 0;	// has keyboard input focus
+QWidget	 *QApplication::active_window  = 0;	// toplevel with keyboard focus
+bool	  QApplication::obey_desktop_settings = TRUE;	// use winsys resources
+int	  QApplication::cursor_flash_time = 1000;	// text caret flash time
+int	  QApplication::mouse_double_click_time = 400;	// mouse dbl click limit
+#ifndef QT_NO_WHEELEVENT
+int	  QApplication::wheel_scroll_lines = 3;		// number of lines to scroll
+#endif
+bool	  qt_is_gui_used;
+bool      Q_EXPORT qt_resolve_symlinks = TRUE;
+bool      Q_EXPORT qt_tab_all_widgets  = TRUE;
+QRect qt_maxWindowRect;
+static int drag_time = 500;
+static int drag_distance = 4;
+static bool reverse_layout = FALSE;
+QSize     QApplication::app_strut	= QSize( 0,0 ); // no default application strut
+bool	  QApplication::animate_ui	= TRUE;
+bool	  QApplication::animate_menu	= FALSE;
+bool	  QApplication::fade_menu	= FALSE;
+bool	  QApplication::animate_combo	= FALSE;
+bool	  QApplication::animate_tooltip	= FALSE;
+bool	  QApplication::fade_tooltip	= FALSE;
+bool	  QApplication::animate_toolbox	= FALSE;
+bool	  QApplication::widgetCount	= FALSE;
+QApplication::Type qt_appType=QApplication::Tty;
+#ifndef QT_NO_COMPONENT
+QStringList *QApplication::app_libpaths = 0;
+#endif
+bool	  QApplication::metaComposeUnicode = FALSE;
+int	  QApplication::composedUnicode   = 0;
+
+#ifdef QT_THREAD_SUPPORT
+QMutex *QApplication::qt_mutex		= 0;
+static QMutex *postevent_mutex		= 0;
+static Qt::HANDLE qt_application_thread_id = 0;
+Q_EXPORT Qt::HANDLE qt_get_application_thread_id()
+{
+    return qt_application_thread_id;
+}
+#endif // QT_THREAD_SUPPORT
+
+QEventLoop *QApplication::eventloop = 0;	// application event loop
+
+#ifndef QT_NO_ACCEL
+extern bool qt_dispatchAccelEvent( QWidget*, QKeyEvent* ); // def in qaccel.cpp
+extern bool qt_tryComposeUnicode( QWidget*, QKeyEvent* ); // def in qaccel.cpp
+#endif
+
+#if defined(QT_TABLET_SUPPORT)
+bool chokeMouse = FALSE;
+#endif
+
+void qt_setMaxWindowRect(const QRect& r)
+{
+    qt_maxWindowRect = r;
+    // Re-resize any maximized windows
+    QWidgetList* l = QApplication::topLevelWidgets();
+    if ( l ) {
+	QWidget *w = l->first();
+	while ( w ) {
+	    if ( w->isVisible() && w->isMaximized() )
+	    {
+		w->showNormal(); //#### flicker
+		w->showMaximized();
+	    }
+	    w = l->next();
+	}
+	delete l;
+    }
+}
+
+typedef void (*VFPTR)();
+typedef QValueList<VFPTR> QVFuncList;
+static QVFuncList *postRList = 0;		// list of post routines
+
+/*!
+  \relates QApplication
+
+  Adds a global routine that will be called from the QApplication
+  destructor. This function is normally used to add cleanup routines
+  for program-wide functionality.
+
+  The function given by \a p should take no arguments and return
+  nothing, like this:
+  \code
+    static int *global_ptr = 0;
+
+    static void cleanup_ptr()
+    {
+	delete [] global_ptr;
+	global_ptr = 0;
+    }
+
+    void init_ptr()
+    {
+	global_ptr = new int[100];	// allocate data
+	qAddPostRoutine( cleanup_ptr );	// delete later
+    }
+  \endcode
+
+  Note that for an application- or module-wide cleanup,
+  qAddPostRoutine() is often not suitable. People have a tendency to
+  make such modules dynamically loaded, and then unload those modules
+  long before the QApplication destructor is called, for example.
+
+  For modules and libraries, using a reference-counted initialization
+  manager or Qt' parent-child delete mechanism may be better. Here is
+  an example of a private class which uses the parent-child mechanism
+  to call a cleanup function at the right time:
+
+  \code
+    class MyPrivateInitStuff: public QObject {
+    private:
+	MyPrivateInitStuff( QObject * parent ): QObject( parent) {
+	    // initialization goes here
+	}
+	MyPrivateInitStuff * p;
+
+    public:
+	static MyPrivateInitStuff * initStuff( QObject * parent ) {
+	    if ( !p )
+		p = new MyPrivateInitStuff( parent );
+	    return p;
+	}
+
+	~MyPrivateInitStuff() {
+	    // cleanup (the "post routine") goes here
+	}
+    }
+  \endcode
+
+  By selecting the right parent widget/object, this can often be made
+  to clean up the module's data at the exact right moment.
+*/
+
+Q_EXPORT void qAddPostRoutine( QtCleanUpFunction p)
+{
+    if ( !postRList ) {
+	postRList = new QVFuncList;
+	Q_CHECK_PTR( postRList );
+    }
+    postRList->prepend( p );
+}
+
+
+Q_EXPORT void qRemovePostRoutine( QtCleanUpFunction p )
+{
+    if ( !postRList ) return;
+    QVFuncList::Iterator it = postRList->begin();
+    while ( it != postRList->end() ) {
+	if ( *it == p ) {
+	    postRList->remove( it );
+	    it = postRList->begin();
+	} else {
+	    ++it;
+	}
+    }
+}
+
+// Default application palettes and fonts (per widget type)
+QAsciiDict<QPalette> *QApplication::app_palettes = 0;
+QAsciiDict<QFont>    *QApplication::app_fonts = 0;
+
+#ifndef QT_NO_SESSIONMANAGER
+QString *QApplication::session_key = 0;		// ## session key. Should be a member in 4.0
+#endif
+QWidgetList *QApplication::popupWidgets = 0;	// has keyboard input focus
+
+QDesktopWidget *qt_desktopWidget = 0;		// root window widgets
+#ifndef QT_NO_CLIPBOARD
+QClipboard	      *qt_clipboard = 0;	// global clipboard object
+#endif
+QWidgetList * qt_modal_stack=0;		// stack of modal widgets
+
+// Definitions for posted events
+struct QPostEvent {
+    QPostEvent( QObject *r, QEvent *e ): receiver( r ), event( e ) {}
+   ~QPostEvent()			{ delete event; }
+    QObject  *receiver;
+    QEvent   *event;
+};
+
+class Q_EXPORT QPostEventList : public QPtrList<QPostEvent>
+{
+public:
+    QPostEventList() : QPtrList<QPostEvent>() {}
+    QPostEventList( const QPostEventList &list ) : QPtrList<QPostEvent>(list) {}
+   ~QPostEventList() { clear(); }
+    QPostEventList &operator=(const QPostEventList &list)
+	{ return (QPostEventList&)QPtrList<QPostEvent>::operator=(list); }
+};
+class Q_EXPORT QPostEventListIt : public QPtrListIterator<QPostEvent>
+{
+public:
+    QPostEventListIt( const QPostEventList &l ) : QPtrListIterator<QPostEvent>(l) {}
+    QPostEventListIt &operator=(const QPostEventListIt &i)
+{ return (QPostEventListIt&)QPtrListIterator<QPostEvent>::operator=(i); }
+};
+
+static QPostEventList *globalPostedEvents = 0;	// list of posted events
+
+uint qGlobalPostedEventsCount()
+{
+    if (!globalPostedEvents)
+	return 0;
+    return globalPostedEvents->count();
+}
+
+static QSingleCleanupHandler<QPostEventList> qapp_cleanup_events;
+
+#ifndef QT_NO_PALETTE
+QPalette *qt_std_pal = 0;
+
+void qt_create_std_palette()
+{
+    if ( qt_std_pal )
+	delete qt_std_pal;
+
+    QColor standardLightGray( 192, 192, 192 );
+    QColor light( 255, 255, 255 );
+    QColor dark( standardLightGray.dark( 150 ) );
+    QColorGroup std_act( Qt::black, standardLightGray,
+			 light, dark, Qt::gray,
+			 Qt::black, Qt::white );
+    QColorGroup std_dis( Qt::darkGray, standardLightGray,
+			 light, dark, Qt::gray,
+			 Qt::darkGray, std_act.background() );
+    QColorGroup std_inact( Qt::black, standardLightGray,
+			   light, dark, Qt::gray,
+			   Qt::black, Qt::white );
+    qt_std_pal = new QPalette( std_act, std_dis, std_inact );
+}
+
+static void qt_fix_tooltips()
+{
+    // No resources for this yet (unlike on Windows).
+    QColorGroup cg( Qt::black, QColor(255,255,220),
+		    QColor(96,96,96), Qt::black, Qt::black,
+		    Qt::black, QColor(255,255,220) );
+    QPalette pal( cg, cg, cg );
+    QApplication::setPalette( pal, TRUE, "QTipLabel");
+}
+#endif
+
+void QApplication::process_cmdline( int* argcptr, char ** argv )
+{
+    // process platform-indep command line
+    if ( !qt_is_gui_used || !*argcptr)
+	return;
+
+    int argc = *argcptr;
+    int i, j;
+
+    j = 1;
+    for ( i=1; i<argc; i++ ) {
+	if ( argv[i] && *argv[i] != '-' ) {
+	    argv[j++] = argv[i];
+	    continue;
+	}
+	QCString arg = argv[i];
+	QCString s;
+	if ( arg == "-qdevel" || arg == "-qdebug") {
+	    // obsolete argument
+	} else if ( arg.find( "-style=", 0, FALSE ) != -1 ) {
+	    s = arg.right( arg.length() - 7 );
+	} else if ( qstrcmp(arg,"-style") == 0 && i < argc-1 ) {
+	    s = argv[++i];
+	    s = s.lower();
+#ifndef QT_NO_SESSIONMANAGER
+	} else if ( qstrcmp(arg,"-session") == 0 && i < argc-1 ) {
+	    QCString s = argv[++i];
+	    if ( !s.isEmpty() ) {
+		session_id = QString::fromLatin1( s );
+		int p = session_id.find( '_' );
+		if ( p >= 0 ) {
+		    if ( !session_key )
+			session_key = new QString;
+		    *session_key = session_id.mid( p +1 );
+		    session_id = session_id.left( p );
+		}
+		is_session_restored = TRUE;
+	    }
+#endif
+	} else if ( qstrcmp(arg, "-reverse") == 0 ) {
+	    setReverseLayout( TRUE );
+	} else if ( qstrcmp(arg, "-widgetcount") == 0 ) {
+	    widgetCount = TRUE;;
+	} else {
+	    argv[j++] = argv[i];
+	}
+#ifndef QT_NO_STYLE
+	if ( !s.isEmpty() ) {
+	    setStyle( s );
+	}
+#endif
+    }
+
+    if(j < argc) {
+#ifdef Q_WS_MACX
+	static char* empty = "\0";
+	argv[j] = empty;
+#else
+	argv[j] = 0;
+#endif
+	*argcptr = j;
+    }
+}
+
+/*!
+  Initializes the window system and constructs an application object
+  with \a argc command line arguments in \a argv.
+
+  The global \c qApp pointer refers to this application object. Only
+  one application object should be created.
+
+  This application object must be constructed before any \link
+  QPaintDevice paint devices\endlink (including widgets, pixmaps, bitmaps
+  etc.).
+
+  Note that \a argc and \a argv might be changed. Qt removes command
+  line arguments that it recognizes. The modified \a argc and \a argv
+  can also be accessed later with \c qApp->argc() and \c qApp->argv().
+  The documentation for argv() contains a detailed description of how
+  to process command line arguments.
+
+  Qt debugging options (not available if Qt was compiled with the
+  QT_NO_DEBUG flag defined):
+  \list
+  \i -nograb, tells Qt that it must never grab the mouse or the keyboard.
+  \i -dograb (only under X11), running under a debugger can cause
+  an implicit -nograb, use -dograb to override.
+  \i -sync (only under X11), switches to synchronous mode for
+	debugging.
+  \endlist
+
+  See \link debug.html Debugging Techniques \endlink for a more
+  detailed explanation.
+
+  All Qt programs automatically support the following command line options:
+  \list
+  \i -reverse causes text to be formatted for right-to-left languages
+       rather than in the usual left-to-right direction.
+  \i -style= \e style, sets the application GUI style. Possible values
+       are \c motif, \c windows, and \c platinum. If you compiled Qt
+       with additional styles or have additional styles as plugins these
+       will be available to the \c -style command line option.
+  \i -style \e style, is the same as listed above.
+  \i -session= \e session, restores the application from an earlier
+       \link session.html session \endlink.
+  \i -session \e session, is the same as listed above.
+  \i -widgetcount, prints debug message at the end about number of widgets left
+       undestroyed and maximum number of widgets existed at the same time
+  \endlist
+
+  The X11 version of Qt also supports some traditional X11
+  command line options:
+  \list
+  \i -display \e display, sets the X display (default is $DISPLAY).
+  \i -geometry \e geometry, sets the client geometry of the
+	\link setMainWidget() main widget\endlink.
+  \i -fn or \c -font \e font, defines the application font. The
+  font should be specified using an X logical font description.
+  \i -bg or \c -background \e color, sets the default background color
+	and an application palette (light and dark shades are calculated).
+  \i -fg or \c -foreground \e color, sets the default foreground color.
+  \i -btn or \c -button \e color, sets the default button color.
+  \i -name \e name, sets the application name.
+  \i -title \e title, sets the application title (caption).
+  \i -visual \c TrueColor, forces the application to use a TrueColor visual
+       on an 8-bit display.
+  \i -ncols \e count, limits the number of colors allocated in the
+       color cube on an 8-bit display, if the application is using the
+       \c QApplication::ManyColor color specification. If \e count is
+       216 then a 6x6x6 color cube is used (i.e. 6 levels of red, 6 of green,
+       and 6 of blue); for other values, a cube
+       approximately proportional to a 2x3x1 cube is used.
+  \i -cmap, causes the application to install a private color map
+       on an 8-bit display.
+  \endlist
+
+  \sa argc(), argv()
+*/
+
+//######### BINARY COMPATIBILITY constructor
+QApplication::QApplication( int &argc, char **argv )
+{
+    construct( argc, argv, GuiClient );
+}
+
+
+/*!
+  Constructs an application object with \a argc command line arguments
+  in \a argv. If \a GUIenabled is TRUE, a GUI application is
+  constructed, otherwise a non-GUI (console) application is created.
+
+  Set \a GUIenabled to FALSE for programs without a graphical user
+  interface that should be able to run without a window system.
+
+  On X11, the window system is initialized if \a GUIenabled is TRUE.
+  If \a GUIenabled is FALSE, the application does not connect to the
+  X-server.
+  On Windows and Macintosh, currently the window system is always
+  initialized, regardless of the value of GUIenabled. This may change in
+  future versions of Qt.
+
+  The following example shows how to create an application that
+  uses a graphical interface when available.
+  \code
+  int main( int argc, char **argv )
+  {
+#ifdef Q_WS_X11
+    bool useGUI = getenv( "DISPLAY" ) != 0;
+#else
+    bool useGUI = TRUE;
+#endif
+    QApplication app(argc, argv, useGUI);
+
+    if ( useGUI ) {
+       //start GUI version
+       ...
+    } else {
+       //start non-GUI version
+       ...
+    }
+    return app.exec();
+  }
+\endcode
+*/
+
+QApplication::QApplication( int &argc, char **argv, bool GUIenabled  )
+{
+    construct( argc, argv, GUIenabled ? GuiClient : Tty );
+}
+
+/*!
+  Constructs an application object with \a argc command line arguments
+  in \a argv.
+
+  For Qt/Embedded, passing \c QApplication::GuiServer for \a type
+  makes this application the server (equivalent to running with the
+  -qws option).
+*/
+QApplication::QApplication( int &argc, char **argv, Type type )
+{
+    construct( argc, argv, type );
+}
+
+Q_EXPORT void qt_ucm_initialize( QApplication *theApp )
+{
+    if ( qApp )
+	return;
+    int argc = theApp->argc();
+    char **argv = theApp->argv();
+    theApp->construct( argc, argv, qApp->type() );
+
+    Q_ASSERT( qApp == theApp );
+}
+
+void QApplication::construct( int &argc, char **argv, Type type )
+{
+    qt_appType = type;
+    qt_is_gui_used = (type != Tty);
+    init_precmdline();
+    static const char *empty = "";
+    if ( argc == 0 || argv == 0 ) {
+	argc = 0;
+	argv = (char **)&empty; // ouch! careful with QApplication::argv()!
+    }
+    app_argc = argc;
+    app_argv = argv;
+
+    qt_init( &argc, argv, type );   // Must be called before initialize()
+    process_cmdline( &argc, argv );
+    initialize( argc, argv );
+    if ( qt_is_gui_used )
+	qt_maxWindowRect = desktop()->rect();
+    if ( eventloop )
+	eventloop->appStartingUp();
+}
+
+/*!
+    Returns the type of application, Tty, GuiClient or GuiServer.
+*/
+
+QApplication::Type QApplication::type() const
+{
+    return qt_appType;
+}
+
+#if defined(Q_WS_X11)
+/*!
+  Create an application, given an already open display \a dpy. If \a
+  visual and \a colormap are non-zero, the application will use those as
+  the default Visual and Colormap contexts.
+
+  \warning Qt only supports TrueColor visuals at depths higher than 8
+  bits-per-pixel.
+
+  This is available only on X11.
+*/
+
+QApplication::QApplication( Display* dpy, HANDLE visual, HANDLE colormap )
+{
+    static int aargc = 1;
+    // ### a string literal is a cont char*
+    // ### using it as a char* is wrong and could lead to segfaults
+    // ### if aargv is modified someday
+    static char *aargv[] = { (char*)"unknown", 0 };
+
+    app_argc = aargc;
+    app_argv = aargv;
+
+    qt_appType = GuiClient;
+    qt_is_gui_used = TRUE;
+    qt_appType = GuiClient;
+    init_precmdline();
+    // ... no command line.
+
+    if ( ! dpy ) {
+#ifdef QT_CHECK_STATE
+	qWarning( "QApplication: invalid Display* argument." );
+#endif // QT_CHECK_STATE
+
+	qt_init( &aargc, aargv, GuiClient );
+    } else {
+	qt_init( dpy, visual, colormap );
+    }
+
+    initialize( aargc, aargv );
+
+    if ( qt_is_gui_used )
+	qt_maxWindowRect = desktop()->rect();
+    if ( eventloop )
+	eventloop->appStartingUp();
+}
+
+/*!
+  Create an application, given an already open display \a dpy and using
+  \a argc command line arguments in \a argv. If \a
+  visual and \a colormap are non-zero, the application will use those as
+  the default Visual and Colormap contexts.
+
+  \warning Qt only supports TrueColor visuals at depths higher than 8
+  bits-per-pixel.
+
+  This is available only on X11.
+
+*/
+QApplication::QApplication(Display *dpy, int argc, char **argv,
+			   HANDLE visual, HANDLE colormap)
+{
+    qt_appType = GuiClient;
+    qt_is_gui_used = TRUE;
+    qt_appType = GuiClient;
+    init_precmdline();
+
+    app_argc = argc;
+    app_argv = argv;
+
+    if ( ! dpy ) {
+#ifdef QT_CHECK_STATE
+	qWarning( "QApplication: invalid Display* argument." );
+#endif // QT_CHECK_STATE
+
+	qt_init( &argc, argv, GuiClient );
+    } else {
+	qt_init(dpy, visual, colormap);
+    }
+
+    process_cmdline( &argc, argv );
+    initialize(argc, argv);
+
+    if ( qt_is_gui_used )
+	qt_maxWindowRect = desktop()->rect();
+    if ( eventloop )
+	eventloop->appStartingUp();
+}
+
+
+#endif // Q_WS_X11
+
+
+void QApplication::init_precmdline()
+{
+    translators = 0;
+    is_app_closing = FALSE;
+#ifndef QT_NO_SESSIONMANAGER
+    is_session_restored = FALSE;
+#endif
+#if defined(QT_CHECK_STATE)
+    if ( qApp )
+	qWarning( "QApplication: There should be max one application object" );
+#endif
+    qApp = (QApplication*)this;
+}
+
+/*!
+  Initializes the QApplication object, called from the constructors.
+*/
+
+void QApplication::initialize( int argc, char **argv )
+{
+#ifdef QT_THREAD_SUPPORT
+    qt_mutex = new QMutex( TRUE );
+    postevent_mutex = new QMutex( TRUE );
+    qt_application_thread_id = QThread::currentThread();
+#endif // QT_THREAD_SUPPORT
+
+    app_argc = argc;
+    app_argv = argv;
+    quit_now = FALSE;
+    quit_code = 0;
+    QWidget::createMapper(); // create widget mapper
+#ifndef QT_NO_PALETTE
+    (void) palette();  // trigger creation of application palette
+#endif
+    is_app_running = TRUE; // no longer starting up
+
+#ifndef QT_NO_SESSIONMANAGER
+    // connect to the session manager
+    if ( !session_key )
+	session_key = new QString;
+    session_manager = new QSessionManager( qApp, session_id, *session_key );
+#endif
+
+}
+
+
+/*****************************************************************************
+  Functions returning the active popup and modal widgets.
+ *****************************************************************************/
+
+/*!
+  Returns the active popup widget.
+
+  A popup widget is a special top level widget that sets the \c
+  WType_Popup widget flag, e.g. the QPopupMenu widget. When the
+  application opens a popup widget, all events are sent to the popup.
+  Normal widgets and modal widgets cannot be accessed before the popup
+  widget is closed.
+
+  Only other popup widgets may be opened when a popup widget is shown.
+  The popup widgets are organized in a stack. This function returns
+  the active popup widget at the top of the stack.
+
+  \sa activeModalWidget(), topLevelWidgets()
+*/
+
+QWidget *QApplication::activePopupWidget()
+{
+    return popupWidgets ? popupWidgets->getLast() : 0;
+}
+
+
+/*!
+  Returns the active modal widget.
+
+  A modal widget is a special top level widget which is a subclass of
+  QDialog that specifies the modal parameter of the constructor as
+  TRUE. A modal widget must be closed before the user can continue
+  with other parts of the program.
+
+  Modal widgets are organized in a stack. This function returns
+  the active modal widget at the top of the stack.
+
+  \sa activePopupWidget(), topLevelWidgets()
+*/
+
+QWidget *QApplication::activeModalWidget()
+{
+    return qt_modal_stack ? qt_modal_stack->getFirst() : 0;
+}
+
+/*!
+  Cleans up any window system resources that were allocated by this
+  application. Sets the global variable \c qApp to 0.
+*/
+
+QApplication::~QApplication()
+{
+#ifndef QT_NO_CLIPBOARD
+    // flush clipboard contents
+    if ( qt_clipboard ) {
+	QCustomEvent event( QEvent::Clipboard );
+	QApplication::sendEvent( qt_clipboard, &event );
+    }
+#endif
+
+    if ( eventloop )
+	eventloop->appClosingDown();
+    if ( postRList ) {
+	QVFuncList::Iterator it = postRList->begin();
+	while ( it != postRList->end() ) {	// call post routines
+	    (**it)();
+	    postRList->remove( it );
+	    it = postRList->begin();
+	}
+	delete postRList;
+	postRList = 0;
+    }
+
+    QObject *tipmanager = child( "toolTipManager", "QTipManager", FALSE );
+    delete tipmanager;
+
+    delete qt_desktopWidget;
+    qt_desktopWidget = 0;
+    is_app_closing = TRUE;
+
+#ifndef QT_NO_CLIPBOARD
+    delete qt_clipboard;
+    qt_clipboard = 0;
+#endif
+    QWidget::destroyMapper();
+#ifndef QT_NO_PALETTE
+    delete qt_std_pal;
+    qt_std_pal = 0;
+    delete app_pal;
+    app_pal = 0;
+    delete app_palettes;
+    app_palettes = 0;
+#endif
+    delete app_font;
+    app_font = 0;
+    delete app_fonts;
+    app_fonts = 0;
+#ifndef QT_NO_STYLE
+    delete app_style;
+    app_style = 0;
+#endif
+#ifndef QT_NO_CURSOR
+    delete app_cursor;
+    app_cursor = 0;
+#endif
+#ifndef QT_NO_TRANSLATION
+    delete translators;
+#endif
+
+#ifndef QT_NO_DRAGANDDROP
+    extern QDragManager *qt_dnd_manager;
+    delete qt_dnd_manager;
+#endif
+
+    qt_cleanup();
+
+#ifndef QT_NO_COMPONENT
+    delete app_libpaths;
+    app_libpaths = 0;
+#endif
+
+#ifdef QT_THREAD_SUPPORT
+    delete qt_mutex;
+    qt_mutex = 0;
+    delete postevent_mutex;
+    postevent_mutex = 0;
+#endif // QT_THREAD_SUPPORT
+
+    if( qApp == this ) {
+	if ( postedEvents )
+	    removePostedEvents( this );
+	qApp = 0;
+    }
+    is_app_running = FALSE;
+
+    if ( widgetCount ) {
+	qDebug( "Widgets left: %i    Max widgets: %i \n", QWidget::instanceCounter, QWidget::maxInstances );
+    }
+#ifndef QT_NO_SESSIONMANAGER
+    delete session_manager;
+    session_manager = 0;
+    delete session_key;
+    session_key = 0;
+#endif //QT_NO_SESSIONMANAGER
+
+    qt_explicit_app_style = FALSE;
+    qt_app_has_font = FALSE;
+    app_tracking = 0;
+    obey_desktop_settings = TRUE;
+    cursor_flash_time = 1000;
+    mouse_double_click_time = 400;
+#ifndef QT_NO_WHEELEVENT
+    wheel_scroll_lines = 3;
+#endif
+    drag_time = 500;
+    drag_distance = 4;
+    reverse_layout = FALSE;
+    app_strut = QSize( 0, 0 );
+    animate_ui = TRUE;
+    animate_menu = FALSE;
+    fade_menu = FALSE;
+    animate_combo = FALSE;
+    animate_tooltip = FALSE;
+    fade_tooltip = FALSE;
+    widgetCount = FALSE;
+}
+
+
+/*!
+    \fn int QApplication::argc() const
+
+    Returns the number of command line arguments.
+
+    The documentation for argv() describes how to process command line
+    arguments.
+
+    \sa argv(), QApplication::QApplication()
+*/
+
+/*!
+    \fn char **QApplication::argv() const
+
+    Returns the command line argument vector.
+
+    \c argv()[0] is the program name, \c argv()[1] is the first
+    argument and \c argv()[argc()-1] is the last argument.
+
+    A QApplication object is constructed by passing \e argc and \e
+    argv from the \c main() function. Some of the arguments may be
+    recognized as Qt options and removed from the argument vector. For
+    example, the X11 version of Qt knows about \c -display, \c -font
+    and a few more options.
+
+    Example:
+    \code
+	// showargs.cpp - displays program arguments in a list box
+
+	#include <qapplication.h>
+	#include <qlistbox.h>
+
+	int main( int argc, char **argv )
+	{
+	    QApplication a( argc, argv );
+	    QListBox b;
+	    a.setMainWidget( &b );
+	    for ( int i = 0; i < a.argc(); i++ )  // a.argc() == argc
+		b.insertItem( a.argv()[i] );      // a.argv()[i] == argv[i]
+	    b.show();
+	    return a.exec();
+	}
+    \endcode
+
+    If you run \c{showargs -display unix:0 -font 9x15bold hello world}
+    under X11, the list box contains the three strings "showargs",
+    "hello" and "world".
+
+    Qt provides a global pointer, \c qApp, that points to the
+    QApplication object, and through which you can access argc() and
+    argv() in functions other than main().
+
+    \sa argc(), QApplication::QApplication()
+*/
+
+/*!
+    \fn void QApplication::setArgs( int argc, char **argv )
+    \internal
+*/
+
+
+#ifndef QT_NO_STYLE
+
+static QString *qt_style_override = 0;
+
+/*!
+  Returns the application's style object.
+
+  \sa setStyle(), QStyle
+*/
+QStyle& QApplication::style()
+{
+#ifndef QT_NO_STYLE
+    if ( app_style )
+	return *app_style;
+    if ( !qt_is_gui_used )
+	qFatal( "No style available in non-gui applications!" );
+
+#if defined(Q_WS_X11)
+    if(!qt_style_override)
+	x11_initialize_style(); // run-time search for default style
+#endif
+    if ( !app_style ) {
+	// Compile-time search for default style
+	//
+	QString style;
+	if ( qt_style_override ) {
+	    style = *qt_style_override;
+	    delete qt_style_override;
+	    qt_style_override = 0;
+	} else {
+#  if defined(Q_WS_WIN) && defined(Q_OS_TEMP)
+	    style = "PocketPC";
+#elif defined(Q_WS_WIN)
+	    if ( qWinVersion() >= Qt::WV_XP && qWinVersion() < Qt::WV_NT_based )
+		style = "WindowsXP";
+	    else
+		style = "Windows";		// default styles for Windows
+#elif defined(Q_WS_X11) && defined(Q_OS_SOLARIS)
+	    style = "CDE";			// default style for X11 on Solaris
+#elif defined(Q_WS_X11) && defined(Q_OS_IRIX)
+	    style = "SGI";			// default style for X11 on IRIX
+#elif defined(Q_WS_X11)
+		style = "Motif";		// default style for X11
+#elif defined(Q_WS_MAC)
+		style = "Macintosh";		// default style for all Mac's
+#elif defined(Q_WS_QWS)
+	    style = "Compact";		// default style for small devices
+#endif
+	}
+	app_style = QStyleFactory::create( style );
+	if ( !app_style &&		// platform default style not available, try alternatives
+	     !(app_style = QStyleFactory::create( "Windows" ) ) &&
+	     !(app_style = QStyleFactory::create( "Platinum" ) ) &&
+	     !(app_style = QStyleFactory::create( "MotifPlus" ) ) &&
+	     !(app_style = QStyleFactory::create( "Motif" ) ) &&
+	     !(app_style = QStyleFactory::create( "CDE" ) ) &&
+	     !(app_style = QStyleFactory::create( "Aqua" ) ) &&
+	     !(app_style = QStyleFactory::create( "SGI" ) ) &&
+	     !(app_style = QStyleFactory::create( "Compact" ) )
+#ifndef QT_NO_STRINGLIST
+	    && !(app_style = QStyleFactory::create( QStyleFactory::keys()[0]  ) )
+#endif
+	)
+	    qFatal( "No %s style available!", style.latin1() );
+    }
+
+    QPalette app_pal_copy ( *app_pal );
+    app_style->polish( *app_pal );
+
+    if ( is_app_running && !is_app_closing && (*app_pal != app_pal_copy) ) {
+	QEvent e( QEvent::ApplicationPaletteChange );
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {		// for all widgets...
+	    ++it;
+	    sendEvent( w, &e );
+	}
+    }
+
+    app_style->polish( qApp );
+#endif
+    return *app_style;
+}
+
+/*!
+  Sets the application's GUI style to \a style. Ownership of the style
+  object is transferred to QApplication, so QApplication will delete
+  the style object on application exit or when a new style is set.
+
+  Example usage:
+  \code
+    QApplication::setStyle( new QWindowsStyle );
+  \endcode
+
+  When switching application styles, the color palette is set back to
+  the initial colors or the system defaults. This is necessary since
+  certain styles have to adapt the color palette to be fully
+  style-guide compliant.
+
+  \sa style(), QStyle, setPalette(), desktopSettingsAware()
+*/
+void QApplication::setStyle( QStyle *style )
+{
+    QStyle* old = app_style;
+    app_style = style;
+#ifdef Q_WS_X11
+    qt_explicit_app_style = TRUE;
+#endif // Q_WS_X11
+
+    if ( startingUp() ) {
+	delete old;
+	return;
+    }
+
+    // clean up the old style
+    if (old) {
+	if ( is_app_running && !is_app_closing ) {
+	    QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	    register QWidget *w;
+	    while ( (w=it.current()) ) {		// for all widgets...
+		++it;
+		if ( !w->testWFlags(WType_Desktop) &&	// except desktop
+		     w->testWState(WState_Polished) ) { // has been polished
+		    old->unPolish(w);
+		}
+	    }
+	}
+	old->unPolish( qApp );
+    }
+
+    // take care of possible palette requirements of certain gui
+    // styles. Do it before polishing the application since the style
+    // might call QApplication::setStyle() itself
+    if ( !qt_std_pal )
+	qt_create_std_palette();
+    QPalette tmpPal = *qt_std_pal;
+    setPalette( tmpPal, TRUE );
+
+    // initialize the application with the new style
+    app_style->polish( qApp );
+
+    // re-polish existing widgets if necessary
+    if (old) {
+	if ( is_app_running && !is_app_closing ) {
+	    QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	    register QWidget *w;
+	    while ( (w=it.current()) ) {		// for all widgets...
+		++it;
+		if ( !w->testWFlags(WType_Desktop) ) {	// except desktop
+		    if ( w->testWState(WState_Polished) )
+			app_style->polish(w);		// repolish
+		    w->styleChange( *old );
+		    if ( w->isVisible() ){
+			w->update();
+		    }
+		}
+	    }
+	}
+	delete old;
+    }
+}
+
+/*!
+  \overload
+
+  Requests a QStyle object for \a style from the QStyleFactory.
+
+  The string must be one of the QStyleFactory::keys(), typically one
+  of "windows", "motif", "cde", "motifplus", "platinum", "sgi" and
+  "compact". Depending on the platform, "windowsxp", "aqua" or
+  "macintosh" may be available.
+
+  A later call to the QApplication constructor will override the
+  requested style when a "-style" option is passed in as a commandline
+  parameter.
+
+  Returns 0 if an unknown \a style is passed, otherwise the QStyle object
+  returned is set as the application's GUI style.
+*/
+QStyle* QApplication::setStyle( const QString& style )
+{
+#ifdef Q_WS_X11
+    qt_explicit_app_style = TRUE;
+#endif // Q_WS_X11
+
+    if ( startingUp() ) {
+	if(qt_style_override)
+	    *qt_style_override = style;
+	else
+	    qt_style_override = new QString(style);
+	return 0;
+    }
+    QStyle *s = QStyleFactory::create( style );
+    if ( !s )
+	return 0;
+
+    setStyle( s );
+    return s;
+}
+
+#endif
+
+
+#if 1  /* OBSOLETE */
+
+QApplication::ColorMode QApplication::colorMode()
+{
+    return (QApplication::ColorMode)app_cspec;
+}
+
+void QApplication::setColorMode( QApplication::ColorMode mode )
+{
+    app_cspec = mode;
+}
+#endif
+
+
+/*!
+  Returns the color specification.
+  \sa QApplication::setColorSpec()
+ */
+
+int QApplication::colorSpec()
+{
+    return app_cspec;
+}
+
+/*!
+  Sets the color specification for the application to \a spec.
+
+  The color specification controls how the application allocates colors
+  when run on a display with a limited amount of colors, e.g. 8 bit / 256
+  color displays.
+
+  The color specification must be set before you create the QApplication
+  object.
+
+  The options are:
+  \list
+  \i QApplication::NormalColor.
+    This is the default color allocation strategy. Use this option if
+    your application uses buttons, menus, texts and pixmaps with few
+    colors. With this option, the application uses system global
+    colors. This works fine for most applications under X11, but on
+    Windows machines it may cause dithering of non-standard colors.
+  \i QApplication::CustomColor.
+    Use this option if your application needs a small number of custom
+    colors. On X11, this option is the same as NormalColor. On Windows, Qt
+    creates a Windows palette, and allocates colors to it on demand.
+  \i QApplication::ManyColor.
+    Use this option if your application is very color hungry
+    (e.g. it requires thousands of colors).
+    Under X11 the effect is:
+    \list
+    \i For 256-color displays which have at best a 256 color true color
+       visual, the default visual is used, and colors are allocated
+       from a color cube. The color cube is the 6x6x6 (216 color) "Web
+       palette"<sup>*</sup>, but the number of colors can be changed
+       by the \e -ncols option. The user can force the application to
+       use the true color visual with the \link
+       QApplication::QApplication() -visual \endlink option.
+    \i For 256-color displays which have a true color visual with more
+       than 256 colors, use that visual. Silicon Graphics X servers
+       have this feature, for example. They provide an 8 bit visual
+       by default but can deliver true color when asked.
+    \endlist
+    On Windows, Qt creates a Windows palette, and fills it with a color cube.
+  \endlist
+
+  Be aware that the CustomColor and ManyColor choices may lead to colormap
+  flashing: The foreground application gets (most) of the available
+  colors, while the background windows will look less attractive.
+
+  Example:
+  \code
+  int main( int argc, char **argv )
+  {
+      QApplication::setColorSpec( QApplication::ManyColor );
+      QApplication a( argc, argv );
+      ...
+  }
+  \endcode
+
+  QColor provides more functionality for controlling color allocation and
+  freeing up certain colors. See QColor::enterAllocContext() for more
+  information.
+
+  To check what mode you end up with, call QColor::numBitPlanes() once
+  the QApplication object exists. A value greater than 8 (typically
+  16, 24 or 32) means true color.
+
+  <sup>*</sup> The color cube used by Qt has 216 colors whose red,
+  green, and blue components always have one of the following values:
+  0x00, 0x33, 0x66, 0x99, 0xCC, or 0xFF.
+
+  \sa colorSpec(), QColor::numBitPlanes(), QColor::enterAllocContext() */
+
+void QApplication::setColorSpec( int spec )
+{
+#if defined(QT_CHECK_STATE)
+    if ( qApp ) {
+	qWarning( "QApplication::setColorSpec: This function must be "
+		 "called before the QApplication object is created" );
+    }
+#endif
+    app_cspec = spec;
+}
+
+/*!
+  \fn QSize QApplication::globalStrut()
+
+  Returns the application's global strut.
+
+  The strut is a size object whose dimensions are the minimum that any
+  GUI element that the user can interact with should have. For example
+  no button should be resized to be smaller than the global strut size.
+
+  \sa setGlobalStrut()
+*/
+
+/*!
+  Sets the application's global strut to \a strut.
+
+  The strut is a size object whose dimensions are the minimum that any
+  GUI element that the user can interact with should have. For example
+  no button should be resized to be smaller than the global strut size.
+
+  The strut size should be considered when reimplementing GUI controls
+  that may be used on touch-screens or similar IO-devices.
+
+  Example:
+  \code
+  QSize& WidgetClass::sizeHint() const
+  {
+      return QSize( 80, 25 ).expandedTo( QApplication::globalStrut() );
+  }
+  \endcode
+
+  \sa globalStrut()
+*/
+
+void QApplication::setGlobalStrut( const QSize& strut )
+{
+    app_strut = strut;
+}
+
+#if defined( Q_WS_WIN ) || defined( Q_WS_MAC )
+extern const char *qAppFileName();
+#endif
+
+#ifndef QT_NO_DIR
+#ifndef Q_WS_WIN
+static QString resolveSymlinks( const QString& path, int depth = 0 )
+{
+    bool foundLink = FALSE;
+    QString linkTarget;
+    QString part = path;
+    int slashPos = path.length();
+
+    // too deep; we give up
+    if ( depth == 128 )
+	return QString::null;
+
+    do {
+	part = part.left( slashPos );
+	QFileInfo fileInfo( part );
+	if ( fileInfo.isSymLink() ) {
+	    foundLink = TRUE;
+	    linkTarget = fileInfo.readLink();
+	    break;
+	}
+    } while ( (slashPos = part.findRev('/')) != -1 );
+
+    if ( foundLink ) {
+	QString path2;
+	if ( linkTarget[0] == '/' ) {
+	    path2 = linkTarget;
+	    if ( slashPos < (int) path.length() )
+		path2 += "/" + path.right( path.length() - slashPos - 1 );
+	} else {
+	    QString relPath;
+	    relPath = part.left( part.findRev('/') + 1 ) + linkTarget;
+	    if ( slashPos < (int) path.length() ) {
+		if ( !linkTarget.endsWith( "/" ) )
+		    relPath += "/";
+		relPath += path.right( path.length() - slashPos - 1 );
+	    }
+	    path2 = QDir::current().absFilePath( relPath );
+	}
+	path2 = QDir::cleanDirPath( path2 );
+	return resolveSymlinks( path2, depth + 1 );
+    } else {
+	return path;
+    }
+}
+#endif // Q_WS_WIN
+
+/*!
+    Returns the directory that contains the application executable.
+
+    For example, if you have installed Qt in the \c{C:\Trolltech\Qt}
+    directory, and you run the \c{demo} example, this function will
+    return "C:/Trolltech/Qt/examples/demo".
+
+    On Mac OS X this will point to the directory actually containing the
+    executable, which may be inside of an application bundle (if the
+    application is bundled).
+
+    \warning On Unix, this function assumes that argv[0] contains the file
+    name of the executable (which it normally does). It also assumes that
+    the current directory hasn't been changed by the application.
+
+    \sa applicationFilePath()
+*/
+QString QApplication::applicationDirPath()
+{
+    return QFileInfo( applicationFilePath() ).dirPath();
+}
+
+/*!
+    Returns the file path of the application executable.
+
+    For example, if you have installed Qt in the \c{C:\Trolltech\Qt}
+    directory, and you run the \c{demo} example, this function will
+    return "C:/Trolltech/Qt/examples/demo/demo.exe".
+
+    \warning On Unix, this function assumes that argv[0] contains the file
+    name of the executable (which it normally does). It also assumes that
+    the current directory hasn't been changed by the application.
+
+    \sa applicationDirPath()
+*/
+QString QApplication::applicationFilePath()
+{
+#if defined( Q_WS_WIN )
+    QFileInfo filePath;
+    QT_WA({
+        WCHAR module_name[256];
+        GetModuleFileNameW(0, module_name, sizeof(module_name));
+        filePath = QString::fromUcs2((const unsigned short *)module_name);
+    }, {
+        char module_name[256];
+        GetModuleFileNameA(0, module_name, sizeof(module_name));
+        filePath = QString::fromLocal8Bit(module_name);
+    });
+
+    return filePath.filePath();
+#elif defined( Q_WS_MAC )
+    return QDir::cleanDirPath( QFile::decodeName( qAppFileName() ) );
+#else
+    QString argv0 = QFile::decodeName( argv()[0] );
+    QString absPath;
+
+    if ( argv0[0] == '/' ) {
+	/*
+	  If argv0 starts with a slash, it is already an absolute
+	  file path.
+	*/
+	absPath = argv0;
+    } else if ( argv0.find('/') != -1 ) {
+	/*
+	  If argv0 contains one or more slashes, it is a file path
+	  relative to the current directory.
+	*/
+	absPath = QDir::current().absFilePath( argv0 );
+    } else {
+	/*
+	  Otherwise, the file path has to be determined using the
+	  PATH environment variable.
+	*/
+	char *pEnv = getenv( "PATH" );
+	QStringList paths( QStringList::split(QChar(':'), pEnv) );
+	QStringList::const_iterator p = paths.begin();
+	while ( p != paths.end() ) {
+	    QString candidate = QDir::current().absFilePath( *p + "/" + argv0 );
+	    if ( QFile::exists(candidate) ) {
+		absPath = candidate;
+		break;
+	    }
+	    ++p;
+	}
+    }
+
+    absPath = QDir::cleanDirPath( absPath );
+    if ( QFile::exists(absPath) ) {
+	return resolveSymlinks( absPath );
+    } else {
+	return QString::null;
+    }
+#endif
+}
+#endif // QT_NO_DIR
+
+#ifndef QT_NO_COMPONENT
+
+/*!
+  Returns a list of paths that the application will search when
+  dynamically loading libraries.
+  The installation directory for plugins is the only entry if no
+  paths have been set.  The default installation directory for plugins
+  is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was
+  installed. The directory of the application executable (NOT the
+  working directory) is also added to the plugin paths.
+
+  If you want to iterate over the list, you should iterate over a
+  copy, e.g.
+    \code
+    QStringList list = app.libraryPaths();
+    QStringList::Iterator it = list.begin();
+    while( it != list.end() ) {
+	myProcessing( *it );
+	++it;
+    }
+    \endcode
+
+  See the \link plugins-howto.html plugins documentation\endlink for a
+  description of how the library paths are used.
+
+  \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary
+*/
+QStringList QApplication::libraryPaths()
+{
+    if ( !app_libpaths ) {
+	app_libpaths = new QStringList;
+	QString installPathPlugins = QString::fromLocal8Bit(qInstallPathPlugins());
+	if ( QFile::exists(installPathPlugins) ) {
+#ifdef Q_WS_WIN
+	    installPathPlugins.replace('\\', '/');
+#endif
+	    app_libpaths->append(installPathPlugins);
+	}
+
+	QString app_location;
+	if (qApp)
+	    app_location = qApp->applicationFilePath();
+#ifdef Q_WS_WIN
+	else {
+	    app_location = QString(qAppFileName());
+	    app_location.replace('\\', '/');
+	}
+#endif
+	if (!app_location.isEmpty()) {
+	    app_location.truncate( app_location.findRev( '/' ) );
+	    if ( app_location != qInstallPathPlugins() && QFile::exists( app_location ) )
+		app_libpaths->append( app_location );
+	}
+    }
+    return *app_libpaths;
+}
+
+
+/*!
+  Sets the list of directories to search when loading libraries to \a paths.
+  All existing paths will be deleted and the path list will consist of the
+  paths given in \a paths.
+
+  \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary
+ */
+void QApplication::setLibraryPaths( const QStringList &paths )
+{
+    delete app_libpaths;
+    app_libpaths = new QStringList( paths );
+}
+
+/*!
+  Append \a path to the end of the library path list. If \a path is
+  empty or already in the path list, the path list is not changed.
+
+  The default path list consists of a single entry, the installation
+  directory for plugins.  The default installation directory for plugins
+  is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was
+  installed.
+
+  \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()
+ */
+void QApplication::addLibraryPath( const QString &path )
+{
+    if ( path.isEmpty() )
+	return;
+
+    // make sure that library paths is initialized
+    libraryPaths();
+
+    if ( !app_libpaths->contains( path ) )
+	app_libpaths->prepend( path );
+}
+
+/*!
+  Removes \a path from the library path list. If \a path is empty or not
+  in the path list, the list is not changed.
+
+  \sa addLibraryPath(), libraryPaths(), setLibraryPaths()
+*/
+void QApplication::removeLibraryPath( const QString &path )
+{
+    if ( path.isEmpty() )
+	return;
+
+    // make sure that library paths is initialized
+    libraryPaths();
+
+    if ( app_libpaths->contains( path ) )
+	app_libpaths->remove( path );
+}
+#endif //QT_NO_COMPONENT
+
+/*!
+  Returns the application palette.
+
+  If a widget is passed in \a w, the default palette for the
+  widget's class is returned. This may or may not be the application
+  palette. In most cases there isn't a special palette for certain
+  types of widgets, but one notable exception is the popup menu under
+  Windows, if the user has defined a special background color for
+  menus in the display settings.
+
+  \sa setPalette(), QWidget::palette()
+*/
+#ifndef QT_NO_PALETTE
+QPalette QApplication::palette(const QWidget* w)
+{
+#if defined(QT_CHECK_STATE)
+    if ( !qApp )
+	qWarning( "QApplication::palette: This function can only be "
+		  "called after the QApplication object has been created" );
+#endif
+    if ( !app_pal ) {
+	if ( !qt_std_pal )
+	    qt_create_std_palette();
+	app_pal = new QPalette( *qt_std_pal );
+	qt_fix_tooltips();
+    }
+
+    if ( w && app_palettes ) {
+	QPalette* wp = app_palettes->find( w->className() );
+	if ( wp )
+	    return *wp;
+	QAsciiDictIterator<QPalette> it( *app_palettes );
+	const char* name;
+	while ( (name=it.currentKey()) != 0 ) {
+	    if ( w->inherits( name ) )
+		return *it.current();
+	    ++it;
+	}
+    }
+    return *app_pal;
+}
+
+/*!
+  Changes the default application palette to \a palette. If \a
+  informWidgets is TRUE, then existing widgets are informed about the
+  change and may adjust themselves to the new application
+  setting. If \a informWidgets is FALSE, the change only affects newly
+  created widgets.
+
+  If \a className is passed, the change applies only to widgets that
+  inherit \a className (as reported by QObject::inherits()). If
+  \a className is left 0, the change affects all widgets, thus overriding
+  any previously set class specific palettes.
+
+  The palette may be changed according to the current GUI style in
+  QStyle::polish().
+
+  \sa QWidget::setPalette(), palette(), QStyle::polish()
+*/
+
+void QApplication::setPalette( const QPalette &palette, bool informWidgets,
+			       const char* className )
+{
+    QPalette pal = palette;
+    QPalette *oldpal = 0;
+#ifndef QT_NO_STYLE
+    if ( !startingUp() ) // on startup this has been done already
+	qApp->style().polish( pal );	// NB: non-const reference
+#endif
+    bool all = FALSE;
+    if ( !className ) {
+	if ( !app_pal ) {
+	    app_pal = new QPalette( pal );
+	    Q_CHECK_PTR( app_pal );
+	} else {
+	    *app_pal = pal;
+	}
+	all = app_palettes != 0;
+	delete app_palettes;
+	app_palettes = 0;
+	qt_fix_tooltips();
+    } else {
+	if ( !app_palettes ) {
+	    app_palettes = new QAsciiDict<QPalette>;
+	    Q_CHECK_PTR( app_palettes );
+	    app_palettes->setAutoDelete( TRUE );
+	}
+	oldpal = app_palettes->find( className );
+	app_palettes->insert( className, new QPalette( pal ) );
+    }
+    if ( informWidgets && is_app_running && !is_app_closing ) {
+	if ( !oldpal || ( *oldpal != pal ) ) {
+	    QEvent e( QEvent::ApplicationPaletteChange );
+	    QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	    register QWidget *w;
+	    while ( (w=it.current()) ) {		// for all widgets...
+		++it;
+		if ( all || (!className && w->isTopLevel() ) || w->inherits(className) ) // matching class
+		    sendEvent( w, &e );
+	    }
+	}
+    }
+}
+
+#endif // QT_NO_PALETTE
+
+/*!
+  Returns the default font for the widget \a w, or the default
+  application font if \a w is 0.
+
+  \sa setFont(), fontMetrics(), QWidget::font()
+*/
+
+QFont QApplication::font( const QWidget *w )
+{
+    if ( w && app_fonts ) {
+	QFont* wf = app_fonts->find( w->className() );
+	if ( wf )
+	    return *wf;
+	QAsciiDictIterator<QFont> it( *app_fonts );
+	const char* name;
+	while ( (name=it.currentKey()) != 0 ) {
+	    if ( w->inherits( name ) )
+		return *it.current();
+	    ++it;
+	}
+    }
+    if ( !app_font ) {
+	app_font = new QFont( "Helvetica" );
+	Q_CHECK_PTR( app_font );
+    }
+    return *app_font;
+}
+
+/*! Changes the default application font to \a font. If \a
+  informWidgets is TRUE, then existing widgets are informed about the
+  change and may adjust themselves to the new application
+  setting. If \a informWidgets is FALSE, the change only affects newly
+  created widgets. If \a className is passed, the change applies only
+  to classes that inherit \a className (as reported by
+  QObject::inherits()).
+
+  On application start-up, the default font depends on the window
+  system. It can vary depending on both the window system version and
+  the locale. This function lets you override the default font; but
+  overriding may be a bad idea because, for example, some locales need
+  extra-large fonts to support their special characters.
+
+  \sa font(), fontMetrics(), QWidget::setFont()
+*/
+
+void QApplication::setFont( const QFont &font, bool informWidgets,
+			    const char* className )
+{
+    bool all = FALSE;
+    if ( !className ) {
+	qt_app_has_font = TRUE;
+	if ( !app_font ) {
+	    app_font = new QFont( font );
+	    Q_CHECK_PTR( app_font );
+	} else {
+	    *app_font = font;
+	}
+
+	// make sure the application font is complete
+	app_font->detach();
+	app_font->d->mask = QFontPrivate::Complete;
+
+	all = app_fonts != 0;
+	delete app_fonts;
+	app_fonts = 0;
+    } else {
+	if (!app_fonts){
+	    app_fonts = new QAsciiDict<QFont>;
+	    Q_CHECK_PTR( app_fonts );
+	    app_fonts->setAutoDelete( TRUE );
+	}
+	QFont* fnt = new QFont(font);
+	Q_CHECK_PTR( fnt );
+	app_fonts->insert(className, fnt);
+    }
+    if ( informWidgets && is_app_running && !is_app_closing ) {
+	QEvent e( QEvent::ApplicationFontChange );
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {		// for all widgets...
+	    ++it;
+	    if ( all || (!className && w->isTopLevel() ) || w->inherits(className) ) // matching class
+		sendEvent( w, &e );
+	}
+    }
+}
+
+
+/*!
+  Initialization of the appearance of the widget \a w \e before it is first
+  shown.
+
+  Usually widgets call this automatically when they are polished. It
+  may be used to do some style-based central customization of widgets.
+
+  Note that you are not limited to the public functions of QWidget.
+  Instead, based on meta information like QObject::className() you are
+  able to customize any kind of widget.
+
+  \sa QStyle::polish(), QWidget::polish(), setPalette(), setFont()
+*/
+
+void QApplication::polish( QWidget *w )
+{
+#ifndef QT_NO_STYLE
+    w->style().polish( w );
+#endif
+}
+
+
+/*!
+  Returns a list of the top level widgets in the application.
+
+  The list is created using \c new and must be deleted by the caller.
+
+  The list is empty (QPtrList::isEmpty()) if there are no top level
+  widgets.
+
+  Note that some of the top level widgets may be hidden, for example
+  the tooltip if no tooltip is currently shown.
+
+  Example:
+  \code
+    // Show all hidden top level widgets.
+    QWidgetList	 *list = QApplication::topLevelWidgets();
+    QWidgetListIt it( *list );	// iterate over the widgets
+    QWidget * w;
+    while ( (w=it.current()) != 0 ) {	// for each top level widget...
+	++it;
+	if ( !w->isVisible() )
+	    w->show();
+    }
+    delete list;		// delete the list, not the widgets
+  \endcode
+
+  \warning Delete the list as soon you have finished using it.
+  The widgets in the list may be deleted by someone else at any time.
+
+  \sa allWidgets(), QWidget::isTopLevel(), QWidget::isVisible(),
+      QPtrList::isEmpty()
+*/
+
+QWidgetList *QApplication::topLevelWidgets()
+{
+    return QWidget::tlwList();
+}
+
+/*!
+  Returns a list of all the widgets in the application.
+
+  The list is created using \c new and must be deleted by the caller.
+
+  The list is empty (QPtrList::isEmpty()) if there are no widgets.
+
+  Note that some of the widgets may be hidden.
+
+  Example that updates all widgets:
+  \code
+    QWidgetList	 *list = QApplication::allWidgets();
+    QWidgetListIt it( *list );         // iterate over the widgets
+    QWidget * w;
+    while ( (w=it.current()) != 0 ) {  // for each widget...
+	++it;
+	w->update();
+    }
+    delete list;                      // delete the list, not the widgets
+  \endcode
+
+  The QWidgetList class is defined in the \c qwidgetlist.h header
+  file.
+
+  \warning Delete the list as soon as you have finished using it.
+  The widgets in the list may be deleted by someone else at any time.
+
+  \sa topLevelWidgets(), QWidget::isVisible(), QPtrList::isEmpty(),
+*/
+
+QWidgetList *QApplication::allWidgets()
+{
+    return QWidget::wList();
+}
+
+/*!
+  \fn QWidget *QApplication::focusWidget() const
+
+  Returns the application widget that has the keyboard input focus, or
+  0 if no widget in this application has the focus.
+
+  \sa QWidget::setFocus(), QWidget::hasFocus(), activeWindow()
+*/
+
+/*!
+  \fn QWidget *QApplication::activeWindow() const
+
+  Returns the application top-level window that has the keyboard input
+  focus, or 0 if no application window has the focus. Note that
+  there might be an activeWindow() even if there is no focusWidget(),
+  for example if no widget in that window accepts key events.
+
+  \sa QWidget::setFocus(), QWidget::hasFocus(), focusWidget()
+*/
+
+/*!
+  Returns display (screen) font metrics for the application font.
+
+  \sa font(), setFont(), QWidget::fontMetrics(), QPainter::fontMetrics()
+*/
+
+QFontMetrics QApplication::fontMetrics()
+{
+    return desktop()->fontMetrics();
+}
+
+
+
+/*!
+  Tells the application to exit with return code 0 (success).
+  Equivalent to calling QApplication::exit( 0 ).
+
+  It's common to connect the lastWindowClosed() signal to quit(), and
+  you also often connect e.g. QButton::clicked() or signals in
+  QAction, QPopupMenu or QMenuBar to it.
+
+  Example:
+  \code
+    QPushButton *quitButton = new QPushButton( "Quit" );
+    connect( quitButton, SIGNAL(clicked()), qApp, SLOT(quit()) );
+  \endcode
+
+  \sa exit() aboutToQuit() lastWindowClosed() QAction
+*/
+
+void QApplication::quit()
+{
+    QApplication::exit( 0 );
+}
+
+
+/*!
+  Closes all top-level windows.
+
+  This function is particularly useful for applications with many
+  top-level windows. It could, for example, be connected to a "Quit"
+  entry in the file menu as shown in the following code example:
+
+  \code
+    // the "Quit" menu entry should try to close all windows
+    QPopupMenu* file = new QPopupMenu( this );
+    file->insertItem( "&Quit", qApp, SLOT(closeAllWindows()), CTRL+Key_Q );
+
+    // when the last window is closed, the application should quit
+    connect( qApp, SIGNAL( lastWindowClosed() ), qApp, SLOT( quit() ) );
+  \endcode
+
+  The windows are closed in random order, until one window does not
+  accept the close event.
+
+  \sa QWidget::close(), QWidget::closeEvent(), lastWindowClosed(),
+  quit(), topLevelWidgets(), QWidget::isTopLevel()
+
+ */
+void QApplication::closeAllWindows()
+{
+    bool did_close = TRUE;
+    QWidget *w;
+    while((w = activeModalWidget()) && did_close) {
+	if(w->isHidden())
+	    break;
+	did_close = w->close();
+    }
+    QWidgetList *list = QApplication::topLevelWidgets();
+    for ( w = list->first(); did_close && w; ) {
+	if ( !w->isHidden() ) {
+	    did_close = w->close();
+	    delete list;
+	    list = QApplication::topLevelWidgets();
+	    w = list->first();
+	} else {
+	    w = list->next();
+	}
+    }
+    delete list;
+}
+
+/*!
+    Displays a simple message box about Qt. The message includes the
+    version number of Qt being used by the application.
+
+    This is useful for inclusion in the Help menu of an application.
+    See the examples/menu/menu.cpp example.
+
+    This function is a convenience slot for QMessageBox::aboutQt().
+*/
+void QApplication::aboutQt()
+{
+#ifndef QT_NO_MESSAGEBOX
+    QMessageBox::aboutQt( mainWidget() );
+#endif // QT_NO_MESSAGEBOX
+}
+
+
+/*!
+  \fn void QApplication::lastWindowClosed()
+
+  This signal is emitted when the user has closed the last
+  top level window.
+
+  The signal is very useful when your application has many top level
+  widgets but no main widget. You can then connect it to the quit()
+  slot.
+
+  For convenience, this signal is \e not emitted for transient top level
+  widgets such as popup menus and dialogs.
+
+  \sa mainWidget(), topLevelWidgets(), QWidget::isTopLevel(), QWidget::close()
+*/
+
+/*!
+  \fn void QApplication::aboutToQuit()
+
+  This signal is emitted when the application is about to quit the
+  main event loop, e.g. when the event loop level drops to zero.
+  This may happen either after a call to quit() from inside the
+  application or when the users shuts down the entire desktop session.
+
+  The signal is particularly useful if your application has to do some
+  last-second cleanup. Note that no user interaction is possible in
+  this state.
+
+  \sa quit()
+*/
+
+
+/*!
+  \fn void QApplication::guiThreadAwake()
+
+  This signal is emitted after the event loop returns from a function
+  that could block.
+
+  \sa wakeUpGuiThread()
+*/
+
+
+/*!
+  \fn bool QApplication::sendEvent( QObject *receiver, QEvent *event )
+
+  Sends event \a event directly to receiver \a receiver, using the
+  notify() function. Returns the value that was returned from the event
+  handler.
+
+    The event is \e not deleted when the event has been sent. The normal
+    approach is to create the event on the stack, e.g.
+    \code
+    QMouseEvent me( QEvent::MouseButtonPress, pos, 0, 0 );
+    QApplication::sendEvent( mainWindow, &me );
+    \endcode
+    If you create the event on the heap you must delete it.
+
+  \sa postEvent(), notify()
+*/
+
+/*!
+  Sends event \a e to \a receiver: \a {receiver}->event(\a e).
+  Returns the value that is returned from the receiver's event handler.
+
+  For certain types of events (e.g. mouse and key events),
+  the event will be propagated to the receiver's parent and so on up to
+  the top-level object if the receiver is not interested in the event
+  (i.e., it returns FALSE).
+
+  There are five different ways that events can be processed;
+  reimplementing this virtual function is just one of them. All five
+  approaches are listed below:
+  \list 1
+  \i Reimplementing this function. This is very powerful, providing
+  complete control; but only one subclass can be qApp.
+
+  \i Installing an event filter on qApp. Such an event filter is able
+  to process all events for all widgets, so it's just as powerful as
+  reimplementing notify(); furthermore, it's possible to have more
+  than one application-global event filter. Global event filters even
+  see mouse events for \link QWidget::isEnabled() disabled
+  widgets, \endlink and if \link setGlobalMouseTracking() global mouse
+  tracking \endlink is enabled, as well as mouse move events for all
+  widgets.
+
+  \i Reimplementing QObject::event() (as QWidget does). If you do
+  this you get Tab key presses, and you get to see the events before
+  any widget-specific event filters.
+
+  \i Installing an event filter on the object. Such an event filter
+  gets all the events except Tab and Shift-Tab key presses.
+
+  \i Reimplementing paintEvent(), mousePressEvent() and so
+  on. This is the commonest, easiest and least powerful way.
+  \endlist
+
+  \sa QObject::event(), installEventFilter()
+*/
+
+bool QApplication::notify( QObject *receiver, QEvent *e )
+{
+    // no events are delivered after ~QApplication() has started
+    if ( is_app_closing )
+	return FALSE;
+
+    if ( receiver == 0 ) {			// serious error
+#if defined(QT_CHECK_NULL)
+	qWarning( "QApplication::notify: Unexpected null receiver" );
+#endif
+	return FALSE;
+    }
+
+    if ( e->type() == QEvent::ChildRemoved && receiver->postedEvents && globalPostedEvents) {
+
+#ifdef QT_THREAD_SUPPORT
+	QMutexLocker locker( postevent_mutex );
+#endif // QT_THREAD_SUPPORT
+
+	// the QObject destructor calls QObject::removeChild, which calls
+	// QApplication::sendEvent() directly.  this can happen while the event
+	// loop is in the middle of posting events, and when we get here, we may
+	// not have any more posted events for this object.
+	if ( receiver->postedEvents ) {
+	    // if this is a child remove event and the child insert
+	    // hasn't been dispatched yet, kill that insert
+	    QPostEventList * l = receiver->postedEvents;
+	    QObject * c = ((QChildEvent*)e)->child();
+	    QPostEvent * pe;
+	    l->first();
+	    while( ( pe = l->current()) != 0 ) {
+		if ( pe->event && pe->receiver == receiver &&
+		     pe->event->type() == QEvent::ChildInserted &&
+		     ((QChildEvent*)pe->event)->child() == c ) {
+		    pe->event->posted = FALSE;
+		    delete pe->event;
+		    pe->event = 0;
+		    l->remove();
+		    continue;
+		}
+		l->next();
+	    }
+	}
+    }
+
+    bool res = FALSE;
+    if ( !receiver->isWidgetType() )
+	res = internalNotify( receiver, e );
+    else switch ( e->type() ) {
+#ifndef QT_NO_ACCEL
+    case QEvent::Accel:
+	{
+	    QKeyEvent* key = (QKeyEvent*) e;
+	    res = internalNotify( receiver, e );
+
+	    if ( !res && !key->isAccepted() )
+		res = qt_dispatchAccelEvent( (QWidget*)receiver, key );
+
+	    // next lines are for compatibility with Qt <= 3.0.x: old
+	    // QAccel was listening on toplevel widgets
+	    if ( !res && !key->isAccepted() && !((QWidget*)receiver)->isTopLevel() )
+		res = internalNotify( ((QWidget*)receiver)->topLevelWidget(), e );
+	}
+    break;
+#endif //QT_NO_ACCEL
+    case QEvent::KeyPress:
+    case QEvent::KeyRelease:
+    case QEvent::AccelOverride:
+	{
+	    QWidget* w = (QWidget*)receiver;
+	    QKeyEvent* key = (QKeyEvent*) e;
+#ifndef QT_NO_ACCEL
+	    if ( qt_tryComposeUnicode( w, key ) )
+		break;
+#endif
+	    bool def = key->isAccepted();
+	    while ( w ) {
+		if ( def )
+		    key->accept();
+		else
+		    key->ignore();
+		res = internalNotify( w, e );
+		if ( res || key->isAccepted() )
+		    break;
+		w = w->parentWidget( TRUE );
+	    }
+	}
+    break;
+    case QEvent::MouseButtonPress:
+	    if ( e->spontaneous() ) {
+		QWidget* fw = (QWidget*)receiver;
+		while ( fw->focusProxy() )
+		    fw = fw->focusProxy();
+		if ( fw->isEnabled() && fw->focusPolicy() & QWidget::ClickFocus ) {
+		    QFocusEvent::setReason( QFocusEvent::Mouse);
+		    fw->setFocus();
+		    QFocusEvent::resetReason();
+		}
+	    }
+	    // fall through intended
+    case QEvent::MouseButtonRelease:
+    case QEvent::MouseButtonDblClick:
+    case QEvent::MouseMove:
+	{
+	    QWidget* w = (QWidget*)receiver;
+	    QMouseEvent* mouse = (QMouseEvent*) e;
+	    QPoint relpos = mouse->pos();
+	    while ( w ) {
+		QMouseEvent me(mouse->type(), relpos, mouse->globalPos(), mouse->button(), mouse->state());
+		me.spont = mouse->spontaneous();
+		res = internalNotify( w, w == receiver ? mouse : &me );
+		e->spont = FALSE;
+		if (res || w->isTopLevel() || w->testWFlags(WNoMousePropagation))
+		    break;
+
+		relpos += w->pos();
+		w = w->parentWidget();
+	    }
+	    if ( res )
+		mouse->accept();
+	    else
+		mouse->ignore();
+	}
+    break;
+#ifndef QT_NO_WHEELEVENT
+    case QEvent::Wheel:
+	{
+	    if ( e->spontaneous() ) {
+		QWidget* fw = (QWidget*)receiver;
+		while ( fw->focusProxy() )
+		    fw = fw->focusProxy();
+		if ( fw->isEnabled() && (fw->focusPolicy() & QWidget::WheelFocus) == QWidget::WheelFocus ) {
+		    QFocusEvent::setReason( QFocusEvent::Mouse);
+		    fw->setFocus();
+		    QFocusEvent::resetReason();
+		}
+	    }
+
+	    QWidget* w = (QWidget*)receiver;
+	    QWheelEvent* wheel = (QWheelEvent*) e;
+	    QPoint relpos = wheel->pos();
+	    while ( w ) {
+		QWheelEvent we(relpos, wheel->globalPos(), wheel->delta(), wheel->state(), wheel->orientation());
+		we.spont = wheel->spontaneous();
+		res = internalNotify( w,  w == receiver ? wheel : &we );
+		e->spont = FALSE;
+		if (res || w->isTopLevel() || w->testWFlags(WNoMousePropagation))
+		    break;
+
+		relpos += w->pos();
+		w = w->parentWidget();
+	    }
+	    if ( res )
+		wheel->accept();
+	    else
+		wheel->ignore();
+	}
+    break;
+#endif
+    case QEvent::ContextMenu:
+	{
+	    QWidget* w = (QWidget*)receiver;
+	    QContextMenuEvent *context = (QContextMenuEvent*) e;
+	    QPoint relpos = context->pos();
+	    while ( w ) {
+		QContextMenuEvent ce(context->reason(), relpos, context->globalPos(), context->state());
+		ce.spont = e->spontaneous();
+		res = internalNotify( w,  w == receiver ? context : &ce );
+		e->spont = FALSE;
+
+		if (res || w->isTopLevel() || w->testWFlags(WNoMousePropagation))
+		    break;
+
+		relpos += w->pos();
+		w = w->parentWidget();
+	    }
+	    if ( res )
+		context->accept();
+	    else
+		context->ignore();
+	}
+    break;
+#if defined (QT_TABLET_SUPPORT)
+    case QEvent::TabletMove:
+    case QEvent::TabletPress:
+    case QEvent::TabletRelease:
+	{
+	    QWidget *w = (QWidget*)receiver;
+	    QTabletEvent *tablet = (QTabletEvent*)e;
+	    QPoint relpos = tablet->pos();
+	    while ( w ) {
+		QTabletEvent te(tablet->pos(), tablet->globalPos(), tablet->device(),
+				tablet->pressure(), tablet->xTilt(), tablet->yTilt(),
+				tablet->uniqueId());
+		te.spont = e->spontaneous();
+		res = internalNotify( w, w == receiver ? tablet : &te );
+		e->spont = FALSE;
+		if (res || w->isTopLevel() || w->testWFlags(WNoMousePropagation))
+		    break;
+
+		relpos += w->pos();
+		w = w->parentWidget();
+	    }
+	    if ( res )
+		tablet->accept();
+	    else
+		tablet->ignore();
+	    chokeMouse = tablet->isAccepted();
+	}
+    break;
+#endif
+    default:
+	res = internalNotify( receiver, e );
+	break;
+    }
+
+    return res;
+}
+
+/*!\reimp
+
+*/
+bool QApplication::event( QEvent *e )
+{
+    if(e->type() == QEvent::Close) {
+	QCloseEvent *ce = (QCloseEvent*)e;
+	ce->accept();
+	closeAllWindows();
+
+	QWidgetList *list = topLevelWidgets();
+	for(QWidget *w = list->first(); w; w = list->next()) {
+	    if ( !w->isHidden() && !w->isDesktop() && !w->isPopup() &&
+		 (!w->isDialog() || !w->parentWidget())) {
+		ce->ignore();
+		break;
+	    }
+	}
+	if(ce->isAccepted())
+	    return TRUE;
+    } else if (e->type() == QEvent::Quit) {
+	quit();
+	return TRUE;
+    }
+    return QObject::event(e);
+}
+
+/*!\internal
+
+  Helper function called by notify()
+ */
+bool QApplication::internalNotify( QObject *receiver, QEvent * e)
+{
+    if ( eventFilters ) {
+	QObjectListIt it( *eventFilters );
+	register QObject *obj;
+	while ( (obj=it.current()) != 0 ) {	// send to all filters
+	    ++it;				//   until one returns TRUE
+	    if ( obj->eventFilter(receiver,e) )
+		return TRUE;
+	}
+    }
+
+    bool consumed = FALSE;
+    bool handled = FALSE;
+    if ( receiver->isWidgetType() ) {
+	QWidget *widget = (QWidget*)receiver;
+
+	// toggle HasMouse widget state on enter and leave
+	if ( e->type() == QEvent::Enter || e->type() == QEvent::DragEnter )
+	    widget->setWState( WState_HasMouse );
+	else if ( e->type() == QEvent::Leave || e->type() == QEvent::DragLeave )
+	    widget->clearWState( WState_HasMouse );
+
+	// throw away any mouse-tracking-only mouse events
+	if ( e->type() == QEvent::MouseMove &&
+	     (((QMouseEvent*)e)->state()&QMouseEvent::MouseButtonMask) == 0 &&
+	     !widget->hasMouseTracking() ) {
+	    handled = TRUE;
+	    consumed = TRUE;
+	} else if ( !widget->isEnabled() ) { // throw away mouse events to disabled widgets
+	    switch(e->type()) {
+	    case QEvent::MouseButtonPress:
+	    case QEvent::MouseButtonRelease:
+	    case QEvent::MouseButtonDblClick:
+	    case QEvent::MouseMove:
+		( (QMouseEvent*) e)->ignore();
+		handled = TRUE;
+		consumed = TRUE;
+		break;
+#ifndef QT_NO_DRAGANDDROP
+	    case QEvent::DragEnter:
+	    case QEvent::DragMove:
+		( (QDragMoveEvent*) e)->ignore();
+		handled = TRUE;
+		break;
+
+	    case QEvent::DragLeave:
+	    case QEvent::DragResponse:
+		handled = TRUE;
+		break;
+
+	    case QEvent::Drop:
+		( (QDropEvent*) e)->ignore();
+		handled = TRUE;
+		break;
+#endif
+#ifndef QT_NO_WHEELEVENT
+	    case QEvent::Wheel:
+		( (QWheelEvent*) e)->ignore();
+		handled = TRUE;
+		break;
+#endif
+	    case QEvent::ContextMenu:
+		( (QContextMenuEvent*) e)->ignore();
+		handled = TRUE;
+		break;
+	    default:
+		break;
+	    }
+	}
+
+    }
+
+    if (!handled)
+	consumed = receiver->event( e );
+    e->spont = FALSE;
+    return consumed;
+}
+
+/*!
+  Returns TRUE if an application object has not been created yet;
+  otherwise returns FALSE.
+
+  \sa closingDown()
+*/
+
+bool QApplication::startingUp()
+{
+    return !is_app_running;
+}
+
+/*!
+  Returns TRUE if the application objects are being destroyed;
+  otherwise returns FALSE.
+
+  \sa startingUp()
+*/
+
+bool QApplication::closingDown()
+{
+    return is_app_closing;
+}
+
+
+/*!
+    Processes pending events, for 3 seconds or until there are no more
+    events to process, whichever is shorter.
+
+    You can call this function occasionally when your program is busy
+    performing a long operation (e.g. copying a file).
+
+    \sa exec(), QTimer, QEventLoop::processEvents()
+*/
+
+void QApplication::processEvents()
+{
+    processEvents( 3000 );
+}
+
+/*!
+    \overload
+
+    Processes pending events for \a maxtime milliseconds or until
+    there are no more events to process, whichever is shorter.
+
+    You can call this function occasionally when you program is busy
+    doing a long operation (e.g. copying a file).
+
+    \sa exec(), QTimer, QEventLoop::processEvents()
+*/
+void QApplication::processEvents( int maxtime )
+{
+    eventLoop()->processEvents( QEventLoop::AllEvents, maxtime );
+}
+
+/*! \obsolete
+  Waits for an event to occur, processes it, then returns.
+
+  This function is useful for adapting Qt to situations where the
+  event processing must be grafted onto existing program loops.
+
+  Using this function in new applications may be an indication of design
+  problems.
+
+  \sa processEvents(), exec(), QTimer
+*/
+
+void QApplication::processOneEvent()
+{
+    eventLoop()->processEvents( QEventLoop::AllEvents |
+				QEventLoop::WaitForMore );
+}
+
+/*****************************************************************************
+  Main event loop wrappers
+ *****************************************************************************/
+
+/*!
+    Returns the application event loop. This function will return
+    zero if called during and after destroying QApplication.
+
+    To create your own instance of QEventLoop or QEventLoop subclass create
+    it before you create the QApplication object.
+
+    \sa QEventLoop
+*/
+QEventLoop *QApplication::eventLoop()
+{
+    if ( !eventloop && !is_app_closing )
+	(void) new QEventLoop( qApp, "default event loop" );
+    return eventloop;
+}
+
+
+/*!
+    Enters the main event loop and waits until exit() is called or the
+    main widget is destroyed, and returns the value that was set to
+    exit() (which is 0 if exit() is called via quit()).
+
+    It is necessary to call this function to start event handling. The
+    main event loop receives events from the window system and
+    dispatches these to the application widgets.
+
+    Generally speaking, no user interaction can take place before
+    calling exec(). As a special case, modal widgets like QMessageBox
+    can be used before calling exec(), because modal widgets call
+    exec() to start a local event loop.
+
+    To make your application perform idle processing, i.e. executing a
+    special function whenever there are no pending events, use a
+    QTimer with 0 timeout. More advanced idle processing schemes can
+    be achieved using processEvents().
+
+    \sa quit(), exit(), processEvents(), setMainWidget()
+*/
+int QApplication::exec()
+{
+    return eventLoop()->exec();
+}
+
+/*!
+  Tells the application to exit with a return code.
+
+  After this function has been called, the application leaves the main
+  event loop and returns from the call to exec(). The exec() function
+  returns \a retcode.
+
+  By convention, a \a retcode of 0 means success, and any non-zero
+  value indicates an error.
+
+  Note that unlike the C library function of the same name, this
+  function \e does return to the caller -- it is event processing that
+  stops.
+
+  \sa quit(), exec()
+*/
+void QApplication::exit( int retcode )
+{
+    qApp->eventLoop()->exit( retcode );
+}
+
+/*!
+    \obsolete
+
+    This function enters the main event loop (recursively). Do not call
+    it unless you really know what you are doing.
+
+    Use QApplication::eventLoop()->enterLoop() instead.
+
+*/
+int QApplication::enter_loop()
+{
+    return eventLoop()->enterLoop();
+}
+
+/*!
+    \obsolete
+
+    This function exits from a recursive call to the main event loop.
+    Do not call it unless you are an expert.
+
+    Use QApplication::eventLoop()->exitLoop() instead.
+
+*/
+void QApplication::exit_loop()
+{
+    eventLoop()->exitLoop();
+}
+
+/*!
+    \obsolete
+
+    Returns the current loop level.
+
+    Use QApplication::eventLoop()->loopLevel() instead.
+
+*/
+int QApplication::loopLevel() const
+{
+    return eventLoop()->loopLevel();
+}
+
+/*!
+
+  Wakes up the GUI thread.
+
+  \sa guiThreadAwake() \link threads.html Thread Support in Qt\endlink
+*/
+void QApplication::wakeUpGuiThread()
+{
+    eventLoop()->wakeUp();
+}
+
+/*!
+    This function returns TRUE if there are pending events; otherwise
+    returns FALSE. Pending events can be either from the window system
+    or posted events using QApplication::postEvent().
+*/
+bool QApplication::hasPendingEvents()
+{
+    return eventLoop()->hasPendingEvents();
+}
+
+#if !defined(Q_WS_X11)
+
+// The doc and X implementation of these functions is in qapplication_x11.cpp
+
+void QApplication::flushX()	{}		// do nothing
+
+void QApplication::syncX()	{}		// do nothing
+
+#endif
+
+/*!
+  \fn void QApplication::setWinStyleHighlightColor( const QColor & )
+  \obsolete
+
+  Sets the color used to mark selections in windows style for all widgets
+  in the application. Will repaint all widgets if the color is changed.
+
+  The default color is \c darkBlue.
+  \sa winStyleHighlightColor()
+*/
+
+/*!
+  \fn const QColor& QApplication::winStyleHighlightColor()
+  \obsolete
+
+  Returns the color used to mark selections in windows style.
+
+  \sa setWinStyleHighlightColor()
+*/
+
+/*!
+  Returns the version of the Windows operating system that is running:
+
+  \list
+  \i Qt::WV_95 - Windows 95
+  \i Qt::WV_98 - Windows 98
+  \i Qt::WV_Me - Windows Me
+  \i Qt::WV_NT - Windows NT 4.x
+  \i Qt::WV_2000 - Windows 2000 (NT5)
+  \i Qt::WV_XP - Windows XP
+  \i Qt::WV_2003 - Windows Server 2003 family
+  \i Qt::WV_CE - Windows CE
+  \i Qt::WV_CENET - Windows CE.NET
+  \endlist
+
+  Note that this function is implemented for the Windows version
+  of Qt only.
+*/
+
+#if defined(Q_OS_CYGWIN)
+Qt::WindowsVersion QApplication::winVersion()
+{
+    return qt_winver;
+}
+#endif
+
+#ifndef QT_NO_TRANSLATION
+
+bool qt_detectRTLLanguage()
+{
+    return QApplication::tr( "QT_LAYOUT_DIRECTION",
+	    "Translate this string to the string 'LTR' in left-to-right"
+	    " languages or to 'RTL' in right-to-left languages (such as Hebrew"
+	    " and Arabic) to get proper widget layout." ) == "RTL";
+}
+
+/*!
+  Adds the message file \a mf to the list of message files to be used
+  for translations.
+
+  Multiple message files can be installed. Translations are searched
+  for in the last installed message file, then the one from last, and
+  so on, back to the first installed message file. The search stops as
+  soon as a matching translation is found.
+
+  \sa removeTranslator() translate() QTranslator::load()
+*/
+
+void QApplication::installTranslator( QTranslator * mf )
+{
+    if ( !mf )
+	return;
+    if ( !translators )
+	translators = new QValueList<QTranslator*>;
+
+    translators->prepend( mf );
+
+#ifndef QT_NO_TRANSLATION_BUILDER
+    if ( mf->isEmpty() )
+	return;
+#endif
+
+    // hook to set the layout direction of dialogs
+    setReverseLayout( qt_detectRTLLanguage() );
+
+    QWidgetList *list = topLevelWidgets();
+    QWidgetListIt it( *list );
+    QWidget *w;
+    while ( ( w=it.current() ) != 0 ) {
+	++it;
+	if (!w->isDesktop())
+	    postEvent( w, new QEvent( QEvent::LanguageChange ) );
+    }
+    delete list;
+}
+
+/*!
+  Removes the message file \a mf from the list of message files used by
+  this application. (It does not delete the message file from the file
+  system.)
+
+  \sa installTranslator() translate(), QObject::tr()
+*/
+
+void QApplication::removeTranslator( QTranslator * mf )
+{
+    if ( !translators || !mf )
+	return;
+
+    if ( translators->remove( mf ) && ! qApp->closingDown() ) {
+	setReverseLayout( qt_detectRTLLanguage() );
+
+	QWidgetList *list = topLevelWidgets();
+	QWidgetListIt it( *list );
+	QWidget *w;
+	while ( ( w=it.current() ) != 0 ) {
+	    ++it;
+	    postEvent( w, new QEvent( QEvent::LanguageChange ) );
+	}
+	delete list;
+    }
+}
+
+#ifndef QT_NO_TEXTCODEC
+/*! \obsolete
+  This is the same as QTextCodec::setCodecForTr().
+*/
+void QApplication::setDefaultCodec( QTextCodec* codec )
+{
+    QTextCodec::setCodecForTr( codec );
+}
+
+/*! \obsolete
+  Returns QTextCodec::codecForTr().
+*/
+QTextCodec* QApplication::defaultCodec() const
+{
+    return QTextCodec::codecForTr();
+}
+#endif //QT_NO_TEXTCODEC
+
+/*! \enum QApplication::Encoding
+
+  This enum type defines the 8-bit encoding of character string
+  arguments to translate():
+
+  \value DefaultCodec - the encoding specified by
+  QTextCodec::codecForTr() (Latin-1 if none has been set)
+  \value UnicodeUTF8 - UTF-8
+
+  \sa QObject::tr(), QObject::trUtf8(), QString::fromUtf8()
+*/
+
+/*! \reentrant
+  Returns the translation text for \a sourceText, by querying the
+  installed messages files. The message files are searched from the most
+  recently installed message file back to the first installed message
+  file.
+
+  QObject::tr() and QObject::trUtf8() provide this functionality more
+  conveniently.
+
+  \a context is typically a class name (e.g., "MyDialog") and
+  \a sourceText is either English text or a short identifying text, if
+  the output text will be very long (as for help texts).
+
+  \a comment is a disambiguating comment, for when the same \a
+  sourceText is used in different roles within the same context. By
+  default, it is null. \a encoding indicates the 8-bit encoding of
+  character stings
+
+  See the \l QTranslator documentation for more information about
+  contexts and comments.
+
+  If none of the message files contain a translation for \a
+  sourceText in \a context, this function returns a QString
+  equivalent of \a sourceText. The encoding of \a sourceText is
+  specified by \e encoding; it defaults to \c DefaultCodec.
+
+  This function is not virtual. You can use alternative translation
+  techniques by subclassing \l QTranslator.
+
+  \warning This method is reentrant only if all translators are
+  installed \e before calling this method.  Installing or removing
+  translators while performing translations is not supported.  Doing
+  so will most likely result in crashes or other undesirable behavior.
+
+  \sa QObject::tr() installTranslator() defaultCodec()
+*/
+
+QString QApplication::translate( const char * context, const char * sourceText,
+				 const char * comment, Encoding encoding ) const
+{
+    if ( !sourceText )
+	return QString::null;
+
+    if ( translators ) {
+	QValueList<QTranslator*>::iterator it;
+	QTranslator * mf;
+	QString result;
+	for ( it = translators->begin(); it != translators->end(); ++it ) {
+	    mf = *it;
+	    result = mf->findMessage( context, sourceText, comment ).translation();
+	    if ( !result.isNull() )
+		return result;
+	}
+    }
+#ifndef QT_NO_TEXTCODEC
+    if ( encoding == UnicodeUTF8 )
+	return QString::fromUtf8( sourceText );
+    else if ( QTextCodec::codecForTr() != 0 )
+	return QTextCodec::codecForTr()->toUnicode( sourceText );
+    else
+#endif
+	return QString::fromLatin1( sourceText );
+}
+
+#endif
+
+/*****************************************************************************
+  QApplication management of posted events
+ *****************************************************************************/
+
+//see also notify(), which does the removal of ChildInserted when ChildRemoved.
+
+/*!
+  Adds the event \a event with the object \a receiver as the receiver of the
+  event, to an event queue and returns immediately.
+
+  The event must be allocated on the heap since the post event queue
+  will take ownership of the event and delete it once it has been posted.
+
+  When control returns to the main event loop, all events that are
+  stored in the queue will be sent using the notify() function.
+
+  \threadsafe
+
+  \sa sendEvent(), notify()
+*/
+
+void QApplication::postEvent( QObject *receiver, QEvent *event )
+{
+    if ( receiver == 0 ) {
+#if defined(QT_CHECK_NULL)
+	qWarning( "QApplication::postEvent: Unexpected null receiver" );
+#endif
+	delete event;
+	return;
+    }
+
+#ifdef QT_THREAD_SUPPORT
+    QMutexLocker locker( postevent_mutex );
+#endif // QT_THREAD_SUPPORT
+
+    if ( !globalPostedEvents ) {			// create list
+	globalPostedEvents = new QPostEventList;
+	Q_CHECK_PTR( globalPostedEvents );
+	globalPostedEvents->setAutoDelete( TRUE );
+	qapp_cleanup_events.set( &globalPostedEvents );
+    }
+
+    if ( !receiver->postedEvents )
+	receiver->postedEvents = new QPostEventList;
+    QPostEventList * l = receiver->postedEvents;
+
+    // if this is one of the compressible events, do compression
+    if ( event->type() == QEvent::Paint ||
+	 event->type() == QEvent::LayoutHint ||
+	 event->type() == QEvent::Resize ||
+	 event->type() == QEvent::Move ||
+	 event->type() == QEvent::LanguageChange ) {
+	l->first();
+	QPostEvent * cur = 0;
+	for ( ;; ) {
+	    while ( (cur=l->current()) != 0 &&
+		    ( cur->receiver != receiver ||
+		      cur->event == 0 ||
+		      cur->event->type() != event->type() ) )
+		l->next();
+	    if ( l->current() != 0 ) {
+		if ( cur->event->type() == QEvent::Paint ) {
+		    QPaintEvent * p = (QPaintEvent*)(cur->event);
+		    if ( p->erase != ((QPaintEvent*)event)->erase ) {
+			l->next();
+			continue;
+		    }
+		    p->reg = p->reg.unite( ((QPaintEvent *)event)->reg );
+		    p->rec = p->rec.unite( ((QPaintEvent *)event)->rec );
+		    delete event;
+		    return;
+		} else if ( cur->event->type() == QEvent::LayoutHint ) {
+		    delete event;
+		    return;
+		} else if ( cur->event->type() == QEvent::Resize ) {
+		    ((QResizeEvent *)(cur->event))->s = ((QResizeEvent *)event)->s;
+		    delete event;
+		    return;
+		} else if ( cur->event->type() == QEvent::Move ) {
+		    ((QMoveEvent *)(cur->event))->p = ((QMoveEvent *)event)->p;
+		    delete event;
+		    return;
+		} else if ( cur->event->type() == QEvent::LanguageChange ) {
+		    delete event;
+		    return;
+		}
+	    }
+	    break;
+	};
+    }
+
+    // if no compression could be done, just append something
+    event->posted = TRUE;
+    QPostEvent * pe = new QPostEvent( receiver, event );
+    l->append( pe );
+    globalPostedEvents->append( pe );
+
+    if (eventloop)
+	eventloop->wakeUp();
+}
+
+
+/*! \overload
+
+    Dispatches all posted events, i.e. empties the event queue.
+*/
+void QApplication::sendPostedEvents()
+{
+    sendPostedEvents( 0, 0 );
+}
+
+
+
+/*!
+  Immediately dispatches all events which have been previously queued
+  with QApplication::postEvent() and which are for the object \a receiver
+  and have the event type \a event_type.
+
+  Note that events from the window system are \e not dispatched by this
+  function, but by processEvents().
+
+  If \a receiver is null, the events of \a event_type are sent for all
+  objects. If \a event_type is 0, all the events are sent for \a receiver.
+*/
+
+void QApplication::sendPostedEvents( QObject *receiver, int event_type )
+{
+    // Make sure the object hierarchy is stable before processing events
+    // to avoid endless loops
+    if ( receiver == 0 && event_type == 0 )
+	sendPostedEvents( 0, QEvent::ChildInserted );
+
+    if ( !globalPostedEvents || ( receiver && !receiver->postedEvents ) )
+	return;
+
+#ifdef QT_THREAD_SUPPORT
+    QMutexLocker locker( postevent_mutex );
+#endif
+
+    bool sent = TRUE;
+    while ( sent ) {
+	sent = FALSE;
+
+	if ( !globalPostedEvents || ( receiver && !receiver->postedEvents ) )
+	    return;
+
+	// if we have a receiver, use the local list. Otherwise, use the
+	// global list
+	QPostEventList * l = receiver ? receiver->postedEvents : globalPostedEvents;
+
+	// okay. here is the tricky loop. be careful about optimizing
+	// this, it looks the way it does for good reasons.
+	QPostEventListIt it( *l );
+	QPostEvent *pe;
+	while ( (pe=it.current()) != 0 ) {
+	    ++it;
+	    if ( pe->event // hasn't been sent yet
+		 && ( receiver == 0 // we send to all receivers
+		      || receiver == pe->receiver ) // we send to THAT receiver
+		 && ( event_type == 0 // we send all types
+		      || event_type == pe->event->type() ) ) { // we send THAT type
+		// first, we diddle the event so that we can deliver
+		// it, and that noone will try to touch it later.
+		pe->event->posted = FALSE;
+		QEvent * e = pe->event;
+		QObject * r = pe->receiver;
+		pe->event = 0;
+
+		// next, update the data structure so that we're ready
+		// for the next event.
+
+		// look for the local list, and take whatever we're
+		// delivering out of it. r->postedEvents maybe *l
+		if ( r->postedEvents ) {
+		    r->postedEvents->removeRef( pe );
+		    // if possible, get rid of that list. this is not
+		    // ideal - we will create and delete a list for
+		    // each update() call. it would be better if we'd
+		    // leave the list empty here, and delete it
+		    // somewhere else if it isn't being used.
+		    if ( r->postedEvents->isEmpty() ) {
+			delete r->postedEvents;
+			r->postedEvents = 0;
+		    }
+		}
+
+#ifdef QT_THREAD_SUPPORT
+		if ( locker.mutex() ) locker.mutex()->unlock();
+#endif // QT_THREAD_SUPPORT
+		// after all that work, it's time to deliver the event.
+		if ( e->type() == QEvent::Paint && r->isWidgetType() ) {
+		    QWidget * w = (QWidget*)r;
+		    QPaintEvent * p = (QPaintEvent*)e;
+		    if ( w->isVisible() )
+			w->repaint( p->reg, p->erase );
+		} else {
+		    sent = TRUE;
+		    QApplication::sendEvent( r, e );
+		}
+#ifdef QT_THREAD_SUPPORT
+		if ( locker.mutex() ) locker.mutex()->lock();
+#endif // QT_THREAD_SUPPORT
+
+		delete e;
+		// careful when adding anything below this point - the
+		// sendEvent() call might invalidate any invariants this
+		// function depends on.
+	    }
+	}
+
+	// clear the global list, i.e. remove everything that was
+	// delivered.
+	if ( l == globalPostedEvents ) {
+	    globalPostedEvents->first();
+	    while( (pe=globalPostedEvents->current()) != 0 ) {
+		if ( pe->event )
+		    globalPostedEvents->next();
+		else
+		    globalPostedEvents->remove();
+	    }
+	}
+    }
+}
+
+/*!
+  Removes all events posted using postEvent() for \a receiver.
+
+  The events are \e not dispatched, instead they are removed from the
+  queue. You should never need to call this function. If you do call it,
+  be aware that killing events may cause \a receiver to break one or
+  more invariants.
+
+  \threadsafe
+*/
+
+void QApplication::removePostedEvents( QObject *receiver )
+{
+    if ( !receiver )
+	return;
+
+#ifdef QT_THREAD_SUPPORT
+    QMutexLocker locker( postevent_mutex );
+#endif // QT_THREAD_SUPPORT
+
+    // the QObject destructor calls this function directly.  this can
+    // happen while the event loop is in the middle of posting events,
+    // and when we get here, we may not have any more posted events
+    // for this object.
+    if ( !receiver->postedEvents )
+	return;
+
+    // iterate over the object-specifc list and delete the events.
+    // leave the QPostEvent objects; they'll be deleted by
+    // sendPostedEvents().
+    QPostEventList * l = receiver->postedEvents;
+    receiver->postedEvents = 0;
+    l->first();
+    QPostEvent * pe;
+    while( (pe=l->current()) != 0 ) {
+	if ( pe->event ) {
+	    pe->event->posted = FALSE;
+	    delete pe->event;
+	    pe->event = 0;
+	}
+	l->remove();
+    }
+    delete l;
+}
+
+
+/*!
+  Removes \a event from the queue of posted events, and emits a
+  warning message if appropriate.
+
+  \warning This function can be \e really slow. Avoid using it, if
+  possible.
+
+  \threadsafe
+*/
+
+void QApplication::removePostedEvent( QEvent *  event )
+{
+    if ( !event || !event->posted )
+	return;
+
+    if ( !globalPostedEvents ) {
+#if defined(QT_DEBUG)
+	qDebug( "QApplication::removePostedEvent: %p %d is posted: impossible",
+		(void*)event, event->type() );
+	return;
+#endif
+    }
+
+#ifdef QT_THREAD_SUPPORT
+    QMutexLocker locker( postevent_mutex );
+#endif // QT_THREAD_SUPPORT
+
+    QPostEventListIt it( *globalPostedEvents );
+    QPostEvent * pe;
+    while( (pe = it.current()) != 0 ) {
+	++it;
+	if ( pe->event == event ) {
+#if defined(QT_DEBUG)
+	    const char *n;
+	    switch ( event->type() ) {
+	    case QEvent::Timer:
+		n = "Timer";
+		break;
+	    case QEvent::MouseButtonPress:
+		n = "MouseButtonPress";
+		break;
+	    case QEvent::MouseButtonRelease:
+		n = "MouseButtonRelease";
+		break;
+	    case QEvent::MouseButtonDblClick:
+		n = "MouseButtonDblClick";
+		break;
+	    case QEvent::MouseMove:
+		n = "MouseMove";
+		break;
+#ifndef QT_NO_WHEELEVENT
+	    case QEvent::Wheel:
+		n = "Wheel";
+		break;
+#endif
+	    case QEvent::KeyPress:
+		n = "KeyPress";
+		break;
+	    case QEvent::KeyRelease:
+		n = "KeyRelease";
+		break;
+	    case QEvent::FocusIn:
+		n = "FocusIn";
+		break;
+	    case QEvent::FocusOut:
+		n = "FocusOut";
+		break;
+	    case QEvent::Enter:
+		n = "Enter";
+		break;
+	    case QEvent::Leave:
+		n = "Leave";
+		break;
+	    case QEvent::Paint:
+		n = "Paint";
+		break;
+	    case QEvent::Move:
+		n = "Move";
+		break;
+	    case QEvent::Resize:
+		n = "Resize";
+		break;
+	    case QEvent::Create:
+		n = "Create";
+		break;
+	    case QEvent::Destroy:
+		n = "Destroy";
+		break;
+	    case QEvent::Close:
+		n = "Close";
+		break;
+	    case QEvent::Quit:
+		n = "Quit";
+		break;
+	    default:
+		n = "<other>";
+		break;
+	    }
+	    qWarning("QEvent: Warning: %s event deleted while posted to %s %s",
+		     n,
+		     pe->receiver ? pe->receiver->className() : "null",
+		     pe->receiver ? pe->receiver->name() : "object" );
+	    // note the beautiful uglehack if !pe->receiver :)
+#endif
+	    event->posted = FALSE;
+	    delete pe->event;
+	    pe->event = 0;
+	    return;
+	}
+    }
+}
+
+/*!\internal
+
+  Sets the active window in reaction to a system event. Call this
+  from the platform specific event handlers.
+
+  It sets the activeWindow() and focusWidget() attributes and sends
+  proper WindowActivate/WindowDeactivate and FocusIn/FocusOut events
+  to all appropriate widgets.
+
+  \sa activeWindow()
+ */
+void QApplication::setActiveWindow( QWidget* act )
+{
+    QWidget* window = act?act->topLevelWidget():0;
+
+    if ( active_window == window )
+	return;
+
+    // first the activation/deactivation events
+    if ( active_window ) {
+	QWidgetList deacts;
+#ifndef QT_NO_STYLE
+	if ( style().styleHint(QStyle::SH_Widget_ShareActivation, active_window ) ) {
+	    QWidgetList *list = topLevelWidgets();
+	    if ( list ) {
+		for ( QWidget *w = list->first(); w; w = list->next() ) {
+		    if ( w->isVisible() && w->isActiveWindow() )
+			deacts.append(w);
+		}
+		delete list;
+	    }
+	} else
+#endif
+	    deacts.append(active_window);
+	active_window = 0;
+	QEvent e( QEvent::WindowDeactivate );
+	for(QWidget *w = deacts.first(); w; w = deacts.next())
+	    QApplication::sendSpontaneousEvent( w, &e );
+    }
+
+    active_window = window;
+    if ( active_window ) {
+	QEvent e( QEvent::WindowActivate );
+	QWidgetList acts;
+#ifndef QT_NO_STYLE
+	if ( style().styleHint(QStyle::SH_Widget_ShareActivation, active_window ) ) {
+	    QWidgetList *list = topLevelWidgets();
+	    if ( list ) {
+		for ( QWidget *w = list->first(); w; w = list->next() ) {
+		    if ( w->isVisible() && w->isActiveWindow() )
+			acts.append(w);
+		}
+		delete list;
+	    }
+	} else
+#endif
+	    acts.append(active_window);
+	for(QWidget *w = acts.first(); w; w = acts.next())
+	    QApplication::sendSpontaneousEvent( w, &e );
+    }
+
+    // then focus events
+    QFocusEvent::setReason( QFocusEvent::ActiveWindow );
+    if ( !active_window && focus_widget ) {
+	QFocusEvent out( QEvent::FocusOut );
+	QWidget *tmp = focus_widget;
+	focus_widget = 0;
+#ifdef Q_WS_WIN
+	QInputContext::accept( tmp );
+#endif
+	QApplication::sendSpontaneousEvent( tmp, &out );
+    } else if ( active_window ) {
+	QWidget *w = active_window->focusWidget();
+	if ( w && w->focusPolicy() != QWidget::NoFocus )
+	    w->setFocus();
+	else
+	    active_window->focusNextPrevChild( TRUE );
+    }
+    QFocusEvent::resetReason();
+}
+
+
+/*!\internal
+
+  Creates the proper Enter/Leave event when widget \a enter is entered
+  and widget \a leave is left.
+ */
+Q_EXPORT void qt_dispatchEnterLeave( QWidget* enter, QWidget* leave ) {
+#if 0
+    if ( leave ) {
+	QEvent e( QEvent::Leave );
+	QApplication::sendEvent( leave, & e );
+    }
+    if ( enter ) {
+	QEvent e( QEvent::Enter );
+	QApplication::sendEvent( enter, & e );
+    }
+    return;
+#endif
+
+    QWidget* w ;
+    if ( !enter && !leave )
+	return;
+    QWidgetList leaveList;
+    QWidgetList enterList;
+
+    bool sameWindow = leave && enter && leave->topLevelWidget() == enter->topLevelWidget();
+    if ( leave && !sameWindow ) {
+	w = leave;
+	do {
+	    leaveList.append( w );
+	} while ( (w = w->parentWidget( TRUE ) ) );
+    }
+    if ( enter && !sameWindow ) {
+	w = enter;
+	do {
+	    enterList.prepend( w );
+	} while ( (w = w->parentWidget(TRUE) ) );
+    }
+    if ( sameWindow ) {
+	int enterDepth = 0;
+	int leaveDepth = 0;
+	w = enter;
+	while ( ( w = w->parentWidget( TRUE ) ) )
+	    enterDepth++;
+	w = leave;
+	while ( ( w = w->parentWidget( TRUE ) ) )
+	    leaveDepth++;
+	QWidget* wenter = enter;
+	QWidget* wleave = leave;
+	while ( enterDepth > leaveDepth ) {
+	    wenter = wenter->parentWidget();
+	    enterDepth--;
+	}
+	while ( leaveDepth > enterDepth ) {
+	    wleave = wleave->parentWidget();
+	    leaveDepth--;
+	}
+	while ( !wenter->isTopLevel() && wenter != wleave ) {
+	    wenter = wenter->parentWidget();
+	    wleave = wleave->parentWidget();
+	}
+
+	w = leave;
+	while ( w != wleave ) {
+	    leaveList.append( w );
+	    w = w->parentWidget();
+	}
+	w = enter;
+	while ( w != wenter ) {
+	    enterList.prepend( w );
+	    w = w->parentWidget();
+	}
+    }
+
+    QEvent leaveEvent( QEvent::Leave );
+    for ( w = leaveList.first(); w; w = leaveList.next() ) {
+	if ( !qApp->activeModalWidget() || qt_tryModalHelper( w, 0 ))
+	    QApplication::sendEvent( w, &leaveEvent );
+    }
+    QEvent enterEvent( QEvent::Enter );
+    for ( w = enterList.first(); w; w = enterList.next() ) {
+	if ( !qApp->activeModalWidget() || qt_tryModalHelper( w, 0 ))
+	    QApplication::sendEvent( w, &enterEvent );
+    }
+}
+
+
+#ifdef Q_WS_MACX
+extern QWidget *qt_tryModalHelperMac( QWidget * top ); //qapplication_mac.cpp
+#endif
+
+
+/*!\internal
+
+  Called from qapplication_<platform>.cpp, returns TRUE
+  if the widget should accept the event.
+ */
+Q_EXPORT bool qt_tryModalHelper( QWidget *widget, QWidget **rettop ) {
+    QWidget *modal=0, *top=QApplication::activeModalWidget();
+    if ( rettop ) *rettop = top;
+
+    if ( qApp->activePopupWidget() )
+	return TRUE;
+
+#ifdef Q_WS_MACX
+    top = qt_tryModalHelperMac( top );
+    if ( rettop ) *rettop = top;
+#endif
+
+    QWidget* groupLeader = widget;
+    widget = widget->topLevelWidget();
+
+    if ( widget->testWFlags(Qt::WShowModal) )	// widget is modal
+	modal = widget;
+    if ( !top || modal == top )			// don't block event
+	return TRUE;
+
+    QWidget * p = widget->parentWidget(); // Check if the active modal widget is a parent of our widget
+    while ( p ) {
+	if ( p == top )
+	    return TRUE;
+	p = p->parentWidget();
+    }
+
+    while ( groupLeader && !groupLeader->testWFlags( Qt::WGroupLeader ) )
+	groupLeader = groupLeader->parentWidget();
+
+    if ( groupLeader ) {
+	// Does groupLeader have a child in qt_modal_stack?
+	bool unrelated = TRUE;
+	modal = qt_modal_stack->first();
+	while (modal && unrelated) {
+	    QWidget* p = modal->parentWidget();
+	    while ( p && p != groupLeader && !p->testWFlags( Qt::WGroupLeader) ) {
+		p = p->parentWidget();
+	    }
+	    modal = qt_modal_stack->next();
+	    if ( p == groupLeader ) unrelated = FALSE;
+	}
+
+	if ( unrelated )
+	    return TRUE;		// don't block event
+    }
+    return FALSE;
+}
+
+
+/*!
+  Returns the desktop widget (also called the root window).
+
+  The desktop widget is useful for obtaining the size of the screen.
+  It may also be possible to draw on the desktop. We recommend against
+  assuming that it's possible to draw on the desktop, since this does
+  not work on all operating systems.
+
+  \code
+    QDesktopWidget *d = QApplication::desktop();
+    int w = d->width();	    // returns desktop width
+    int h = d->height();    // returns desktop height
+  \endcode
+*/
+
+QDesktopWidget *QApplication::desktop()
+{
+    if ( !qt_desktopWidget || // not created yet
+	 !qt_desktopWidget->isDesktop() ) { // reparented away
+	qt_desktopWidget = new QDesktopWidget();
+	Q_CHECK_PTR( qt_desktopWidget );
+    }
+    return qt_desktopWidget;
+}
+
+#ifndef QT_NO_CLIPBOARD
+/*!
+  Returns a pointer to the application global clipboard.
+*/
+QClipboard *QApplication::clipboard()
+{
+    if ( qt_clipboard == 0 ) {
+	qt_clipboard = new QClipboard;
+	Q_CHECK_PTR( qt_clipboard );
+    }
+    return qt_clipboard;
+}
+#endif // QT_NO_CLIPBOARD
+
+/*!
+  By default, Qt will try to use the current standard colors, fonts
+  etc., from the underlying window system's desktop settings,
+  and use them for all relevant widgets. This behavior can be switched off
+  by calling this function with \a on set to FALSE.
+
+  This static function must be called before creating the QApplication
+  object, like this:
+
+  \code
+  int main( int argc, char** argv ) {
+    QApplication::setDesktopSettingsAware( FALSE ); // I know better than the user
+    QApplication myApp( argc, argv ); // Use default fonts & colors
+    ...
+  }
+  \endcode
+
+  \sa desktopSettingsAware()
+*/
+
+void QApplication::setDesktopSettingsAware( bool on )
+{
+    obey_desktop_settings = on;
+}
+
+/*!
+  Returns the value set by setDesktopSettingsAware(); by default TRUE.
+
+  \sa setDesktopSettingsAware()
+*/
+
+bool QApplication::desktopSettingsAware()
+{
+    return obey_desktop_settings;
+}
+
+/*! \fn void QApplication::lock()
+
+  Lock the Qt Library Mutex. If another thread has already locked the
+  mutex, the calling thread will block until the other thread has
+  unlocked the mutex.
+
+  \sa unlock() locked() \link threads.html Thread Support in Qt\endlink
+*/
+
+
+/*! \fn void QApplication::unlock(bool wakeUpGui)
+
+  Unlock the Qt Library Mutex. If \a wakeUpGui is TRUE (the default),
+  then the GUI thread will be woken with QApplication::wakeUpGuiThread().
+
+  \sa lock(), locked() \link threads.html Thread Support in Qt\endlink
+*/
+
+
+/*! \fn bool QApplication::locked()
+
+  Returns TRUE if the Qt Library Mutex is locked by a different thread;
+  otherwise returns FALSE.
+
+  \warning Due to different implementations of recursive mutexes on
+  the supported platforms, calling this function from the same thread
+  that previously locked the mutex will give undefined results.
+
+  \sa lock() unlock() \link threads.html Thread Support in Qt\endlink
+*/
+
+/*! \fn bool QApplication::tryLock()
+
+  Attempts to lock the Qt Library Mutex, and returns immediately. If
+  the lock was obtained, this function returns TRUE. If another thread
+  has locked the mutex, this function returns FALSE, instead of
+  waiting for the lock to become available.
+
+  The mutex must be unlocked with unlock() before another thread can
+  successfully lock it.
+
+  \sa lock(), unlock() \link threads.html Thread Support in Qt\endlink
+*/
+
+#if defined(QT_THREAD_SUPPORT)
+void QApplication::lock()
+{
+    qt_mutex->lock();
+}
+
+void QApplication::unlock(bool wakeUpGui)
+{
+    qt_mutex->unlock();
+
+    if (wakeUpGui)
+	wakeUpGuiThread();
+}
+
+bool QApplication::locked()
+{
+    return qt_mutex->locked();
+}
+
+bool QApplication::tryLock()
+{
+    return qt_mutex->tryLock();
+}
+#endif
+
+
+/*!
+  \fn bool QApplication::isSessionRestored() const
+
+  Returns TRUE if the application has been restored from an earlier
+  \link session.html session\endlink; otherwise returns FALSE.
+
+  \sa sessionId(), commitData(), saveState()
+*/
+
+
+/*!
+  \fn QString QApplication::sessionId() const
+
+  Returns the current \link session.html session's\endlink identifier.
+
+  If the application has been restored from an earlier session, this
+  identifier is the same as it was in that previous session.
+
+  The session identifier is guaranteed to be unique both for different
+  applications and for different instances of the same application.
+
+  \sa isSessionRestored(), sessionKey(), commitData(), saveState()
+ */
+
+/*!
+  \fn QString QApplication::sessionKey() const
+
+  Returns the session key in the current \link session.html
+  session\endlink.
+
+  If the application has been restored from an earlier session, this
+  key is the same as it was when the previous session ended.
+
+  The session key changes with every call of commitData() or
+  saveState().
+
+  \sa isSessionRestored(), sessionId(), commitData(), saveState()
+ */
+
+
+/*!
+  \fn void QApplication::commitData( QSessionManager& sm )
+
+  This function deals with \link session.html session
+  management\endlink. It is invoked when the QSessionManager wants the
+  application to commit all its data.
+
+  Usually this means saving all open files, after getting
+  permission from the user. Furthermore you may want to provide a means
+  by which the user can cancel the shutdown.
+
+  Note that you should not exit the application within this function.
+  Instead, the session manager may or may not do this afterwards,
+  depending on the context.
+
+  \warning Within this function, no user interaction is possible, \e
+  unless you ask the session manager \a sm for explicit permission.
+  See QSessionManager::allowsInteraction() and
+  QSessionManager::allowsErrorInteraction() for details and example
+  usage.
+
+  The default implementation requests interaction and sends a close
+  event to all visible top level widgets. If any event was
+  rejected, the shutdown is canceled.
+
+  \sa isSessionRestored(), sessionId(), saveState(), \link session.html the Session Management overview\endlink
+*/
+#ifndef QT_NO_SESSIONMANAGER
+void QApplication::commitData( QSessionManager& sm  )
+{
+
+    if ( sm.allowsInteraction() ) {
+	QWidgetList done;
+	QWidgetList *list = QApplication::topLevelWidgets();
+	bool cancelled = FALSE;
+	QWidget* w = list->first();
+	while ( !cancelled && w ) {
+	    if ( !w->isHidden() ) {
+		QCloseEvent e;
+		sendEvent( w, &e );
+		cancelled = !e.isAccepted();
+		if ( !cancelled )
+		    done.append( w );
+		delete list; // one never knows...
+		list = QApplication::topLevelWidgets();
+		w = list->first();
+	    } else {
+		w = list->next();
+	    }
+	    while ( w && done.containsRef( w ) )
+		w = list->next();
+	}
+	delete list;
+	if ( cancelled )
+	    sm.cancel();
+    }
+}
+
+
+/*!
+  \fn void QApplication::saveState( QSessionManager& sm )
+
+  This function deals with \link session.html session
+  management\endlink. It is invoked when the
+  \link QSessionManager session manager \endlink wants the application
+  to preserve its state for a future session.
+
+  For example, a text editor would create a temporary file that
+  includes the current contents of its edit buffers, the location of
+  the cursor and other aspects of the current editing session.
+
+  Note that you should never exit the application within this
+  function. Instead, the session manager may or may not do this
+  afterwards, depending on the context. Futhermore, most session
+  managers will very likely request a saved state immediately after
+  the application has been started. This permits the session manager
+  to learn about the application's restart policy.
+
+  \warning Within this function, no user interaction is possible, \e
+  unless you ask the session manager \a sm for explicit permission.
+  See QSessionManager::allowsInteraction() and
+  QSessionManager::allowsErrorInteraction() for details.
+
+  \sa isSessionRestored(), sessionId(), commitData(), \link session.html the Session Management overview\endlink
+*/
+
+void QApplication::saveState( QSessionManager& /* sm */ )
+{
+}
+#endif //QT_NO_SESSIONMANAGER
+/*!
+  Sets the time after which a drag should start to \a ms ms.
+
+  \sa startDragTime()
+*/
+
+void QApplication::setStartDragTime( int ms )
+{
+    drag_time = ms;
+}
+
+/*!
+  If you support drag and drop in you application and a drag should
+  start after a mouse click and after a certain time elapsed, you
+  should use the value which this method returns as the delay (in ms).
+
+  Qt also uses this delay internally, e.g. in QTextEdit and QLineEdit,
+  for starting a drag.
+
+  The default value is 500 ms.
+
+  \sa setStartDragTime(), startDragDistance()
+*/
+
+int QApplication::startDragTime()
+{
+    return drag_time;
+}
+
+/*!
+  Sets the distance after which a drag should start to \a l pixels.
+
+  \sa startDragDistance()
+*/
+
+void QApplication::setStartDragDistance( int l )
+{
+    drag_distance = l;
+}
+
+/*!
+  If you support drag and drop in you application and a drag should
+  start after a mouse click and after moving the mouse a certain
+  distance, you should use the value which this method returns as the
+  distance.
+
+  For example, if the mouse position of the click is stored in \c
+  startPos and the current position (e.g. in the mouse move event) is
+  \c currPos, you can find out if a drag should be started with code
+  like this:
+  \code
+  if ( ( startPos - currPos ).manhattanLength() >
+       QApplication::startDragDistance() )
+    startTheDrag();
+  \endcode
+
+  Qt uses this value internally, e.g. in QFileDialog.
+
+  The default value is 4 pixels.
+
+  \sa setStartDragDistance(), startDragTime(), QPoint::manhattanLength()
+*/
+
+int QApplication::startDragDistance()
+{
+    return drag_distance;
+}
+
+/*!
+  If \a b is TRUE, all dialogs and widgets will be laid out in a
+  mirrored fashion, as required by right to left languages such as
+  Arabic and Hebrew. If \a b is FALSE, dialogs and widgets are laid
+  out left to right.
+
+  Changing this flag in runtime does not cause a relayout of already
+  instantiated widgets.
+
+  \sa reverseLayout()
+*/
+void QApplication::setReverseLayout( bool b )
+{
+    if ( reverse_layout == b )
+	return;
+
+    reverse_layout = b;
+
+    QWidgetList *list = topLevelWidgets();
+    QWidgetListIt it( *list );
+    QWidget *w;
+    while ( ( w=it.current() ) != 0 ) {
+	++it;
+	postEvent( w, new QEvent( QEvent::LayoutDirectionChange ) );
+    }
+    delete list;
+}
+
+/*!
+    Returns TRUE if all dialogs and widgets will be laid out in a
+    mirrored (right to left) fashion. Returns FALSE if dialogs and
+    widgets will be laid out left to right.
+
+  \sa setReverseLayout()
+*/
+bool QApplication::reverseLayout()
+{
+    return reverse_layout;
+}
+
+
+/*!
+  \class QSessionManager qsessionmanager.h
+  \brief The QSessionManager class provides access to the session manager.
+
+  \ingroup application
+  \ingroup environment
+
+  The session manager is responsible for session management, most
+  importantly for interruption and resumption. A "session" is a kind
+  of record of the state of the system, e.g. which applications were
+  run at start up and which applications are currently running. The
+  session manager is used to save the session, e.g. when the machine
+  is shut down; and to restore a session, e.g. when the machine is
+  started up. Use QSettings to save and restore an individual
+  application's settings, e.g. window positions, recently used files,
+  etc.
+
+  QSessionManager provides an interface between the application and
+  the session manager so that the program can work well with the
+  session manager. In Qt, session management requests for action
+  are handled by the two virtual functions QApplication::commitData()
+  and QApplication::saveState(). Both provide a reference to
+  a session manager object as argument, to allow the application
+  to communicate with the session manager.
+
+  During a session management action (i.e. within commitData() and
+  saveState()), no user interaction is possible \e unless the
+  application got explicit permission from the session manager. You
+  ask for permission by calling allowsInteraction() or, if it's really
+  urgent, allowsErrorInteraction(). Qt does not enforce this, but the
+  session manager may.
+
+  You can try to abort the shutdown process by calling cancel(). The
+  default commitData() function does this if some top-level window
+  rejected its closeEvent().
+
+  For sophisticated session managers provided on Unix/X11, QSessionManager
+  offers further possibilites to fine-tune an application's session
+  management behavior: setRestartCommand(), setDiscardCommand(),
+  setRestartHint(), setProperty(), requestPhase2(). See the respective
+  function descriptions for further details.
+*/
+
+/*! \enum QSessionManager::RestartHint
+
+  This enum type defines the circumstances under which this
+  application wants to be restarted by the session manager. The
+  current values are
+
+  \value RestartIfRunning  if the application is still running when
+  the session is shut down, it wants to be restarted at the start of
+  the next session.
+
+  \value RestartAnyway  the application wants to be started at the
+  start of the next session, no matter what. (This is useful for
+  utilities that run just after startup and then quit.)
+
+  \value RestartImmediately  the application wants to be started
+  immediately whenever it is not running.
+
+  \value RestartNever  the application does not want to be restarted
+  automatically.
+
+  The default hint is \c RestartIfRunning.
+*/
+
+
+/*!
+  \fn QString QSessionManager::sessionId() const
+
+  Returns the identifier of the current session.
+
+  If the application has been restored from an earlier session, this
+  identifier is the same as it was in that earlier session.
+
+  \sa sessionKey(), QApplication::sessionId()
+ */
+
+/*!
+  \fn QString QSessionManager::sessionKey() const
+
+  Returns the session key in the current session.
+
+  If the application has been restored from an earlier session, this
+  key is the same as it was when the previous session ended.
+
+  The session key changes with every call of commitData() or
+  saveState().
+
+  \sa sessionId(), QApplication::sessionKey()
+ */
+
+// ### Note: This function is undocumented, since it is #ifdef'd.
+
+/*!
+  \fn void* QSessionManager::handle() const
+
+  X11 only: returns a handle to the current \c SmcConnection.
+*/
+
+
+/*!
+  \fn bool QSessionManager::allowsInteraction()
+
+  Asks the session manager for permission to interact with the
+  user. Returns TRUE if interaction is permitted; otherwise
+  returns FALSE.
+
+  The rationale behind this mechanism is to make it possible to
+  synchronize user interaction during a shutdown. Advanced session
+  managers may ask all applications simultaneously to commit their
+  data, resulting in a much faster shutdown.
+
+  When the interaction is completed we strongly recommend releasing the
+  user interaction semaphore with a call to release(). This way, other
+  applications may get the chance to interact with the user while your
+  application is still busy saving data. (The semaphore is implicitly
+  released when the application exits.)
+
+  If the user decides to cancel the shutdown process during the
+  interaction phase, you must tell the session manager that this has
+  happened by calling cancel().
+
+  Here's an example of how an application's QApplication::commitData()
+  might be implemented:
+
+\code
+void MyApplication::commitData( QSessionManager& sm ) {
+    if ( sm.allowsInteraction() ) {
+	switch ( QMessageBox::warning(
+		    yourMainWindow,
+		    tr("Application Name"),
+		    tr("Save changes to document Foo?"),
+		    tr("&Yes"),
+		    tr("&No"),
+		    tr("Cancel"),
+		    0, 2) ) {
+	case 0: // yes
+	    sm.release();
+	    // save document here; if saving fails, call sm.cancel()
+	    break;
+	case 1: // continue without saving
+	    break;
+	default: // cancel
+	    sm.cancel();
+	    break;
+	}
+    } else {
+	// we did not get permission to interact, then
+	// do something reasonable instead.
+    }
+}
+\endcode
+
+  If an error occurred within the application while saving its data,
+  you may want to try allowsErrorInteraction() instead.
+
+  \sa QApplication::commitData(), release(), cancel()
+*/
+
+
+/*!
+  \fn bool QSessionManager::allowsErrorInteraction()
+
+  This is similar to allowsInteraction(), but also tells the session
+  manager that an error occurred. Session managers may give error
+  interaction request higher priority, which means that it is more likely
+  that an error interaction is permitted. However, you are still not
+  guaranteed that the session manager will allow interaction.
+
+  \sa allowsInteraction(), release(), cancel()
+*/
+
+/*!
+  \fn void QSessionManager::release()
+
+  Releases the session manager's interaction semaphore after an
+  interaction phase.
+
+  \sa allowsInteraction(), allowsErrorInteraction()
+*/
+
+/*!
+  \fn void QSessionManager::cancel()
+
+  Tells the session manager to cancel the shutdown process.  Applications
+  should not call this function without first asking the user.
+
+  \sa allowsInteraction(), allowsErrorInteraction()
+
+*/
+
+/*!
+  \fn void QSessionManager::setRestartHint( RestartHint hint )
+
+  Sets the application's restart hint to \a hint. On application
+  startup the hint is set to \c RestartIfRunning.
+
+  Note that these flags are only hints, a session manager may or may
+  not respect them.
+
+  We recommend setting the restart hint in QApplication::saveState()
+  because most session managers perform a checkpoint shortly after an
+  application's startup.
+
+  \sa restartHint()
+*/
+
+/*!
+  \fn QSessionManager::RestartHint QSessionManager::restartHint() const
+
+  Returns the application's current restart hint. The default is
+  \c RestartIfRunning.
+
+  \sa setRestartHint()
+*/
+
+/*!
+  \fn void QSessionManager::setRestartCommand( const QStringList& command )
+
+  If the session manager is capable of restoring sessions it will
+  execute \a command in order to restore the application. The command
+  defaults to
+
+  \code
+	appname -session id
+  \endcode
+
+  The \c -session option is mandatory; otherwise QApplication cannot
+  tell whether it has been restored or what the current session
+  identifier is. See QApplication::isSessionRestored() and
+  QApplication::sessionId() for details.
+
+  If your application is very simple, it may be possible to store the
+  entire application state in additional command line options. This
+  is usually a very bad idea because command lines are often limited
+  to a few hundred bytes. Instead, use QSettings, or temporary files
+  or a database for this purpose. By marking the data with the unique
+  sessionId(), you will be able to restore the application in a future
+  session.
+
+  \sa restartCommand(), setDiscardCommand(), setRestartHint()
+*/
+
+/*!
+  \fn QStringList QSessionManager::restartCommand() const
+
+  Returns the currently set restart command.
+
+  Note that if you want to iterate over the list, you should
+  iterate over a copy, e.g.
+    \code
+    QStringList list = mySession.restartCommand();
+    QStringList::Iterator it = list.begin();
+    while( it != list.end() ) {
+	myProcessing( *it );
+	++it;
+    }
+    \endcode
+
+  \sa setRestartCommand(), restartHint()
+*/
+
+/*!
+  \fn void QSessionManager::setDiscardCommand( const QStringList& )
+
+  \sa discardCommand(), setRestartCommand()
+*/
+
+
+/*!
+  \fn QStringList QSessionManager::discardCommand() const
+
+  Returns the currently set discard command.
+
+  Note that if you want to iterate over the list, you should
+  iterate over a copy, e.g.
+    \code
+    QStringList list = mySession.discardCommand();
+    QStringList::Iterator it = list.begin();
+    while( it != list.end() ) {
+	myProcessing( *it );
+	++it;
+    }
+    \endcode
+
+  \sa setDiscardCommand(), restartCommand(), setRestartCommand()
+*/
+
+/*!
+  \overload void QSessionManager::setManagerProperty( const QString& name,
+						      const QString& value )
+
+  Low-level write access to the application's identification and state
+  records are kept in the session manager.
+
+    The property called \a name has its value set to the string \a value.
+*/
+
+/*!
+  \fn void QSessionManager::setManagerProperty( const QString& name,
+						const QStringList& value )
+
+  Low-level write access to the application's identification and state
+  record are kept in the session manager.
+
+    The property called \a name has its value set to the string list \a value.
+*/
+
+/*!
+  \fn bool QSessionManager::isPhase2() const
+
+  Returns TRUE if the session manager is currently performing a second
+  session management phase; otherwise returns FALSE.
+
+  \sa requestPhase2()
+*/
+
+/*!
+  \fn void QSessionManager::requestPhase2()
+
+  Requests a second session management phase for the application. The
+  application may then return immediately from the
+  QApplication::commitData() or QApplication::saveState() function,
+  and they will be called again once most or all other applications have
+  finished their session management.
+
+  The two phases are useful for applications such as the X11 window manager
+  that need to store information about another application's windows
+  and therefore have to wait until these applications have completed their
+  respective session management tasks.
+
+  Note that if another application has requested a second phase it
+  may get called before, simultaneously with, or after your
+  application's second phase.
+
+  \sa isPhase2()
+*/
+
+/*!
+  \fn int QApplication::horizontalAlignment( int align )
+
+  Strips out vertical alignment flags and transforms an
+  alignment \a align of AlignAuto into AlignLeft or
+  AlignRight according to the language used. The other horizontal
+  alignment flags are left untouched.
+*/
+
+
+/*****************************************************************************
+  Stubbed session management support
+ *****************************************************************************/
+#ifndef QT_NO_SESSIONMANAGER
+#if defined( QT_NO_SM_SUPPORT ) || defined( Q_WS_WIN ) || defined( Q_WS_MAC ) || defined( Q_WS_QWS )
+
+class QSessionManagerData
+{
+public:
+    QStringList restartCommand;
+    QStringList discardCommand;
+    QString sessionId;
+    QString sessionKey;
+    QSessionManager::RestartHint restartHint;
+};
+
+QSessionManager* qt_session_manager_self = 0;
+QSessionManager::QSessionManager( QApplication * app, QString &id, QString &key )
+    : QObject( app, "qt_sessionmanager" )
+{
+    qt_session_manager_self = this;
+    d = new QSessionManagerData;
+#if defined(Q_WS_WIN) && !defined(Q_OS_TEMP)
+    wchar_t guidstr[40];
+    GUID guid;
+    CoCreateGuid( &guid );
+    StringFromGUID2(guid, guidstr, 40);
+    id = QString::fromUcs2((ushort*)guidstr);
+    CoCreateGuid( &guid );
+    StringFromGUID2(guid, guidstr, 40);
+    key = QString::fromUcs2((ushort*)guidstr);
+#endif
+    d->sessionId = id;
+    d->sessionKey = key;
+    d->restartHint = RestartIfRunning;
+}
+
+QSessionManager::~QSessionManager()
+{
+    delete d;
+    qt_session_manager_self = 0;
+}
+
+QString QSessionManager::sessionId() const
+{
+    return d->sessionId;
+}
+
+QString QSessionManager::sessionKey() const
+{
+    return d->sessionKey;
+}
+
+
+#if defined(Q_WS_X11) || defined(Q_WS_MAC)
+void* QSessionManager::handle() const
+{
+    return 0;
+}
+#endif
+
+#if !defined(Q_WS_WIN)
+bool QSessionManager::allowsInteraction()
+{
+    return TRUE;
+}
+
+bool QSessionManager::allowsErrorInteraction()
+{
+    return TRUE;
+}
+void QSessionManager::release()
+{
+}
+
+void QSessionManager::cancel()
+{
+}
+#endif
+
+
+void QSessionManager::setRestartHint( QSessionManager::RestartHint hint)
+{
+    d->restartHint = hint;
+}
+
+QSessionManager::RestartHint QSessionManager::restartHint() const
+{
+    return d->restartHint;
+}
+
+void QSessionManager::setRestartCommand( const QStringList& command)
+{
+    d->restartCommand = command;
+}
+
+QStringList QSessionManager::restartCommand() const
+{
+    return d->restartCommand;
+}
+
+void QSessionManager::setDiscardCommand( const QStringList& command)
+{
+    d->discardCommand = command;
+}
+
+QStringList QSessionManager::discardCommand() const
+{
+    return d->discardCommand;
+}
+
+void QSessionManager::setManagerProperty( const QString&, const QString&)
+{
+}
+
+void QSessionManager::setManagerProperty( const QString&, const QStringList& )
+{
+}
+
+bool QSessionManager::isPhase2() const
+{
+    return FALSE;
+}
+
+void QSessionManager::requestPhase2()
+{
+}
+
+#endif // QT_NO_SM_SUPPORT
+#endif //QT_NO_SESSIONMANAGER
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication.h qt-x11-free-3.3.8b/src/kernel/qapplication.h
--- qt-x11-free-3.3.8b/src/kernel/qapplication.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication.h	2009-10-18 14:38:39.108543295 -0700
@@ -55,4 +55,7 @@
 class QTranslator;
 class QEventLoop;
+#if defined(Q_WS_X11)
+class QIMEvent;
+#endif
 #if defined(Q_WS_QWS)
 class QWSDecoration;
@@ -276,6 +279,17 @@
 #endif
 #if defined(Q_WS_X11)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    virtual QWidget *locateICHolderWidget( QWidget *w );
+    virtual QWidgetList *icHolderWidgets();
+    static void create_im();
+    static void close_im();
+#else
+    QWidget *locateICHolderWidget( QWidget *w );
+    QWidgetList *icHolderWidgets();
     static void create_xim();
     static void close_xim();
+#endif
+    static QString defaultInputMethod();
+    void	changeAllInputContext( const QString & );
     static bool x11_apply_settings();
 #endif
@@ -332,4 +346,10 @@
 #endif
 
+#if defined(Q_WS_X11)
+private slots:
+    void postIMEvent( QObject *receiver, QIMEvent *event );
+#endif
+
+private:
 #ifdef QT_THREAD_SUPPORT
     static QMutex   *qt_mutex;
@@ -381,7 +401,10 @@
     bool	     is_session_restored;
 #endif
-#if defined(Q_WS_X11) && !defined (QT_NO_STYLE )
+#if defined(Q_WS_X11)
+#if !defined (QT_NO_STYLE)
     static void x11_initialize_style();
 #endif
+    static QString defaultIM; // default input method's name in this application.
+#endif
 
     static QSize     app_strut;
@@ -400,4 +423,5 @@
     static bool      sendSpontaneousEvent( QObject *receiver, QEvent *event );
     static void      removePostedEvent( QEvent * );
+    static void      removePostedEvents( QObject *receiver, int event_type );
 
     friend class QWidget;
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication.h.orig qt-x11-free-3.3.8b/src/kernel/qapplication.h.orig
--- qt-x11-free-3.3.8b/src/kernel/qapplication.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication.h.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,531 @@
+/****************************************************************************
+**
+** Definition of QApplication class
+**
+** Created : 931107
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QAPPLICATION_H
+#define QAPPLICATION_H
+
+#ifndef QT_H
+#include "qdesktopwidget.h"
+#include "qasciidict.h"
+#include "qpalette.h"
+#include "qtranslator.h"
+#include "qstrlist.h"
+#include "qstringlist.h"
+#endif // QT_H
+
+class QSessionManager;
+class QStyle;
+class QTranslator;
+class QEventLoop;
+#if defined(Q_WS_QWS)
+class QWSDecoration;
+#endif
+
+#ifdef QT_THREAD_SUPPORT
+class QMutex;
+#endif // QT_THREAD_SUPPORT
+
+
+class QApplication;
+extern Q_EXPORT QApplication *qApp;		// global application object
+
+
+class Q_EXPORT QApplication : public QObject
+{
+    Q_OBJECT
+public:
+    QApplication( int &argc, char **argv );
+    QApplication( int &argc, char **argv, bool GUIenabled );
+    enum Type { Tty, GuiClient, GuiServer };
+    QApplication( int &argc, char **argv, Type );
+#if defined(Q_WS_X11)
+    QApplication( Display* dpy, HANDLE visual = 0, HANDLE cmap = 0 );
+    QApplication( Display *dpy, int argc, char **argv,
+		  HANDLE visual = 0, HANDLE cmap= 0 );
+#endif
+    virtual ~QApplication();
+
+    int		    argc()	const;
+    char	  **argv()	const;
+
+    Type type() const;
+
+#ifndef QT_NO_STYLE
+    static QStyle  &style();
+    static void	    setStyle( QStyle* );
+    static QStyle*  setStyle( const QString& );
+#endif
+#ifndef Q_QDOC
+    enum ColorMode { NormalColors, CustomColors };
+    static ColorMode colorMode();
+    static void      setColorMode( QApplication::ColorMode );
+#endif
+
+    enum ColorSpec { NormalColor=0, CustomColor=1, ManyColor=2 };
+    static int	     colorSpec();
+    static void      setColorSpec( int );
+#ifndef QT_NO_CURSOR
+    static QCursor  *overrideCursor();
+    static void	     setOverrideCursor( const QCursor &, bool replace=FALSE );
+    static void	     restoreOverrideCursor();
+#endif
+    static bool	     hasGlobalMouseTracking();
+    static void	     setGlobalMouseTracking( bool enable );
+#ifndef QT_NO_PALETTE
+    static QPalette  palette( const QWidget* = 0 );
+    static void	     setPalette( const QPalette &, bool informWidgets=FALSE,
+				 const char* className = 0 );
+#endif
+    static QFont     font( const QWidget* = 0 );
+    static void	     setFont( const QFont &, bool informWidgets=FALSE,
+			      const char* className = 0 );
+    static QFontMetrics fontMetrics();
+
+    QWidget	    *mainWidget()  const;
+    virtual void     setMainWidget( QWidget * );
+    virtual void     polish( QWidget * );
+
+    static QWidgetList *allWidgets();
+    static QWidgetList *topLevelWidgets();
+
+    static QDesktopWidget   *desktop();
+
+    static QWidget     *activePopupWidget();
+    static QWidget     *activeModalWidget();
+#ifndef QT_NO_CLIPBOARD
+    static QClipboard  *clipboard();
+#endif
+    QWidget	       *focusWidget() const;
+    QWidget	       *activeWindow() const;
+
+    static QWidget  *widgetAt( int x, int y, bool child=FALSE );
+    static QWidget  *widgetAt( const QPoint &, bool child=FALSE );
+
+    static QEventLoop *eventLoop();
+
+    int		     exec();
+    void	     processEvents();
+    void	     processEvents( int maxtime );
+    void	     processOneEvent();
+    bool	     hasPendingEvents();
+    int		     enter_loop();
+    void	     exit_loop();
+    int		     loopLevel() const;
+    static void	     exit( int retcode=0 );
+
+    static bool	     sendEvent( QObject *receiver, QEvent *event );
+    static void	     postEvent( QObject *receiver, QEvent *event );
+    static void	     sendPostedEvents( QObject *receiver, int event_type );
+    static void	     sendPostedEvents();
+
+    static void      removePostedEvents( QObject *receiver );
+
+    virtual bool     notify( QObject *, QEvent * );
+
+    static bool	     startingUp();
+    static bool	     closingDown();
+
+    static void	     flushX();
+    static void flush();
+    static void	     syncX();
+
+    static void	     beep();
+
+#ifndef QT_NO_TRANSLATION
+# ifndef QT_NO_TEXTCODEC
+    void	     setDefaultCodec( QTextCodec * );
+    QTextCodec*	     defaultCodec() const;
+# endif
+    void	     installTranslator( QTranslator * );
+    void	     removeTranslator( QTranslator * );
+#endif
+    enum Encoding { DefaultCodec, UnicodeUTF8 };
+    QString	     translate( const char * context,
+				const char * key,
+				const char * comment = 0,
+				Encoding encoding = DefaultCodec ) const;
+#ifndef QT_NO_DIR
+    QString   applicationDirPath();
+    QString   applicationFilePath();
+#endif
+#ifndef QT_NO_PALETTE
+    // obsolete functions
+    static void      setWinStyleHighlightColor( const QColor &c ) {
+	QPalette p( palette() );
+	p.setColor( QColorGroup::Highlight, c );
+	setPalette( p, TRUE);
+    }
+    static const QColor &winStyleHighlightColor() {
+	return palette().active().highlight();
+    }
+#endif
+    static void      setDesktopSettingsAware( bool );
+    static bool      desktopSettingsAware();
+
+    static void      setCursorFlashTime( int );
+    static int       cursorFlashTime();
+
+    static void      setDoubleClickInterval( int );
+    static int       doubleClickInterval();
+#ifndef QT_NO_WHEELEVENT
+    static void      setWheelScrollLines( int );
+    static int       wheelScrollLines();
+#endif
+    static void	     setGlobalStrut( const QSize & );
+    static QSize     globalStrut();
+
+#ifndef QT_NO_COMPONENT
+    static void      setLibraryPaths( const QStringList & );
+    static QStringList libraryPaths();
+    static void      addLibraryPath( const QString & );
+    static void      removeLibraryPath( const QString & );
+#endif // QT_NO_COMPONENT
+    static void setStartDragTime( int ms );
+    static int startDragTime();
+    static void setStartDragDistance( int l );
+    static int startDragDistance();
+
+    static void setReverseLayout( bool b );
+    static bool reverseLayout();
+
+    static int horizontalAlignment( int align );
+
+    static bool	    isEffectEnabled( Qt::UIEffect );
+    static void	    setEffectEnabled( Qt::UIEffect, bool enable = TRUE );
+
+#if defined(Q_WS_MAC)
+    virtual bool     macEventFilter( EventHandlerCallRef, EventRef );
+#endif
+#if defined(Q_WS_WIN)
+    virtual bool     winEventFilter( MSG * );
+#endif
+#if defined(Q_WS_X11)
+    virtual bool     x11EventFilter( XEvent * );
+    virtual int	     x11ClientMessage( QWidget*, XEvent*, bool passive_only);
+    int              x11ProcessEvent( XEvent* );
+#endif
+#if defined(Q_WS_QWS)
+    virtual bool     qwsEventFilter( QWSEvent * );
+    int              qwsProcessEvent( QWSEvent* );
+    void             qwsSetCustomColors( QRgb *colortable, int start, int numColors );
+/*!
+  \internal
+    Returns true if the process is GUI server
+*/
+    bool          qwsIsGUIServer();
+#ifndef QT_NO_QWS_MANAGER
+    static QWSDecoration &qwsDecoration();
+    static void      qwsSetDecoration( QWSDecoration *);
+#endif
+#endif
+
+#if defined(Q_OS_WIN32) || defined(Q_OS_CYGWIN)
+    static WindowsVersion winVersion();
+#elif defined(Q_OS_MAC)
+    static MacintoshVersion macVersion();
+#endif
+#if defined(Q_WS_WIN)
+    void	     winFocus( QWidget *, bool );
+    static void	     winMouseButtonUp();
+#endif
+
+#ifndef QT_NO_SESSIONMANAGER
+    // session management
+    bool	     isSessionRestored() const;
+    QString 	sessionId() const;
+    QString 	sessionKey() const;
+    virtual void     commitData( QSessionManager& sm );
+    virtual void     saveState( QSessionManager& sm );
+#endif
+#if defined(Q_WS_X11)
+    static void create_xim();
+    static void close_xim();
+    static bool x11_apply_settings();
+#endif
+    void	     wakeUpGuiThread();
+#if defined(QT_THREAD_SUPPORT)
+    void	     lock();
+    void	     unlock(bool wakeUpGui = TRUE);
+    bool	     locked();
+    bool             tryLock();
+#endif
+
+signals:
+    void	     lastWindowClosed();
+    void	     aboutToQuit();
+    void	     guiThreadAwake();
+
+public slots:
+    void	     quit();
+    void	     closeAllWindows();
+    void	     aboutQt();
+
+#if defined(Q_WS_QWS)
+protected:
+    void setArgs(int, char **);
+#endif
+
+protected:
+    bool event(QEvent *);
+
+private:
+    void construct( int &argc, char **argv, Type );
+    void initialize( int, char ** );
+    void init_precmdline();
+    void process_cmdline( int* argcptr, char ** argv );
+    bool internalNotify( QObject *, QEvent * );
+#if defined(Q_WS_QWS)
+    static QWidget *findChildWidget( const QWidget *p, const QPoint &pos );
+    static QWidget *findWidget( const QObjectList&, const QPoint &, bool rec );
+#endif
+
+#if defined(Q_WS_MAC)
+    bool do_mouse_down(Point *, bool *);
+    static QMAC_PASCAL OSStatus globalEventProcessor(EventHandlerCallRef,  EventRef, void *);
+    static QMAC_PASCAL OSStatus globalAppleEventProcessor(const AppleEvent *, AppleEvent *, long);
+    static QMAC_PASCAL void qt_context_timer_callbk(EventLoopTimerRef, void *);
+    static QMAC_PASCAL void qt_select_timer_callbk(EventLoopTimerRef, void *);
+    static bool qt_mac_apply_settings();
+    friend class QMacInputMethod;
+    friend QMAC_PASCAL OSStatus qt_window_event(EventHandlerCallRef, EventRef, void *);
+    friend void qt_mac_update_os_settings();
+    friend bool qt_set_socket_handler( int, int, QObject *, bool);
+    friend void qt_mac_destroy_widget(QWidget *);
+    friend void qt_init(int *, char **, QApplication::Type);
+#endif
+
+#ifdef QT_THREAD_SUPPORT
+    static QMutex   *qt_mutex;
+#endif // QT_THREAD_SUPPORT
+
+    int		     app_argc;
+    char	   **app_argv;
+    bool	     quit_now;
+    int		     quit_code;
+    static QStyle   *app_style;
+    static int	     app_cspec;
+#ifndef QT_NO_PALETTE
+    static QPalette *app_pal;
+#endif
+    static QFont    *app_font;
+#ifndef QT_NO_CURSOR
+    static QCursor  *app_cursor;
+#endif
+    static QEventLoop* eventloop;
+    static int	     app_tracking;
+    static bool	     is_app_running;
+    static bool	     is_app_closing;
+    static bool	     app_exit_loop;
+    static int	     loop_level;
+    static QWidget  *main_widget;
+    static QWidget  *focus_widget;
+    static QWidget  *active_window;
+    static bool	     obey_desktop_settings;
+    static int	     cursor_flash_time;
+    static int	     mouse_double_click_time;
+    static int	     wheel_scroll_lines;
+    static int	     composedUnicode; // Value, meta-composed character
+
+    static bool	     animate_ui;
+    static bool	     animate_menu;
+    static bool	     animate_tooltip;
+    static bool	     animate_combo;
+    static bool	     fade_menu;
+    static bool	     fade_tooltip;
+    static bool	     animate_toolbox;
+    static bool	     widgetCount; // Coupled with -widgetcount switch
+    static bool	     metaComposeUnicode;
+
+    QValueList<QTranslator*> *translators;
+#ifndef QT_NO_SESSIONMANAGER
+    QSessionManager *session_manager;
+    QString	     session_id;
+    static QString* session_key;
+    bool	     is_session_restored;
+#endif
+#if defined(Q_WS_X11) && !defined (QT_NO_STYLE )
+    static void x11_initialize_style();
+#endif
+
+    static QSize     app_strut;
+#ifndef QT_NO_COMPONENT
+    static QStringList *app_libpaths;
+#endif
+    static QAsciiDict<QPalette> *app_palettes;
+    static QAsciiDict<QFont>    *app_fonts;
+
+    static QWidgetList *popupWidgets;
+    bool	     inPopupMode() const;
+    void	     closePopup( QWidget *popup );
+    void	     openPopup( QWidget *popup );
+    void	     setActiveWindow( QWidget* act );
+
+    static bool      sendSpontaneousEvent( QObject *receiver, QEvent *event );
+    static void      removePostedEvent( QEvent * );
+
+    friend class QWidget;
+    friend class QETWidget;
+    friend class QDialog;
+    friend class QAccelManager;
+    friend class QEvent;
+    friend class QTranslator;
+    friend class QEventLoop;
+    friend Q_EXPORT void qt_ucm_initialize( QApplication * );
+#if defined(Q_WS_WIN)
+    friend bool qt_sendSpontaneousEvent( QObject*, QEvent* );
+#endif
+#if defined(Q_WS_QWS)
+    friend class QInputContext;
+#endif
+private: // Disabled copy constructor and operator=
+#if defined(Q_DISABLE_COPY)
+    QApplication( const QApplication & );
+    QApplication &operator=( const QApplication & );
+#endif
+};
+
+inline int QApplication::argc() const
+{
+    return app_argc;
+}
+
+inline char **QApplication::argv() const
+{
+    return app_argv;
+}
+
+#if defined(Q_WS_QWS)
+inline void QApplication::setArgs(int c, char **v)
+{
+        app_argc = c;
+	    app_argv = v;
+}
+#endif
+
+#ifndef QT_NO_CURSOR
+inline QCursor *QApplication::overrideCursor()
+{
+    return app_cursor;
+}
+#endif
+inline bool QApplication::hasGlobalMouseTracking()
+{
+    return app_tracking > 0;
+}
+
+inline QWidget *QApplication::mainWidget() const
+{
+    return main_widget;
+}
+
+inline QWidget *QApplication::focusWidget() const
+{
+    return focus_widget;
+}
+
+inline QWidget *QApplication::activeWindow() const
+{
+    return active_window;
+}
+
+inline QWidget *QApplication::widgetAt( const QPoint &p, bool child )
+{
+    return widgetAt( p.x(), p.y(), child );
+}
+
+inline bool QApplication::inPopupMode() const
+{
+    return popupWidgets != 0;
+}
+#ifndef QT_NO_SESSIONMANAGER
+inline bool QApplication::isSessionRestored() const
+{
+    return is_session_restored;
+}
+
+inline QString QApplication::sessionId() const
+{
+    return session_id;
+}
+
+inline QString QApplication::sessionKey() const
+{
+    return session_key ? *session_key : QString::null;
+}
+#endif
+inline QSize QApplication::globalStrut()
+{
+    return app_strut;
+}
+
+inline bool QApplication::sendEvent( QObject *receiver, QEvent *event )
+{  if ( event ) event->spont = FALSE; return qApp ? qApp->notify( receiver, event ) : FALSE; }
+
+inline bool QApplication::sendSpontaneousEvent( QObject *receiver, QEvent *event )
+{ if ( event ) event->spont = TRUE; return qApp ? qApp->notify( receiver, event ) : FALSE; }
+
+#ifdef QT_NO_TRANSLATION
+// Simple versions
+inline QString QApplication::translate( const char *, const char *sourceText,
+					const char *, Encoding encoding ) const
+{
+#ifndef QT_NO_TEXTCODEC
+    if ( encoding == UnicodeUTF8 )
+	return QString::fromUtf8( sourceText );
+    else
+#endif
+	return QString::fromLatin1( sourceText );
+}
+#endif
+
+inline int QApplication::horizontalAlignment( int align )
+{
+    align &= AlignHorizontal_Mask;
+    if ( align == AlignAuto ) {
+	if ( reverseLayout() )
+	    align = AlignRight;
+	else
+	    align = AlignLeft;
+    }
+    return align;
+}
+
+#endif // QAPPLICATION_H
+
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp
--- qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp	2009-10-18 14:38:39.135201813 -0700
@@ -93,5 +93,7 @@
 
 // Input method stuff - UNFINISHED
-#include "qinputcontext_p.h"
+#ifndef QT_NO_IM
+#include "qinputcontext.h"
+#endif // QT_NO_IM
 #include "qinternal_p.h" // shared double buffer cleanup
 
@@ -193,8 +195,7 @@
 static const char *mwTitle	= 0;		// main widget title
 //Ming-Che 10/10
-static char    *ximServer	= 0;		// XIM Server will connect to
+char    *qt_ximServer	= 0;		// XIM Server will connect to
 static bool	mwIconic	= FALSE;	// main widget iconified
 //Ming-Che 10/10
-static bool	noxim		= FALSE;	// connect to xim or not
 static Display *appDpy		= 0;		// X11 application display
 static char    *appDpyName	= 0;		// X11 display name
@@ -395,12 +396,12 @@
 
 #if !defined(QT_NO_XIM)
-XIM		qt_xim			= 0;
+//XIM		qt_xim			= 0;
 XIMStyle	qt_xim_style		= 0;
+XIMStyle	qt_xim_preferred_style	= 0;
 static XIMStyle xim_default_style	= XIMPreeditCallbacks | XIMStatusNothing;
-static XIMStyle	xim_preferred_style	= 0;
 #endif
 
-static int composingKeycode=0;
-static QTextCodec * input_mapper = 0;
+int qt_ximComposingKeycode=0;
+QTextCodec * qt_input_mapper = 0;
 
 Q_EXPORT Time	qt_x_time = CurrentTime;
@@ -515,6 +516,5 @@
     void clearWFlags( WFlags f )	{ QWidget::clearWFlags(f); }
     bool translateMouseEvent( const XEvent * );
-    bool translateKeyEventInternal( const XEvent *, int& count, QString& text, int& state, char& ascii, int &code,
-				    QEvent::Type &type, bool willRepeat=FALSE );
+    bool translateKeyEventInternal( const XEvent *, int& count, QString& text, int& state, char& ascii, int &code, QEvent::Type &type, bool willRepeat=FALSE, bool statefulTranslation=TRUE );
     bool translateKeyEvent( const XEvent *, bool grab );
     bool translatePaintEvent( const XEvent * );
@@ -533,112 +533,118 @@
 
 // ************************************************************************
-// X Input Method support
+// Input Method support
 // ************************************************************************
 
-#if !defined(QT_NO_XIM)
+/*!
+    An identifier name of the default input method.
+*/
+QString	QApplication::defaultIM = "imsw-multi";
 
-#if defined(Q_C_CALLBACKS)
-extern "C" {
-#endif // Q_C_CALLBACKS
 
-#ifdef USE_X11R6_XIM
-    static void xim_create_callback(XIM /*im*/,
-				    XPointer /*client_data*/,
-				    XPointer /*call_data*/)
-    {
-	// qDebug("xim_create_callback");
-	QApplication::create_xim();
-    }
+/*!
+    This function handles the query about location of the widget
+    holding the QInputContext instance for widget \a w.
 
-    static void xim_destroy_callback(XIM /*im*/,
-				     XPointer /*client_data*/,
-				     XPointer /*call_data*/)
-    {
-	// qDebug("xim_destroy_callback");
-	QApplication::close_xim();
-	XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
-				       (XIMProc) xim_create_callback, 0);
-    }
+    The input context is used for text input to widget \a w. By
+    default, it returns the top-level widget of \a w.
 
-#endif // USE_X11R6_XIM
+    If you want to change the mapping of widget \w to QInputContext
+    instance, reimplement both this function and
+    QApplication::icHolderWidgets(). For example, suppose a tabbed web
+    browser. The browser should allocate a input context per tab
+    widget because users may switch the tabs and input a new text
+    during previous input contexts live.
 
-#if defined(Q_C_CALLBACKS)
+    See also 'Sharing input context between text widgets' and 'Preedit
+    preservation' section of the class description of QInputContext.
+
+    \sa QInputContext, icHolderWidgets()
+*/
+QWidget *QApplication::locateICHolderWidget( QWidget *w )
+{
+    return w->topLevelWidget();
 }
-#endif // Q_C_CALLBACKS
 
-#endif // QT_NO_XIM
 
+/*!
+    This function returns all widgets holding QInputContext.
 
-/*! \internal
-  Creates the application input method.
- */
-void QApplication::create_xim()
+    By default, This function returns top-level widgets. So if you
+    want to change the mapping of a widget to QInputContext instance,
+    you must override this function and locateICHolderWidget().
+
+    \sa locateICHolderWidget()
+*/
+QWidgetList *QApplication::icHolderWidgets()
 {
-#ifndef QT_NO_XIM
-    qt_xim = XOpenIM( appDpy, 0, 0, 0 );
-    if ( qt_xim ) {
+    return QApplication::topLevelWidgets();
+}
 
-#ifdef USE_X11R6_XIM
-	XIMCallback destroy;
-	destroy.callback = (XIMProc) xim_destroy_callback;
-	destroy.client_data = 0;
-	if ( XSetIMValues( qt_xim, XNDestroyCallback, &destroy, (char *) 0 ) != 0 )
-	    qWarning( "Xlib dosn't support destroy callback");
-#endif // USE_X11R6_XIM
-
-	XIMStyles *styles = 0;
-	XGetIMValues(qt_xim, XNQueryInputStyle, &styles, (char *) 0, (char *) 0);
-	if ( styles ) {
-	    int i;
-	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
-		if ( styles->supported_styles[i] == xim_preferred_style ) {
-		    qt_xim_style = xim_preferred_style;
-		    break;
-		}
-	    }
-	    // if the preferred input style couldn't be found, look for
-	    // Nothing
-	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
-		if ( styles->supported_styles[i] == (XIMPreeditNothing |
-						     XIMStatusNothing) ) {
-		    qt_xim_style = XIMPreeditNothing | XIMStatusNothing;
-		    break;
-		}
-	    }
-	    // ... and failing that, None.
-	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
-		if ( styles->supported_styles[i] == (XIMPreeditNone |
-						     XIMStatusNone) ) {
-		    qt_xim_style = XIMPreeditNone | XIMStatusNone;
-		    break;
-		}
-	    }
 
-	    // qDebug("QApplication: using im style %lx", qt_xim_style);
-	    XFree( (char *)styles );
-	}
+/*!
+    This function replaces all QInputContext instances in the
+    application. The function's argument is the identifier name of
+    the newly selected input method.
+*/
+void QApplication::changeAllInputContext( const QString &identifierName )
+{
+    QWidgetList *list = qApp->icHolderWidgets();
+    QWidgetListIt it(*list);
+    while(it.current()) {
+	it.current()->changeInputContext( identifierName );
+	++it;
+    }
+    delete list;
+
+    // defaultIM = identifierName ; // Change of defaultIM -- default input method -- may be enabled.
+}
 
-	if ( qt_xim_style ) {
 
-#ifdef USE_X11R6_XIM
-	    XUnregisterIMInstantiateCallback(appDpy, 0, 0, 0,
-					     (XIMProc) xim_create_callback, 0);
-#endif // USE_X11R6_XIM
-
-	    QWidgetList *list= qApp->topLevelWidgets();
-	    QWidgetListIt it(*list);
-	    QWidget * w;
-	    while( (w=it.current()) != 0 ) {
-		++it;
-		w->createTLSysExtra();
-	    }
-	    delete list;
-	} else {
-	    // Give up
-	    qWarning( "No supported input style found."
-		      "  See InputMethod documentation.");
-	    close_xim();
-	}
+/*!
+    \internal
+    This is an internal function, you should never call this.
+
+    \sa QInputContext::imEventGenerated()
+*/
+void QApplication::postIMEvent( QObject *receiver, QIMEvent *event )
+{
+    if ( event->type() == QEvent::IMCompose ) {
+	// enable event compression to reduce preedit flicker on fast
+	// typing
+	postEvent( receiver, event );
+    } else {
+	// cancel queued preedit update
+	if ( event->type() == QEvent::IMEnd )
+	    removePostedEvents( receiver, QEvent::IMCompose );
+
+	// to avoid event receiving order inversion between QKeyEvent
+	// and QIMEvent, we must send IMStart and IMEnd via
+	// sendEvent().
+	sendEvent( receiver, event );
+	delete event;
     }
+}
+
+
+/*!
+    This function returns the identifier name of the default input
+    method in this Application. The value is identical to the value of
+    QApplication::defaultIM.
+*/
+QString QApplication::defaultInputMethod()
+{
+    return QApplication::defaultIM;
+}
+
+
+#if !defined(QT_NO_IM_EXTENSIONS)
+/*! \internal
+    Creates the application input method.
+*/
+void QApplication::create_im()
+{
+#ifndef QT_NO_XIM
+    if ( ! qt_xim_preferred_style ) // no configured input style, use the default
+	qt_xim_preferred_style = xim_default_style;
 #endif // QT_NO_XIM
 }
@@ -648,4 +654,41 @@
   Closes the application input method.
 */
+void QApplication::close_im()
+{
+    QWidgetList *list = qApp->icHolderWidgets();
+    QWidgetListIt it(*list);
+    while(it.current()) {
+	it.current()->destroyInputContext();
+	++it;
+    }
+    delete list;
+}
+
+#else
+
+/*! \internal
+    Creates the application input method.
+*/
+void QApplication::create_xim()
+{
+#ifndef QT_NO_XIM
+    if ( ! qt_xim_preferred_style ) // no configured input style, use the default
+	qt_xim_preferred_style = xim_default_style;
+#endif // QT_NO_XIM
+
+    QWidgetList *list= qApp->topLevelWidgets();
+    QWidgetListIt it(*list);
+    QWidget * w;
+    while( (w=it.current()) != 0 ) {
+	++it;
+	w->createTLSysExtra();
+    }
+    delete list;
+}
+
+
+ /*! \internal
+   Closes the application input method.
+ */
 void QApplication::close_xim()
 {
@@ -655,5 +698,8 @@
     // We prefer a less serious memory leak
 
-    qt_xim = 0;
+    // if ( qt_xim )
+    // 	qt_xim = 0;
+
+#endif // QT_NO_XIM
     QWidgetList *list = qApp->topLevelWidgets();
     QWidgetListIt it(*list);
@@ -663,7 +709,6 @@
     }
     delete list;
-#endif // QT_NO_XIM
 }
-
+#endif
 
 /*****************************************************************************
@@ -1036,16 +1081,38 @@
 
 #ifndef QT_NO_XIM
-    if (xim_preferred_style == 0) {
+    if (qt_xim_preferred_style == 0) {
         QString ximInputStyle =
             settings.readEntry( "/qt/XIMInputStyle",
                                 QObject::trUtf8( "On The Spot" ) ).lower();
         if ( ximInputStyle == "on the spot" )
-            xim_preferred_style = XIMPreeditCallbacks | XIMStatusNothing;
+            qt_xim_preferred_style = XIMPreeditCallbacks | XIMStatusNothing;
         else if ( ximInputStyle == "over the spot" )
-            xim_preferred_style = XIMPreeditPosition | XIMStatusNothing;
+            qt_xim_preferred_style = XIMPreeditPosition | XIMStatusNothing;
         else if ( ximInputStyle == "off the spot" )
-            xim_preferred_style = XIMPreeditArea | XIMStatusArea;
+            qt_xim_preferred_style = XIMPreeditArea | XIMStatusArea;
         else if ( ximInputStyle == "root" )
-            xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
+            qt_xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
+    }
+#endif
+
+#ifndef QT_NO_IM
+    /*
+	The identifier name of an input method is acquired from the
+	configuration file as a default. If a environment variable
+	"QT_IM_SWITCHER" is not empty it will overwrite the
+	configuration file. The "imsw-multi" becomes the default if the entry
+	is not configured.
+     */
+    if ( getenv( "QT_IM_SWITCHER" ) )
+        defaultIM = getenv( "QT_IM_SWITCHER" );
+#ifndef QT_NO_IM_EXTENSIONS
+    else
+        defaultIM = settings.readEntry( "/qt/DefaultInputMethodSwitcher", "imsw-multi" );
+#endif
+
+    // defaultIM is restricted to be an IM-switcher. An IM-switcher
+    // has a 'imsw-' prefix
+    if ( ! defaultIM.startsWith( "imsw-" ) ) {
+	defaultIM = "imsw-multi";
     }
 #endif
@@ -1083,17 +1150,17 @@
 	// XIMs, and since we cannot get a sensible answer about the encoding
 	// from the XIM.
-	input_mapper = QTextCodec::codecForLocale();
+	qt_input_mapper = QTextCodec::codecForLocale();
 
     } else {
 	if ( !qstricmp( data, "locale" ) )
-	    input_mapper = QTextCodec::codecForLocale();
+	    qt_input_mapper = QTextCodec::codecForLocale();
 	else
-	    input_mapper = QTextCodec::codecForName( data );
+	    qt_input_mapper = QTextCodec::codecForName( data );
 	// make sure we have an input codec
-	if( !input_mapper )
-	    input_mapper = QTextCodec::codecForName( "ISO 8859-1" );
+	if( !qt_input_mapper )
+	    qt_input_mapper = QTextCodec::codecForName( "ISO 8859-1" );
     }
-    if ( input_mapper->mibEnum() == 11 ) // 8859-8
-	input_mapper = QTextCodec::codecForName( "ISO 8859-8-I");
+    if ( qt_input_mapper->mibEnum() == 11 ) // 8859-8
+	qt_input_mapper = QTextCodec::codecForName( "ISO 8859-8-I");
     if( data )
 	XFree( (char *)data );
@@ -1533,4 +1600,6 @@
 #define XK_MISCELLANY
 #define XK_LATIN1
+#define XK_KOREAN
+#define XK_XKB_KEYS
 #include <X11/keysymdef.h>
 
@@ -1623,8 +1692,5 @@
 	    } else if ( arg == "-im" ) {
 		if ( ++i < argc )
-		    ximServer = argv[i];
-	    } else if ( arg == "-noxim" ) {
-		noxim=TRUE;
-		//
+		    qt_ximServer = argv[i];
 	    } else if ( arg == "-iconic" ) {
 		mwIconic = !mwIconic;
@@ -1646,15 +1712,15 @@
 		    QCString s = QCString(argv[i]).lower();
 		    if ( s == "onthespot" )
-			xim_preferred_style = XIMPreeditCallbacks |
-					      XIMStatusNothing;
+			qt_xim_preferred_style = XIMPreeditCallbacks |
+						 XIMStatusNothing;
 		    else if ( s == "overthespot" )
-			xim_preferred_style = XIMPreeditPosition |
-					      XIMStatusNothing;
+			qt_xim_preferred_style = XIMPreeditPosition |
+						 XIMStatusNothing;
 		    else if ( s == "offthespot" )
-			xim_preferred_style = XIMPreeditArea |
-					      XIMStatusArea;
+			qt_xim_preferred_style = XIMPreeditArea |
+						 XIMStatusArea;
 		    else if ( s == "root" )
-			xim_preferred_style = XIMPreeditNothing |
-					      XIMStatusNothing;
+			qt_xim_preferred_style = XIMPreeditNothing |
+						 XIMStatusNothing;
 		}
 #endif
@@ -2104,32 +2170,11 @@
 	}
 
-#ifndef QT_NO_XIM
-	if ( ! xim_preferred_style ) // no configured input style, use the default
-	    xim_preferred_style = xim_default_style;
-
-	qt_xim = 0;
-	QString ximServerName(ximServer);
-	if (ximServer)
-	    ximServerName.prepend("@im=");
-	else
-	    ximServerName = "";
-
-	if ( !XSupportsLocale() )
-	    qWarning("Qt: Locales not supported on X server");
-
-#ifdef USE_X11R6_XIM
-	else if ( XSetLocaleModifiers (ximServerName.ascii()) == 0 )
-	    qWarning( "Qt: Cannot set locale modifiers: %s",
-		      ximServerName.ascii());
-	else if (! noxim)
-	    XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
-					   (XIMProc) xim_create_callback, 0);
-#else // !USE_X11R6_XIM
-	else if ( XSetLocaleModifiers ("") == 0 )
-	    qWarning("Qt: Cannot set locale modifiers");
-	else if (! noxim)
-	    QApplication::create_xim();
-#endif // USE_X11R6_XIM
-#endif // QT_NO_XIM
+#if !defined(QT_NO_IM)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    QApplication::create_im();
+#else
+    QApplication::create_xim();
+#endif
+#endif
 
 #if defined (QT_TABLET_SUPPORT)
@@ -2380,7 +2425,10 @@
 #endif
 
-#if !defined(QT_NO_XIM)
-    if ( qt_xim )
-	QApplication::close_xim();
+#if !defined(QT_NO_IM)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    QApplication::close_im();
+#else
+    QApplication::close_xim();
+#endif
 #endif
 
@@ -3241,75 +3289,57 @@
     }
 
-    int xkey_keycode = event->xkey.keycode;
-    if ( XFilterEvent( event,
-		       keywidget ? keywidget->topLevelWidget()->winId() : None ) ) {
-	if ( keywidget )
-	    composingKeycode = xkey_keycode; // ### not documented in xlib
-
-#ifndef QT_NO_XIM
- 	if ( event->type != XKeyPress || ! (qt_xim_style & XIMPreeditCallbacks) )
-	    return 1;
-
-	/*
-	 * The Solaris htt input method will transform a ClientMessage
-	 * event into a filtered KeyPress event, in which case our
-	 * keywidget is still zero.
-	 */
-        if ( ! keywidget ) {
- 	    keywidget = (QETWidget*)QWidget::keyboardGrabber();
-	    if ( keywidget ) {
-	        grabbed = TRUE;
-	    } else {
-	        if ( focus_widget )
-		    keywidget = (QETWidget*)focus_widget;
-	        if ( !keywidget ) {
-		    if ( inPopupMode() ) // no focus widget, see if we have a popup
-		        keywidget = (QETWidget*) activePopupWidget();
-		    else if ( widget )
-		        keywidget = (QETWidget*)widget->topLevelWidget();
-	        }
-	    }
-        }
+#ifndef QT_NO_IM
+    // Filtering input events by the input context. It has to be taken
+    // place before any other key event consumers such as eventfilters
+    // and accelerators because some input methods require quite
+    // various key combination and sequences. It often conflicts with
+    // accelerators and so on, so we must give the input context the
+    // filtering opportunity first to ensure all input methods work
+    // properly regardless of application design.
 
-	/*
-	  if the composition string has been emptied, we need to send
-	  an IMEnd event.  however, we have no way to tell if the user
-	  has cancelled input, or if the user has accepted the
-	  composition.
-
-	  so, we have to look for the next keypress and see if it is
-	  the 'commit' key press (keycode == 0).  if it is, we deliver
-	  an IMEnd event with the final text, otherwise we deliver an
-	  IMEnd with empty text (meaning the user has cancelled the
-	  input).
-	*/
-	QInputContext *qic =
-	    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
-	extern bool qt_compose_emptied; // qinputcontext_x11.cpp
-	if ( qic && qic->composing && qic->focusWidget && qt_compose_emptied ) {
-	    XEvent event2;
-	    bool found = FALSE;
-	    if ( XCheckTypedEvent( QPaintDevice::x11AppDisplay(),
-				   XKeyPress, &event2 ) ) {
-		if ( event2.xkey.keycode == 0 ) {
-		    // found a key event with the 'commit' string
-		    found = TRUE;
-		    XPutBackEvent( QPaintDevice::x11AppDisplay(), &event2 );
-		}
-	    }
+#ifndef QT_NO_IM_EXTENSIONS
+    if( keywidget && keywidget->isEnabled() && keywidget->isInputMethodEnabled() ) {
+#else
+    if( keywidget && keywidget->isEnabled() ) {
+#endif
+	if( ( event->type==XKeyPress || event->type==XKeyRelease ) &&
+	    sm_blockUserInput ) // block user interaction during session management
+	    return TRUE;
 
-	    if ( !found ) {
-		// no key event, so the user must have cancelled the composition
-		QIMEvent endevent( QEvent::IMEnd, QString::null, -1 );
-		QApplication::sendEvent( qic->focusWidget, &endevent );
+        // for XIM handling
+	QInputContext *qic = keywidget->getInputContext();
+	if( qic && qic->x11FilterEvent( keywidget, event ) )
+	    return TRUE;
 
-		qic->focusWidget = 0;
-	    }
+	// filterEvent() accepts QEvent *event rather than preexpanded key
+	// event attribute values. This is intended to pass other IM-related
+	// events in future. The IM-related events are supposed as
+	// QWheelEvent, QTabletEvent and so on. Other non IM-related events
+	// should not be forwarded to input contexts to prevent weird event
+	// handling.
+	if ( ( event->type == XKeyPress || event->type == XKeyRelease ) ) {
+	    int code = -1;
+	    int count = 0;
+	    int state;
+	    char ascii = 0;
+	    QEvent::Type type;
+	    QString text;
+
+	    keywidget->translateKeyEventInternal( event, count, text,
+						  state, ascii, code, type,
+						  FALSE, FALSE );
+
+	    // both key press/release is required for some complex
+	    // input methods. don't eliminate anything.
+	    QKeyEvent keyevent( type, code, ascii, state, text, FALSE, count );
 
-	    qt_compose_emptied = FALSE;
+	    if( qic && qic->filterEvent( &keyevent ) )
+		return TRUE;
 	}
-#endif // QT_NO_XIM
-
-	return 1;
+    } else
+#endif // QT_NO_IM
+    {
+	if ( XFilterEvent( event, None ) )
+	    return TRUE;
     }
 
@@ -3462,32 +3492,6 @@
 	{
 	    if ( keywidget && keywidget->isEnabled() ) { // should always exist
-#ifndef QT_NO_XIM
-		QInputContext *qic =
-		    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
-
-		if ((qt_xim_style & XIMPreeditCallbacks) && event->xkey.keycode == 0 &&
-		    qic && qic->composing && qic->focusWidget) {
-		    // input method has sent us a commit string
-		    QCString data(513);
-		    KeySym sym;    // unused
-		    Status status; // unused
-		    QString text;
-		    int count = qic->lookupString( &(event->xkey), data,
-						   &sym, &status );
-		    if ( count > 0 )
-			text = input_mapper->toUnicode( data, count );
-
-		    // qDebug( "sending IMEnd with %d chars", text.length() );
-		    QIMEvent endevent( QEvent::IMEnd, text, -1 );
-		    QApplication::sendEvent( qic->focusWidget, &endevent );
-
-		    qic->focusWidget = 0;
-		    qic->text = QString::null;
-		} else
-#endif // !QT_NO_XIM
-		    {
-			// qDebug( "sending key event" );
-			keywidget->translateKeyEvent( event, grabbed );
-		    }
+	        // qDebug( "sending key event" );
+	        keywidget->translateKeyEvent( event, grabbed );
 	    }
 	    break;
@@ -4784,4 +4788,90 @@
     0x1005FF11,         Qt::Key_F12,         // hardcoded Sun F37 (labeled F12)
 
+    // International input method support keys
+
+    // International & multi-key character composition
+    XK_Multi_key,		Qt::Key_Multi_key,
+    XK_Codeinput,		Qt::Key_Codeinput,
+    XK_SingleCandidate,		Qt::Key_SingleCandidate,
+    XK_MultipleCandidate,	Qt::Key_MultipleCandidate,
+    XK_PreviousCandidate,	Qt::Key_PreviousCandidate,
+
+    // Misc Functions
+    XK_Mode_switch,		Qt::Key_Mode_switch,
+    //XK_script_switch,		Qt::Key_script_switch,
+    XK_script_switch,		Qt::Key_Mode_switch,
+
+    // Japanese keyboard support
+    XK_Kanji,			Qt::Key_Kanji,
+    XK_Muhenkan,		Qt::Key_Muhenkan,
+    //XK_Henkan_Mode,		Qt::Key_Henkan_Mode,
+    XK_Henkan_Mode,		Qt::Key_Henkan,
+    XK_Henkan,			Qt::Key_Henkan,
+    XK_Romaji,			Qt::Key_Romaji,
+    XK_Hiragana,		Qt::Key_Hiragana,
+    XK_Katakana,		Qt::Key_Katakana,
+    XK_Hiragana_Katakana,	Qt::Key_Hiragana_Katakana,
+    XK_Zenkaku,			Qt::Key_Zenkaku,
+    XK_Hankaku,			Qt::Key_Hankaku,
+    XK_Zenkaku_Hankaku,		Qt::Key_Zenkaku_Hankaku,
+    XK_Touroku,			Qt::Key_Touroku,
+    XK_Massyo,			Qt::Key_Massyo,
+    XK_Kana_Lock,		Qt::Key_Kana_Lock,
+    XK_Kana_Shift,		Qt::Key_Kana_Shift,
+    XK_Eisu_Shift,		Qt::Key_Eisu_Shift,
+    XK_Eisu_toggle,		Qt::Key_Eisu_toggle,
+    //XK_Kanji_Bangou,		Qt::Key_Kanji_Bangou,
+    //XK_Zen_Koho,		Qt::Key_Zen_Koho,
+    //XK_Mae_Koho,		Qt::Key_Mae_Koho,
+    XK_Kanji_Bangou,		Qt::Key_Codeinput,
+    XK_Zen_Koho,		Qt::Key_MultipleCandidate,
+    XK_Mae_Koho,		Qt::Key_PreviousCandidate,
+
+#ifdef XK_KOREAN
+    // Korean keyboard support
+    XK_Hangul,			Qt::Key_Hangul,
+    XK_Hangul_Start,		Qt::Key_Hangul_Start,
+    XK_Hangul_End,		Qt::Key_Hangul_End,
+    XK_Hangul_Hanja,		Qt::Key_Hangul_Hanja,
+    XK_Hangul_Jamo,		Qt::Key_Hangul_Jamo,
+    XK_Hangul_Romaja,		Qt::Key_Hangul_Romaja,
+    //XK_Hangul_Codeinput,	Qt::Key_Hangul_Codeinput,
+    XK_Hangul_Codeinput,	Qt::Key_Codeinput,
+    XK_Hangul_Jeonja,		Qt::Key_Hangul_Jeonja,
+    XK_Hangul_Banja,		Qt::Key_Hangul_Banja,
+    XK_Hangul_PreHanja,		Qt::Key_Hangul_PreHanja,
+    XK_Hangul_PostHanja,	Qt::Key_Hangul_PostHanja,
+    //XK_Hangul_SingleCandidate,	Qt::Key_Hangul_SingleCandidate,
+    //XK_Hangul_MultipleCandidate, Qt::Key_Hangul_MultipleCandidate,
+    //XK_Hangul_PreviousCandidate, Qt::Key_Hangul_PreviousCandidate,
+    XK_Hangul_SingleCandidate,	Qt::Key_SingleCandidate,
+    XK_Hangul_MultipleCandidate, Qt::Key_MultipleCandidate,
+    XK_Hangul_PreviousCandidate, Qt::Key_PreviousCandidate,
+    XK_Hangul_Special,		Qt::Key_Hangul_Special,
+    //XK_Hangul_switch,		Qt::Key_Hangul_switch,
+    XK_Hangul_switch,		Qt::Key_Mode_switch,
+#endif  // XK_KOREAN
+
+    // dead keys
+    XK_dead_grave,              Qt::Key_Dead_Grave,
+    XK_dead_acute,              Qt::Key_Dead_Acute,
+    XK_dead_circumflex,         Qt::Key_Dead_Circumflex,
+    XK_dead_tilde,              Qt::Key_Dead_Tilde,
+    XK_dead_macron,             Qt::Key_Dead_Macron,
+    XK_dead_breve,              Qt::Key_Dead_Breve,
+    XK_dead_abovedot,           Qt::Key_Dead_Abovedot,
+    XK_dead_diaeresis,          Qt::Key_Dead_Diaeresis,
+    XK_dead_abovering,          Qt::Key_Dead_Abovering,
+    XK_dead_doubleacute,        Qt::Key_Dead_Doubleacute,
+    XK_dead_caron,              Qt::Key_Dead_Caron,
+    XK_dead_cedilla,            Qt::Key_Dead_Cedilla,
+    XK_dead_ogonek,             Qt::Key_Dead_Ogonek,
+    XK_dead_iota,               Qt::Key_Dead_Iota,
+    XK_dead_voiced_sound,       Qt::Key_Dead_Voiced_Sound,
+    XK_dead_semivoiced_sound,   Qt::Key_Dead_Semivoiced_Sound,
+    XK_dead_belowdot,           Qt::Key_Dead_Belowdot,
+    XK_dead_hook,               Qt::Key_Dead_Hook,
+    XK_dead_horn,               Qt::Key_Dead_Horn,
+
     // Special multimedia keys
     // currently only tested with MS internet keyboard
@@ -5001,7 +5091,7 @@
 					   QString& text,
 					   int& state,
-					   char& ascii, int& code, QEvent::Type &type, bool willRepeat )
+					   char& ascii, int& code, QEvent::Type &type, bool willRepeat, bool statefulTranslation )
 {
-    QTextCodec *mapper = input_mapper;
+    QTextCodec *mapper = qt_input_mapper;
     // some XmbLookupString implementations don't return buffer overflow correctly,
     // so we increase the input buffer to allow for long strings...
@@ -5050,4 +5140,9 @@
     if ( type == QEvent::KeyPress ) {
 	bool mb=FALSE;
+	// commit string handling is done by
+	// QXIMInputContext::x11FilterEvent() and are passed to
+	// widgets via QIMEvent regardless of XIM style, so the
+	// following code is commented out.
+#if 0
 	if ( qt_xim ) {
 	    QTLWExtra*  xd = tlw->topData();
@@ -5058,4 +5153,5 @@
 	    }
 	}
+#endif
 	if ( !mb ) {
 	    count = XLookupString( &xkeyevent,
@@ -5063,6 +5159,6 @@
 	}
 	if ( count && !keycode ) {
-	    keycode = composingKeycode;
-	    composingKeycode = 0;
+	    keycode = qt_ximComposingKeycode;
+	    qt_ximComposingKeycode = 0;
 	}
 	if ( key )
@@ -5141,5 +5237,6 @@
 
     static int directionKeyEvent = 0;
-    if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
+    static unsigned int lastWinId = 0;
+    if ( qt_use_rtl_extensions && type == QEvent::KeyRelease && statefulTranslation ) {
 	if (directionKeyEvent == Key_Direction_R || directionKeyEvent == Key_Direction_L ) {
 	    type = QEvent::KeyPress;
@@ -5147,7 +5244,9 @@
 	    chars[0] = 0;
 	    directionKeyEvent = 0;
+	    lastWinId = 0;
 	    return TRUE;
 	} else {
 	    directionKeyEvent = 0;
+	    lastWinId = 0;
 	}
     }
@@ -5159,8 +5258,12 @@
     // or Shift is held while Ctrl is pressed) since the 'state' doesn't tell
     // us whether the modifier held is Left or Right.
-    if (qt_use_rtl_extensions && type  == QEvent::KeyPress)
+    if ( qt_use_rtl_extensions && type  == QEvent::KeyPress && statefulTranslation )
         if (key == XK_Control_L || key == XK_Control_R || key == XK_Shift_L || key == XK_Shift_R) {
-           if (!directionKeyEvent)
+	    if (!directionKeyEvent) {
 	      directionKeyEvent = key;
+	      // This code exists in order to check that 
+	      // the event is occurred in the same widget.
+	      lastWinId = winId();
+	    }
         } else {
            // this can no longer be a direction-changing accel.
@@ -5176,5 +5279,5 @@
     // QKeyEvent::text().
     //
-    if ( key < 128 || (key < 256 && (!input_mapper || input_mapper->mibEnum()==4)) ) {
+    if ( key < 128 || (key < 256 && (!qt_input_mapper || qt_input_mapper->mibEnum()==4)) ) {
 	code = isprint((int)key) ? toupper((int)key) : 0; // upper-case key, if known
     } else if ( key >= XK_F1 && key <= XK_F35 ) {
@@ -5227,6 +5330,6 @@
 	}
 
-	if ( qt_use_rtl_extensions && type  == QEvent::KeyPress ) {
-	    if ( directionKeyEvent ) {
+	if ( qt_use_rtl_extensions && type  == QEvent::KeyPress && statefulTranslation ) {
+	    if ( directionKeyEvent && lastWinId == winId() ) {
 		if ( key == XK_Shift_L && directionKeyEvent == XK_Control_L ||
 		     key == XK_Control_L && directionKeyEvent == XK_Shift_L ) {
@@ -5404,6 +5507,32 @@
     }
 
+#ifndef QT_NO_IM
+    QInputContext *qic = getInputContext();
+#endif
+
     // compress keys
     if ( !text.isEmpty() && testWState(WState_CompressKeys) &&
+#ifndef QT_NO_IM
+	 // Ordinary input methods require discrete key events to work
+	 // properly, so key compression has to be disabled when input
+	 // context exists.
+	 //
+	 // And further consideration, some complex input method
+	 // require all key press/release events discretely even if
+	 // the input method awares of key compression and compressed
+	 // keys are ordinary alphabets. For example, the uim project
+	 // is planning to implement "combinational shift" feature for
+	 // a Japanese input method, uim-skk. It will work as follows.
+	 //
+	 // 1. press "r"
+	 // 2. press "u"
+	 // 3. release both "r" and "u" in arbitrary order
+	 // 4. above key sequence generates "Ru"
+	 //
+	 // Of course further consideration about other participants
+	 // such as key repeat mechanism is required to implement such
+	 // feature.
+	 ! qic &&
+#endif // QT_NO_IM
 	 // do not compress keys if the key event we just got above matches
 	 // one of the key ranges used to compute stopCompression
@@ -5464,5 +5593,10 @@
     // autorepeat compression makes sense for all widgets (Windows
     // does it automatically .... )
-    if ( event->type == XKeyPress && text.length() <= 1 ) {
+    if ( event->type == XKeyPress && text.length() <= 1
+#ifndef QT_NO_IM
+	 // input methods need discrete key events
+	 && ! qic
+#endif// QT_NO_IM
+	 ) {
 	XEvent dummy;
 
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp.orig qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qapplication_x11.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,6443 @@
+/****************************************************************************
+**
+** Implementation of X11 startup routines and event handling
+**
+** Created : 931029
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+// ### 4.0: examine Q_EXPORT's below. The respective symbols had all
+// been in use (e.g. in the KDE wm ) before the introduction of a version
+// map. One might want to turn some of them into propert public API and
+// provide a proper alternative for others. See also the exports in
+// qapplication_win.cpp which suggest a unification.
+
+// ### needed for solaris-g++ in beta5
+#define QT_CLEAN_NAMESPACE
+
+#include "qplatformdefs.h"
+
+// POSIX Large File Support redefines open -> open64
+#if defined(open)
+# undef open
+#endif
+
+// Solaris redefines connect -> __xnet_connect with _XOPEN_SOURCE_EXTENDED.
+#if defined(connect)
+# undef connect
+#endif
+
+// POSIX Large File Support redefines truncate -> truncate64
+#if defined(truncate)
+# undef truncate
+#endif
+
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qcolor_p.h"
+#include "qcursor.h"
+#include "qwidget.h"
+#include "qwidget_p.h"
+#include "qobjectlist.h"
+#include "qwidgetlist.h"
+#include "qwidgetintdict.h"
+#include "qbitarray.h"
+#include "qpainter.h"
+#include "qpixmapcache.h"
+#include "qdatetime.h"
+#include "qtextcodec.h"
+#include "qdatastream.h"
+#include "qbuffer.h"
+#include "qsocketnotifier.h"
+#include "qsessionmanager.h"
+#include "qvaluelist.h"
+#include "qdict.h"
+#include "qguardedptr.h"
+#include "qclipboard.h"
+#include "qwhatsthis.h" // ######## dependency
+#include "qsettings.h"
+#include "qstylefactory.h"
+#include "qfileinfo.h"
+
+// Input method stuff - UNFINISHED
+#include "qinputcontext_p.h"
+#include "qinternal_p.h" // shared double buffer cleanup
+
+#if defined(QT_THREAD_SUPPORT)
+# include "qthread.h"
+#endif
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+# include "qfile.h"
+#endif
+
+#include "qt_x11_p.h"
+
+#if !defined(QT_NO_XFTFREETYPE)
+// XFree86 4.0.3 implementation is missing XftInitFtLibrary forward
+extern "C" Bool XftInitFtLibrary(void);
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <locale.h>
+
+//#define X_NOT_BROKEN
+#ifdef X_NOT_BROKEN
+// Some X libraries are built with setlocale #defined to _Xsetlocale,
+// even though library users are then built WITHOUT such a definition.
+// This creates a problem - Qt might setlocale() one value, but then
+// X looks and doesn't see the value Qt set. The solution here is to
+// implement _Xsetlocale just in case X calls it - redirecting it to
+// the real libC version.
+//
+# ifndef setlocale
+extern "C" char *_Xsetlocale(int category, const char *locale);
+char *_Xsetlocale(int category, const char *locale)
+{
+    //qDebug("_Xsetlocale(%d,%s),category,locale");
+    return setlocale(category,locale);
+}
+# endif // setlocale
+#endif // X_NOT_BROKEN
+
+
+// resolve the conflict between X11's FocusIn and QEvent::FocusIn
+const int XFocusOut = FocusOut;
+const int XFocusIn = FocusIn;
+#undef FocusOut
+#undef FocusIn
+
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
+#undef KeyPress
+#undef KeyRelease
+
+
+// Fix old X libraries
+#ifndef XK_KP_Home
+#define XK_KP_Home              0xFF95
+#endif
+#ifndef XK_KP_Left
+#define XK_KP_Left              0xFF96
+#endif
+#ifndef XK_KP_Up
+#define XK_KP_Up                0xFF97
+#endif
+#ifndef XK_KP_Right
+#define XK_KP_Right             0xFF98
+#endif
+#ifndef XK_KP_Down
+#define XK_KP_Down              0xFF99
+#endif
+#ifndef XK_KP_Prior
+#define XK_KP_Prior             0xFF9A
+#endif
+#ifndef XK_KP_Next
+#define XK_KP_Next              0xFF9B
+#endif
+#ifndef XK_KP_End
+#define XK_KP_End               0xFF9C
+#endif
+#ifndef XK_KP_Insert
+#define XK_KP_Insert            0xFF9E
+#endif
+#ifndef XK_KP_Delete
+#define XK_KP_Delete            0xFF9F
+#endif
+
+
+/*****************************************************************************
+  Internal variables and functions
+ *****************************************************************************/
+static const char *appName;			// application name
+static const char *appClass;			// application class
+static const char *appFont	= 0;		// application font
+static const char *appBGCol	= 0;		// application bg color
+static const char *appFGCol	= 0;		// application fg color
+static const char *appBTNCol	= 0;		// application btn color
+static const char *mwGeometry	= 0;		// main widget geometry
+static const char *mwTitle	= 0;		// main widget title
+//Ming-Che 10/10
+static char    *ximServer	= 0;		// XIM Server will connect to
+static bool	mwIconic	= FALSE;	// main widget iconified
+//Ming-Che 10/10
+static bool	noxim		= FALSE;	// connect to xim or not
+static Display *appDpy		= 0;		// X11 application display
+static char    *appDpyName	= 0;		// X11 display name
+static bool	appForeignDpy	= FALSE;        // we didn't create display
+static bool	appSync		= FALSE;	// X11 synchronization
+#if defined(QT_DEBUG)
+static bool	appNoGrab	= FALSE;	// X11 grabbing enabled
+static bool	appDoGrab	= FALSE;	// X11 grabbing override (gdb)
+#endif
+static int	appScreen;			// X11 screen number
+static int	appScreenCount;			// X11 screen count
+static bool	app_save_rootinfo = FALSE;	// save root info
+static bool	app_do_modal	= FALSE;	// modal mode
+static Window	curWin = 0;			// current window
+
+static GC*	app_gc_ro	= 0;		// read-only GC
+static GC*	app_gc_tmp	= 0;		// temporary GC
+static GC*	app_gc_ro_m	= 0;		// read-only GC (monochrome)
+static GC*	app_gc_tmp_m	= 0;		// temporary GC (monochrome)
+// symbols needed by extern QXEmbed class
+Q_EXPORT Atom	qt_wm_protocols		= 0;	// window manager protocols
+Q_EXPORT Atom	qt_wm_delete_window	= 0;	// delete window protocol
+Q_EXPORT Atom	qt_wm_take_focus	= 0;	// take focus window protocol
+
+Atom		qt_qt_scrolldone	= 0;	// scroll synchronization
+Atom		qt_net_wm_context_help	= 0;	// context help
+Atom		qt_net_wm_ping		= 0;	// _NET_WM_PING protocol
+
+static Atom	qt_xsetroot_id		= 0;
+Atom            qt_xa_clipboard         = 0;
+Atom		qt_selection_property	= 0;
+Atom            qt_clipboard_sentinel   = 0;
+Atom		qt_selection_sentinel	= 0;
+Q_EXPORT Atom	qt_wm_state		= 0;
+Atom		qt_wm_change_state	= 0;
+static Atom     qt_settings_timestamp	= 0;    // Qt >=3 settings timestamp
+static Atom	qt_input_encoding	= 0;	// Qt desktop properties
+static Atom	qt_resource_manager	= 0;	// X11 Resource manager
+Atom		qt_sizegrip		= 0;	// sizegrip
+Atom		qt_wm_client_leader	= 0;
+Q_EXPORT Atom	qt_window_role		= 0;
+Q_EXPORT Atom	qt_sm_client_id		= 0;
+Atom		qt_xa_motif_wm_hints	= 0;
+Atom		qt_cde_running		= 0;
+Atom		qt_kwin_running	= 0;
+Atom		qt_kwm_running	= 0;
+Atom		qt_gbackground_properties	= 0;
+Atom		qt_x_incr		= 0;
+Atom		qt_utf8_string = 0;
+
+// detect broken window managers
+Atom            qt_sgi_desks_manager    = 0;
+bool		qt_broken_wm		= FALSE;
+static void qt_detect_broken_window_manager();
+
+// NET WM support
+Atom		qt_net_supported	= 0;
+Atom		qt_net_wm_name		= 0;
+Atom		qt_net_wm_icon_name	= 0;
+Atom		qt_net_virtual_roots	= 0;
+Atom		qt_net_workarea		= 0;
+Atom		qt_net_wm_state		= 0;
+Atom		qt_net_wm_state_modal	= 0;
+Atom		qt_net_wm_state_max_v	= 0;
+Atom		qt_net_wm_state_max_h	= 0;
+Atom		qt_net_wm_state_fullscreen = 0;
+Atom		qt_net_wm_state_above	= 0;
+Atom            qt_net_wm_window_type   = 0;
+Atom            qt_net_wm_window_type_normal	= 0;
+Atom            qt_net_wm_window_type_dialog	= 0;
+Atom            qt_net_wm_window_type_toolbar	= 0;
+Atom		qt_net_wm_window_type_menu	= 0;
+Atom		qt_net_wm_window_type_utility	= 0;
+Atom            qt_net_wm_window_type_splash    = 0;
+Atom            qt_net_wm_window_type_override	= 0;	// KDE extension
+Atom		qt_net_wm_frame_strut		= 0;	// KDE extension
+Atom		qt_net_wm_state_stays_on_top	= 0;	// KDE extension
+Atom		qt_net_wm_pid		= 0;
+Atom		qt_net_wm_user_time	= 0;
+// Enlightenment support
+Atom		qt_enlightenment_desktop	= 0;
+
+// window managers list of supported "stuff"
+Atom		*qt_net_supported_list	= 0;
+// list of virtual root windows
+Window		*qt_net_virtual_root_list	= 0;
+
+
+
+// client leader window
+Window qt_x11_wm_client_leader = 0;
+
+// function to update the workarea of the screen - in qdesktopwidget_x11.cpp
+extern void qt_desktopwidget_update_workarea();
+
+// current focus model
+static const int FocusModel_Unknown = -1;
+static const int FocusModel_Other = 0;
+static const int FocusModel_PointerRoot = 1;
+static int qt_focus_model = -1;
+
+#ifndef QT_NO_XRANDR
+// TRUE if Qt is compiled w/ XRandR support and XRandR exists on the connected
+// Display
+bool	qt_use_xrandr	= FALSE;
+static int xrandr_eventbase;
+#endif
+
+// TRUE if Qt is compiled w/ XRender support and XRender exists on the connected
+// Display
+Q_EXPORT bool qt_use_xrender = FALSE;
+
+// modifier masks for alt/meta - detected when the application starts
+static long qt_alt_mask = 0;
+static long qt_meta_mask = 0;
+// modifier mask to remove mode switch from modifiers that have alt/meta set
+// this problem manifests itself on HP/UX 10.20 at least, and without it
+// modifiers do not work at all...
+static long qt_mode_switch_remove_mask = 0;
+
+// flags for extensions for special Languages, currently only for RTL languages
+static bool 	qt_use_rtl_extensions = FALSE;
+bool qt_hebrew_keyboard_hack = FALSE;
+
+static Window	mouseActWindow	     = 0;	// window where mouse is
+static int	mouseButtonPressed   = 0;	// last mouse button pressed
+static int	mouseButtonState     = 0;	// mouse button state
+static Time	mouseButtonPressTime = 0;	// when was a button pressed
+static short	mouseXPos, mouseYPos;		// mouse pres position in act window
+static short	mouseGlobalXPos, mouseGlobalYPos; // global mouse press position
+
+extern QWidgetList *qt_modal_stack;		// stack of modal widgets
+static bool	    ignoreNextMouseReleaseEvent = FALSE; // ignore the next mouse release
+							 // event if return from a modal
+							 // widget
+
+static QWidget     *popupButtonFocus = 0;
+static QWidget     *popupOfPopupButtonFocus = 0;
+static bool	    popupCloseDownMode = FALSE;
+static bool	    popupGrabOk;
+
+static bool sm_blockUserInput = FALSE;		// session management
+
+int qt_xfocusout_grab_counter = 0;
+
+#if defined (QT_TABLET_SUPPORT)
+// since XInput event classes aren't created until we actually open an XInput
+// device, here is a static list that we will use later on...
+const int INVALID_EVENT = -1;
+const int TOTAL_XINPUT_EVENTS = 7;
+
+XDevice *devStylus = NULL;
+XDevice *devEraser = NULL;
+XEventClass event_list_stylus[TOTAL_XINPUT_EVENTS];
+XEventClass event_list_eraser[TOTAL_XINPUT_EVENTS];
+
+int qt_curr_events_stylus = 0;
+int qt_curr_events_eraser = 0;
+
+// well, luckily we only need to do this once.
+static int xinput_motion = INVALID_EVENT;
+static int xinput_key_press = INVALID_EVENT;
+static int xinput_key_release = INVALID_EVENT;
+static int xinput_button_press = INVALID_EVENT;
+static int xinput_button_release = INVALID_EVENT;
+
+// making this assumption on XFree86, since we can only use 1 device,
+// the pressure for the eraser and the stylus should be the same, if they aren't
+// well, they certainly have a strange pen then...
+static int max_pressure;
+extern bool chokeMouse;
+#endif
+
+// last timestamp read from QSettings
+static uint appliedstamp = 0;
+
+
+typedef int (*QX11EventFilter) (XEvent*);
+QX11EventFilter qt_set_x11_event_filter(QX11EventFilter filter);
+
+static QX11EventFilter qt_x11_event_filter = 0;
+Q_EXPORT QX11EventFilter qt_set_x11_event_filter(QX11EventFilter filter)
+{
+    QX11EventFilter old_filter = qt_x11_event_filter;
+    qt_x11_event_filter = filter;
+    return old_filter;
+}
+static bool qt_x11EventFilter( XEvent* ev )
+{
+    if ( qt_x11_event_filter  && qt_x11_event_filter( ev )  )
+	return TRUE;
+    return qApp->x11EventFilter( ev );
+}
+
+
+
+
+
+#if !defined(QT_NO_XIM)
+XIM		qt_xim			= 0;
+XIMStyle	qt_xim_style		= 0;
+static XIMStyle xim_default_style	= XIMPreeditCallbacks | XIMStatusNothing;
+static XIMStyle	xim_preferred_style	= 0;
+#endif
+
+static int composingKeycode=0;
+static QTextCodec * input_mapper = 0;
+
+Q_EXPORT Time	qt_x_time = CurrentTime;
+Q_EXPORT Time	qt_x_user_time = CurrentTime;
+extern bool     qt_check_clipboard_sentinel(); //def in qclipboard_x11.cpp
+extern bool	qt_check_selection_sentinel(); //def in qclipboard_x11.cpp
+
+static void	qt_save_rootinfo();
+bool	qt_try_modal( QWidget *, XEvent * );
+
+int		qt_ncols_option  = 216;		// used in qcolor_x11.cpp
+int		qt_visual_option = -1;
+bool		qt_cmap_option	 = FALSE;
+QWidget	       *qt_button_down	 = 0;		// widget got last button-down
+
+extern bool qt_tryAccelEvent( QWidget*, QKeyEvent* ); // def in qaccel.cpp
+
+struct QScrollInProgress {
+    static long serial;
+    QScrollInProgress( QWidget* w, int x, int y ) :
+    id( serial++ ), scrolled_widget( w ), dx( x ), dy( y ) {}
+    long id;
+    QWidget* scrolled_widget;
+    int dx, dy;
+};
+long QScrollInProgress::serial=0;
+static QPtrList<QScrollInProgress> *sip_list = 0;
+
+
+// stuff in qt_xdnd.cpp
+// setup
+extern void qt_xdnd_setup();
+// x event handling
+extern void qt_handle_xdnd_enter( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_position( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_status( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_leave( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_drop( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_finished( QWidget *, const XEvent *, bool );
+extern void qt_xdnd_handle_selection_request( const XSelectionRequestEvent * );
+extern bool qt_xdnd_handle_badwindow();
+
+extern void qt_motifdnd_handle_msg( QWidget *, const XEvent *, bool );
+extern void qt_x11_motifdnd_init();
+
+// client message atoms
+extern Atom qt_xdnd_enter;
+extern Atom qt_xdnd_position;
+extern Atom qt_xdnd_status;
+extern Atom qt_xdnd_leave;
+extern Atom qt_xdnd_drop;
+extern Atom qt_xdnd_finished;
+// xdnd selection atom
+extern Atom qt_xdnd_selection;
+extern bool qt_xdnd_dragging;
+
+// gui or non-gui from qapplication.cpp
+extern bool qt_is_gui_used;
+extern bool qt_app_has_font;
+
+static bool qt_x11_cmdline_font = false;
+
+
+extern bool qt_resolve_symlinks; // from qapplication.cpp
+
+// Paint event clipping magic
+extern void qt_set_paintevent_clipping( QPaintDevice* dev, const QRegion& region);
+extern void qt_clear_paintevent_clipping();
+
+
+// Palette handling
+extern QPalette *qt_std_pal;
+extern void qt_create_std_palette();
+
+void qt_x11_intern_atom( const char *, Atom * );
+
+static QPtrList<QWidget>* deferred_map_list = 0;
+static void qt_deferred_map_cleanup()
+{
+    delete deferred_map_list;
+    deferred_map_list = 0;
+}
+void qt_deferred_map_add( QWidget* w)
+{
+    if ( !deferred_map_list ) {
+	deferred_map_list = new QPtrList<QWidget>;
+	qAddPostRoutine( qt_deferred_map_cleanup );
+    }
+    deferred_map_list->append( w );
+}
+void qt_deferred_map_take( QWidget* w )
+{
+    if (deferred_map_list ) {
+	deferred_map_list->remove( w );
+    }
+}
+bool qt_deferred_map_contains( QWidget* w )
+{
+    if (!deferred_map_list)
+	return FALSE;
+    else
+	return deferred_map_list->contains( w );
+}
+
+
+class QETWidget : public QWidget		// event translator widget
+{
+public:
+    void setWState( WFlags f )		{ QWidget::setWState(f); }
+    void clearWState( WFlags f )	{ QWidget::clearWState(f); }
+    void setWFlags( WFlags f )		{ QWidget::setWFlags(f); }
+    void clearWFlags( WFlags f )	{ QWidget::clearWFlags(f); }
+    bool translateMouseEvent( const XEvent * );
+    bool translateKeyEventInternal( const XEvent *, int& count, QString& text, int& state, char& ascii, int &code,
+				    QEvent::Type &type, bool willRepeat=FALSE );
+    bool translateKeyEvent( const XEvent *, bool grab );
+    bool translatePaintEvent( const XEvent * );
+    bool translateConfigEvent( const XEvent * );
+    bool translateCloseEvent( const XEvent * );
+    bool translateScrollDoneEvent( const XEvent * );
+    bool translateWheelEvent( int global_x, int global_y, int delta, int state, Orientation orient );
+#if defined (QT_TABLET_SUPPORT)
+    bool translateXinputEvent( const XEvent* );
+#endif
+    bool translatePropertyEvent(const XEvent *);
+};
+
+
+
+
+// ************************************************************************
+// X Input Method support
+// ************************************************************************
+
+#if !defined(QT_NO_XIM)
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif // Q_C_CALLBACKS
+
+#ifdef USE_X11R6_XIM
+    static void xim_create_callback(XIM /*im*/,
+				    XPointer /*client_data*/,
+				    XPointer /*call_data*/)
+    {
+	// qDebug("xim_create_callback");
+	QApplication::create_xim();
+    }
+
+    static void xim_destroy_callback(XIM /*im*/,
+				     XPointer /*client_data*/,
+				     XPointer /*call_data*/)
+    {
+	// qDebug("xim_destroy_callback");
+	QApplication::close_xim();
+	XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
+				       (XIMProc) xim_create_callback, 0);
+    }
+
+#endif // USE_X11R6_XIM
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif // Q_C_CALLBACKS
+
+#endif // QT_NO_XIM
+
+
+/*! \internal
+  Creates the application input method.
+ */
+void QApplication::create_xim()
+{
+#ifndef QT_NO_XIM
+    qt_xim = XOpenIM( appDpy, 0, 0, 0 );
+    if ( qt_xim ) {
+
+#ifdef USE_X11R6_XIM
+	XIMCallback destroy;
+	destroy.callback = (XIMProc) xim_destroy_callback;
+	destroy.client_data = 0;
+	if ( XSetIMValues( qt_xim, XNDestroyCallback, &destroy, (char *) 0 ) != 0 )
+	    qWarning( "Xlib dosn't support destroy callback");
+#endif // USE_X11R6_XIM
+
+	XIMStyles *styles = 0;
+	XGetIMValues(qt_xim, XNQueryInputStyle, &styles, (char *) 0, (char *) 0);
+	if ( styles ) {
+	    int i;
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == xim_preferred_style ) {
+		    qt_xim_style = xim_preferred_style;
+		    break;
+		}
+	    }
+	    // if the preferred input style couldn't be found, look for
+	    // Nothing
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNothing |
+						     XIMStatusNothing) ) {
+		    qt_xim_style = XIMPreeditNothing | XIMStatusNothing;
+		    break;
+		}
+	    }
+	    // ... and failing that, None.
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNone |
+						     XIMStatusNone) ) {
+		    qt_xim_style = XIMPreeditNone | XIMStatusNone;
+		    break;
+		}
+	    }
+
+	    // qDebug("QApplication: using im style %lx", qt_xim_style);
+	    XFree( (char *)styles );
+	}
+
+	if ( qt_xim_style ) {
+
+#ifdef USE_X11R6_XIM
+	    XUnregisterIMInstantiateCallback(appDpy, 0, 0, 0,
+					     (XIMProc) xim_create_callback, 0);
+#endif // USE_X11R6_XIM
+
+	    QWidgetList *list= qApp->topLevelWidgets();
+	    QWidgetListIt it(*list);
+	    QWidget * w;
+	    while( (w=it.current()) != 0 ) {
+		++it;
+		w->createTLSysExtra();
+	    }
+	    delete list;
+	} else {
+	    // Give up
+	    qWarning( "No supported input style found."
+		      "  See InputMethod documentation.");
+	    close_xim();
+	}
+    }
+#endif // QT_NO_XIM
+}
+
+
+/*! \internal
+  Closes the application input method.
+*/
+void QApplication::close_xim()
+{
+#ifndef QT_NO_XIM
+    // Calling XCloseIM gives a Purify FMR error
+    // XCloseIM( qt_xim );
+    // We prefer a less serious memory leak
+
+    qt_xim = 0;
+    QWidgetList *list = qApp->topLevelWidgets();
+    QWidgetListIt it(*list);
+    while(it.current()) {
+	it.current()->destroyInputContext();
+	++it;
+    }
+    delete list;
+#endif // QT_NO_XIM
+}
+
+
+/*****************************************************************************
+  Default X error handlers
+ *****************************************************************************/
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static bool x11_ignore_badwindow;
+static bool x11_badwindow;
+
+    // starts to ignore bad window errors from X
+void qt_ignore_badwindow()
+{
+    x11_ignore_badwindow = TRUE;
+    x11_badwindow = FALSE;
+}
+
+    // ends ignoring bad window errors and returns whether an error
+    // had happen.
+bool qt_badwindow()
+{
+    x11_ignore_badwindow = FALSE;
+    return x11_badwindow;
+}
+
+static int (*original_x_errhandler)( Display *dpy, XErrorEvent * );
+static int (*original_xio_errhandler)( Display *dpy );
+
+static int qt_x_errhandler( Display *dpy, XErrorEvent *err )
+{
+    if ( err->error_code == BadWindow ) {
+	x11_badwindow = TRUE;
+	if ( err->request_code == 25 /* X_SendEvent */ &&
+	     qt_xdnd_handle_badwindow() )
+	    return 0;
+	if ( x11_ignore_badwindow )
+	    return 0;
+    } else if ( err->error_code == BadMatch &&
+		err->request_code == 42 /* X_SetInputFocus */ ) {
+	return 0;
+    }
+
+    char errstr[256];
+    XGetErrorText( dpy, err->error_code, errstr, 256 );
+    qWarning( "X Error: %s %d\n"
+	      "  Major opcode:  %d\n"
+	      "  Minor opcode:  %d\n"
+	      "  Resource id:  0x%lx",
+	      errstr, err->error_code,
+	      err->request_code,
+	      err->minor_code,
+	      err->resourceid );
+
+    // ### we really should distinguish between severe, non-severe and
+    // ### application specific errors
+
+    return 0;
+}
+
+
+static int qt_xio_errhandler( Display * )
+{
+    qWarning( "%s: Fatal IO error: client killed", appName );
+    qApp = 0;
+    exit( 1 );
+    //### give the application a chance for a proper shutdown instead,
+    //### exit(1) doesn't help.
+    return 0;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+// Memory leak: if the app exits before qt_init_internal(), this dict
+// isn't released correctly.
+static QAsciiDict<Atom> *atoms_to_be_created = 0;
+static bool create_atoms_now = 0;
+
+/*****************************************************************************
+  qt_x11_intern_atom() - efficiently interns an atom, now or later.
+
+  If the application is being initialized, this function stores the
+  adddress of the atom and qt_init_internal will do the actual work
+  quickly. If the application is running, the atom is created here.
+
+  Neither argument may point to temporary variables.
+ *****************************************************************************/
+
+void qt_x11_intern_atom( const char *name, Atom *result)
+{
+    if ( !name || !result || *result )
+	return;
+
+    if ( create_atoms_now ) {
+	*result = XInternAtom( appDpy, name, False );
+    } else {
+	if ( !atoms_to_be_created ) {
+	    atoms_to_be_created = new QAsciiDict<Atom>;
+	    atoms_to_be_created->setAutoDelete( FALSE );
+	}
+	atoms_to_be_created->insert( name, result );
+	*result = 0;
+    }
+}
+
+
+static void qt_x11_process_intern_atoms()
+{
+    if ( atoms_to_be_created ) {
+#if defined(XlibSpecificationRelease) && (XlibSpecificationRelease >= 6)
+	int i = atoms_to_be_created->count();
+	Atom * res = (Atom *)malloc( i * sizeof( Atom ) );
+	Atom ** resp = (Atom **)malloc( i * sizeof( Atom* ) );
+	char ** names = (char **)malloc( i * sizeof(const char*));
+
+	i = 0;
+	QAsciiDictIterator<Atom> it( *atoms_to_be_created );
+	while( it.current() ) {
+	    res[i] = 0;
+	    resp[i] = it.current();
+	    names[i] = qstrdup(it.currentKey());
+	    i++;
+	    ++it;
+	}
+	XInternAtoms( appDpy, names, i, False, res );
+	while( i ) {
+	    i--;
+	    delete [] names[i];
+	    if ( res[i] && resp[i] )
+		*(resp[i]) = res[i];
+	}
+	free( res );
+	free( resp );
+	free( names );
+#else
+	QAsciiDictIterator<Atom> it( *atoms_to_be_created );
+	Atom * result;
+	const char * name;
+	while( (result = it.current()) != 0 ) {
+	    name = it.currentKey();
+	    ++it;
+	    *result = XInternAtom( appDpy, name, False );
+	}
+#endif
+	delete atoms_to_be_created;
+	atoms_to_be_created = 0;
+	create_atoms_now = TRUE;
+    }
+}
+
+
+/*! \internal
+    apply the settings to the application
+*/
+bool QApplication::x11_apply_settings()
+{
+    if (! qt_std_pal)
+	qt_create_std_palette();
+
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after = 1;
+    unsigned char *data = 0;
+    QDateTime timestamp, settingsstamp;
+    bool update_timestamp = FALSE;
+
+    if (XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			   qt_settings_timestamp, 0, 0,
+			   False, AnyPropertyType, &type, &format, &nitems,
+			   &after, &data) == Success && format == 8) {
+	if (data)
+	    XFree(data);
+
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			       qt_settings_timestamp,
+			       offset, 1024, False, AnyPropertyType,
+			       &type, &format, &nitems, &after, &data);
+	    if (format == 8) {
+		ts.writeBlock((const char *) data, nitems);
+		offset += nitems / 4;
+	    }
+
+	    XFree(data);
+	}
+
+	QDataStream d(ts.buffer(), IO_ReadOnly);
+	d >> timestamp;
+    }
+
+    QSettings settings;
+    settingsstamp = settings.lastModificationTime( "/qt/font" );
+    if (! settingsstamp.isValid())
+	return FALSE;
+
+    if ( appliedstamp && appliedstamp == settingsstamp.toTime_t() )
+	return TRUE;
+    appliedstamp = settingsstamp.toTime_t();
+
+    if (! timestamp.isValid() || settingsstamp > timestamp)
+	update_timestamp = TRUE;
+
+    /*
+      Qt settings. This is now they are written into the datastream.
+
+      /qt/Palette/ *             - QPalette
+      /qt/font                   - QFont
+      /qt/libraryPath            - QStringList
+      /qt/style                  - QString
+      /qt/doubleClickInterval    - int
+      /qt/cursorFlashTime        - int
+      /qt/wheelScrollLines       - int
+      /qt/colorSpec              - QString
+      /qt/defaultCodec           - QString
+      /qt/globalStrut            - QSize
+      /qt/GUIEffects             - QStringList
+      /qt/Font Substitutions/ *  - QStringList
+      /qt/Font Substitutions/... - QStringList
+    */
+
+    QString str;
+    QStringList strlist;
+    int i, num;
+    QPalette pal(QApplication::palette());
+    strlist = settings.readListEntry("/qt/Palette/active");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Active, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+    strlist = settings.readListEntry("/qt/Palette/inactive");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Inactive, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+    strlist = settings.readListEntry("/qt/Palette/disabled");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Disabled, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+
+    // workaround for KDE 3.0, which messes up the buttonText value of
+    // the disabled palette in QSettings
+    if ( pal.disabled().buttonText() == pal.active().buttonText() ) {
+	pal.setColor( QPalette::Disabled, QColorGroup::ButtonText,
+		      pal.disabled().foreground() );
+    }
+
+    if (pal != *qt_std_pal && pal != QApplication::palette()) {
+	QApplication::setPalette(pal, TRUE);
+	*qt_std_pal = pal;
+    }
+
+    QFont font(QApplication::font());
+    if ( !qt_app_has_font && !qt_x11_cmdline_font ) {
+        // read new font
+        str = settings.readEntry("/qt/font");
+        if (! str.isNull() && ! str.isEmpty()) {
+            font.fromString(str);
+
+            if (font != QApplication::font())
+                QApplication::setFont(font, TRUE);
+        }
+    }
+
+    // read library (ie. plugin) path list
+    QString libpathkey =
+	QString("/qt/%1.%2/libraryPath").arg( QT_VERSION >> 16 ).arg( (QT_VERSION & 0xff00 ) >> 8 );
+    QStringList pathlist = settings.readListEntry(libpathkey, ':');
+    if (! pathlist.isEmpty()) {
+	QStringList::ConstIterator it = pathlist.begin();
+	while (it != pathlist.end())
+	    QApplication::addLibraryPath(*it++);
+    }
+
+    // read new QStyle
+    extern bool qt_explicit_app_style; // defined in qapplication.cpp
+    QString stylename = settings.readEntry( "/qt/style" );
+    if ( !stylename.isEmpty() && !qt_explicit_app_style ) {
+	QApplication::setStyle( stylename );
+	// took the style from the user settings, so mark the explicit flag FALSE
+	qt_explicit_app_style = FALSE;
+    }
+
+    num =
+	settings.readNumEntry("/qt/doubleClickInterval",
+			      QApplication::doubleClickInterval());
+    QApplication::setDoubleClickInterval(num);
+
+    num =
+	settings.readNumEntry("/qt/cursorFlashTime",
+			      QApplication::cursorFlashTime());
+    QApplication::setCursorFlashTime(num);
+
+    num =
+	settings.readNumEntry("/qt/wheelScrollLines",
+			      QApplication::wheelScrollLines());
+    QApplication::setWheelScrollLines(num);
+
+    QString colorspec = settings.readEntry("/qt/colorSpec", "default");
+    if (colorspec == "normal")
+	QApplication::setColorSpec(QApplication::NormalColor);
+    else if (colorspec == "custom")
+	QApplication::setColorSpec(QApplication::CustomColor);
+    else if (colorspec == "many")
+	QApplication::setColorSpec(QApplication::ManyColor);
+    else if (colorspec != "default")
+	colorspec = "default";
+
+    QString defaultcodec = settings.readEntry("/qt/defaultCodec", "none");
+    if (defaultcodec != "none") {
+	QTextCodec *codec = QTextCodec::codecForName(defaultcodec);
+	if (codec)
+	    qApp->setDefaultCodec(codec);
+    }
+
+    QStringList strut = settings.readListEntry("/qt/globalStrut");
+    if (! strut.isEmpty()) {
+	if (strut.count() == 2) {
+	    QSize sz(strut[0].toUInt(), strut[1].toUInt());
+
+	    if (sz.isValid())
+		QApplication::setGlobalStrut(sz);
+	}
+    }
+
+    QStringList effects = settings.readListEntry("/qt/GUIEffects");
+
+    QApplication::setEffectEnabled( Qt::UI_General, effects.contains("general") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateMenu, effects.contains("animatemenu") );
+    QApplication::setEffectEnabled( Qt::UI_FadeMenu, effects.contains("fademenu") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateCombo, effects.contains("animatecombo") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, effects.contains("animatetooltip") );
+    QApplication::setEffectEnabled( Qt::UI_FadeTooltip, effects.contains("fadetooltip") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, effects.contains("animatetoolbox") );
+
+    QStringList fontsubs =
+	settings.entryList("/qt/Font Substitutions");
+    if (!fontsubs.isEmpty()) {
+	QStringList subs;
+	QString fam, skey;
+	QStringList::Iterator it = fontsubs.begin();
+	while (it != fontsubs.end()) {
+	    fam = (*it++);
+	    skey = "/qt/Font Substitutions/" + fam;
+	    subs = settings.readListEntry(skey);
+	    QFont::insertSubstitutions(fam, subs);
+	}
+    }
+
+    qt_broken_wm =
+	settings.readBoolEntry("/qt/brokenWindowManager", qt_broken_wm);
+
+    qt_resolve_symlinks =
+	settings.readBoolEntry("/qt/resolveSymlinks", TRUE);
+
+    qt_use_rtl_extensions =
+    	settings.readBoolEntry("/qt/useRtlExtensions", FALSE);
+
+#ifndef QT_NO_XIM
+    if (xim_preferred_style == 0) {
+        QString ximInputStyle =
+            settings.readEntry( "/qt/XIMInputStyle",
+                                QObject::trUtf8( "On The Spot" ) ).lower();
+        if ( ximInputStyle == "on the spot" )
+            xim_preferred_style = XIMPreeditCallbacks | XIMStatusNothing;
+        else if ( ximInputStyle == "over the spot" )
+            xim_preferred_style = XIMPreeditPosition | XIMStatusNothing;
+        else if ( ximInputStyle == "off the spot" )
+            xim_preferred_style = XIMPreeditArea | XIMStatusArea;
+        else if ( ximInputStyle == "root" )
+            xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
+    }
+#endif
+
+    if (update_timestamp) {
+	QBuffer stamp;
+	QDataStream s(stamp.buffer(), IO_WriteOnly);
+	s << settingsstamp;
+
+	XChangeProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			qt_settings_timestamp, qt_settings_timestamp, 8,
+			PropModeReplace, (unsigned char *) stamp.buffer().data(),
+			stamp.buffer().size());
+    }
+
+    return TRUE;
+}
+
+
+// read the _QT_INPUT_ENCODING property and apply the settings to
+// the application
+static void qt_set_input_encoding()
+{
+    Atom type;
+    int format;
+    ulong  nitems, after = 1;
+    const char *data;
+
+    int e = XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+				qt_input_encoding, 0, 1024,
+				False, XA_STRING, &type, &format, &nitems,
+				&after,  (unsigned char**)&data );
+    if ( e != Success || !nitems || type == None ) {
+	// Always use the locale codec, since we have no examples of non-local
+	// XIMs, and since we cannot get a sensible answer about the encoding
+	// from the XIM.
+	input_mapper = QTextCodec::codecForLocale();
+
+    } else {
+	if ( !qstricmp( data, "locale" ) )
+	    input_mapper = QTextCodec::codecForLocale();
+	else
+	    input_mapper = QTextCodec::codecForName( data );
+	// make sure we have an input codec
+	if( !input_mapper )
+	    input_mapper = QTextCodec::codecForName( "ISO 8859-1" );
+    }
+    if ( input_mapper->mibEnum() == 11 ) // 8859-8
+	input_mapper = QTextCodec::codecForName( "ISO 8859-8-I");
+    if( data )
+	XFree( (char *)data );
+}
+
+// set font, foreground and background from x11 resources. The
+// arguments may override the resource settings.
+static void qt_set_x11_resources( const char* font = 0, const char* fg = 0,
+				  const char* bg = 0, const char* button = 0 )
+{
+    if ( !qt_std_pal )
+	qt_create_std_palette();
+
+    QCString resFont, resFG, resBG, resEF, sysFont;
+
+    QApplication::setEffectEnabled( Qt::UI_General, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_AnimateMenu, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_FadeMenu, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_AnimateCombo, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_FadeTooltip, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, FALSE );
+
+    if ( QApplication::desktopSettingsAware() && !QApplication::x11_apply_settings()  ) {
+	int format;
+	ulong  nitems, after = 1;
+	QCString res;
+	long offset = 0;
+	Atom type = None;
+
+	while (after > 0) {
+	    uchar *data;
+	    XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+				qt_resource_manager,
+				offset, 8192, False, AnyPropertyType,
+				&type, &format, &nitems, &after,
+				&data );
+	    res += (char*)data;
+	    offset += 2048; // offset is in 32bit quantities... 8192/4 == 2048
+	    if ( data )
+		XFree( (char *)data );
+	}
+
+	QCString key, value;
+	int l = 0, r;
+	QCString apn = appName;
+	QCString apc = appClass;
+	int apnl = apn.length();
+	int apcl = apc.length();
+	int resl = res.length();
+
+	while (l < resl) {
+	    r = res.find( '\n', l );
+	    if ( r < 0 )
+		r = resl;
+	    while ( isspace((uchar) res[l]) )
+		l++;
+	    bool mine = FALSE;
+	    if ( res[l] == '*' &&
+		 (res[l+1] == 'f' || res[l+1] == 'b' || res[l+1] == 'g' ||
+		  res[l+1] == 'F' || res[l+1] == 'B' || res[l+1] == 'G' ||
+		  res[l+1] == 's' || res[l+1] == 'S' ) ) {
+		// OPTIMIZED, since we only want "*[fbgs].."
+
+		QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		int i = item.find( ":" );
+		key = item.left( i ).stripWhiteSpace().mid(1).lower();
+		value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		mine = TRUE;
+	    } else if ( res[l] == appName[0] || (appClass && res[l] == appClass[0]) ) {
+		if (res.mid(l,apnl) == apn && (res[l+apnl] == '.' || res[l+apnl] == '*')) {
+		    QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		    int i = item.find( ":" );
+		    key = item.left( i ).stripWhiteSpace().mid(apnl+1).lower();
+		    value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		    mine = TRUE;
+		} else if (res.mid(l,apcl) == apc && (res[l+apcl] == '.' || res[l+apcl] == '*')) {
+		    QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		    int i = item.find( ":" );
+		    key = item.left( i ).stripWhiteSpace().mid(apcl+1).lower();
+		    value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		    mine = TRUE;
+		}
+	    }
+
+	    if ( mine ) {
+		if ( !font && key == "systemfont")
+		    sysFont = value.left( value.findRev(':') ).copy();
+		if ( !font && key == "font")
+		    resFont = value.copy();
+		else if  ( !fg &&  key == "foreground" )
+		    resFG = value.copy();
+		else if ( !bg && key == "background")
+		    resBG = value.copy();
+		else if ( key == "guieffects")
+		    resEF = value.copy();
+		// NOTE: if you add more, change the [fbg] stuff above
+	    }
+
+	    l = r + 1;
+	}
+    }
+    if ( !sysFont.isEmpty() )
+	resFont = sysFont;
+    if ( resFont.isEmpty() )
+	resFont = font;
+    if ( resFG.isEmpty() )
+	resFG = fg;
+    if ( resBG.isEmpty() )
+	resBG = bg;
+    if ( (!qt_app_has_font || qt_x11_cmdline_font) && !resFont.isEmpty() ) { // set application font
+        QFont fnt;
+        fnt.setRawName( resFont );
+
+        // the font we get may actually be an alias for another font,
+        // so we reset the application font to the real font info.
+        if ( ! fnt.exactMatch() ) {
+            QFontInfo fontinfo( fnt );
+            fnt.setFamily( fontinfo.family() );
+            fnt.setRawMode( fontinfo.rawMode() );
+
+            if ( ! fnt.rawMode() ) {
+                fnt.setItalic( fontinfo.italic() );
+                fnt.setWeight( fontinfo.weight() );
+                fnt.setUnderline( fontinfo.underline() );
+                fnt.setStrikeOut( fontinfo.strikeOut() );
+                fnt.setStyleHint( fontinfo.styleHint() );
+
+                if ( fnt.pointSize() <= 0 && fnt.pixelSize() <= 0 )
+                    // size is all wrong... fix it
+                    fnt.setPointSize( (int) ( ( fontinfo.pixelSize() * 72. /
+                                                (float) QPaintDevice::x11AppDpiY() ) +
+                                              0.5 ) );
+            }
+        }
+
+        if ( fnt != QApplication::font() ) {
+            QApplication::setFont( fnt, TRUE );
+        }
+    }
+
+    if ( button || !resBG.isEmpty() || !resFG.isEmpty() ) {// set app colors
+	QColor btn;
+	QColor bg;
+	QColor fg;
+	if ( !resBG.isEmpty() )
+	    bg = QColor(QString(resBG));
+	else
+	    bg = qt_std_pal->active().background();
+	if ( !resFG.isEmpty() )
+	    fg = QColor(QString(resFG));
+	else
+	    fg = qt_std_pal->active().foreground();
+	if ( button )
+	    btn = QColor( button );
+	else if ( !resBG.isEmpty() )
+	    btn = bg;
+	else
+	    btn = qt_std_pal->active().button();
+
+	int h,s,v;
+	fg.hsv(&h,&s,&v);
+	QColor base = Qt::white;
+	bool bright_mode = FALSE;
+	if (v >= 255-50) {
+	    base = btn.dark(150);
+	    bright_mode = TRUE;
+	}
+
+	QColorGroup cg( fg, btn, btn.light(),
+			btn.dark(), btn.dark(150), fg, Qt::white, base, bg );
+	if (bright_mode) {
+	    cg.setColor( QColorGroup::HighlightedText, base );
+	    cg.setColor( QColorGroup::Highlight, Qt::white );
+	} else {
+	    cg.setColor( QColorGroup::HighlightedText, Qt::white );
+	    cg.setColor( QColorGroup::Highlight, Qt::darkBlue );
+	}
+	QColor disabled( (fg.red()+btn.red())/2,
+			 (fg.green()+btn.green())/2,
+			 (fg.blue()+btn.blue())/2);
+	QColorGroup dcg( disabled, btn, btn.light( 125 ), btn.dark(), btn.dark(150),
+			 disabled, Qt::white, Qt::white, bg );
+	if (bright_mode) {
+	    dcg.setColor( QColorGroup::HighlightedText, base );
+	    dcg.setColor( QColorGroup::Highlight, Qt::white );
+	} else {
+	    dcg.setColor( QColorGroup::HighlightedText, Qt::white );
+	    dcg.setColor( QColorGroup::Highlight, Qt::darkBlue );
+	}
+	QPalette pal( cg, dcg, cg );
+	if ( pal != *qt_std_pal && pal != QApplication::palette() )
+	    QApplication::setPalette( pal, TRUE );
+	*qt_std_pal = pal;
+    }
+
+    if ( !resEF.isEmpty() ) {
+	QStringList effects = QStringList::split(" ",resEF);
+	QApplication::setEffectEnabled( Qt::UI_General,  effects.contains("general") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateMenu, effects.contains("animatemenu") );
+	QApplication::setEffectEnabled( Qt::UI_FadeMenu, effects.contains("fademenu") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateCombo, effects.contains("animatecombo") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, effects.contains("animatetooltip") );
+	QApplication::setEffectEnabled( Qt::UI_FadeTooltip, effects.contains("fadetooltip") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, effects.contains("animatetoolbox") );
+    }
+}
+
+
+static void qt_detect_broken_window_manager()
+{
+    Atom type;
+    int format;
+    ulong nitems, after;
+    uchar *data = 0;
+
+    // look for SGI's 4Dwm
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+                               qt_sgi_desks_manager, 0, 1, False, XA_WINDOW,
+                               &type, &format, &nitems, &after, &data);
+    if (data)
+        XFree(data);
+
+    if (e == Success && type == XA_WINDOW && format == 32 && nitems == 1 && after == 0) {
+        // detected SGI 4Dwm
+        qt_broken_wm = TRUE;
+    }
+}
+
+
+// update the supported array
+void qt_get_net_supported()
+{
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data = 0;
+
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_supported, 0, 0,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+	XFree(data);
+
+    if (qt_net_supported_list)
+	delete [] qt_net_supported_list;
+    qt_net_supported_list = 0;
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_supported, offset, 1024,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+	    if (type == XA_ATOM && format == 32) {
+		ts.writeBlock((const char *) data, nitems * sizeof(long));
+		offset += nitems;
+	    } else
+		after = 0;
+	    if (data)
+		XFree(data);
+	}
+
+	// compute nitems
+	QByteArray buffer(ts.buffer());
+	nitems = buffer.size() / sizeof(Atom);
+	qt_net_supported_list = new Atom[nitems + 1];
+	Atom *a = (Atom *) buffer.data();
+	uint i;
+	for (i = 0; i < nitems; i++)
+	    qt_net_supported_list[i] = a[i];
+	qt_net_supported_list[nitems] = 0;
+    }
+}
+
+
+bool qt_net_supports(Atom atom)
+{
+    if (! qt_net_supported_list)
+	return FALSE;
+
+    bool supported = FALSE;
+    int i = 0;
+    while (qt_net_supported_list[i] != 0) {
+	if (qt_net_supported_list[i++] == atom) {
+	    supported = TRUE;
+	    break;
+	}
+    }
+
+    return supported;
+}
+
+
+// update the virtual roots array
+void qt_get_net_virtual_roots()
+{
+    if (qt_net_virtual_root_list)
+	delete [] qt_net_virtual_root_list;
+    qt_net_virtual_root_list = 0;
+
+    if (! qt_net_supports(qt_net_virtual_roots))
+	return;
+
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data;
+
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_virtual_roots, 0, 0,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+	XFree(data);
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_virtual_roots, offset, 1024,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+	    if (type == XA_ATOM && format == 32) {
+		ts.writeBlock((const char *) data, nitems * 4);
+		offset += nitems;
+	    } else
+		after = 0;
+	    if (data)
+		XFree(data);
+	}
+
+	// compute nitems
+	QByteArray buffer(ts.buffer());
+	nitems = buffer.size() / sizeof(Window);
+	qt_net_virtual_root_list = new Window[nitems + 1];
+	Window *a = (Window *) buffer.data();
+	uint i;
+	for (i = 0; i < nitems; i++)
+	    qt_net_virtual_root_list[i] = a[i];
+	qt_net_virtual_root_list[nitems] = 0;
+    }
+}
+
+void qt_x11_create_wm_client_leader()
+{
+    if ( qt_x11_wm_client_leader ) return;
+
+    qt_x11_wm_client_leader =
+	XCreateSimpleWindow( QPaintDevice::x11AppDisplay(),
+			     QPaintDevice::x11AppRootWindow(),
+			     0, 0, 1, 1, 0, 0, 0 );
+
+    // set client leader property to itself
+    XChangeProperty( QPaintDevice::x11AppDisplay(),
+		     qt_x11_wm_client_leader, qt_wm_client_leader,
+		     XA_WINDOW, 32, PropModeReplace,
+		     (unsigned char *)&qt_x11_wm_client_leader, 1 );
+
+    // If we are session managed, inform the window manager about it
+    QCString session = qApp->sessionId().latin1();
+    if ( !session.isEmpty() ) {
+	XChangeProperty( QPaintDevice::x11AppDisplay(),
+			 qt_x11_wm_client_leader, qt_sm_client_id,
+			 XA_STRING, 8, PropModeReplace,
+			 (unsigned char *)session.data(), session.length() );
+    }
+}
+
+static void qt_net_update_user_time(QWidget *tlw)
+{
+    XChangeProperty(QPaintDevice::x11AppDisplay(), tlw->winId(), qt_net_wm_user_time, XA_CARDINAL,
+		    32, PropModeReplace, (unsigned char *) &qt_x_user_time, 1);
+}
+
+static void qt_check_focus_model()
+{
+    Window fw = None;
+    int unused;
+    XGetInputFocus( appDpy, &fw, &unused );
+    if ( fw == PointerRoot )
+	qt_focus_model = FocusModel_PointerRoot;
+    else
+	qt_focus_model = FocusModel_Other;
+}
+
+
+/*
+  Returns a truecolor visual (if there is one). 8-bit TrueColor visuals
+  are ignored, unless the user has explicitly requested -visual TrueColor.
+  The SGI X server usually has an 8 bit default visual, but the application
+  can also ask for a truecolor visual. This is what we do if
+  QApplication::colorSpec() is QApplication::ManyColor.
+*/
+
+static Visual *find_truecolor_visual( Display *dpy, int scr, int *depth, int *ncols )
+{
+    XVisualInfo *vi, rvi;
+    int best=0, n, i;
+    rvi.c_class = TrueColor;
+    rvi.screen  = scr;
+    vi = XGetVisualInfo( dpy, VisualClassMask | VisualScreenMask,
+			 &rvi, &n );
+    if ( vi ) {
+	for ( i=0; i<n; i++ ) {
+	    if ( vi[i].depth > vi[best].depth )
+		best = i;
+	}
+    }
+    Visual *v = DefaultVisual(dpy,scr);
+    if ( !vi || (vi[best].visualid == XVisualIDFromVisual(v)) ||
+	 (vi[best].depth <= 8 && qt_visual_option != TrueColor) )
+	{
+	*depth = DefaultDepth(dpy,scr);
+	*ncols = DisplayCells(dpy,scr);
+    } else {
+	v = vi[best].visual;
+	*depth = vi[best].depth;
+	*ncols = vi[best].colormap_size;
+    }
+    if ( vi )
+	XFree( (char *)vi );
+    return v;
+}
+
+
+/*****************************************************************************
+  qt_init() - initializes Qt for X11
+ *****************************************************************************/
+
+#define XK_MISCELLANY
+#define XK_LATIN1
+#include <X11/keysymdef.h>
+
+// ### This should be static but it isn't because of the friend declaration
+// ### in qpaintdevice.h which then should have a static too but can't have
+// ### it because "storage class specifiers invalid in friend function
+// ### declarations" :-) Ideas anyone?
+void qt_init_internal( int *argcptr, char **argv,
+		       Display *display, Qt::HANDLE visual, Qt::HANDLE colormap )
+{
+    setlocale( LC_ALL, "" );		// use correct char set mapping
+    setlocale( LC_NUMERIC, "C" );	// make sprintf()/scanf() work
+
+    if ( display ) {
+	// Qt part of other application
+
+	appForeignDpy = TRUE;
+	appDpy  = display;
+
+	// Set application name and class
+	appName = qstrdup( "Qt-subapplication" );
+	char *app_class = 0;
+	if (argv) {
+	    const char* p = strrchr( argv[0], '/' );
+	    app_class = qstrdup(p ? p + 1 : argv[0]);
+	    if (app_class[0])
+		app_class[0] = toupper(app_class[0]);
+	}
+	appClass = app_class;
+
+	// Install default error handlers
+	original_x_errhandler = XSetErrorHandler( qt_x_errhandler );
+	original_xio_errhandler = XSetIOErrorHandler( qt_xio_errhandler );
+    } else {
+	// Qt controls everything (default)
+
+	int argc = *argcptr;
+	int j;
+
+	// Install default error handlers
+	original_x_errhandler = XSetErrorHandler( qt_x_errhandler );
+	original_xio_errhandler = XSetIOErrorHandler( qt_xio_errhandler );
+
+	// Set application name and class
+	char *app_class = 0;
+	if (argv) {
+	    const char *p = strrchr( argv[0], '/' );
+	    appName = p ? p + 1 : argv[0];
+	    app_class = qstrdup(appName);
+	    if (app_class[0])
+		app_class[0] = toupper(app_class[0]);
+	}
+	appClass = app_class;
+
+	// Get command line params
+	j = argc ? 1 : 0;
+	for ( int i=1; i<argc; i++ ) {
+	    if ( argv[i] && *argv[i] != '-' ) {
+		argv[j++] = argv[i];
+		continue;
+	    }
+	    QCString arg = argv[i];
+	    if ( arg == "-display" ) {
+		if ( ++i < argc )
+		    appDpyName = argv[i];
+	    } else if ( arg == "-fn" || arg == "-font" ) {
+		if ( ++i < argc ) {
+		    appFont = argv[i];
+		    qt_x11_cmdline_font = true;
+		}
+	    } else if ( arg == "-bg" || arg == "-background" ) {
+		if ( ++i < argc )
+		    appBGCol = argv[i];
+	    } else if ( arg == "-btn" || arg == "-button" ) {
+		if ( ++i < argc )
+		    appBTNCol = argv[i];
+	    } else if ( arg == "-fg" || arg == "-foreground" ) {
+		if ( ++i < argc )
+		    appFGCol = argv[i];
+	    } else if ( arg == "-name" ) {
+		if ( ++i < argc )
+		    appName = argv[i];
+	    } else if ( arg == "-title" ) {
+		if ( ++i < argc )
+		    mwTitle = argv[i];
+	    } else if ( arg == "-geometry" ) {
+		if ( ++i < argc )
+		    mwGeometry = argv[i];
+		//Ming-Che 10/10
+	    } else if ( arg == "-im" ) {
+		if ( ++i < argc )
+		    ximServer = argv[i];
+	    } else if ( arg == "-noxim" ) {
+		noxim=TRUE;
+		//
+	    } else if ( arg == "-iconic" ) {
+		mwIconic = !mwIconic;
+	    } else if ( arg == "-ncols" ) {   // xv and netscape use this name
+		if ( ++i < argc )
+		    qt_ncols_option = QMAX(0,atoi(argv[i]));
+	    } else if ( arg == "-visual" ) {  // xv and netscape use this name
+		if ( ++i < argc ) {
+		    QCString s = QCString(argv[i]).lower();
+		    if ( s == "truecolor" ) {
+			qt_visual_option = TrueColor;
+		    } else {
+			// ### Should we honor any others?
+		    }
+		}
+#ifndef QT_NO_XIM
+	    } else if ( arg == "-inputstyle" ) {
+		if ( ++i < argc ) {
+		    QCString s = QCString(argv[i]).lower();
+		    if ( s == "onthespot" )
+			xim_preferred_style = XIMPreeditCallbacks |
+					      XIMStatusNothing;
+		    else if ( s == "overthespot" )
+			xim_preferred_style = XIMPreeditPosition |
+					      XIMStatusNothing;
+		    else if ( s == "offthespot" )
+			xim_preferred_style = XIMPreeditArea |
+					      XIMStatusArea;
+		    else if ( s == "root" )
+			xim_preferred_style = XIMPreeditNothing |
+					      XIMStatusNothing;
+		}
+#endif
+	    } else if ( arg == "-cmap" ) {    // xv uses this name
+		qt_cmap_option = TRUE;
+	    }
+#if defined(QT_DEBUG)
+	    else if ( arg == "-sync" )
+		appSync = !appSync;
+	    else if ( arg == "-nograb" )
+		appNoGrab = !appNoGrab;
+	    else if ( arg == "-dograb" )
+		appDoGrab = !appDoGrab;
+#endif
+	    else
+		argv[j++] = argv[i];
+	}
+
+	*argcptr = j;
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+	if ( !appNoGrab && !appDoGrab ) {
+	    QCString s;
+	    s.sprintf( "/proc/%d/cmdline", getppid() );
+	    QFile f( s );
+	    if ( f.open( IO_ReadOnly ) ) {
+		s.truncate( 0 );
+		int c;
+		while ( (c = f.getch()) > 0 ) {
+		    if ( c == '/' )
+			s.truncate( 0 );
+		    else
+			s += (char)c;
+		}
+		if ( s == "gdb" ) {
+		    appNoGrab = TRUE;
+		    qDebug( "Qt: gdb: -nograb added to command-line options.\n"
+			    "\t Use the -dograb option to enforce grabbing." );
+		}
+		f.close();
+	    }
+	}
+#endif
+	// Connect to X server
+
+	if( qt_is_gui_used ) {
+	    if ( ( appDpy = XOpenDisplay(appDpyName) ) == 0 ) {
+		qWarning( "%s: cannot connect to X server %s", appName,
+			  XDisplayName(appDpyName) );
+		qApp = 0;
+		exit( 1 );
+	    }
+
+	    if ( appSync )				// if "-sync" argument
+		XSynchronize( appDpy, TRUE );
+	}
+    }
+    // Common code, regardless of whether display is foreign.
+
+    // Get X parameters
+
+    if( qt_is_gui_used ) {
+	appScreen = DefaultScreen(appDpy);
+	appScreenCount = ScreenCount(appDpy);
+
+	QPaintDevice::x_appdisplay = appDpy;
+	QPaintDevice::x_appscreen = appScreen;
+
+	// allocate the arrays for the QPaintDevice data
+	QPaintDevice::x_appdepth_arr = new int[ appScreenCount ];
+	QPaintDevice::x_appcells_arr = new int[ appScreenCount ];
+	QPaintDevice::x_approotwindow_arr = new Qt::HANDLE[ appScreenCount ];
+	QPaintDevice::x_appcolormap_arr = new Qt::HANDLE[ appScreenCount ];
+	QPaintDevice::x_appdefcolormap_arr = new bool[ appScreenCount ];
+	QPaintDevice::x_appvisual_arr = new void*[ appScreenCount ];
+	QPaintDevice::x_appdefvisual_arr = new bool[ appScreenCount ];
+	Q_CHECK_PTR( QPaintDevice::x_appdepth_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appcells_arr );
+	Q_CHECK_PTR( QPaintDevice::x_approotwindow_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appcolormap_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appdefcolormap_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appvisual_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appdefvisual_arr );
+
+	int screen;
+	QString serverVendor( ServerVendor( appDpy) );
+	if (serverVendor.contains("XFree86") && VendorRelease(appDpy) < 40300000)
+	    qt_hebrew_keyboard_hack = TRUE;
+
+	for ( screen = 0; screen < appScreenCount; ++screen ) {
+	    QPaintDevice::x_appdepth_arr[ screen ] = DefaultDepth(appDpy, screen);
+	    QPaintDevice::x_appcells_arr[ screen ] = DisplayCells(appDpy, screen);
+	    QPaintDevice::x_approotwindow_arr[ screen ] = RootWindow(appDpy, screen);
+
+	    // setup the visual and colormap for each screen
+	    Visual *vis = 0;
+	    if ( visual && screen == appScreen ) {
+		// use the provided visual on the default screen only
+		vis = (Visual *) visual;
+
+		// figure out the depth of the visual we are using
+		XVisualInfo *vi, rvi;
+		int n;
+		rvi.visualid = XVisualIDFromVisual(vis);
+		rvi.screen  = screen;
+		vi = XGetVisualInfo( appDpy, VisualIDMask | VisualScreenMask, &rvi, &n );
+		if (vi) {
+		    QPaintDevice::x_appdepth_arr[ screen ] = vi->depth;
+		    QPaintDevice::x_appcells_arr[ screen ] = vi->visual->map_entries;
+		    QPaintDevice::x_appvisual_arr[ screen ] = vi->visual;
+		    QPaintDevice::x_appdefvisual_arr[ screen ] = FALSE;
+		    XFree(vi);
+		} else {
+		    // couldn't get info about the visual, use the default instead
+		    vis = 0;
+		}
+	    }
+
+	    if (!vis) {
+		// use the default visual
+		vis = DefaultVisual(appDpy, screen);
+		QPaintDevice::x_appdefvisual_arr[ screen ] = TRUE;
+
+		if ( qt_visual_option == TrueColor ||
+		     QApplication::colorSpec() == QApplication::ManyColor ) {
+		    // find custom visual
+
+		    int d, c;
+		    vis = find_truecolor_visual( appDpy, screen, &d, &c );
+		    QPaintDevice::x_appdepth_arr[ screen ] = d;
+		    QPaintDevice::x_appcells_arr[ screen ] = c;
+
+		    QPaintDevice::x_appvisual_arr[ screen ] = vis;
+		    QPaintDevice::x_appdefvisual_arr[ screen ] =
+			(XVisualIDFromVisual(vis) ==
+			 XVisualIDFromVisual(DefaultVisual(appDpy, screen)));
+		}
+
+		QPaintDevice::x_appvisual_arr[ screen ] = vis;
+	    }
+
+	    // we assume that 8bpp == pseudocolor, but this is not
+	    // always the case (according to the X server), so we need
+	    // to make sure that our internal data is setup in a way
+	    // that is compatible with our assumptions
+	    if ( vis->c_class == TrueColor &&
+		 QPaintDevice::x_appdepth_arr[ screen ] == 8 &&
+		 QPaintDevice::x_appcells_arr[ screen ] == 8 )
+		QPaintDevice::x_appcells_arr[ screen ] = 256;
+
+	    if ( colormap && screen == appScreen ) {
+		// use the provided colormap for the default screen only
+		QPaintDevice::x_appcolormap_arr[ screen ] = colormap;
+		QPaintDevice::x_appdefcolormap_arr[ screen ] = FALSE;
+	    } else {
+		if ( vis->c_class == TrueColor ) {
+		    QPaintDevice::x_appdefcolormap_arr[ screen ] =
+			QPaintDevice::x_appdefvisual_arr[ screen ];
+		} else {
+		    QPaintDevice::x_appdefcolormap_arr[ screen ] =
+			!qt_cmap_option && QPaintDevice::x_appdefvisual_arr[ screen ];
+		}
+
+		if ( QPaintDevice::x_appdefcolormap_arr[ screen ] ) {
+		    // use default colormap
+		    XStandardColormap *stdcmap;
+		    VisualID vid =
+			XVisualIDFromVisual((Visual *)
+					    QPaintDevice::x_appvisual_arr[ screen ]);
+		    int i, count;
+
+		    QPaintDevice::x_appcolormap_arr[ screen ] = 0;
+
+		    if ( ! serverVendor.contains( "Hewlett-Packard" ) ) {
+			// on HPUX 10.20 local displays, the RGB_DEFAULT_MAP colormap
+			// doesn't give us correct colors. Why this happens, I have
+			// no clue, so we disable this for HPUX
+			if (XGetRGBColormaps(appDpy,
+					     QPaintDevice::x11AppRootWindow( screen ),
+					     &stdcmap, &count, XA_RGB_DEFAULT_MAP)) {
+			    i = 0;
+			    while (i < count &&
+				   QPaintDevice::x_appcolormap_arr[ screen ] == 0) {
+				if (stdcmap[i].visualid == vid) {
+				    QPaintDevice::x_appcolormap_arr[ screen ] =
+					stdcmap[i].colormap;
+				}
+				i++;
+			    }
+
+			    XFree( (char *)stdcmap );
+			}
+		    }
+
+		    if (QPaintDevice::x_appcolormap_arr[ screen ] == 0) {
+			QPaintDevice::x_appcolormap_arr[ screen ] =
+			    DefaultColormap(appDpy, screen);
+		    }
+		} else {
+		    // create a custom colormap
+		    QPaintDevice::x_appcolormap_arr[ screen ] =
+			XCreateColormap(appDpy, QPaintDevice::x11AppRootWindow( screen ),
+					vis, AllocNone);
+		}
+	    }
+	}
+
+	// Set X paintdevice parameters for the default screen
+	QPaintDevice::x_appdepth = QPaintDevice::x_appdepth_arr[ appScreen ];
+	QPaintDevice::x_appcells = QPaintDevice::x_appcells_arr[ appScreen ];
+	QPaintDevice::x_approotwindow = QPaintDevice::x_approotwindow_arr[ appScreen ];
+	QPaintDevice::x_appcolormap = QPaintDevice::x_appcolormap_arr[ appScreen ];
+	QPaintDevice::x_appdefcolormap = QPaintDevice::x_appdefcolormap_arr[ appScreen ];
+	QPaintDevice::x_appvisual = QPaintDevice::x_appvisual_arr[ appScreen ];
+	QPaintDevice::x_appdefvisual = QPaintDevice::x_appdefvisual_arr[ appScreen ];
+
+	// Support protocols
+
+	qt_x11_intern_atom( "WM_PROTOCOLS", &qt_wm_protocols );
+	qt_x11_intern_atom( "WM_DELETE_WINDOW", &qt_wm_delete_window );
+	qt_x11_intern_atom( "WM_STATE", &qt_wm_state );
+	qt_x11_intern_atom( "WM_CHANGE_STATE", &qt_wm_change_state );
+	qt_x11_intern_atom( "WM_TAKE_FOCUS", &qt_wm_take_focus );
+	qt_x11_intern_atom( "WM_CLIENT_LEADER", &qt_wm_client_leader);
+	qt_x11_intern_atom( "WM_WINDOW_ROLE", &qt_window_role);
+	qt_x11_intern_atom( "SM_CLIENT_ID", &qt_sm_client_id);
+	qt_x11_intern_atom( "CLIPBOARD", &qt_xa_clipboard );
+	qt_x11_intern_atom( "RESOURCE_MANAGER", &qt_resource_manager );
+	qt_x11_intern_atom( "INCR", &qt_x_incr );
+	qt_x11_intern_atom( "_XSETROOT_ID", &qt_xsetroot_id );
+	qt_x11_intern_atom( "_QT_SELECTION", &qt_selection_property );
+	qt_x11_intern_atom( "_QT_CLIPBOARD_SENTINEL", &qt_clipboard_sentinel );
+	qt_x11_intern_atom( "_QT_SELECTION_SENTINEL", &qt_selection_sentinel );
+	qt_x11_intern_atom( "_QT_SCROLL_DONE", &qt_qt_scrolldone );
+	qt_x11_intern_atom( "_QT_INPUT_ENCODING", &qt_input_encoding );
+	qt_x11_intern_atom( "_QT_SIZEGRIP", &qt_sizegrip );
+	qt_x11_intern_atom( "_NET_WM_CONTEXT_HELP", &qt_net_wm_context_help );
+	qt_x11_intern_atom( "_NET_WM_PING", &qt_net_wm_ping );
+	qt_x11_intern_atom( "_MOTIF_WM_HINTS", &qt_xa_motif_wm_hints );
+	qt_x11_intern_atom( "DTWM_IS_RUNNING", &qt_cde_running );
+	qt_x11_intern_atom( "KWIN_RUNNING", &qt_kwin_running );
+	qt_x11_intern_atom( "KWM_RUNNING", &qt_kwm_running );
+	qt_x11_intern_atom( "GNOME_BACKGROUND_PROPERTIES", &qt_gbackground_properties );
+
+	QString atomname("_QT_SETTINGS_TIMESTAMP_");
+	atomname += XDisplayName(appDpyName);
+	qt_x11_intern_atom( atomname.latin1(), &qt_settings_timestamp );
+
+	qt_x11_intern_atom( "_NET_SUPPORTED", &qt_net_supported );
+	qt_x11_intern_atom( "_NET_VIRTUAL_ROOTS", &qt_net_virtual_roots );
+	qt_x11_intern_atom( "_NET_WORKAREA", &qt_net_workarea );
+	qt_x11_intern_atom( "_NET_WM_STATE", &qt_net_wm_state );
+	qt_x11_intern_atom( "_NET_WM_STATE_MODAL", &qt_net_wm_state_modal );
+	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_VERT", &qt_net_wm_state_max_v );
+	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_HORZ", &qt_net_wm_state_max_h );
+	qt_x11_intern_atom( "_NET_WM_STATE_FULLSCREEN", &qt_net_wm_state_fullscreen );
+	qt_x11_intern_atom( "_NET_WM_STATE_ABOVE", &qt_net_wm_state_above );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE", &qt_net_wm_window_type );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_NORMAL", &qt_net_wm_window_type_normal );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_DIALOG", &qt_net_wm_window_type_dialog );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_TOOLBAR", &qt_net_wm_window_type_toolbar );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_MENU", &qt_net_wm_window_type_menu );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_UTILITY", &qt_net_wm_window_type_utility );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_SPLASH", &qt_net_wm_window_type_splash );
+	qt_x11_intern_atom( "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE", &qt_net_wm_window_type_override );
+	qt_x11_intern_atom( "_KDE_NET_WM_FRAME_STRUT", &qt_net_wm_frame_strut );
+	qt_x11_intern_atom( "_NET_WM_STATE_STAYS_ON_TOP",
+			    &qt_net_wm_state_stays_on_top );
+	qt_x11_intern_atom( "_NET_WM_PID", &qt_net_wm_pid );
+	qt_x11_intern_atom( "_NET_WM_USER_TIME", &qt_net_wm_user_time );
+	qt_x11_intern_atom( "ENLIGHTENMENT_DESKTOP", &qt_enlightenment_desktop );
+	qt_x11_intern_atom( "_NET_WM_NAME", &qt_net_wm_name );
+	qt_x11_intern_atom( "_NET_WM_ICON_NAME", &qt_net_wm_icon_name );
+	qt_x11_intern_atom( "UTF8_STRING", &qt_utf8_string );
+        qt_x11_intern_atom( "_SGI_DESKS_MANAGER", &qt_sgi_desks_manager );
+
+	qt_xdnd_setup();
+	qt_x11_motifdnd_init();
+
+	// Finally create all atoms
+	qt_x11_process_intern_atoms();
+
+        // look for broken window managers
+        qt_detect_broken_window_manager();
+
+	// initialize NET lists
+	qt_get_net_supported();
+	qt_get_net_virtual_roots();
+
+#ifndef QT_NO_XRANDR
+	// See if XRandR is supported on the connected display
+	int xrandr_errorbase;
+	Q_UNUSED( xrandr_eventbase );
+	if ( XRRQueryExtension( appDpy, &xrandr_eventbase, &xrandr_errorbase ) ) {
+	    // XRandR is supported
+	    qt_use_xrandr = TRUE;
+	}
+#endif // QT_NO_XRANDR
+
+#ifndef QT_NO_XRENDER
+	// See if XRender is supported on the connected display
+	int xrender_eventbase, xrender_errorbase;
+	if (XRenderQueryExtension(appDpy, &xrender_eventbase, &xrender_errorbase)) {
+	    // XRender is supported, let's see if we have a PictFormat for the
+	    // default visual
+	    XRenderPictFormat *format =
+		XRenderFindVisualFormat(appDpy,
+					(Visual *) QPaintDevice::x_appvisual);
+	    qt_use_xrender = (format != 0) && (QPaintDevice::x_appdepth != 8);
+	}
+#endif // QT_NO_XRENDER
+
+#ifndef QT_NO_XKB
+	// If XKB is detected, set the GrabsUseXKBState option so input method
+	// compositions continue to work (ie. deadkeys)
+	unsigned int state = XkbPCF_GrabsUseXKBStateMask;
+	(void) XkbSetPerClientControls(appDpy, state, &state);
+#endif
+
+#if !defined(QT_NO_XFTFREETYPE)
+	// defined in qfont_x11.cpp
+	extern bool qt_has_xft;
+#ifndef QT_XFT2
+        if (!qt_use_xrender)
+            qt_has_xft = FALSE;
+        else
+#endif
+            qt_has_xft = XftInit(0) && XftInitFtLibrary();
+
+        if (qt_has_xft) {
+            char *dpi_str = XGetDefault(appDpy, "Xft", "dpi");
+            if (dpi_str) {
+                // use a custom DPI
+                char *end = 0;
+                int dpi = strtol(dpi_str, &end, 0);
+                if (dpi_str != end) {
+                    for (int s = 0; s < ScreenCount(appDpy); ++s) {
+                        QPaintDevice::x11SetAppDpiX(dpi, s);
+                        QPaintDevice::x11SetAppDpiY(dpi, s);
+                    }
+                }
+            }
+        }
+#endif // QT_NO_XFTFREETYPE
+
+	// look at the modifier mapping, and get the correct masks for alt/meta
+	// find the alt/meta masks
+	XModifierKeymap *map = XGetModifierMapping(appDpy);
+	if (map) {
+	    int i, maskIndex = 0, mapIndex = 0;
+	    for (maskIndex = 0; maskIndex < 8; maskIndex++) {
+		for (i = 0; i < map->max_keypermod; i++) {
+		    if (map->modifiermap[mapIndex]) {
+			KeySym sym =
+			    XKeycodeToKeysym(appDpy, map->modifiermap[mapIndex], 0);
+			if ( qt_alt_mask == 0 &&
+			     ( sym == XK_Alt_L || sym == XK_Alt_R ) ) {
+			    qt_alt_mask = 1 << maskIndex;
+			}
+			if ( qt_meta_mask == 0 &&
+			     (sym == XK_Meta_L || sym == XK_Meta_R ) ) {
+			    qt_meta_mask = 1 << maskIndex;
+			}
+		    }
+		    mapIndex++;
+		}
+	    }
+
+	    // not look for mode_switch in qt_alt_mask and qt_meta_mask - if it is
+	    // present in one or both, then we set qt_mode_switch_remove_mask.
+	    // see QETWidget::translateKeyEventInternal for an explanation
+	    // of why this is needed
+	    mapIndex = 0;
+	    for ( maskIndex = 0; maskIndex < 8; maskIndex++ ) {
+		if ( qt_alt_mask  != ( 1 << maskIndex ) &&
+		     qt_meta_mask != ( 1 << maskIndex ) ) {
+		    for ( i = 0; i < map->max_keypermod; i++ )
+			mapIndex++;
+		    continue;
+		}
+
+		for ( i = 0; i < map->max_keypermod; i++ ) {
+		    if ( map->modifiermap[ mapIndex ] ) {
+			KeySym sym =
+			    XKeycodeToKeysym( appDpy, map->modifiermap[ mapIndex ], 0 );
+			if ( sym == XK_Mode_switch ) {
+			    qt_mode_switch_remove_mask |= 1 << maskIndex;
+			}
+		    }
+		    mapIndex++;
+		}
+	    }
+
+	    XFreeModifiermap(map);
+	} else {
+	    // assume defaults
+	    qt_alt_mask = Mod1Mask;
+	    qt_meta_mask = Mod4Mask;
+	    qt_mode_switch_remove_mask = 0;
+	}
+
+	// Misc. initialization
+
+	QColor::initialize();
+	QFont::initialize();
+	QCursor::initialize();
+	QPainter::initialize();
+    }
+
+#if defined(QT_THREAD_SUPPORT)
+    QThread::initialize();
+#endif
+
+    if( qt_is_gui_used ) {
+	qApp->setName( appName );
+
+	int screen;
+	for ( screen = 0; screen < appScreenCount; ++screen ) {
+	    XSelectInput( appDpy, QPaintDevice::x11AppRootWindow( screen ),
+			  KeymapStateMask | EnterWindowMask | LeaveWindowMask |
+			  PropertyChangeMask );
+
+#ifndef QT_NO_XRANDR
+	    if (qt_use_xrandr)
+		XRRSelectInput( appDpy, QPaintDevice::x11AppRootWindow( screen ), True );
+#endif // QT_NO_XRANDR
+	}
+    }
+
+    if ( qt_is_gui_used ) {
+	qt_set_input_encoding();
+
+	qt_set_x11_resources( appFont, appFGCol, appBGCol, appBTNCol);
+
+	// be smart about the size of the default font. most X servers have helvetica
+	// 12 point available at 2 resolutions:
+	//     75dpi (12 pixels) and 100dpi (17 pixels).
+	// At 95 DPI, a 12 point font should be 16 pixels tall - in which case a 17
+	// pixel font is a closer match than a 12 pixel font
+	int ptsz =
+	    (int) ( ( ( QPaintDevice::x11AppDpiY() >= 95 ? 17. : 12. ) *
+		      72. / (float) QPaintDevice::x11AppDpiY() ) + 0.5 );
+
+	if ( !qt_app_has_font && !qt_x11_cmdline_font ) {
+	    QFont f( "Helvetica", ptsz );
+	    QApplication::setFont( f );
+	}
+
+#ifndef QT_NO_XIM
+	if ( ! xim_preferred_style ) // no configured input style, use the default
+	    xim_preferred_style = xim_default_style;
+
+	qt_xim = 0;
+	QString ximServerName(ximServer);
+	if (ximServer)
+	    ximServerName.prepend("@im=");
+	else
+	    ximServerName = "";
+
+	if ( !XSupportsLocale() )
+	    qWarning("Qt: Locales not supported on X server");
+
+#ifdef USE_X11R6_XIM
+	else if ( XSetLocaleModifiers (ximServerName.ascii()) == 0 )
+	    qWarning( "Qt: Cannot set locale modifiers: %s",
+		      ximServerName.ascii());
+	else if (! noxim)
+	    XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
+					   (XIMProc) xim_create_callback, 0);
+#else // !USE_X11R6_XIM
+	else if ( XSetLocaleModifiers ("") == 0 )
+	    qWarning("Qt: Cannot set locale modifiers");
+	else if (! noxim)
+	    QApplication::create_xim();
+#endif // USE_X11R6_XIM
+#endif // QT_NO_XIM
+
+#if defined (QT_TABLET_SUPPORT)
+	int ndev,
+	    i,
+	    j;
+	bool gotStylus,
+	    gotEraser;
+	XDeviceInfo *devices, *devs;
+	XInputClassInfo *ip;
+	XAnyClassPtr any;
+	XValuatorInfoPtr v;
+	XAxisInfoPtr a;
+	XDevice *dev;
+	XEventClass *ev_class;
+	int curr_event_count;
+
+#if !defined(Q_OS_IRIX)
+	// XFree86 divides a stylus and eraser into 2 devices, so we must do for both...
+	const QString XFREENAMESTYLUS = "stylus";
+	const QString XFREENAMEPEN = "pen";
+	const QString XFREENAMEERASER = "eraser";
+#endif
+
+	devices = XListInputDevices( appDpy, &ndev);
+	if ( devices == NULL ) {
+	    qWarning( "Failed to get list of devices" );
+	    ndev = -1;
+	}
+	dev = NULL;
+	for ( devs = devices, i = 0; i < ndev; i++, devs++ ) {
+	    gotEraser = FALSE;
+#if defined(Q_OS_IRIX)
+
+	    gotStylus = ( !strncmp(devs->name,
+				   WACOM_NAME, sizeof(WACOM_NAME) - 1) );
+#else
+	    QString devName = devs->name;
+	    devName = devName.lower();
+	    gotStylus = ( devName.startsWith(XFREENAMEPEN)
+			  || devName.startsWith(XFREENAMESTYLUS) );
+	    if ( !gotStylus )
+		gotEraser = devName.startsWith( XFREENAMEERASER );
+
+#endif
+	    if ( gotStylus || gotEraser ) {
+		// I only wanted to do this once, so wrap pointers around these
+		curr_event_count = 0;
+
+		if ( gotStylus ) {
+		    devStylus = XOpenDevice( appDpy, devs->id );
+		    dev = devStylus;
+		    ev_class = event_list_stylus;
+		} else if ( gotEraser ) {
+		    devEraser = XOpenDevice( appDpy, devs->id );
+		    dev = devEraser;
+		    ev_class = event_list_eraser;
+		}
+		if ( dev == NULL ) {
+		    qWarning( "Failed to open device" );
+		} else {
+		    if ( dev->num_classes > 0 ) {
+			for ( ip = dev->classes, j = 0; j < devs->num_classes;
+			      ip++, j++ ) {
+			    switch ( ip->input_class ) {
+			    case KeyClass:
+				DeviceKeyPress( dev, xinput_key_press,
+						ev_class[curr_event_count] );
+				curr_event_count++;
+				DeviceKeyRelease( dev, xinput_key_release,
+						  ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    case ButtonClass:
+				DeviceButtonPress( dev, xinput_button_press,
+						   ev_class[curr_event_count] );
+				curr_event_count++;
+				DeviceButtonRelease( dev, xinput_button_release,
+						     ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    case ValuatorClass:
+				// I'm only going to be interested in motion when the
+				// stylus is already down anyway!
+				DeviceMotionNotify( dev, xinput_motion,
+						    ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    default:
+				break;
+			    }
+			}
+		    }
+		}
+		// get the min/max value for pressure!
+		any = (XAnyClassPtr) ( devs->inputclassinfo );
+		if ( dev == devStylus ) {
+		    qt_curr_events_stylus = curr_event_count;
+		    for (j = 0; j < devs->num_classes; j++) {
+			if ( any->c_class == ValuatorClass ) {
+			    v = (XValuatorInfoPtr) any;
+			    a = (XAxisInfoPtr) ((char *) v +
+						sizeof (XValuatorInfo));
+#if defined (Q_OS_IRIX)
+			    max_pressure = a[WAC_PRESSURE_I].max_value;
+#else
+			    max_pressure = a[2].max_value;
+#endif
+			    // got the max pressure no need to go further...
+			    break;
+			}
+			any = (XAnyClassPtr) ((char *) any + any->length);
+		    }
+		} else {
+		    qt_curr_events_eraser = curr_event_count;
+		}
+		// at this point we are assuming there is only one
+		// wacom device...
+#if defined (Q_OS_IRIX)
+		if ( devStylus != NULL ) {
+#else
+		    if ( devStylus != NULL && devEraser != NULL ) {
+#endif
+			break;
+		    }
+		}
+	    } // end for loop
+	    XFreeDeviceList( devices );
+#endif // QT_TABLET_SUPPORT
+
+	} else {
+	    // read some non-GUI settings when not using the X server...
+
+	    if ( QApplication::desktopSettingsAware() ) {
+		QSettings settings;
+
+		// read library (ie. plugin) path list
+		QString libpathkey = QString("/qt/%1.%2/libraryPath")
+				     .arg( QT_VERSION >> 16 )
+				     .arg( (QT_VERSION & 0xff00 ) >> 8 );
+		QStringList pathlist =
+		    settings.readListEntry(libpathkey, ':');
+		if (! pathlist.isEmpty()) {
+		    QStringList::ConstIterator it = pathlist.begin();
+		    while (it != pathlist.end())
+			QApplication::addLibraryPath(*it++);
+		}
+
+		QString defaultcodec = settings.readEntry("/qt/defaultCodec", "none");
+		if (defaultcodec != "none") {
+		    QTextCodec *codec = QTextCodec::codecForName(defaultcodec);
+		    if (codec)
+			qApp->setDefaultCodec(codec);
+		}
+
+		qt_resolve_symlinks =
+		    settings.readBoolEntry("/qt/resolveSymlinks", TRUE);
+	    }
+	}
+    }
+
+
+#ifndef QT_NO_STYLE
+    // run-time search for default style
+void QApplication::x11_initialize_style()
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_kwin_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	if ( data ) XFree( (char *)data );
+	// kwin is there. check if KDE's styles are available,
+	// otherwise use windows style
+	if ( (app_style = QStyleFactory::create("highcolor") ) == 0 )
+	    app_style = QStyleFactory::create("windows");
+    }
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_kwm_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	if ( data ) XFree( (char *)data );
+	app_style = QStyleFactory::create("windows");
+    }
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_cde_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	// DTWM is running, meaning most likely CDE is running...
+	if ( data ) XFree( (char *) data );
+	app_style = QStyleFactory::create( "cde" );
+    }
+    // maybe another desktop?
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+			     qt_gbackground_properties, 0, 1, False, AnyPropertyType,
+			     &type, &format, &length, &after, &data ) == Success &&
+	 length ) {
+	if ( data ) XFree( (char *)data );
+	// default to MotifPlus with hovering
+	app_style = QStyleFactory::create("motifplus" );
+    }
+}
+#endif
+
+void qt_init( int *argcptr, char **argv, QApplication::Type )
+{
+    qt_init_internal( argcptr, argv, 0, 0, 0 );
+}
+
+void qt_init( Display *display, Qt::HANDLE visual, Qt::HANDLE colormap )
+{
+    qt_init_internal( 0, 0, display, visual, colormap );
+}
+
+
+/*****************************************************************************
+  qt_cleanup() - cleans up when the application is finished
+ *****************************************************************************/
+
+void qt_cleanup()
+{
+    appliedstamp = 0;
+
+    if ( app_save_rootinfo )			// root window must keep state
+	qt_save_rootinfo();
+
+    if ( qt_is_gui_used ) {
+	QPixmapCache::clear();
+	QPainter::cleanup();
+	QCursor::cleanup();
+	QFont::cleanup();
+	QColor::cleanup();
+	QSharedDoubleBuffer::cleanup();
+    }
+#if defined(QT_THREAD_SUPPORT)
+    QThread::cleanup();
+#endif
+
+#if defined (QT_TABLET_SUPPORT)
+    if ( devStylus != NULL )
+	XCloseDevice( appDpy, devStylus );
+    if ( devEraser != NULL )
+	XCloseDevice( appDpy, devEraser );
+#endif
+
+#if !defined(QT_NO_XIM)
+    if ( qt_xim )
+	QApplication::close_xim();
+#endif
+
+    if ( qt_is_gui_used ) {
+	int screen;
+	for ( screen = 0; screen < appScreenCount; screen++ ) {
+	    if ( ! QPaintDevice::x11AppDefaultColormap( screen ) )
+		XFreeColormap( QPaintDevice::x11AppDisplay(),
+			       QPaintDevice::x11AppColormap( screen ) );
+	}
+    }
+
+#define QT_CLEANUP_GC(g) if (g) { for (int i=0;i<appScreenCount;i++){if(g[i])XFreeGC(appDpy,g[i]);} delete [] g; g = 0; }
+    QT_CLEANUP_GC(app_gc_ro);
+    QT_CLEANUP_GC(app_gc_ro_m);
+    QT_CLEANUP_GC(app_gc_tmp);
+    QT_CLEANUP_GC(app_gc_tmp_m);
+#undef QT_CLEANUP_GC
+
+    delete sip_list;
+    sip_list = 0;
+
+    // Reset the error handlers
+    XSetErrorHandler( original_x_errhandler );
+    XSetIOErrorHandler( original_xio_errhandler );
+
+    if ( qt_is_gui_used && !appForeignDpy )
+	XCloseDisplay( appDpy );		// close X display
+    appDpy = 0;
+
+    qt_x11_wm_client_leader = 0;
+
+    if ( QPaintDevice::x_appdepth_arr )
+	delete [] QPaintDevice::x_appdepth_arr;
+    if ( QPaintDevice::x_appcells_arr )
+	delete [] QPaintDevice::x_appcells_arr;
+    if ( QPaintDevice::x_appcolormap_arr )
+	delete []QPaintDevice::x_appcolormap_arr;
+    if ( QPaintDevice::x_appdefcolormap_arr )
+	delete [] QPaintDevice::x_appdefcolormap_arr;
+    if ( QPaintDevice::x_appvisual_arr )
+	delete [] QPaintDevice::x_appvisual_arr;
+    if ( QPaintDevice::x_appdefvisual_arr )
+	delete [] QPaintDevice::x_appdefvisual_arr;
+
+    if ( appForeignDpy ) {
+	delete [] (char *)appName;
+	appName = 0;
+	delete [] (char *)appClass;
+	appClass = 0;
+    }
+
+    if (qt_net_supported_list)
+	delete [] qt_net_supported_list;
+    qt_net_supported_list = 0;
+
+    if (qt_net_virtual_root_list)
+	delete [] qt_net_virtual_root_list;
+    qt_net_virtual_root_list = 0;
+}
+
+
+/*****************************************************************************
+  Platform specific global and internal functions
+ *****************************************************************************/
+
+void qt_save_rootinfo()				// save new root info
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+
+    if ( qt_xsetroot_id ) {			// kill old pixmap
+	if ( XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+				 qt_xsetroot_id, 0, 1,
+				 True, AnyPropertyType, &type, &format,
+				 &length, &after, &data ) == Success ) {
+	    if ( type == XA_PIXMAP && format == 32 && length == 1 &&
+		 after == 0 && data ) {
+		XKillClient( appDpy, *((Pixmap*)data) );
+	    }
+	    Pixmap dummy = XCreatePixmap( appDpy, QPaintDevice::x11AppRootWindow(),
+					  1, 1, 1 );
+	    XChangeProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+			     qt_xsetroot_id, XA_PIXMAP, 32,
+			     PropModeReplace, (uchar *)&dummy, 1 );
+	    XSetCloseDownMode( appDpy, RetainPermanent );
+	}
+    }
+    if ( data )
+	XFree( (char *)data );
+}
+
+void qt_updated_rootinfo()
+{
+    app_save_rootinfo = TRUE;
+}
+
+bool qt_wstate_iconified( WId winid )
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+    int r = XGetWindowProperty( appDpy, winid, qt_wm_state, 0, 2,
+				 False, AnyPropertyType, &type, &format,
+				 &length, &after, &data );
+    bool iconic = FALSE;
+    if ( r == Success && data && format == 32 ) {
+	// Q_UINT32 *wstate = (Q_UINT32*)data;
+	unsigned long *wstate = (unsigned long *) data;
+	iconic = (*wstate == IconicState );
+	XFree( (char *)data );
+    }
+    return iconic;
+}
+
+const char *qAppName()				// get application name
+{
+    return appName;
+}
+
+const char *qAppClass()				// get application class
+{
+    return appClass;
+}
+
+Display *qt_xdisplay()				// get current X display
+{
+    return appDpy;
+}
+
+int qt_xscreen()				// get current X screen
+{
+    return appScreen;
+}
+
+// ### REMOVE 4.0
+WId qt_xrootwin()				// get X root window
+{
+    return QPaintDevice::x11AppRootWindow();
+}
+
+WId qt_xrootwin( int scrn )			// get X root window for screen
+{
+    return QPaintDevice::x11AppRootWindow( scrn );
+}
+
+bool qt_nograb()				// application no-grab option
+{
+#if defined(QT_DEBUG)
+    return appNoGrab;
+#else
+    return FALSE;
+#endif
+}
+
+static GC create_gc( int scrn, bool monochrome )
+{
+    GC gc;
+    if ( monochrome ) {
+	Pixmap pm = XCreatePixmap( appDpy, RootWindow( appDpy, scrn ), 8, 8, 1 );
+	gc = XCreateGC( appDpy, pm, 0, 0 );
+	XFreePixmap( appDpy, pm );
+    } else {
+	if ( QPaintDevice::x11AppDefaultVisual( scrn ) ) {
+	    gc = XCreateGC( appDpy, RootWindow( appDpy, scrn ), 0, 0 );
+	} else {
+	    Window w;
+	    XSetWindowAttributes a;
+	    a.background_pixel = Qt::black.pixel( scrn );
+	    a.border_pixel = Qt::black.pixel( scrn );
+	    a.colormap = QPaintDevice::x11AppColormap( scrn );
+	    w = XCreateWindow( appDpy, RootWindow( appDpy, scrn ), 0, 0, 100, 100,
+			       0, QPaintDevice::x11AppDepth( scrn ), InputOutput,
+			       (Visual*)QPaintDevice::x11AppVisual( scrn ),
+			       CWBackPixel|CWBorderPixel|CWColormap, &a );
+	    gc = XCreateGC( appDpy, w, 0, 0 );
+	    XDestroyWindow( appDpy, w );
+	}
+    }
+    XSetGraphicsExposures( appDpy, gc, False );
+    return gc;
+}
+
+GC qt_xget_readonly_gc( int scrn, bool monochrome )	// get read-only GC
+{
+    if ( scrn < 0 || scrn >= appScreenCount ) {
+	qDebug("invalid screen %d %d", scrn, appScreenCount );
+	QWidget* bla = 0;
+	bla->setName("hello");
+    }
+    GC gc;
+    if ( monochrome ) {
+	if ( !app_gc_ro_m )			// create GC for bitmap
+	    memset( (app_gc_ro_m = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_ro_m[scrn] )
+	    app_gc_ro_m[scrn] = create_gc( scrn, TRUE );
+	gc = app_gc_ro_m[scrn];
+    } else {					// create standard GC
+	if ( !app_gc_ro )
+	    memset( (app_gc_ro = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_ro[scrn] )
+	    app_gc_ro[scrn] = create_gc( scrn, FALSE );
+	gc = app_gc_ro[scrn];
+    }
+    return gc;
+}
+
+GC qt_xget_temp_gc( int scrn, bool monochrome )		// get temporary GC
+{
+    if ( scrn < 0 || scrn >= appScreenCount ) {
+	qDebug("invalid screen (tmp) %d %d", scrn, appScreenCount );
+	QWidget* bla = 0;
+	bla->setName("hello");
+    }
+    GC gc;
+    if ( monochrome ) {
+	if ( !app_gc_tmp_m )			// create GC for bitmap
+	    memset( (app_gc_tmp_m = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_tmp_m[scrn] )
+	    app_gc_tmp_m[scrn] = create_gc( scrn, TRUE );
+	gc = app_gc_tmp_m[scrn];
+    } else {					// create standard GC
+	if ( !app_gc_tmp )
+	    memset( (app_gc_tmp = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_tmp[scrn] )
+	    app_gc_tmp[scrn] = create_gc( scrn, FALSE );
+	gc = app_gc_tmp[scrn];
+    }
+    return gc;
+}
+
+
+/*****************************************************************************
+  Platform specific QApplication members
+ *****************************************************************************/
+
+/*!
+    \fn QWidget *QApplication::mainWidget() const
+
+    Returns the main application widget, or 0 if there is no main
+    widget.
+
+    \sa setMainWidget()
+*/
+
+/*!
+    Sets the application's main widget to \a mainWidget.
+
+    In most respects the main widget is like any other widget, except
+    that if it is closed, the application exits. Note that
+    QApplication does \e not take ownership of the \a mainWidget, so
+    if you create your main widget on the heap you must delete it
+    yourself.
+
+    You need not have a main widget; connecting lastWindowClosed() to
+    quit() is an alternative.
+
+    For X11, this function also resizes and moves the main widget
+    according to the \e -geometry command-line option, so you should
+    set the default geometry (using \l QWidget::setGeometry()) before
+    calling setMainWidget().
+
+    \sa mainWidget(), exec(), quit()
+*/
+
+void QApplication::setMainWidget( QWidget *mainWidget )
+{
+#if defined(QT_CHECK_STATE)
+    if ( mainWidget && mainWidget->parentWidget() &&
+	 ! mainWidget->parentWidget()->isDesktop() )
+	qWarning( "QApplication::setMainWidget(): New main widget (%s/%s) "
+		  "has a parent!",
+		  mainWidget->className(), mainWidget->name() );
+#endif
+    main_widget = mainWidget;
+    if ( main_widget ) {			// give WM command line
+	XSetWMProperties( main_widget->x11Display(), main_widget->winId(),
+			  0, 0, app_argv, app_argc, 0, 0, 0 );
+	if ( mwTitle )
+	    XStoreName( main_widget->x11Display(), main_widget->winId(), (char*)mwTitle );
+	if ( mwGeometry ) {			// parse geometry
+	    int x, y;
+	    int w, h;
+	    int m = XParseGeometry( (char*)mwGeometry, &x, &y, (uint*)&w, (uint*)&h );
+	    QSize minSize = main_widget->minimumSize();
+	    QSize maxSize = main_widget->maximumSize();
+	    if ( (m & XValue) == 0 )
+		x = main_widget->geometry().x();
+	    if ( (m & YValue) == 0 )
+		y = main_widget->geometry().y();
+	    if ( (m & WidthValue) == 0 )
+		w = main_widget->width();
+	    if ( (m & HeightValue) == 0 )
+		h = main_widget->height();
+	    w = QMIN(w,maxSize.width());
+	    h = QMIN(h,maxSize.height());
+	    w = QMAX(w,minSize.width());
+	    h = QMAX(h,minSize.height());
+	    if ( (m & XNegative) ) {
+		x = desktop()->width()  + x - w;
+		qt_widget_tlw_gravity = NorthEastGravity;
+	    }
+	    if ( (m & YNegative) ) {
+		y = desktop()->height() + y - h;
+		qt_widget_tlw_gravity = (m & XNegative) ? SouthEastGravity : SouthWestGravity;
+	    }
+	    main_widget->setGeometry( x, y, w, h );
+	}
+    }
+}
+
+#ifndef QT_NO_CURSOR
+
+/*****************************************************************************
+  QApplication cursor stack
+ *****************************************************************************/
+
+extern void qt_x11_enforce_cursor( QWidget * w );
+
+typedef QPtrList<QCursor> QCursorList;
+
+static QCursorList *cursorStack = 0;
+
+/*!
+    \fn QCursor *QApplication::overrideCursor()
+
+    Returns the active application override cursor.
+
+    This function returns 0 if no application cursor has been defined
+    (i.e. the internal cursor stack is empty).
+
+    \sa setOverrideCursor(), restoreOverrideCursor()
+*/
+
+/*!
+    Sets the application override cursor to \a cursor.
+
+    Application override cursors are intended for showing the user
+    that the application is in a special state, for example during an
+    operation that might take some time.
+
+    This cursor will be displayed in all the application's widgets
+    until restoreOverrideCursor() or another setOverrideCursor() is
+    called.
+
+    Application cursors are stored on an internal stack.
+    setOverrideCursor() pushes the cursor onto the stack, and
+    restoreOverrideCursor() pops the active cursor off the stack.
+    Every setOverrideCursor() must eventually be followed by a
+    corresponding restoreOverrideCursor(), otherwise the stack will
+    never be emptied.
+
+    If \a replace is TRUE, the new cursor will replace the last
+    override cursor (the stack keeps its depth). If \a replace is
+    FALSE, the new stack is pushed onto the top of the stack.
+
+    Example:
+    \code
+	QApplication::setOverrideCursor( QCursor(Qt::WaitCursor) );
+	calculateHugeMandelbrot();              // lunch time...
+	QApplication::restoreOverrideCursor();
+    \endcode
+
+    \sa overrideCursor(), restoreOverrideCursor(), QWidget::setCursor()
+*/
+
+void QApplication::setOverrideCursor( const QCursor &cursor, bool replace )
+{
+    if ( !cursorStack ) {
+	cursorStack = new QCursorList;
+	Q_CHECK_PTR( cursorStack );
+	cursorStack->setAutoDelete( TRUE );
+    }
+    app_cursor = new QCursor( cursor );
+    Q_CHECK_PTR( app_cursor );
+    if ( replace )
+	cursorStack->removeLast();
+    cursorStack->append( app_cursor );
+
+    QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+    register QWidget *w;
+    while ( (w=it.current()) ) {		// for all widgets that have
+	if ( w->testWState( WState_OwnCursor ) )
+	    qt_x11_enforce_cursor( w );
+	++it;
+    }
+    XFlush( appDpy );				// make X execute it NOW
+}
+
+/*!
+    Undoes the last setOverrideCursor().
+
+    If setOverrideCursor() has been called twice, calling
+    restoreOverrideCursor() will activate the first cursor set.
+    Calling this function a second time restores the original widgets'
+    cursors.
+
+    \sa setOverrideCursor(), overrideCursor().
+*/
+
+void QApplication::restoreOverrideCursor()
+{
+    if ( !cursorStack )				// no cursor stack
+	return;
+    cursorStack->removeLast();
+    app_cursor = cursorStack->last();
+    if ( QWidget::mapper != 0 && !closingDown() ) {
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {		// set back to original cursors
+	    if ( w->testWState( WState_OwnCursor ) )
+		qt_x11_enforce_cursor( w );
+	    ++it;
+	}
+	XFlush( appDpy );
+    }
+    if ( !app_cursor ) {
+	delete cursorStack;
+	cursorStack = 0;
+    }
+}
+
+#endif
+
+/*!
+    \fn bool QApplication::hasGlobalMouseTracking()
+
+    Returns TRUE if global mouse tracking is enabled; otherwise
+    returns FALSE.
+
+    \sa setGlobalMouseTracking()
+*/
+
+/*!
+    Enables global mouse tracking if \a enable is TRUE, or disables it
+    if \a enable is FALSE.
+
+    Enabling global mouse tracking makes it possible for widget event
+    filters or application event filters to get all mouse move events,
+    even when no button is depressed. This is useful for special GUI
+    elements, e.g. tooltips.
+
+    Global mouse tracking does not affect widgets and their
+    mouseMoveEvent(). For a widget to get mouse move events when no
+    button is depressed, it must do QWidget::setMouseTracking(TRUE).
+
+    This function uses an internal counter. Each
+    setGlobalMouseTracking(TRUE) must have a corresponding
+    setGlobalMouseTracking(FALSE):
+    \code
+	// at this point global mouse tracking is off
+	QApplication::setGlobalMouseTracking( TRUE );
+	QApplication::setGlobalMouseTracking( TRUE );
+	QApplication::setGlobalMouseTracking( FALSE );
+	// at this point it's still on
+	QApplication::setGlobalMouseTracking( FALSE );
+	// but now it's off
+    \endcode
+
+    \sa hasGlobalMouseTracking(), QWidget::hasMouseTracking()
+*/
+
+void QApplication::setGlobalMouseTracking( bool enable )
+{
+    bool tellAllWidgets;
+    if ( enable ) {
+	tellAllWidgets = (++app_tracking == 1);
+    } else {
+	tellAllWidgets = (--app_tracking == 0);
+    }
+    if ( tellAllWidgets ) {
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {
+	    if ( app_tracking > 0 ) {		// switch on
+		if ( !w->testWState(WState_MouseTracking) ) {
+		    w->setMouseTracking( TRUE );
+		    w->clearWState( WState_MouseTracking );
+		}
+	    } else {				// switch off
+		if ( !w->testWState(WState_MouseTracking) ) {
+		    w->setWState( WState_MouseTracking );
+		    w->setMouseTracking( FALSE );
+		}
+	    }
+	    ++it;
+	}
+    }
+}
+
+
+/*****************************************************************************
+  Routines to find a Qt widget from a screen position
+ *****************************************************************************/
+
+Window qt_x11_findClientWindow( Window win, Atom property, bool leaf )
+{
+    Atom   type = None;
+    int	   format, i;
+    ulong  nitems, after;
+    uchar *data;
+    Window root, parent, target=0, *children=0;
+    uint   nchildren;
+    if ( XGetWindowProperty( appDpy, win, property, 0, 0, FALSE, AnyPropertyType,
+			     &type, &format, &nitems, &after, &data ) == Success ) {
+	if ( data )
+	    XFree( (char *)data );
+	if ( type )
+	    return win;
+    }
+    if ( !XQueryTree(appDpy,win,&root,&parent,&children,&nchildren) ) {
+	if ( children )
+	    XFree( (char *)children );
+	return 0;
+    }
+    for ( i=nchildren-1; !target && i >= 0; i-- )
+	target = qt_x11_findClientWindow( children[i], property, leaf );
+    if ( children )
+	XFree( (char *)children );
+    return target;
+}
+
+
+/*!
+    Returns a pointer to the widget at global screen position \a
+    (x, y), or 0 if there is no Qt widget there.
+
+    If \a child is FALSE and there is a child widget at position \a
+    (x, y), the top-level widget containing it is returned. If \a child
+    is TRUE the child widget at position \a (x, y) is returned.
+
+    This function is normally rather slow.
+
+    \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard()
+*/
+
+QWidget *QApplication::widgetAt( int x, int y, bool child )
+{
+    int screen = QCursor::x11Screen();
+    int lx, ly;
+
+    Window target;
+    if ( !XTranslateCoordinates(appDpy,
+				QPaintDevice::x11AppRootWindow(screen),
+				QPaintDevice::x11AppRootWindow(screen),
+				x, y, &lx, &ly, &target) ) {
+	return 0;
+    }
+    if ( !target || target == QPaintDevice::x11AppRootWindow(screen) )
+	return 0;
+    QWidget *w, *c;
+    w = QWidget::find( (WId)target );
+
+    if ( !w ) {
+	qt_ignore_badwindow();
+	target = qt_x11_findClientWindow( target, qt_wm_state, TRUE );
+	if (qt_badwindow() )
+	    return 0;
+	w = QWidget::find( (WId)target );
+#if 0
+	if ( !w ) {
+	    // Perhaps the widgets at (x,y) is inside a foreign application?
+	    // Search all toplevel widgets to see if one is within target
+	    QWidgetList *list   = topLevelWidgets();
+	    QWidget     *widget = list->first();
+	    while ( widget && !w ) {
+		Window	ctarget = target;
+		if ( widget->isVisible() && !widget->isDesktop() ) {
+		    Window wid = widget->winId();
+		    while ( ctarget && !w ) {
+			XTranslateCoordinates(appDpy,
+					      QPaintDevice::x11AppRootWindow(screen),
+					      ctarget, x, y, &lx, &ly, &ctarget);
+			if ( ctarget == wid ) {
+			    // Found
+			    w = widget;
+			    XTranslateCoordinates(appDpy,
+						  QPaintDevice::x11AppRootWindow(screen),
+						  ctarget, x, y, &lx, &ly, &ctarget);
+			}
+		    }
+		}
+		widget = list->next();
+	    }
+	    delete list;
+	}
+#endif
+    }
+    if ( child && w ) {
+	if ( (c = w->childAt( w->mapFromGlobal(QPoint(x, y ) ) ) ) )
+	    return c;
+    }
+    return w;
+}
+
+/*!
+    \overload QWidget *QApplication::widgetAt( const QPoint &pos, bool child )
+
+    Returns a pointer to the widget at global screen position \a pos,
+    or 0 if there is no Qt widget there.
+
+    If \a child is FALSE and there is a child widget at position \a
+    pos, the top-level widget containing it is returned. If \a child
+    is TRUE the child widget at position \a pos is returned.
+*/
+
+
+/*!
+    Flushes the X event queue in the X11 implementation. This normally
+    returns almost immediately. Does nothing on other platforms.
+
+    \sa syncX()
+*/
+
+void QApplication::flushX()
+{
+    if ( appDpy )
+	XFlush( appDpy );
+}
+
+/*!
+    Flushes the window system specific event queues.
+
+    If you are doing graphical changes inside a loop that does not
+    return to the event loop on asynchronous window systems like X11
+    or double buffered window systems like MacOS X, and you want to
+    visualize these changes immediately (e.g. Splash Screens), call
+    this function.
+
+    \sa flushX() sendPostedEvents() QPainter::flush()
+*/
+
+void QApplication::flush()
+{
+    flushX();
+}
+
+/*!
+    Synchronizes with the X server in the X11 implementation. This
+    normally takes some time. Does nothing on other platforms.
+
+    \sa flushX()
+*/
+
+void QApplication::syncX()
+{
+    if ( appDpy )
+	XSync( appDpy, False );			// don't discard events
+}
+
+
+/*!
+    Sounds the bell, using the default volume and sound.
+*/
+
+void QApplication::beep()
+{
+    if ( appDpy )
+	XBell( appDpy, 0 );
+}
+
+
+
+/*****************************************************************************
+  Special lookup functions for windows that have been reparented recently
+ *****************************************************************************/
+
+static QWidgetIntDict *wPRmapper = 0;		// alternative widget mapper
+
+void qPRCreate( const QWidget *widget, Window oldwin )
+{						// QWidget::reparent mechanism
+    if ( !wPRmapper ) {
+	wPRmapper = new QWidgetIntDict;
+	Q_CHECK_PTR( wPRmapper );
+    }
+    wPRmapper->insert( (long)oldwin, widget );	// add old window to mapper
+    QETWidget *w = (QETWidget *)widget;
+    w->setWState( Qt::WState_Reparented );	// set reparented flag
+}
+
+void qPRCleanup( QWidget *widget )
+{
+    QETWidget *etw = (QETWidget *)widget;
+    if ( !(wPRmapper && etw->testWState(Qt::WState_Reparented)) )
+	return;					// not a reparented widget
+    QWidgetIntDictIt it(*wPRmapper);
+    QWidget *w;
+    while ( (w=it.current()) ) {
+	int key = it.currentKey();
+	++it;
+	if ( w == etw ) {                       // found widget
+	    etw->clearWState( Qt::WState_Reparented ); // clear flag
+	    wPRmapper->remove( key );// old window no longer needed
+	    if ( wPRmapper->count() == 0 ) {	// became empty
+		delete wPRmapper;		// then reset alt mapper
+		wPRmapper = 0;
+		return;
+	    }
+	}
+    }
+}
+
+static QETWidget *qPRFindWidget( Window oldwin )
+{
+    return wPRmapper ? (QETWidget*)wPRmapper->find((long)oldwin) : 0;
+}
+
+/*!
+    \internal
+*/
+int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)
+{
+    QETWidget *widget = (QETWidget*)w;
+    if ( event->xclient.format == 32 && event->xclient.message_type ) {
+	if ( event->xclient.message_type == qt_wm_protocols ) {
+	    Atom a = event->xclient.data.l[0];
+	    if ( a == qt_wm_delete_window ) {
+		if ( passive_only ) return 0;
+		widget->translateCloseEvent(event);
+	    }
+	    else if ( a == qt_wm_take_focus ) {
+		QWidget * amw = activeModalWidget();
+		if ( (ulong) event->xclient.data.l[1] > qt_x_time )
+		    qt_x_time = event->xclient.data.l[1];
+		if ( amw && amw != widget ) {
+		    QWidget* groupLeader = widget;
+		    while ( groupLeader && !groupLeader->testWFlags( Qt::WGroupLeader )
+                            && groupLeader != amw )
+			groupLeader = groupLeader->parentWidget();
+		    if ( !groupLeader ) {
+                        QWidget *p = amw->parentWidget();
+                        while (p && p != widget)
+                            p = p->parentWidget();
+                        if (!p || !qt_net_supported_list)
+			    amw->raise(); // help broken window managers
+			amw->setActiveWindow();
+		    }
+		}
+#ifndef QT_NO_WHATSTHIS
+	    } else if ( a == qt_net_wm_context_help ) {
+		QWhatsThis::enterWhatsThisMode();
+#endif // QT_NO_WHATSTHIS
+	    } else if ( a == qt_net_wm_ping ) {
+		// avoid send/reply loops
+		Window root = QPaintDevice::x11AppRootWindow( w->x11Screen() );
+		if (event->xclient.window != root) {
+		    event->xclient.window = root;
+		    XSendEvent( event->xclient.display, event->xclient.window,
+				False, SubstructureNotifyMask|SubstructureRedirectMask, event );
+		}
+	    }
+	} else if ( event->xclient.message_type == qt_qt_scrolldone ) {
+	    widget->translateScrollDoneEvent(event);
+	} else if ( event->xclient.message_type == qt_xdnd_position ) {
+	    qt_handle_xdnd_position( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_enter ) {
+	    qt_handle_xdnd_enter( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_status ) {
+	    qt_handle_xdnd_status( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_leave ) {
+	    qt_handle_xdnd_leave( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_drop ) {
+	    qt_handle_xdnd_drop( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_finished ) {
+	    qt_handle_xdnd_finished( widget, event, passive_only );
+	} else {
+	    if ( passive_only ) return 0;
+	    // All other are interactions
+	}
+    } else {
+	qt_motifdnd_handle_msg( widget, event, passive_only );
+    }
+
+    return 0;
+}
+
+/*!
+    This function does the core processing of individual X
+    \a{event}s, normally by dispatching Qt events to the right
+    destination.
+
+    It returns 1 if the event was consumed by special handling, 0 if
+    the \a event was consumed by normal handling, and -1 if the \a
+    event was for an unrecognized widget.
+
+    \sa x11EventFilter()
+*/
+int QApplication::x11ProcessEvent( XEvent* event )
+{
+    switch ( event->type ) {
+    case ButtonPress:
+	ignoreNextMouseReleaseEvent = FALSE;
+	qt_x_user_time = event->xbutton.time;
+	// fallthrough intended
+    case ButtonRelease:
+	qt_x_time = event->xbutton.time;
+	break;
+    case MotionNotify:
+	qt_x_time = event->xmotion.time;
+	break;
+    case XKeyPress:
+	qt_x_user_time = event->xkey.time;
+	// fallthrough intended
+    case XKeyRelease:
+	qt_x_time = event->xkey.time;
+	break;
+    case PropertyNotify:
+	qt_x_time = event->xproperty.time;
+	break;
+    case EnterNotify:
+    case LeaveNotify:
+	qt_x_time = event->xcrossing.time;
+	break;
+    case SelectionClear:
+	qt_x_time = event->xselectionclear.time;
+	break;
+    default:
+	break;
+    }
+
+    QETWidget *widget = (QETWidget*)QWidget::find( (WId)event->xany.window );
+
+    if ( wPRmapper ) {				// just did a widget reparent?
+	if ( widget == 0 ) {			// not in std widget mapper
+	    switch ( event->type ) {		// only for mouse/key events
+	    case ButtonPress:
+	    case ButtonRelease:
+	    case MotionNotify:
+	    case XKeyPress:
+	    case XKeyRelease:
+		widget = qPRFindWidget( event->xany.window );
+		break;
+	    }
+	}
+	else if ( widget->testWState(WState_Reparented) )
+	    qPRCleanup( widget );		// remove from alt mapper
+    }
+
+    QETWidget *keywidget=0;
+    bool grabbed=FALSE;
+    if ( event->type==XKeyPress || event->type==XKeyRelease ) {
+	keywidget = (QETWidget*)QWidget::keyboardGrabber();
+	if ( keywidget ) {
+	    grabbed = TRUE;
+	} else {
+	    if ( focus_widget )
+		keywidget = (QETWidget*)focus_widget;
+	    if ( !keywidget ) {
+		if ( inPopupMode() ) // no focus widget, see if we have a popup
+		    keywidget = (QETWidget*) activePopupWidget();
+		else if ( widget )
+		    keywidget = (QETWidget*)widget->topLevelWidget();
+	    }
+	}
+    }
+
+    int xkey_keycode = event->xkey.keycode;
+    if ( XFilterEvent( event,
+		       keywidget ? keywidget->topLevelWidget()->winId() : None ) ) {
+	if ( keywidget )
+	    composingKeycode = xkey_keycode; // ### not documented in xlib
+
+#ifndef QT_NO_XIM
+ 	if ( event->type != XKeyPress || ! (qt_xim_style & XIMPreeditCallbacks) )
+	    return 1;
+
+	/*
+	 * The Solaris htt input method will transform a ClientMessage
+	 * event into a filtered KeyPress event, in which case our
+	 * keywidget is still zero.
+	 */
+        if ( ! keywidget ) {
+ 	    keywidget = (QETWidget*)QWidget::keyboardGrabber();
+	    if ( keywidget ) {
+	        grabbed = TRUE;
+	    } else {
+	        if ( focus_widget )
+		    keywidget = (QETWidget*)focus_widget;
+	        if ( !keywidget ) {
+		    if ( inPopupMode() ) // no focus widget, see if we have a popup
+		        keywidget = (QETWidget*) activePopupWidget();
+		    else if ( widget )
+		        keywidget = (QETWidget*)widget->topLevelWidget();
+	        }
+	    }
+        }
+
+	/*
+	  if the composition string has been emptied, we need to send
+	  an IMEnd event.  however, we have no way to tell if the user
+	  has cancelled input, or if the user has accepted the
+	  composition.
+
+	  so, we have to look for the next keypress and see if it is
+	  the 'commit' key press (keycode == 0).  if it is, we deliver
+	  an IMEnd event with the final text, otherwise we deliver an
+	  IMEnd with empty text (meaning the user has cancelled the
+	  input).
+	*/
+	QInputContext *qic =
+	    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
+	extern bool qt_compose_emptied; // qinputcontext_x11.cpp
+	if ( qic && qic->composing && qic->focusWidget && qt_compose_emptied ) {
+	    XEvent event2;
+	    bool found = FALSE;
+	    if ( XCheckTypedEvent( QPaintDevice::x11AppDisplay(),
+				   XKeyPress, &event2 ) ) {
+		if ( event2.xkey.keycode == 0 ) {
+		    // found a key event with the 'commit' string
+		    found = TRUE;
+		    XPutBackEvent( QPaintDevice::x11AppDisplay(), &event2 );
+		}
+	    }
+
+	    if ( !found ) {
+		// no key event, so the user must have cancelled the composition
+		QIMEvent endevent( QEvent::IMEnd, QString::null, -1 );
+		QApplication::sendEvent( qic->focusWidget, &endevent );
+
+		qic->focusWidget = 0;
+	    }
+
+	    qt_compose_emptied = FALSE;
+	}
+#endif // QT_NO_XIM
+
+	return 1;
+    }
+
+    if ( qt_x11EventFilter(event) )		// send through app filter
+	return 1;
+
+    if ( event->type == MappingNotify ) {	// keyboard mapping changed
+	XRefreshKeyboardMapping( &event->xmapping );
+	return 0;
+    }
+
+    if ( event->type == PropertyNotify ) {	// some properties changed
+	if ( event->xproperty.window == QPaintDevice::x11AppRootWindow( 0 ) ) {
+	    // root properties for the first screen
+	    if ( event->xproperty.atom == qt_clipboard_sentinel ) {
+		if (qt_check_clipboard_sentinel() )
+		    emit clipboard()->dataChanged();
+	    } else if ( event->xproperty.atom == qt_selection_sentinel ) {
+		if (qt_check_selection_sentinel() )
+		    emit clipboard()->selectionChanged();
+	    } else if ( obey_desktop_settings ) {
+		if ( event->xproperty.atom == qt_resource_manager )
+		    qt_set_x11_resources();
+		else if ( event->xproperty.atom == qt_settings_timestamp )
+		    QApplication::x11_apply_settings();
+	    }
+	}
+	if ( event->xproperty.window == QPaintDevice::x11AppRootWindow() ) {
+	    // root properties for the default screen
+	    if ( event->xproperty.atom == qt_input_encoding ) {
+		qt_set_input_encoding();
+	    } else if ( event->xproperty.atom == qt_net_supported ) {
+		qt_get_net_supported();
+	    } else if ( event->xproperty.atom == qt_net_virtual_roots ) {
+		qt_get_net_virtual_roots();
+	    } else if ( event->xproperty.atom == qt_net_workarea ) {
+		qt_desktopwidget_update_workarea();
+	    }
+	} else if ( widget ) {
+	    widget->translatePropertyEvent(event);
+	}  else {
+	    return -1; // don't know this window
+	}
+	return 0;
+    }
+
+    if ( !widget ) {				// don't know this windows
+	QWidget* popup = QApplication::activePopupWidget();
+	if ( popup ) {
+
+	    /*
+	      That is more than suboptimal. The real solution should
+	      do some keyevent and buttonevent translation, so that
+	      the popup still continues to work as the user expects.
+	      Unfortunately this translation is currently only
+	      possible with a known widget. I'll change that soon
+	      (Matthias).
+	    */
+
+	    // Danger - make sure we don't lock the server
+	    switch ( event->type ) {
+	    case ButtonPress:
+	    case ButtonRelease:
+	    case XKeyPress:
+	    case XKeyRelease:
+		do {
+		    popup->close();
+		} while ( (popup = qApp->activePopupWidget()) );
+		return 1;
+	    }
+	}
+	return -1;
+    }
+
+    if ( event->type == XKeyPress || event->type == XKeyRelease )
+	widget = keywidget; // send XKeyEvents through keywidget->x11Event()
+
+    if ( app_do_modal )				// modal event handling
+	if ( !qt_try_modal(widget, event) ) {
+	    if ( event->type == ClientMessage )
+		x11ClientMessage( widget, event, TRUE );
+	    return 1;
+	}
+
+
+    if ( widget->x11Event(event) )		// send through widget filter
+	return 1;
+#if defined (QT_TABLET_SUPPORT)
+    if ( event->type == xinput_motion ||
+	 event->type == xinput_button_release ||
+	 event->type == xinput_button_press ) {
+	widget->translateXinputEvent( event );
+	return 0;
+    }
+#endif
+
+#ifndef QT_NO_XRANDR
+    if (event->type == xrandr_eventbase + RRScreenChangeNotify) {
+	// update Xlib internals with the latest screen configuration
+	XRRUpdateConfiguration(event);
+
+	// update the size for desktop widget
+	int scr = XRRRootToScreen( appDpy, event->xany.window );
+	QWidget *w = desktop()->screen( scr );
+	QSize oldSize( w->size() );
+	w->crect.setWidth( DisplayWidth( appDpy, scr ) );
+        w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	if ( w->size() != oldSize ) {
+	    QResizeEvent e( w->size(), oldSize );
+	    QApplication::sendEvent( w, &e );
+	    emit desktop()->resized( scr );
+	}
+    }
+#endif // QT_NO_XRANDR
+
+    switch ( event->type ) {
+
+    case ButtonRelease:			// mouse event
+	if ( ignoreNextMouseReleaseEvent ) {
+	    ignoreNextMouseReleaseEvent = FALSE;
+	    break;
+	}
+	// fall through intended
+    case ButtonPress:
+	if (event->xbutton.root != RootWindow(widget->x11Display(), widget->x11Screen())
+	    && ! qt_xdnd_dragging) {
+	    while ( activePopupWidget() )
+		activePopupWidget()->close();
+	    return 1;
+	}
+	if (event->type == ButtonPress)
+	    qt_net_update_user_time(widget->topLevelWidget());
+	// fall through intended
+    case MotionNotify:
+#if defined(QT_TABLET_SUPPORT)
+	if ( !chokeMouse ) {
+#endif
+	    widget->translateMouseEvent( event );
+#if defined(QT_TABLET_SUPPORT)
+	} else {
+	    chokeMouse = FALSE;
+	}
+#endif
+	break;
+
+    case XKeyPress:				// keyboard event
+	qt_net_update_user_time(widget->topLevelWidget());
+	// fallthrough intended
+    case XKeyRelease:
+	{
+	    if ( keywidget && keywidget->isEnabled() ) { // should always exist
+#ifndef QT_NO_XIM
+		QInputContext *qic =
+		    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
+
+		if ((qt_xim_style & XIMPreeditCallbacks) && event->xkey.keycode == 0 &&
+		    qic && qic->composing && qic->focusWidget) {
+		    // input method has sent us a commit string
+		    QCString data(513);
+		    KeySym sym;    // unused
+		    Status status; // unused
+		    QString text;
+		    int count = qic->lookupString( &(event->xkey), data,
+						   &sym, &status );
+		    if ( count > 0 )
+			text = input_mapper->toUnicode( data, count );
+
+		    // qDebug( "sending IMEnd with %d chars", text.length() );
+		    QIMEvent endevent( QEvent::IMEnd, text, -1 );
+		    QApplication::sendEvent( qic->focusWidget, &endevent );
+
+		    qic->focusWidget = 0;
+		    qic->text = QString::null;
+		} else
+#endif // !QT_NO_XIM
+		    {
+			// qDebug( "sending key event" );
+			keywidget->translateKeyEvent( event, grabbed );
+		    }
+	    }
+	    break;
+	}
+
+    case GraphicsExpose:
+    case Expose:				// paint event
+	widget->translatePaintEvent( event );
+	break;
+
+    case ConfigureNotify:			// window move/resize event
+	if ( event->xconfigure.event == event->xconfigure.window )
+	    widget->translateConfigEvent( event );
+	break;
+
+    case XFocusIn: {				// got focus
+	if ( widget->isDesktop() )
+	    break;
+	if ( inPopupMode() ) // some delayed focus event to ignore
+	    break;
+	if ( !widget->isTopLevel() )
+	    break;
+	if ( event->xfocus.detail != NotifyAncestor &&
+	     event->xfocus.detail != NotifyInferior &&
+	     event->xfocus.detail != NotifyNonlinear )
+	    break;
+	widget->createInputContext();
+	setActiveWindow( widget );
+	if ( qt_focus_model == FocusModel_PointerRoot ) {
+	    // We got real input focus from somewhere, but we were in PointerRoot
+	    // mode, so we don't trust this event.  Check the focus model to make
+	    // sure we know what focus mode we are using...
+	    qt_check_focus_model();
+	}
+    }
+	break;
+
+    case XFocusOut:				// lost focus
+	if ( widget->isDesktop() )
+	    break;
+	if ( !widget->isTopLevel() )
+	    break;
+	if ( event->xfocus.mode == NotifyGrab )
+	    qt_xfocusout_grab_counter++;
+	if ( event->xfocus.mode != NotifyNormal )
+	    break;
+	if ( event->xfocus.detail != NotifyAncestor &&
+	     event->xfocus.detail != NotifyNonlinearVirtual &&
+	     event->xfocus.detail != NotifyNonlinear )
+	    break;
+	if ( !inPopupMode() && widget == active_window )
+	    setActiveWindow( 0 );
+	break;
+
+    case EnterNotify: {			// enter window
+	if ( QWidget::mouseGrabber()  && widget != QWidget::mouseGrabber() )
+	    break;
+	if ( inPopupMode() && widget->topLevelWidget() != activePopupWidget() )
+	    break;
+	if ( event->xcrossing.mode != NotifyNormal ||
+	     event->xcrossing.detail == NotifyVirtual  ||
+	     event->xcrossing.detail == NotifyNonlinearVirtual )
+	    break;
+	if ( event->xcrossing.focus &&
+	     !widget->isDesktop() && !widget->isActiveWindow() ) {
+	    if ( qt_focus_model == FocusModel_Unknown ) // check focus model
+		qt_check_focus_model();
+	    if ( qt_focus_model == FocusModel_PointerRoot ) // PointerRoot mode
+		setActiveWindow( widget );
+	}
+	qt_dispatchEnterLeave( widget, QWidget::find( curWin ) );
+	curWin = widget->winId();
+	widget->translateMouseEvent( event ); //we don't get MotionNotify, emulate it
+    }
+	break;
+
+    case LeaveNotify: {			// leave window
+	if ( QWidget::mouseGrabber()  && widget != QWidget::mouseGrabber() )
+	    break;
+	if ( curWin && widget->winId() != curWin )
+	    break;
+	if ( event->xcrossing.mode != NotifyNormal )
+	    break;
+	if ( !widget->isDesktop() )
+	    widget->translateMouseEvent( event ); //we don't get MotionNotify, emulate it
+
+	QWidget* enter = 0;
+	XEvent ev;
+	while ( XCheckMaskEvent( widget->x11Display(), EnterWindowMask | LeaveWindowMask , &ev )
+		&& !qt_x11EventFilter( &ev )) {
+            QWidget* event_widget = QWidget::find( ev.xcrossing.window );
+            if( event_widget && event_widget->x11Event( &ev ) )
+                break;
+	    if ( ev.type == LeaveNotify && ev.xcrossing.mode == NotifyNormal ){
+		enter = event_widget;
+		XPutBackEvent( widget->x11Display(), &ev );
+		break;
+	    }
+	    if (  ev.xcrossing.mode != NotifyNormal ||
+		  ev.xcrossing.detail == NotifyVirtual  ||
+		  ev.xcrossing.detail == NotifyNonlinearVirtual )
+		continue;
+	    enter = event_widget;
+	    if ( ev.xcrossing.focus &&
+		 enter && !enter->isDesktop() && !enter->isActiveWindow() ) {
+		if ( qt_focus_model == FocusModel_Unknown ) // check focus model
+		    qt_check_focus_model();
+		if ( qt_focus_model == FocusModel_PointerRoot ) // PointerRoot mode
+		    setActiveWindow( enter );
+	    }
+	    break;
+	}
+
+	if ( ( ! enter || enter->isDesktop() ) &&
+	     event->xcrossing.focus && widget == active_window &&
+	     qt_focus_model == FocusModel_PointerRoot // PointerRoot mode
+	     ) {
+	    setActiveWindow( 0 );
+	}
+
+	if ( !curWin )
+	    qt_dispatchEnterLeave( widget, 0 );
+
+	qt_dispatchEnterLeave( enter, widget );
+	curWin = enter ? enter->winId() : 0;
+    }
+	break;
+
+    case UnmapNotify:				// window hidden
+	if ( widget->isTopLevel() && widget->isShown() ) {
+	    widget->topData()->spont_unmapped = 1;
+	    QHideEvent e;
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	    widget->hideChildren( TRUE );
+	}
+	break;
+
+    case MapNotify:				// window shown
+	if ( widget->isTopLevel() &&
+	     widget->topData()->spont_unmapped ) {
+	    widget->topData()->spont_unmapped = 0;
+	    widget->showChildren( TRUE );
+	    QShowEvent e;
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	}
+	break;
+
+    case ClientMessage:			// client message
+	return x11ClientMessage(widget,event,False);
+
+    case ReparentNotify:			// window manager reparents
+	while ( XCheckTypedWindowEvent( widget->x11Display(),
+					widget->winId(),
+					ReparentNotify,
+					event ) )
+	    ;	// skip old reparent events
+	if ( event->xreparent.parent == QPaintDevice::x11AppRootWindow() ) {
+	    if ( widget->isTopLevel() ) {
+		widget->topData()->parentWinId = event->xreparent.parent;
+		if ( qt_deferred_map_contains( widget ) ) {
+		    qt_deferred_map_take( widget );
+		    XMapWindow( appDpy, widget->winId() );
+		}
+	    }
+	} else
+	    // store the parent. Useful for many things, embedding for instance.
+	    widget->topData()->parentWinId = event->xreparent.parent;
+	if ( widget->isTopLevel() ) {
+	    // the widget frame strut should also be invalidated
+	    widget->topData()->fleft = widget->topData()->fright =
+	     widget->topData()->ftop = widget->topData()->fbottom = 0;
+
+	    if ( qt_focus_model != FocusModel_Unknown ) {
+		// toplevel reparented...
+		QWidget *newparent = QWidget::find( event->xreparent.parent );
+		if ( ! newparent || newparent->isDesktop() ) {
+		    // we dont' know about the new parent (or we've been
+		    // reparented to root), perhaps a window manager
+		    // has been (re)started?  reset the focus model to unknown
+		    qt_focus_model = FocusModel_Unknown;
+		}
+	    }
+	}
+	break;
+
+    case SelectionRequest: {
+	XSelectionRequestEvent *req = &event->xselectionrequest;
+	if (! req)
+	    break;
+
+	if ( qt_xdnd_selection && req->selection == qt_xdnd_selection ) {
+	    qt_xdnd_handle_selection_request( req );
+
+	} else if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+    case SelectionClear: {
+	XSelectionClearEvent *req = &event->xselectionclear;
+	// don't deliver dnd events to the clipboard, it gets confused
+	if (! req || qt_xdnd_selection && req->selection == qt_xdnd_selection)
+	    break;
+
+	if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+
+    case SelectionNotify: {
+	XSelectionEvent *req = &event->xselection;
+	// don't deliver dnd events to the clipboard, it gets confused
+	if (! req || qt_xdnd_selection && req->selection == qt_xdnd_selection)
+	    break;
+
+	if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+
+    default:
+	break;
+    }
+
+    return 0;
+}
+
+/*!
+    This virtual function is only implemented under X11.
+
+    If you create an application that inherits QApplication and
+    reimplement this function, you get direct access to all X events
+    that the are received from the X server.
+
+    Return TRUE if you want to stop the event from being processed.
+    Return FALSE for normal event dispatching.
+
+    \sa x11ProcessEvent()
+*/
+
+bool QApplication::x11EventFilter( XEvent * )
+{
+    return FALSE;
+}
+
+
+
+/*****************************************************************************
+  Modal widgets; Since Xlib has little support for this we roll our own
+  modal widget mechanism.
+  A modal widget without a parent becomes application-modal.
+  A modal widget with a parent becomes modal to its parent and grandparents..
+
+  qt_enter_modal()
+	Enters modal state
+	Arguments:
+	    QWidget *widget	A modal widget
+
+  qt_leave_modal()
+	Leaves modal state for a widget
+	Arguments:
+	    QWidget *widget	A modal widget
+ *****************************************************************************/
+
+bool qt_modal_state()
+{
+    return app_do_modal;
+}
+
+void qt_enter_modal( QWidget *widget )
+{
+    if ( !qt_modal_stack ) {			// create modal stack
+	qt_modal_stack = new QWidgetList;
+	Q_CHECK_PTR( qt_modal_stack );
+    }
+    if (widget->parentWidget()) {
+	QEvent e(QEvent::WindowBlocked);
+	QApplication::sendEvent(widget->parentWidget(), &e);
+    }
+
+    qt_dispatchEnterLeave( 0, QWidget::find((WId)curWin) );
+    qt_modal_stack->insert( 0, widget );
+    app_do_modal = TRUE;
+    curWin = 0;
+    ignoreNextMouseReleaseEvent = FALSE;
+}
+
+
+void qt_leave_modal( QWidget *widget )
+{
+    if ( qt_modal_stack && qt_modal_stack->removeRef(widget) ) {
+	if ( qt_modal_stack->isEmpty() ) {
+	    delete qt_modal_stack;
+	    qt_modal_stack = 0;
+	    QPoint p( QCursor::pos() );
+	    QWidget* w = QApplication::widgetAt( p.x(), p.y(), TRUE );
+	    qt_dispatchEnterLeave( w, QWidget::find( curWin ) ); // send synthetic enter event
+	    curWin = w? w->winId() : 0;
+	}
+    }
+    app_do_modal = qt_modal_stack != 0;
+    ignoreNextMouseReleaseEvent = TRUE;
+
+    if (widget->parentWidget()) {
+	QEvent e(QEvent::WindowUnblocked);
+	QApplication::sendEvent(widget->parentWidget(), &e);
+    }
+}
+
+
+bool qt_try_modal( QWidget *widget, XEvent *event )
+{
+    if (qt_xdnd_dragging) {
+	// allow mouse events while DnD is active
+	switch (event->type) {
+	case ButtonPress:
+	case ButtonRelease:
+	case MotionNotify:
+	    return TRUE;
+	default:
+	    break;
+	}
+    }
+
+    if ( qt_tryModalHelper( widget ) )
+	return TRUE;
+
+    bool block_event  = FALSE;
+    switch ( event->type ) {
+	case ButtonPress:			// disallow mouse/key events
+	case ButtonRelease:
+	case MotionNotify:
+	case XKeyPress:
+	case XKeyRelease:
+	case EnterNotify:
+	case LeaveNotify:
+	case ClientMessage:
+	    block_event	 = TRUE;
+	    break;
+    	default:
+            break;
+    }
+
+    return !block_event;
+}
+
+
+/*****************************************************************************
+  Popup widget mechanism
+
+  openPopup()
+	Adds a widget to the list of popup widgets
+	Arguments:
+	    QWidget *widget	The popup widget to be added
+
+  closePopup()
+	Removes a widget from the list of popup widgets
+	Arguments:
+	    QWidget *widget	The popup widget to be removed
+ *****************************************************************************/
+
+
+static int openPopupCount = 0;
+void QApplication::openPopup( QWidget *popup )
+{
+    openPopupCount++;
+    if ( !popupWidgets ) {			// create list
+	popupWidgets = new QWidgetList;
+	Q_CHECK_PTR( popupWidgets );
+    }
+    popupWidgets->append( popup );		// add to end of list
+
+    if ( popupWidgets->count() == 1 && !qt_nograb() ){ // grab mouse/keyboard
+	int r = XGrabKeyboard( popup->x11Display(), popup->winId(), FALSE,
+			       GrabModeSync, GrabModeAsync, CurrentTime );
+	if ( (popupGrabOk = (r == GrabSuccess)) ) {
+	    r = XGrabPointer( popup->x11Display(), popup->winId(), TRUE,
+			      (uint)(ButtonPressMask | ButtonReleaseMask |
+				     ButtonMotionMask | EnterWindowMask |
+				     LeaveWindowMask | PointerMotionMask),
+			      GrabModeSync, GrabModeAsync,
+			      None, None, CurrentTime );
+
+	    if ( (popupGrabOk = (r == GrabSuccess)) )
+		XAllowEvents( popup->x11Display(), SyncPointer, CurrentTime );
+	    else
+		XUngrabKeyboard( popup->x11Display(), CurrentTime );
+	}
+    } else if ( popupGrabOk ) {
+	XAllowEvents(  popup->x11Display(), SyncPointer, CurrentTime );
+    }
+
+    // popups are not focus-handled by the window system (the first
+    // popup grabbed the keyboard), so we have to do that manually: A
+    // new popup gets the focus
+    QFocusEvent::setReason( QFocusEvent::Popup );
+    if ( popup->focusWidget())
+	popup->focusWidget()->setFocus();
+    else
+	popup->setFocus();
+    QFocusEvent::resetReason();
+}
+
+void QApplication::closePopup( QWidget *popup )
+{
+    if ( !popupWidgets )
+	return;
+    popupWidgets->removeRef( popup );
+    if (popup == popupOfPopupButtonFocus) {
+	popupButtonFocus = 0;
+	popupOfPopupButtonFocus = 0;
+    }
+    if ( popupWidgets->count() == 0 ) {		// this was the last popup
+	popupCloseDownMode = TRUE;		// control mouse events
+	delete popupWidgets;
+	popupWidgets = 0;
+	if ( !qt_nograb() && popupGrabOk ) {	// grabbing not disabled
+	    if ( mouseButtonState != 0
+		 || popup->geometry(). contains(QPoint(mouseGlobalXPos, mouseGlobalYPos) ) )
+		{	// mouse release event or inside
+		    XAllowEvents( popup->x11Display(), AsyncPointer,
+				  CurrentTime );
+	    } else {				// mouse press event
+		mouseButtonPressTime -= 10000;	// avoid double click
+		XAllowEvents( popup->x11Display(), ReplayPointer,CurrentTime );
+	    }
+	    XUngrabPointer( popup->x11Display(), CurrentTime );
+	    XFlush( popup->x11Display() );
+	}
+	if ( active_window ) {
+	    QFocusEvent::setReason( QFocusEvent::Popup );
+	    if ( active_window->focusWidget() )
+		active_window->focusWidget()->setFocus();
+	    else
+		active_window->setFocus();
+	    QFocusEvent::resetReason();
+	}
+    } else {
+	// popups are not focus-handled by the window system (the
+	// first popup grabbed the keyboard), so we have to do that
+	// manually: A popup was closed, so the previous popup gets
+	// the focus.
+	 QFocusEvent::setReason( QFocusEvent::Popup );
+	 QWidget* aw = popupWidgets->getLast();
+	 if (aw->focusWidget())
+	     aw->focusWidget()->setFocus();
+	 else
+	     aw->setFocus();
+	 QFocusEvent::resetReason();
+	 if ( popupWidgets->count() == 1 && !qt_nograb() ){ // grab mouse/keyboard
+	     int r = XGrabKeyboard( aw->x11Display(), aw->winId(), FALSE,
+				    GrabModeSync, GrabModeAsync, CurrentTime );
+	     if ( (popupGrabOk = (r == GrabSuccess)) ) {
+		 r = XGrabPointer( aw->x11Display(), aw->winId(), TRUE,
+				   (uint)(ButtonPressMask | ButtonReleaseMask |
+					  ButtonMotionMask | EnterWindowMask |
+					  LeaveWindowMask | PointerMotionMask),
+				   GrabModeSync, GrabModeAsync,
+				   None, None, CurrentTime );
+
+		 if ( (popupGrabOk = (r == GrabSuccess)) )
+		     XAllowEvents( aw->x11Display(), SyncPointer, CurrentTime );
+	     }
+	 }
+     }
+}
+
+/*****************************************************************************
+  Event translation; translates X11 events to Qt events
+ *****************************************************************************/
+
+//
+// Mouse event translation
+//
+// Xlib doesn't give mouse double click events, so we generate them by
+// comparing window, time and position between two mouse press events.
+//
+
+//
+// Keyboard event translation
+//
+
+static int translateButtonState( int s )
+{
+    int bst = 0;
+    if ( s & Button1Mask )
+	bst |= Qt::LeftButton;
+    if ( s & Button2Mask )
+	bst |= Qt::MidButton;
+    if ( s & Button3Mask )
+	bst |= Qt::RightButton;
+    if ( s & ShiftMask )
+	bst |= Qt::ShiftButton;
+    if ( s & ControlMask )
+	bst |= Qt::ControlButton;
+    if ( s & qt_alt_mask )
+	bst |= Qt::AltButton;
+    if ( s & qt_meta_mask )
+	bst |= Qt::MetaButton;
+    return bst;
+}
+
+bool QETWidget::translateMouseEvent( const XEvent *event )
+{
+    static bool manualGrab = FALSE;
+    QEvent::Type type;				// event parameters
+    QPoint pos;
+    QPoint globalPos;
+    int button = 0;
+    int state;
+    XEvent nextEvent;
+
+    if ( sm_blockUserInput ) // block user interaction during session management
+	return TRUE;
+
+    static int x_root_save = -1, y_root_save = -1;
+
+    if ( event->type == MotionNotify ) { // mouse move
+	if (event->xmotion.root != RootWindow(appDpy, x11Screen()) &&
+	    ! qt_xdnd_dragging )
+	    return FALSE;
+
+	XMotionEvent lastMotion = event->xmotion;
+	while( XPending( appDpy ) )  { // compres mouse moves
+	    XNextEvent( appDpy, &nextEvent );
+	    if ( nextEvent.type == ConfigureNotify
+		 || nextEvent.type == PropertyNotify
+		 || nextEvent.type == Expose
+		 || nextEvent.type == NoExpose ) {
+		qApp->x11ProcessEvent( &nextEvent );
+		continue;
+	    } else if ( nextEvent.type != MotionNotify ||
+			nextEvent.xmotion.window != event->xmotion.window ||
+			nextEvent.xmotion.state != event->xmotion.state ) {
+		XPutBackEvent( appDpy, &nextEvent );
+		break;
+	    }
+	    if ( !qt_x11EventFilter(&nextEvent)
+		 && !x11Event( &nextEvent ) ) // send event through filter
+		lastMotion = nextEvent.xmotion;
+	    else
+		break;
+	}
+	type = QEvent::MouseMove;
+	pos.rx() = lastMotion.x;
+	pos.ry() = lastMotion.y;
+	globalPos.rx() = lastMotion.x_root;
+	globalPos.ry() = lastMotion.y_root;
+	state = translateButtonState( lastMotion.state );
+	if ( qt_button_down && (state & (LeftButton |
+					 MidButton |
+					 RightButton ) ) == 0 )
+	    qt_button_down = 0;
+
+	// throw away mouse move events that are sent multiple times to the same
+	// position
+	bool throw_away = FALSE;
+	if ( x_root_save == globalPos.x() &&
+	     y_root_save == globalPos.y() )
+	    throw_away = TRUE;
+	x_root_save = globalPos.x();
+	y_root_save = globalPos.y();
+	if ( throw_away )
+	    return TRUE;
+    } else if ( event->type == EnterNotify || event->type == LeaveNotify) {
+	XEvent *xevent = (XEvent *)event;
+	//unsigned int xstate = event->xcrossing.state;
+	type = QEvent::MouseMove;
+	pos.rx() = xevent->xcrossing.x;
+	pos.ry() = xevent->xcrossing.y;
+	globalPos.rx() = xevent->xcrossing.x_root;
+	globalPos.ry() = xevent->xcrossing.y_root;
+	state = translateButtonState( xevent->xcrossing.state );
+	if ( qt_button_down && (state & (LeftButton |
+					 MidButton |
+					 RightButton ) ) == 0 )
+	    qt_button_down = 0;
+	if ( !qt_button_down )
+	    state = state & ~(LeftButton | MidButton | RightButton );
+    } else {					// button press or release
+	pos.rx() = event->xbutton.x;
+	pos.ry() = event->xbutton.y;
+	globalPos.rx() = event->xbutton.x_root;
+	globalPos.ry() = event->xbutton.y_root;
+	state = translateButtonState( event->xbutton.state );
+	switch ( event->xbutton.button ) {
+	case Button1: button = LeftButton; break;
+	case Button2: button = MidButton; break;
+	case Button3: button = RightButton; break;
+	case Button4:
+	case Button5:
+	case 6:
+	case 7:
+	    // the fancy mouse wheel.
+
+	    // take care about grabbing. We do this here since it
+	    // is clear that we return anyway
+	    if ( qApp->inPopupMode() && popupGrabOk )
+		XAllowEvents( x11Display(), SyncPointer, CurrentTime );
+
+	    // We are only interested in ButtonPress.
+	    if (event->type == ButtonPress ){
+
+		// compress wheel events (the X Server will simply
+		// send a button press for each single notch,
+		// regardless whether the application can catch up
+		// or not)
+		int delta = 1;
+		XEvent xevent;
+		while ( XCheckTypedWindowEvent(x11Display(),winId(),
+					       ButtonPress,&xevent) ){
+		    if (xevent.xbutton.button != event->xbutton.button){
+			XPutBackEvent(x11Display(), &xevent);
+			break;
+		    }
+		    delta++;
+		}
+
+		// the delta is defined as multiples of
+		// WHEEL_DELTA, which is set to 120. Future wheels
+		// may offer a finer-resolution. A positive delta
+		// indicates forward rotation, a negative one
+		// backward rotation respectively.
+		int btn = event->xbutton.button;
+		delta *= 120 * ( (btn == Button4 || btn == 6) ? 1 : -1 );
+		bool hor = ( (btn == Button4 || btn == Button5) && (state&AltButton) ||
+			     (btn == 6 || btn == 7) );
+		translateWheelEvent( globalPos.x(), globalPos.y(), delta, state, (hor)?Horizontal:Vertical );
+	    }
+	    return TRUE;
+	}
+	if ( event->type == ButtonPress ) {	// mouse button pressed
+#if defined(Q_OS_IRIX) && defined(QT_TABLET_SUPPORT)
+	    XEvent myEv;
+	    if ( XCheckTypedEvent( appDpy, xinput_button_press, &myEv ) ) {
+		if ( translateXinputEvent( &myEv ) ) {
+		    //Spontaneous event sent.  Check if we need to continue.
+		    if ( chokeMouse ) {
+			chokeMouse = FALSE;
+			return FALSE;
+		    }
+		}
+	    }
+#endif
+	    qt_button_down = childAt( pos );	//magic for masked widgets
+	    if ( !qt_button_down || !qt_button_down->testWFlags(WMouseNoMask) )
+		qt_button_down = this;
+	    if ( mouseActWindow == event->xbutton.window &&
+		 mouseButtonPressed == button &&
+		 (long)event->xbutton.time -(long)mouseButtonPressTime
+		 < QApplication::doubleClickInterval() &&
+		 QABS(event->xbutton.x - mouseXPos) < 5 &&
+		 QABS(event->xbutton.y - mouseYPos) < 5 ) {
+		type = QEvent::MouseButtonDblClick;
+		mouseButtonPressTime -= 2000;	// no double-click next time
+	    } else {
+		type = QEvent::MouseButtonPress;
+		mouseButtonPressTime = event->xbutton.time;
+	    }
+	    mouseButtonPressed = button;	// save event params for
+	    mouseXPos = pos.x();		// future double click tests
+	    mouseYPos = pos.y();
+	    mouseGlobalXPos = globalPos.x();
+	    mouseGlobalYPos = globalPos.y();
+	} else {				// mouse button released
+#if defined(Q_OS_IRIX) && defined(QT_TABLET_SUPPORT)
+	    XEvent myEv;
+	    if ( XCheckTypedEvent( appDpy, xinput_button_release, &myEv ) ) {
+		if ( translateXinputEvent( &myEv ) ) {
+		    //Spontaneous event sent.  Check if we need to continue.
+		    if ( chokeMouse ) {
+			chokeMouse = FALSE;
+			return FALSE;
+		    }
+		}
+	    }
+#endif
+	    if ( manualGrab ) {			// release manual grab
+		manualGrab = FALSE;
+		XUngrabPointer( x11Display(), CurrentTime );
+		XFlush( x11Display() );
+	    }
+
+	    type = QEvent::MouseButtonRelease;
+	}
+    }
+    mouseActWindow = winId();			// save some event params
+    mouseButtonState = state;
+    if ( type == 0 )				// don't send event
+	return FALSE;
+
+    if ( qApp->inPopupMode() ) {			// in popup mode
+	QWidget *popup = qApp->activePopupWidget();
+	if ( popup != this ) {
+	    if ( testWFlags(WType_Popup) && rect().contains(pos) )
+		popup = this;
+	    else				// send to last popup
+		pos = popup->mapFromGlobal( globalPos );
+	}
+	bool releaseAfter = FALSE;
+	QWidget *popupChild  = popup->childAt( pos );
+	QWidget *popupTarget = popupChild ? popupChild : popup;
+
+	if (popup != popupOfPopupButtonFocus){
+	    popupButtonFocus = 0;
+	    popupOfPopupButtonFocus = 0;
+	}
+
+	if ( !popupTarget->isEnabled() ) {
+	    if ( popupGrabOk )
+		XAllowEvents( x11Display(), SyncPointer, CurrentTime );
+	}
+
+	switch ( type ) {
+	case QEvent::MouseButtonPress:
+	case QEvent::MouseButtonDblClick:
+	    popupButtonFocus = popupChild;
+	    popupOfPopupButtonFocus = popup;
+	    break;
+	case QEvent::MouseButtonRelease:
+	    releaseAfter = TRUE;
+	    break;
+	default:
+	    break;				// nothing for mouse move
+	}
+
+	Display* dpy = x11Display(); // store display, send() may destroy us
+
+
+	int oldOpenPopupCount = openPopupCount;
+
+	if ( popupButtonFocus ) {
+	    QMouseEvent e( type, popupButtonFocus->mapFromGlobal(globalPos),
+			   globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popupButtonFocus, &e );
+	    if ( releaseAfter ) {
+		popupButtonFocus = 0;
+		popupOfPopupButtonFocus = 0;
+	    }
+	} else if ( popupChild ) {
+	    QMouseEvent e( type, popupChild->mapFromGlobal(globalPos),
+			   globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popupChild, &e );
+	} else {
+	    QMouseEvent e( type, pos, globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popup, &e );
+	}
+
+	if ( type == QEvent::MouseButtonPress && button == RightButton && ( openPopupCount == oldOpenPopupCount ) ) {
+	    QWidget *popupEvent = popup;
+	    if(popupButtonFocus)
+		popupEvent = popupButtonFocus;
+	    else if(popupChild)
+		popupEvent = popupChild;
+	    QContextMenuEvent e( QContextMenuEvent::Mouse, pos, globalPos, state );
+	    QApplication::sendSpontaneousEvent( popupEvent, &e );
+	}
+
+	if ( releaseAfter )
+	    qt_button_down = 0;
+
+	if ( qApp->inPopupMode() ) { // still in popup mode
+	    if ( popupGrabOk )
+		XAllowEvents( dpy, SyncPointer, CurrentTime );
+	} else {
+	    if ( type != QEvent::MouseButtonRelease && state != 0 &&
+		 QWidget::find((WId)mouseActWindow) ) {
+		manualGrab = TRUE;		// need to manually grab
+		XGrabPointer( dpy, mouseActWindow, False,
+			      (uint)(ButtonPressMask | ButtonReleaseMask |
+				     ButtonMotionMask |
+				     EnterWindowMask | LeaveWindowMask),
+			      GrabModeAsync, GrabModeAsync,
+			      None, None, CurrentTime );
+	    }
+	}
+
+    } else {
+	QWidget *widget = this;
+	QWidget *w = QWidget::mouseGrabber();
+	if ( !w )
+	    w = qt_button_down;
+	if ( w && w != this ) {
+	    widget = w;
+	    pos = w->mapFromGlobal( globalPos );
+	}
+
+	if ( popupCloseDownMode ) {
+	    popupCloseDownMode = FALSE;
+	    if ( testWFlags(WType_Popup) )	// ignore replayed event
+		return TRUE;
+	}
+
+	if ( type == QEvent::MouseButtonRelease &&
+	     (state & (~button) & ( LeftButton |
+				    MidButton |
+				    RightButton)) == 0 ) {
+	    qt_button_down = 0;
+	}
+
+	int oldOpenPopupCount = openPopupCount;
+
+	QMouseEvent e( type, pos, globalPos, button, state );
+	QApplication::sendSpontaneousEvent( widget, &e );
+
+	if ( type == QEvent::MouseButtonPress && button == RightButton && ( openPopupCount == oldOpenPopupCount ) ) {
+	    QContextMenuEvent e( QContextMenuEvent::Mouse, pos, globalPos, state );
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	}
+    }
+    return TRUE;
+}
+
+
+//
+// Wheel event translation
+//
+bool QETWidget::translateWheelEvent( int global_x, int global_y, int delta, int state, Orientation orient )
+{
+    // send the event to the widget or its ancestors
+    {
+	QWidget* popup = qApp->activePopupWidget();
+	if ( popup && topLevelWidget() != popup )
+	    popup->close();
+	QWheelEvent e( mapFromGlobal(QPoint( global_x, global_y)),
+		       QPoint(global_x, global_y), delta, state, orient );
+	if ( QApplication::sendSpontaneousEvent( this, &e ) )
+	    return TRUE;
+    }
+
+    // send the event to the widget that has the focus or its ancestors, if different
+    QWidget *w = this;
+    if ( w != qApp->focusWidget() && ( w = qApp->focusWidget() ) ) {
+	QWidget* popup = qApp->activePopupWidget();
+	if ( popup && w != popup )
+	    popup->hide();
+	QWheelEvent e( mapFromGlobal(QPoint( global_x, global_y)),
+		       QPoint(global_x, global_y), delta, state, orient );
+	if ( QApplication::sendSpontaneousEvent( w, &e ) )
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+
+//
+// XInput Translation Event
+//
+#if defined (QT_TABLET_SUPPORT)
+bool QETWidget::translateXinputEvent( const XEvent *ev )
+{
+#if defined (Q_OS_IRIX)
+    // Wacom has put defines in their wacom.h file so it would be quite wise
+    // to use them, need to think of a decent way of not using
+    // it when it doesn't exist...
+    XDeviceState *s;
+    XInputClass *iClass;
+    XValuatorState *vs;
+    int j;
+#endif
+    QWidget *w = this;
+    QPoint global,
+	curr;
+    static int pressure = 0;
+    static int xTilt = 0,
+	       yTilt = 0;
+    int deviceType = QTabletEvent::NoDevice;
+    QPair<int, int> tId;
+    XEvent xinputMotionEvent;
+    XEvent mouseMotionEvent;
+    XDevice *dev;
+    const XDeviceMotionEvent *motion = 0;
+    XDeviceButtonEvent *button = 0;
+    QEvent::Type t;
+
+    if ( ev->type == xinput_motion ) {
+	motion = (const XDeviceMotionEvent*)ev;
+	for (;;) {
+	    if (!XCheckTypedWindowEvent(x11Display(), winId(), MotionNotify, &mouseMotionEvent))
+		break;
+	    if (!XCheckTypedWindowEvent(x11Display(), winId(), xinput_motion, &xinputMotionEvent)) {
+		XPutBackEvent(x11Display(), &mouseMotionEvent);
+		break;
+	    }
+	    if (mouseMotionEvent.xmotion.time != motion->time) {
+		XPutBackEvent(x11Display(), &mouseMotionEvent);
+		XPutBackEvent(x11Display(), &xinputMotionEvent);
+		break;
+	    }
+	    motion = ((const XDeviceMotionEvent*)&xinputMotionEvent);
+	}
+	t = QEvent::TabletMove;
+	curr = QPoint( motion->x, motion->y );
+    } else {
+	if ( ev->type == xinput_button_press ) {
+	    t = QEvent::TabletPress;
+        } else {
+	    t = QEvent::TabletRelease;
+	}
+	button = (XDeviceButtonEvent*)ev;
+/*
+	qDebug( "\n\nXInput Button Event" );
+	qDebug( "serial:\t%d", button->serial );
+	qDebug( "send_event:\t%d", button->send_event );
+	qDebug( "display:\t%p", button->display );
+	qDebug( "window:\t%d", button->window );
+	qDebug( "deviceID:\t%d", button->deviceid );
+	qDebug( "root:\t%d", button->root );
+	qDebug( "subwindot:\t%d", button->subwindow );
+	qDebug( "x:\t%d", button->x );
+	qDebug( "y:\t%d", button->y );
+	qDebug( "x_root:\t%d", button->x_root );
+	qDebug( "y_root:\t%d", button->y_root );
+	qDebug( "state:\t%d", button->state );
+	qDebug( "button:\t%d", button->button );
+	qDebug( "same_screen:\t%d", button->same_screen );
+	qDebug( "time:\t%d", button->time );
+*/
+	curr = QPoint( button->x, button->y );
+    }
+#if defined(Q_OS_IRIX)
+    // default...
+    dev = devStylus;
+#else
+    if ( ev->type == xinput_motion ) {
+	if ( motion->deviceid == devStylus->device_id ) {
+	    dev = devStylus;
+	    deviceType = QTabletEvent::Stylus;
+	} else if ( motion->deviceid == devEraser->device_id ) {
+	    dev = devEraser;
+	    deviceType = QTabletEvent::Eraser;
+	}
+    } else {
+	if ( button->deviceid == devStylus->device_id ) {
+	    dev = devStylus;
+	    deviceType = QTabletEvent::Stylus;
+	} else if ( button->deviceid == devEraser->device_id ) {
+	    dev = devEraser;
+	    deviceType = QTabletEvent::Eraser;
+	}
+    }
+#endif
+
+    const int PRESSURE_LEVELS = 255;
+    // we got the maximum pressure at start time, since various tablets have
+    // varying levels of distinguishing pressure changes, let's standardize and
+    // scale everything to 256 different levels...
+    static int scaleFactor = -1;
+    if ( scaleFactor == -1 ) {
+	if ( max_pressure > PRESSURE_LEVELS )
+	    scaleFactor = max_pressure / PRESSURE_LEVELS;
+	else
+	    scaleFactor = PRESSURE_LEVELS / max_pressure;
+    }
+#if defined (Q_OS_IRIX)
+    s = XQueryDeviceState( appDpy, dev );
+    if ( s == NULL )
+        return FALSE;
+    iClass = s->data;
+    for ( j = 0; j < s->num_classes; j++ ) {
+        if ( iClass->c_class == ValuatorClass ) {
+            vs = (XValuatorState *)iClass;
+            // figure out what device we have, based on bitmasking...
+            if ( vs->valuators[WAC_TRANSDUCER_I]
+                 & WAC_TRANSDUCER_PROX_MSK ) {
+                switch ( vs->valuators[WAC_TRANSDUCER_I]
+                         & WAC_TRANSDUCER_MSK ) {
+                case WAC_PUCK_ID:
+                    deviceType = QTabletEvent::Puck;
+                    break;
+                case WAC_STYLUS_ID:
+                    deviceType = QTabletEvent::Stylus;
+                    break;
+                case WAC_ERASER_ID:
+                    deviceType = QTabletEvent::Eraser;
+                    break;
+                }
+                // Get a Unique Id for the device, Wacom gives us this ability
+                tId.first = vs->valuators[WAC_TRANSDUCER_I] & WAC_TRANSDUCER_ID_MSK;
+                tId.second = vs->valuators[WAC_SERIAL_NUM_I];
+            } else
+                deviceType = QTabletEvent::NoDevice;
+            // apparently Wacom needs a cast for the +/- values to make sense
+            xTilt = short(vs->valuators[WAC_XTILT_I]);
+            yTilt = short(vs->valuators[WAC_YTILT_I]);
+            if ( max_pressure > PRESSURE_LEVELS )
+                pressure = vs->valuators[WAC_PRESSURE_I] / scaleFactor;
+            else
+                pressure = vs->valuators[WAC_PRESSURE_I] * scaleFactor;
+	    global = QPoint( vs->valuators[WAC_XCOORD_I],
+                             vs->valuators[WAC_YCOORD_I] );
+	    break;
+	}
+	iClass = (XInputClass*)((char*)iClass + iClass->length);
+    }
+    XFreeDeviceState( s );
+#else
+    if ( motion ) {
+	xTilt = short(motion->axis_data[3]);
+	yTilt = short(motion->axis_data[4]);
+	if ( max_pressure > PRESSURE_LEVELS )
+	    pressure = motion->axis_data[2] / scaleFactor;
+	else
+	    pressure = motion->axis_data[2] * scaleFactor;
+	global = QPoint( motion->axis_data[0], motion->axis_data[1] );
+    } else {
+	xTilt = short(button->axis_data[3]);
+	yTilt = short(button->axis_data[4]);
+	if ( max_pressure > PRESSURE_LEVELS )
+	    pressure = button->axis_data[2]  / scaleFactor;
+	else
+	    pressure = button->axis_data[2] * scaleFactor;
+	global = QPoint( button->axis_data[0], button->axis_data[1] );
+    }
+    // The only way to get these Ids is to scan the XFree86 log, which I'm not going to do.
+    tId.first = tId.second = -1;
+#endif
+
+    QTabletEvent e( t, curr, global, deviceType, pressure, xTilt, yTilt, tId );
+    QApplication::sendSpontaneousEvent( w, &e );
+    return TRUE;
+}
+#endif
+
+bool QETWidget::translatePropertyEvent(const XEvent *event)
+{
+    if (!isTopLevel()) return TRUE;
+
+    Atom ret;
+    int format, e;
+    unsigned char *data = 0;
+    unsigned long nitems, after;
+
+    if (event->xproperty.atom == qt_net_wm_frame_strut) {
+	topData()->fleft = topData()->fright = topData()->ftop = topData()->fbottom = 0;
+	fstrut_dirty = 1;
+
+	if (event->xproperty.state == PropertyNewValue) {
+	    e = XGetWindowProperty(appDpy, event->xproperty.window, qt_net_wm_frame_strut,
+				   0, 4, // struts are 4 longs
+				   False, XA_CARDINAL, &ret, &format, &nitems, &after, &data);
+
+	    if (e == Success && ret == XA_CARDINAL &&
+		format == 32 && nitems == 4) {
+		long *strut = (long *) data;
+		topData()->fleft   = strut[0];
+		topData()->fright  = strut[1];
+		topData()->ftop    = strut[2];
+		topData()->fbottom = strut[3];
+		fstrut_dirty = 0;
+	    }
+	}
+    } else if (event->xproperty.atom == qt_net_wm_state) {
+	bool max = FALSE;
+	bool full = FALSE;
+
+	if (event->xproperty.state == PropertyNewValue) {
+	    // using length of 1024 should be safe for all current and
+	    // possible NET states...
+	    e = XGetWindowProperty(appDpy, event->xproperty.window, qt_net_wm_state, 0, 1024,
+				   False, XA_ATOM, &ret, &format, &nitems, &after, &data);
+
+	    if (e == Success && ret == XA_ATOM && format == 32 && nitems > 0) {
+		Atom *states = (Atom *) data;
+
+		unsigned long i;
+		for (i = 0; i < nitems; i++) {
+		    if (states[i] == qt_net_wm_state_max_v || states[i] == qt_net_wm_state_max_h)
+			max = TRUE;
+		    else if (states[i] == qt_net_wm_state_fullscreen)
+			full = TRUE;
+		}
+	    }
+	}
+
+	bool send_event = FALSE;
+
+        if (qt_net_supports(qt_net_wm_state_max_v)
+            && qt_net_supports(qt_net_wm_state_max_h)) {
+            if (max && !isMaximized()) {
+                setWState(WState_Maximized);
+                send_event = TRUE;
+            } else if (!max && isMaximized()) {
+                clearWState(WState_Maximized);
+                send_event = TRUE;
+            }
+        }
+
+        if (qt_net_supports(qt_net_wm_state_fullscreen)) {
+            if (full && !isFullScreen()) {
+                setWState(WState_FullScreen);
+                send_event = TRUE;
+            } else if (!full && isFullScreen()) {
+                clearWState(WState_FullScreen);
+                send_event = TRUE;
+            }
+        }
+
+	if (send_event) {
+	    QEvent e(QEvent::WindowStateChange);
+	    QApplication::sendSpontaneousEvent(this, &e);
+	}
+    } else if (event->xproperty.atom == qt_wm_state) {
+	// the widget frame strut should also be invalidated
+	topData()->fleft = topData()->fright = topData()->ftop = topData()->fbottom = 0;
+	fstrut_dirty = 1;
+
+	if (event->xproperty.state == PropertyDelete) {
+	    // the window manager has removed the WM State property,
+	    // so it is now in the withdrawn state (ICCCM 4.1.3.1) and
+	    // we are free to reuse this window
+	    topData()->parentWinId = 0;
+	    // map the window if we were waiting for a transition to
+	    // withdrawn
+	    if ( qt_deferred_map_contains( this ) ) {
+		qt_deferred_map_take( this );
+		XMapWindow( appDpy, winId() );
+	    }
+	} else if (topData()->parentWinId != QPaintDevice::x11AppRootWindow(x11Screen())) {
+	    // the window manager has changed the WM State property...
+	    // we are wanting to see if we are withdrawn so that we
+	    // can reuse this window... we only do this check *IF* we
+	    // haven't been reparented to root - (the parentWinId !=
+	    // QPaintDevice::x11AppRootWindow(x11Screen())) check
+	    // above
+
+	    e = XGetWindowProperty(appDpy, winId(), qt_wm_state, 0, 2, False, qt_wm_state,
+				   &ret, &format, &nitems, &after, &data );
+
+	    if (e == Success && ret == qt_wm_state && format == 32 && nitems > 0) {
+		long *state = (long *) data;
+		switch (state[0]) {
+		case WithdrawnState:
+		    // if we are in the withdrawn state, we are free
+		    // to reuse this window provided we remove the
+		    // WM_STATE property (ICCCM 4.1.3.1)
+		    XDeleteProperty(appDpy, winId(), qt_wm_state);
+
+		    // set the parent id to zero, so that show() will
+		    // work again
+		    topData()->parentWinId = 0;
+		    // map the window if we were waiting for a
+		    // transition to withdrawn
+		    if ( qt_deferred_map_contains( this ) ) {
+			qt_deferred_map_take( this );
+			XMapWindow( appDpy, winId() );
+		    }
+		    break;
+
+		case IconicState:
+		    if (!isMinimized()) {
+			// window was minimized
+			setWState(WState_Minimized);
+			QEvent e(QEvent::WindowStateChange);
+			QApplication::sendSpontaneousEvent(this, &e);
+		    }
+		    break;
+
+		default:
+		    if (isMinimized()) {
+			// window was un-minimized
+			clearWState(WState_Minimized);
+			QEvent e(QEvent::WindowStateChange);
+			QApplication::sendSpontaneousEvent(this, &e);
+		    }
+		    break;
+		}
+	    }
+	}
+    }
+
+    if (data)
+	XFree(data);
+
+    return TRUE;
+}
+
+#ifndef XK_ISO_Left_Tab
+#define	XK_ISO_Left_Tab					0xFE20
+#endif
+
+// the next lines are taken from XFree > 4.0 (X11/XF86keysyms.h), defining some special
+// multimedia keys. They are included here as not every system has them.
+#define XF86XK_Standby		0x1008FF10
+#define XF86XK_AudioLowerVolume	0x1008FF11
+#define XF86XK_AudioMute	0x1008FF12
+#define XF86XK_AudioRaiseVolume	0x1008FF13
+#define XF86XK_AudioPlay	0x1008FF14
+#define XF86XK_AudioStop	0x1008FF15
+#define XF86XK_AudioPrev	0x1008FF16
+#define XF86XK_AudioNext	0x1008FF17
+#define XF86XK_HomePage		0x1008FF18
+#define XF86XK_Calculator	0x1008FF1D
+#define XF86XK_Mail		0x1008FF19
+#define XF86XK_Start		0x1008FF1A
+#define XF86XK_Search		0x1008FF1B
+#define XF86XK_AudioRecord	0x1008FF1C
+#define XF86XK_Back		0x1008FF26
+#define XF86XK_Forward		0x1008FF27
+#define XF86XK_Stop		0x1008FF28
+#define XF86XK_Refresh		0x1008FF29
+#define XF86XK_Favorites	0x1008FF30
+#define XF86XK_AudioPause	0x1008FF31
+#define XF86XK_AudioMedia	0x1008FF32
+#define XF86XK_MyComputer	0x1008FF33
+#define XF86XK_OpenURL		0x1008FF38
+#define XF86XK_Launch0		0x1008FF40
+#define XF86XK_Launch1		0x1008FF41
+#define XF86XK_Launch2		0x1008FF42
+#define XF86XK_Launch3		0x1008FF43
+#define XF86XK_Launch4		0x1008FF44
+#define XF86XK_Launch5		0x1008FF45
+#define XF86XK_Launch6		0x1008FF46
+#define XF86XK_Launch7		0x1008FF47
+#define XF86XK_Launch8		0x1008FF48
+#define XF86XK_Launch9		0x1008FF49
+#define XF86XK_LaunchA		0x1008FF4A
+#define XF86XK_LaunchB		0x1008FF4B
+#define XF86XK_LaunchC		0x1008FF4C
+#define XF86XK_LaunchD		0x1008FF4D
+#define XF86XK_LaunchE		0x1008FF4E
+#define XF86XK_LaunchF		0x1008FF4F
+// end of XF86keysyms.h
+
+
+
+static const KeySym KeyTbl[] = {		// keyboard mapping table
+    XK_Escape,		Qt::Key_Escape,		// misc keys
+    XK_Tab,		Qt::Key_Tab,
+    XK_ISO_Left_Tab,    Qt::Key_Backtab,
+    XK_BackSpace,	Qt::Key_Backspace,
+    XK_Return,		Qt::Key_Return,
+    XK_Insert,		Qt::Key_Insert,
+    XK_KP_Insert,	Qt::Key_Insert,
+    XK_Delete,		Qt::Key_Delete,
+    XK_KP_Delete,	Qt::Key_Delete,
+    XK_Clear,		Qt::Key_Delete,
+    XK_Pause,		Qt::Key_Pause,
+    XK_Print,		Qt::Key_Print,
+    XK_KP_Begin,	Qt::Key_Clear,
+    0x1005FF60,		Qt::Key_SysReq,		// hardcoded Sun SysReq
+    0x1007ff00,		Qt::Key_SysReq,		// hardcoded X386 SysReq
+    XK_Home,		Qt::Key_Home,		// cursor movement
+    XK_End,		Qt::Key_End,
+    XK_Left,		Qt::Key_Left,
+    XK_Up,		Qt::Key_Up,
+    XK_Right,		Qt::Key_Right,
+    XK_Down,		Qt::Key_Down,
+    XK_Prior,		Qt::Key_Prior,
+    XK_Next,		Qt::Key_Next,
+    XK_KP_Home,		Qt::Key_Home,
+    XK_KP_End,		Qt::Key_End,
+    XK_KP_Left,		Qt::Key_Left,
+    XK_KP_Up,		Qt::Key_Up,
+    XK_KP_Right,	Qt::Key_Right,
+    XK_KP_Down,		Qt::Key_Down,
+    XK_KP_Prior,	Qt::Key_Prior,
+    XK_KP_Next,		Qt::Key_Next,
+    XK_Shift_L,		Qt::Key_Shift,		// modifiers
+    XK_Shift_R,		Qt::Key_Shift,
+    XK_Shift_Lock,	Qt::Key_Shift,
+    XK_Control_L,	Qt::Key_Control,
+    XK_Control_R,	Qt::Key_Control,
+    XK_Meta_L,		Qt::Key_Meta,
+    XK_Meta_R,		Qt::Key_Meta,
+    XK_Alt_L,		Qt::Key_Alt,
+    XK_Alt_R,		Qt::Key_Alt,
+    XK_Caps_Lock,	Qt::Key_CapsLock,
+    XK_Num_Lock,	Qt::Key_NumLock,
+    XK_Scroll_Lock,	Qt::Key_ScrollLock,
+    XK_KP_Space,	Qt::Key_Space,		// numeric keypad
+    XK_KP_Tab,		Qt::Key_Tab,
+    XK_KP_Enter,	Qt::Key_Enter,
+    XK_KP_Equal,	Qt::Key_Equal,
+    XK_KP_Multiply,	Qt::Key_Asterisk,
+    XK_KP_Add,		Qt::Key_Plus,
+    XK_KP_Separator,	Qt::Key_Comma,
+    XK_KP_Subtract,	Qt::Key_Minus,
+    XK_KP_Decimal,	Qt::Key_Period,
+    XK_KP_Divide,	Qt::Key_Slash,
+    XK_Super_L,		Qt::Key_Super_L,
+    XK_Super_R,		Qt::Key_Super_R,
+    XK_Menu,		Qt::Key_Menu,
+    XK_Hyper_L,		Qt::Key_Hyper_L,
+    XK_Hyper_R,		Qt::Key_Hyper_R,
+    XK_Help,		Qt::Key_Help,
+    0x1000FF74,         Qt::Key_BackTab,     // hardcoded HP backtab
+    0x1005FF10,         Qt::Key_F11,         // hardcoded Sun F36 (labeled F11)
+    0x1005FF11,         Qt::Key_F12,         // hardcoded Sun F37 (labeled F12)
+
+    // Special multimedia keys
+    // currently only tested with MS internet keyboard
+
+    // browsing keys
+    XF86XK_Back,	Qt::Key_Back,
+    XF86XK_Forward,	Qt::Key_Forward,
+    XF86XK_Stop,	Qt::Key_Stop,
+    XF86XK_Refresh,	Qt::Key_Refresh,
+    XF86XK_Favorites,	Qt::Key_Favorites,
+    XF86XK_AudioMedia,	Qt::Key_LaunchMedia,
+    XF86XK_OpenURL,	Qt::Key_OpenUrl,
+    XF86XK_HomePage,	Qt::Key_HomePage,
+    XF86XK_Search,	Qt::Key_Search,
+
+    // media keys
+    XF86XK_AudioLowerVolume, Qt::Key_VolumeDown,
+    XF86XK_AudioMute,	Qt::Key_VolumeMute,
+    XF86XK_AudioRaiseVolume, Qt::Key_VolumeUp,
+    XF86XK_AudioPlay,	Qt::Key_MediaPlay,
+    XF86XK_AudioStop,	Qt::Key_MediaStop,
+    XF86XK_AudioPrev,	Qt::Key_MediaPrev,
+    XF86XK_AudioNext,	Qt::Key_MediaNext,
+    XF86XK_AudioRecord,	Qt::Key_MediaRecord,
+
+    // launch keys
+    XF86XK_Mail,	Qt::Key_LaunchMail,
+    XF86XK_MyComputer,	Qt::Key_Launch0,
+    XF86XK_Calculator,	Qt::Key_Launch1,
+    XF86XK_Standby, 	Qt::Key_Standby,
+
+    XF86XK_Launch0,	Qt::Key_Launch2,
+    XF86XK_Launch1,	Qt::Key_Launch3,
+    XF86XK_Launch2,	Qt::Key_Launch4,
+    XF86XK_Launch3,	Qt::Key_Launch5,
+    XF86XK_Launch4,	Qt::Key_Launch6,
+    XF86XK_Launch5,	Qt::Key_Launch7,
+    XF86XK_Launch6,	Qt::Key_Launch8,
+    XF86XK_Launch7,	Qt::Key_Launch9,
+    XF86XK_Launch8,	Qt::Key_LaunchA,
+    XF86XK_Launch9,	Qt::Key_LaunchB,
+    XF86XK_LaunchA,	Qt::Key_LaunchC,
+    XF86XK_LaunchB,	Qt::Key_LaunchD,
+    XF86XK_LaunchC,	Qt::Key_LaunchE,
+    XF86XK_LaunchD,	Qt::Key_LaunchF,
+
+    0,			0
+};
+
+
+static QIntDict<void>    *keyDict  = 0;
+static QIntDict<void>    *textDict = 0;
+
+static void deleteKeyDicts()
+{
+    if ( keyDict )
+	delete keyDict;
+    keyDict = 0;
+    if ( textDict )
+	delete textDict;
+    textDict = 0;
+}
+
+#if !defined(QT_NO_XIM)
+static const unsigned short katakanaKeysymsToUnicode[] = {
+    0x0000, 0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1,
+    0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3,
+    0x30FC, 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD,
+    0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD,
+    0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC,
+    0x30CD, 0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE,
+    0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9,
+    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
+};
+
+static const unsigned short cyrillicKeysymsToUnicode[] = {
+    0x0000, 0x0452, 0x0453, 0x0451, 0x0454, 0x0455, 0x0456, 0x0457,
+    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x0000, 0x045e, 0x045f,
+    0x2116, 0x0402, 0x0403, 0x0401, 0x0404, 0x0405, 0x0406, 0x0407,
+    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x0000, 0x040e, 0x040f,
+    0x044e, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
+    0x0445, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e,
+    0x043f, 0x044f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0436, 0x0432,
+    0x044c, 0x044b, 0x0437, 0x0448, 0x044d, 0x0449, 0x0447, 0x044a,
+    0x042e, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413,
+    0x0425, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e,
+    0x041f, 0x042f, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
+    0x042c, 0x042b, 0x0417, 0x0428, 0x042d, 0x0429, 0x0427, 0x042a
+};
+
+static const unsigned short greekKeysymsToUnicode[] = {
+    0x0000, 0x0386, 0x0388, 0x0389, 0x038a, 0x03aa, 0x0000, 0x038c,
+    0x038e, 0x03ab, 0x0000, 0x038f, 0x0000, 0x0000, 0x0385, 0x2015,
+    0x0000, 0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03ca, 0x0390, 0x03cc,
+    0x03cd, 0x03cb, 0x03b0, 0x03ce, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
+    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
+    0x03a0, 0x03a1, 0x03a3, 0x0000, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
+    0x03a8, 0x03a9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
+    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
+    0x03c0, 0x03c1, 0x03c3, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
+    0x03c8, 0x03c9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short technicalKeysymsToUnicode[] = {
+    0x0000, 0x23B7, 0x250C, 0x2500, 0x2320, 0x2321, 0x2502, 0x23A1,
+    0x23A3, 0x23A4, 0x23A6, 0x239B, 0x239D, 0x239E, 0x23A0, 0x23A8,
+    0x23AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x2264, 0x2260, 0x2265, 0x222B,
+    0x2234, 0x221D, 0x221E, 0x0000, 0x0000, 0x2207, 0x0000, 0x0000,
+    0x223C, 0x2243, 0x0000, 0x0000, 0x0000, 0x21D4, 0x21D2, 0x2261,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x221A, 0x0000,
+    0x0000, 0x0000, 0x2282, 0x2283, 0x2229, 0x222A, 0x2227, 0x2228,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2202,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0192, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x2190, 0x2191, 0x2192, 0x2193, 0x0000
+};
+
+static const unsigned short specialKeysymsToUnicode[] = {
+    0x25C6, 0x2592, 0x2409, 0x240C, 0x240D, 0x240A, 0x0000, 0x0000,
+    0x2424, 0x240B, 0x2518, 0x2510, 0x250C, 0x2514, 0x253C, 0x23BA,
+    0x23BB, 0x2500, 0x23BC, 0x23BD, 0x251C, 0x2524, 0x2534, 0x252C,
+    0x2502, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short publishingKeysymsToUnicode[] = {
+    0x0000, 0x2003, 0x2002, 0x2004, 0x2005, 0x2007, 0x2008, 0x2009,
+    0x200a, 0x2014, 0x2013, 0x0000, 0x0000, 0x0000, 0x2026, 0x2025,
+    0x2153, 0x2154, 0x2155, 0x2156, 0x2157, 0x2158, 0x2159, 0x215a,
+    0x2105, 0x0000, 0x0000, 0x2012, 0x2329, 0x0000, 0x232a, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x215b, 0x215c, 0x215d, 0x215e, 0x0000,
+    0x0000, 0x2122, 0x2613, 0x0000, 0x25c1, 0x25b7, 0x25cb, 0x25af,
+    0x2018, 0x2019, 0x201c, 0x201d, 0x211e, 0x0000, 0x2032, 0x2033,
+    0x0000, 0x271d, 0x0000, 0x25ac, 0x25c0, 0x25b6, 0x25cf, 0x25ae,
+    0x25e6, 0x25ab, 0x25ad, 0x25b3, 0x25bd, 0x2606, 0x2022, 0x25aa,
+    0x25b2, 0x25bc, 0x261c, 0x261e, 0x2663, 0x2666, 0x2665, 0x0000,
+    0x2720, 0x2020, 0x2021, 0x2713, 0x2717, 0x266f, 0x266d, 0x2642,
+    0x2640, 0x260e, 0x2315, 0x2117, 0x2038, 0x201a, 0x201e, 0x0000
+};
+
+static const unsigned short aplKeysymsToUnicode[] = {
+    0x0000, 0x0000, 0x0000, 0x003c, 0x0000, 0x0000, 0x003e, 0x0000,
+    0x2228, 0x2227, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x00af, 0x0000, 0x22a5, 0x2229, 0x230a, 0x0000, 0x005f, 0x0000,
+    0x0000, 0x0000, 0x2218, 0x0000, 0x2395, 0x0000, 0x22a4, 0x25cb,
+    0x0000, 0x0000, 0x0000, 0x2308, 0x0000, 0x0000, 0x222a, 0x0000,
+    0x2283, 0x0000, 0x2282, 0x0000, 0x22a2, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x22a3, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short koreanKeysymsToUnicode[] = {
+    0x0000, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137,
+    0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f,
+    0x3140, 0x3141, 0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147,
+    0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f,
+    0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157,
+    0x3158, 0x3159, 0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f,
+    0x3160, 0x3161, 0x3162, 0x3163, 0x11a8, 0x11a9, 0x11aa, 0x11ab,
+    0x11ac, 0x11ad, 0x11ae, 0x11af, 0x11b0, 0x11b1, 0x11b2, 0x11b3,
+    0x11b4, 0x11b5, 0x11b6, 0x11b7, 0x11b8, 0x11b9, 0x11ba, 0x11bb,
+    0x11bc, 0x11bd, 0x11be, 0x11bf, 0x11c0, 0x11c1, 0x11c2, 0x316d,
+    0x3171, 0x3178, 0x317f, 0x3181, 0x3184, 0x3186, 0x318d, 0x318e,
+    0x11eb, 0x11f0, 0x11f9, 0x0000, 0x0000, 0x0000, 0x0000, 0x20a9
+};
+
+
+static QChar keysymToUnicode(unsigned char byte3, unsigned char byte4)
+{
+    if ( byte3 == 0x04 ) {
+        // katakana
+        if ( byte4 > 0xa0 && byte4 < 0xe0 )
+           return QChar( katakanaKeysymsToUnicode[byte4 - 0xa0] );
+        else if ( byte4 == 0x7e )
+            return QChar( 0x203e ); // Overline
+    } else if ( byte3 == 0x06 ) {
+	// russian, use lookup table
+	if ( byte4 > 0xa0 )
+	    return QChar( cyrillicKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x07 ) {
+	// greek
+	if ( byte4 > 0xa0 )
+	    return QChar( greekKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x08 ) {
+       // technical
+       if ( byte4 > 0xa0 )
+           return QChar( technicalKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x09 ) {
+       // special
+       if ( byte4 >= 0xe0 )
+           return QChar( specialKeysymsToUnicode[byte4 - 0xe0] );
+    } else if ( byte3 == 0x0a ) {
+       // publishing
+       if ( byte4 > 0xa0 )
+           return QChar( publishingKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x0b ) {
+       // APL
+       if ( byte4 > 0xa0 )
+           return QChar( aplKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x0e ) {
+       // Korean
+       if ( byte4 > 0xa0 )
+           return QChar( koreanKeysymsToUnicode[byte4 - 0xa0] );
+    }
+    return QChar(0x0);
+}
+#endif
+
+
+bool QETWidget::translateKeyEventInternal( const XEvent *event, int& count,
+					   QString& text,
+					   int& state,
+					   char& ascii, int& code, QEvent::Type &type, bool willRepeat )
+{
+    QTextCodec *mapper = input_mapper;
+    // some XmbLookupString implementations don't return buffer overflow correctly,
+    // so we increase the input buffer to allow for long strings...
+    // 256 chars * 2 bytes + 1 null-term == 513 bytes
+    QCString chars(513);
+    QChar converted;
+    KeySym key = 0;
+
+    if ( !keyDict ) {
+	keyDict = new QIntDict<void>( 13 );
+	keyDict->setAutoDelete( FALSE );
+	textDict = new QIntDict<void>( 13 );
+	textDict->setAutoDelete( FALSE );
+	qAddPostRoutine( deleteKeyDicts );
+    }
+
+    QWidget* tlw = topLevelWidget();
+
+    XKeyEvent xkeyevent = event->xkey;
+
+    // save the modifier state, we will use the keystate uint later by passing
+    // it to translateButtonState
+    uint keystate = event->xkey.state;
+    // remove the modifiers where mode_switch exists... HPUX machines seem
+    // to have alt *AND* mode_switch both in Mod1Mask, which causes
+    // XLookupString to return things like '' (aring) for ALT-A.  This
+    // completely breaks modifiers.  If we remove the modifier for Mode_switch,
+    // then things work correctly...
+    xkeyevent.state &= ~qt_mode_switch_remove_mask;
+
+    type = (event->type == XKeyPress)
+           ? QEvent::KeyPress : QEvent::KeyRelease;
+#if defined(QT_NO_XIM)
+
+    count = XLookupString( &xkeyevent, chars.data(), chars.size(), &key, 0 );
+
+    if ( count == 1 )
+	ascii = chars[0];
+
+#else
+    // Implementation for X11R5 and newer, using XIM
+
+    int	       keycode = event->xkey.keycode;
+    Status     status;
+
+    if ( type == QEvent::KeyPress ) {
+	bool mb=FALSE;
+	if ( qt_xim ) {
+	    QTLWExtra*  xd = tlw->topData();
+	    QInputContext *qic = (QInputContext *) xd->xic;
+	    if ( qic ) {
+		mb=TRUE;
+		count = qic->lookupString(&xkeyevent, chars, &key, &status);
+	    }
+	}
+	if ( !mb ) {
+	    count = XLookupString( &xkeyevent,
+				   chars.data(), chars.size(), &key, 0 );
+	}
+	if ( count && !keycode ) {
+	    keycode = composingKeycode;
+	    composingKeycode = 0;
+	}
+	if ( key )
+	    keyDict->replace( keycode, (void*)key );
+	// all keysyms smaller than that are actally keys that can be mapped
+	// to unicode chars
+	if ( count == 0 && key < 0xff00 ) {
+	    unsigned char byte3 = (unsigned char )(key >> 8);
+	    int mib = -1;
+	    switch( byte3 ) {
+	    case 0: // Latin 1
+	    case 1: // Latin 2
+	    case 2: //latin 3
+	    case 3: // latin4
+		mib = byte3 + 4; break;
+	    case 5: // arabic
+		mib = 82; break;
+	    case 12: // Hebrew
+		mib = 85; break;
+	    case 13: // Thai
+		mib = 2259; break;
+	    case 4: // kana
+	    case 6: // cyrillic
+	    case 7: // greek
+	    case 8: // technical, no mapping here at the moment
+	    case 9: // Special
+	    case 10: // Publishing
+	    case 11: // APL
+	    case 14: // Korean, no mapping
+		mib = -1; // manual conversion
+		mapper = 0;
+		converted = keysymToUnicode( byte3, key & 0xff );
+	    case 0x20:
+		// currency symbols
+		if ( key >= 0x20a0 && key <= 0x20ac ) {
+		    mib = -1; // manual conversion
+		    mapper = 0;
+		    converted = (uint)key;
+		}
+		break;
+	    default:
+		break;
+	    }
+	    if ( mib != -1 ) {
+		mapper = QTextCodec::codecForMib( mib );
+		chars[0] = (unsigned char) (key & 0xff); // get only the fourth bit for conversion later
+		count++;
+	    }
+	} else if ( key >= 0x1000000 && key <= 0x100ffff ) {
+	    converted = (ushort) (key - 0x1000000);
+	    mapper = 0;
+	}
+	if ( count < (int)chars.size()-1 )
+	    chars[count] = '\0';
+	if ( count == 1 ) {
+	    ascii = chars[0];
+	    // +256 so we can store all eight-bit codes, including ascii 0,
+	    // and independent of whether char is signed or not.
+	    textDict->replace( keycode, (void*)(long)(256+ascii) );
+	}
+	tlw = 0;
+    } else {
+	key = (int)(long)keyDict->find( keycode );
+	if ( key )
+	    if( !willRepeat ) // Take out key of dictionary only if this call.
+		keyDict->take( keycode );
+	long s = (long)textDict->find( keycode );
+	if ( s ) {
+	    textDict->take( keycode );
+	    ascii = (char)(s-256);
+	}
+    }
+#endif // !QT_NO_XIM
+
+    state = translateButtonState( keystate );
+
+    static int directionKeyEvent = 0;
+    if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
+	if (directionKeyEvent == Key_Direction_R || directionKeyEvent == Key_Direction_L ) {
+	    type = QEvent::KeyPress;
+	    code = directionKeyEvent;
+	    chars[0] = 0;
+	    directionKeyEvent = 0;
+	    return TRUE;
+	} else {
+	    directionKeyEvent = 0;
+	}
+    }
+
+    // Watch for keypresses and if its a key belonging to the Ctrl-Shift
+    // direction-changing accel, remember it.
+    // We keep track of those keys instead of using the event's state
+    // (to figure out whether the Ctrl modifier is held while Shift is pressed,
+    // or Shift is held while Ctrl is pressed) since the 'state' doesn't tell
+    // us whether the modifier held is Left or Right.
+    if (qt_use_rtl_extensions && type  == QEvent::KeyPress)
+        if (key == XK_Control_L || key == XK_Control_R || key == XK_Shift_L || key == XK_Shift_R) {
+           if (!directionKeyEvent)
+	      directionKeyEvent = key;
+        } else {
+           // this can no longer be a direction-changing accel.
+	   // if any other key was pressed.
+           directionKeyEvent = Key_Space;
+        }
+
+    // Commentary in X11/keysymdef says that X codes match ASCII, so it
+    // is safe to use the locale functions to process X codes in ISO8859-1.
+    //
+    // This is mainly for compatibility - applications should not use the
+    // Qt keycodes between 128 and 255, but should rather use the
+    // QKeyEvent::text().
+    //
+    if ( key < 128 || (key < 256 && (!input_mapper || input_mapper->mibEnum()==4)) ) {
+	code = isprint((int)key) ? toupper((int)key) : 0; // upper-case key, if known
+    } else if ( key >= XK_F1 && key <= XK_F35 ) {
+	code = Key_F1 + ((int)key - XK_F1);	// function keys
+    } else if ( key >= XK_KP_0 && key <= XK_KP_9) {
+	code = Key_0 + ((int)key - XK_KP_0);	// numeric keypad keys
+	state |= Keypad;
+    } else {
+	int i = 0;				// any other keys
+	while ( KeyTbl[i] ) {
+	    if ( key == KeyTbl[i] ) {
+		code = (int)KeyTbl[i+1];
+		break;
+	    }
+	    i += 2;
+	}
+	switch ( key ) {
+	case XK_KP_Insert:
+	case XK_KP_Delete:
+	case XK_KP_Home:
+	case XK_KP_End:
+	case XK_KP_Left:
+	case XK_KP_Up:
+	case XK_KP_Right:
+	case XK_KP_Down:
+	case XK_KP_Prior:
+	case XK_KP_Next:
+	case XK_KP_Space:
+	case XK_KP_Tab:
+	case XK_KP_Enter:
+	case XK_KP_Equal:
+	case XK_KP_Multiply:
+	case XK_KP_Add:
+	case XK_KP_Separator:
+	case XK_KP_Subtract:
+	case XK_KP_Decimal:
+	case XK_KP_Divide:
+	    state |= Keypad;
+	    break;
+	default:
+	    break;
+	}
+
+	if ( code == Key_Tab &&
+	     (state & ShiftButton) == ShiftButton ) {
+            // map shift+tab to shift+backtab, QAccel knows about it
+            // and will handle it.
+	    code = Key_Backtab;
+	    chars[0] = 0;
+	}
+
+	if ( qt_use_rtl_extensions && type  == QEvent::KeyPress ) {
+	    if ( directionKeyEvent ) {
+		if ( key == XK_Shift_L && directionKeyEvent == XK_Control_L ||
+		     key == XK_Control_L && directionKeyEvent == XK_Shift_L ) {
+		    directionKeyEvent = Key_Direction_L;
+		} else if ( key == XK_Shift_R && directionKeyEvent == XK_Control_R ||
+			    key == XK_Control_R && directionKeyEvent == XK_Shift_R ) {
+		    directionKeyEvent = Key_Direction_R;
+		}
+	    }
+	    else if ( directionKeyEvent == Key_Direction_L || directionKeyEvent == Key_Direction_R ) {
+		directionKeyEvent = Key_Space; // invalid
+	    }
+	}
+    }
+
+#if 0
+#ifndef Q_EE
+    static int c  = 0;
+    extern void qt_dialog_default_key();
+#define Q_EE(x) c = (c == x || (!c && x == 0x1000) )? x+1 : 0
+    if ( tlw && state == '0' ) {
+	switch ( code ) {
+	case 0x4f: Q_EE(Key_Backtab); break;
+	case 0x52: Q_EE(Key_Tab); break;
+	case 0x54: Q_EE(Key_Escape); break;
+	case 0x4c:
+	    if (c == Key_Return )
+		qt_dialog_default_key();
+	    else
+		Q_EE(Key_Backspace);
+	    break;
+	}
+    }
+#undef Q_EE
+#endif
+#endif
+
+    // convert chars (8bit) to text (unicode).
+    if ( mapper )
+	text = mapper->toUnicode(chars,count);
+    else if ( !mapper && converted.unicode() != 0x0 )
+	text = converted;
+    else
+	text = chars;
+    return TRUE;
+}
+
+
+struct qt_auto_repeat_data
+{
+    // match the window and keycode with timestamp delta of 10ms
+    Window window;
+    KeyCode keycode;
+    Time timestamp;
+
+    // queue scanner state
+    bool release;
+    bool error;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool qt_keypress_scanner(Display *, XEvent *event, XPointer arg)
+{
+    if (event->type != XKeyPress && event->type != XKeyRelease)
+        return FALSE;
+
+    qt_auto_repeat_data *d = (qt_auto_repeat_data *) arg;
+    if (d->error ||
+        event->xkey.window  != d->window ||
+        event->xkey.keycode != d->keycode)
+        return FALSE;
+
+    if (event->type == XKeyPress) {
+        d->error = (! d->release || event->xkey.time - d->timestamp > 10);
+        return (! d->error);
+    }
+
+    // must be XKeyRelease event
+    if (d->release) {
+        // found a second release
+        d->error = TRUE;
+        return FALSE;
+    }
+
+    // found a single release
+    d->release = TRUE;
+    d->timestamp = event->xkey.time;
+
+    return FALSE;
+}
+
+static Bool qt_keyrelease_scanner(Display *, XEvent *event, XPointer arg)
+{
+    const qt_auto_repeat_data *d = (const qt_auto_repeat_data *) arg;
+    return (event->type == XKeyRelease &&
+            event->xkey.window  == d->window &&
+            event->xkey.keycode == d->keycode);
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+bool QETWidget::translateKeyEvent( const XEvent *event, bool grab )
+{
+    int	   code = -1;
+    int	   count = 0;
+    int	   state;
+    char   ascii = 0;
+
+    if ( sm_blockUserInput ) // block user interaction during session management
+	return TRUE;
+
+    Display *dpy = x11Display();
+
+    if ( !isEnabled() )
+	return TRUE;
+
+    QEvent::Type type;
+    bool    autor = FALSE;
+    QString text;
+
+    translateKeyEventInternal( event, count, text, state, ascii, code, type,
+			       qt_mode_switch_remove_mask != 0 );
+
+    static uint curr_autorep = 0;
+    // was this the last auto-repeater?
+    qt_auto_repeat_data auto_repeat_data;
+    auto_repeat_data.window = event->xkey.window;
+    auto_repeat_data.keycode = event->xkey.keycode;
+    auto_repeat_data.timestamp = event->xkey.time;
+
+    if ( event->type == XKeyPress ) {
+        if ( curr_autorep == event->xkey.keycode ) {
+            autor = TRUE;
+            curr_autorep = 0;
+        }
+    } else {
+	// look ahead for auto-repeat
+        XEvent nextpress;
+
+        auto_repeat_data.release = TRUE;
+        auto_repeat_data.error = FALSE;
+        if (XCheckIfEvent(dpy, &nextpress, &qt_keypress_scanner,
+                          (XPointer) &auto_repeat_data)) {
+            autor = TRUE;
+
+	    // Put it back... we COULD send the event now and not need
+	    // the static curr_autorep variable.
+	    XPutBackEvent(dpy,&nextpress);
+	}
+	curr_autorep = autor ? event->xkey.keycode : 0;
+    }
+
+    // process accelerators before doing key compression
+    if ( type == QEvent::KeyPress && !grab ) {
+	// send accel events if the keyboard is not grabbed
+	QKeyEvent a( type, code, ascii, state, text, autor,
+		     QMAX( QMAX(count,1), int(text.length())) );
+	if ( qt_tryAccelEvent( this, &a ) )
+	    return TRUE;
+    }
+
+    long save = 0;
+    if ( qt_mode_switch_remove_mask != 0 ) {
+	save = qt_mode_switch_remove_mask;
+	qt_mode_switch_remove_mask = 0;
+
+	// translate the key event again, but this time apply any Mode_switch
+	// modifiers
+	translateKeyEventInternal( event, count, text, state, ascii, code, type );
+    }
+
+    // compress keys
+    if ( !text.isEmpty() && testWState(WState_CompressKeys) &&
+	 // do not compress keys if the key event we just got above matches
+	 // one of the key ranges used to compute stopCompression
+	 ! ( ( code >= Key_Escape && code <= Key_SysReq ) ||
+	     ( code >= Key_Home && code <= Key_Next ) ||
+	     ( code >= Key_Super_L && code <= Key_Direction_R ) ||
+	     ( ( code == 0 ) && ( ascii == '\n' ) ) ) ) {
+	// the widget wants key compression so it gets it
+	int	codeIntern = -1;
+	int	countIntern = 0;
+	int	stateIntern;
+	char	asciiIntern = 0;
+	XEvent	evRelease;
+	XEvent	evPress;
+
+	// sync the event queue, this makes key compress work better
+	XSync( dpy, FALSE );
+
+	for (;;) {
+	    QString textIntern;
+	    if ( !XCheckTypedWindowEvent(dpy,event->xkey.window,
+					 XKeyRelease,&evRelease) )
+		break;
+	    if ( !XCheckTypedWindowEvent(dpy,event->xkey.window,
+					 XKeyPress,&evPress) ) {
+		XPutBackEvent(dpy, &evRelease);
+		break;
+	    }
+	    QEvent::Type t;
+	    translateKeyEventInternal( &evPress, countIntern, textIntern,
+				       stateIntern, asciiIntern, codeIntern, t );
+	    // use stopCompression to stop key compression for the following
+	    // key event ranges:
+	    bool stopCompression =
+		// 1) misc keys
+		( codeIntern >= Key_Escape && codeIntern <= Key_SysReq ) ||
+		// 2) cursor movement
+		( codeIntern >= Key_Home && codeIntern <= Key_Next ) ||
+		// 3) extra keys
+		( codeIntern >= Key_Super_L && codeIntern <= Key_Direction_R ) ||
+		// 4) something that a) doesn't translate to text or b) translates
+		//    to newline text
+		((codeIntern == 0) && (asciiIntern == '\n'));
+	    if (stateIntern == state && !textIntern.isEmpty() && !stopCompression) {
+		text += textIntern;
+		count += countIntern;
+	    } else {
+		XPutBackEvent(dpy, &evPress);
+		XPutBackEvent(dpy, &evRelease);
+		break;
+	    }
+	}
+    }
+
+    if ( save != 0 )
+	qt_mode_switch_remove_mask = save;
+
+    // autorepeat compression makes sense for all widgets (Windows
+    // does it automatically .... )
+    if ( event->type == XKeyPress && text.length() <= 1 ) {
+	XEvent dummy;
+
+        for (;;) {
+            auto_repeat_data.release = FALSE;
+            auto_repeat_data.error = FALSE;
+            if (! XCheckIfEvent(dpy, &dummy, &qt_keypress_scanner,
+                                (XPointer) &auto_repeat_data))
+                break;
+            if (! XCheckIfEvent(dpy, &dummy, &qt_keyrelease_scanner,
+                                (XPointer) &auto_repeat_data))
+                break;
+
+	    count++;
+	    if (!text.isEmpty())
+		text += text[0];
+	}
+    }
+
+    if (code == 0 && ascii == '\n') {
+	code = Key_Return;
+	ascii = '\r';
+	text = "\r";
+    }
+
+    // try the menukey first
+    if ( type == QEvent::KeyPress && code == Qt::Key_Menu ) {
+	QContextMenuEvent e( QContextMenuEvent::Keyboard, QPoint( 5, 5 ), mapToGlobal( QPoint( 5, 5 ) ), 0 );
+	QApplication::sendSpontaneousEvent( this, &e );
+	if( e.isAccepted() )
+	    return TRUE;
+    }
+
+    QKeyEvent e( type, code, ascii, state, text, autor,
+		 QMAX(QMAX(count,1), int(text.length())) );
+    return QApplication::sendSpontaneousEvent( this, &e );
+}
+
+
+//
+// Paint event translation
+//
+// When receiving many expose events, we compress them (union of all expose
+// rectangles) into one event which is sent to the widget.
+
+struct PaintEventInfo {
+    Window window;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool isPaintOrScrollDoneEvent( Display *, XEvent *ev, XPointer a )
+{
+    PaintEventInfo *info = (PaintEventInfo *)a;
+    if ( ev->type == Expose || ev->type == GraphicsExpose
+      ||    ev->type == ClientMessage
+	 && ev->xclient.message_type == qt_qt_scrolldone )
+    {
+	if ( ev->xexpose.window == info->window )
+	    return True;
+    }
+    return False;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+// declared above: static QPtrList<QScrollInProgress> *sip_list = 0;
+
+void qt_insert_sip( QWidget* scrolled_widget, int dx, int dy )
+{
+    if ( !sip_list ) {
+	sip_list = new QPtrList<QScrollInProgress>;
+	sip_list->setAutoDelete( TRUE );
+    }
+
+    QScrollInProgress* sip = new QScrollInProgress( scrolled_widget, dx, dy );
+    sip_list->append( sip );
+
+    XClientMessageEvent client_message;
+    client_message.type = ClientMessage;
+    client_message.window = scrolled_widget->winId();
+    client_message.format = 32;
+    client_message.message_type = qt_qt_scrolldone;
+    client_message.data.l[0] = sip->id;
+
+    XSendEvent( appDpy, scrolled_widget->winId(), False, NoEventMask,
+	(XEvent*)&client_message );
+}
+
+int qt_sip_count( QWidget* scrolled_widget )
+{
+    if ( !sip_list )
+	return 0;
+
+    int sips=0;
+
+    for (QScrollInProgress* sip = sip_list->first();
+	sip; sip=sip_list->next())
+    {
+	if ( sip->scrolled_widget == scrolled_widget )
+	    sips++;
+    }
+
+    return sips;
+}
+
+static
+bool translateBySips( QWidget* that, QRect& paintRect )
+{
+    if ( sip_list ) {
+	int dx=0, dy=0;
+	int sips=0;
+	for (QScrollInProgress* sip = sip_list->first();
+	    sip; sip=sip_list->next())
+	{
+	    if ( sip->scrolled_widget == that ) {
+		if ( sips ) {
+		    dx += sip->dx;
+		    dy += sip->dy;
+		}
+		sips++;
+	    }
+	}
+	if ( sips > 1 ) {
+	    paintRect.moveBy( dx, dy );
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+bool QETWidget::translatePaintEvent( const XEvent *event )
+{
+    setWState( WState_Exposed );
+    QRect  paintRect( event->xexpose.x,	   event->xexpose.y,
+		      event->xexpose.width, event->xexpose.height );
+    bool   merging_okay = !testWFlags(WPaintClever);
+    XEvent xevent;
+    PaintEventInfo info;
+    info.window = winId();
+    bool should_clip = translateBySips( this, paintRect );
+
+    QRegion paintRegion( paintRect );
+
+    if ( merging_okay ) {
+	// WARNING: this is O(number_of_events * number_of_matching_events)
+	while ( XCheckIfEvent(x11Display(),&xevent,isPaintOrScrollDoneEvent,
+			      (XPointer)&info) &&
+		!qt_x11EventFilter(&xevent)  &&
+		!x11Event( &xevent ) ) // send event through filter
+	{
+	    if ( xevent.type == Expose || xevent.type == GraphicsExpose ) {
+		QRect exposure(xevent.xexpose.x,
+			       xevent.xexpose.y,
+			       xevent.xexpose.width,
+			       xevent.xexpose.height);
+		if ( translateBySips( this, exposure ) )
+		    should_clip = TRUE;
+		paintRegion = paintRegion.unite( exposure );
+	    } else {
+		translateScrollDoneEvent( &xevent );
+	    }
+	}
+    }
+
+    if ( should_clip ) {
+	paintRegion = paintRegion.intersect( rect() );
+	if ( paintRegion.isEmpty() )
+	    return TRUE;
+    }
+
+    QPaintEvent e( paintRegion );
+    setWState( WState_InPaintEvent );
+    if ( !isTopLevel() && backgroundOrigin() != WidgetOrigin )
+	erase( paintRegion );
+    qt_set_paintevent_clipping( this, paintRegion );
+    QApplication::sendSpontaneousEvent( this, &e );
+    qt_clear_paintevent_clipping();
+    clearWState( WState_InPaintEvent );
+    return TRUE;
+}
+
+//
+// Scroll-done event translation.
+//
+
+bool QETWidget::translateScrollDoneEvent( const XEvent *event )
+{
+    if ( !sip_list ) return FALSE;
+
+    long id = event->xclient.data.l[0];
+
+    // Remove any scroll-in-progress record for the given id.
+    for (QScrollInProgress* sip = sip_list->first(); sip; sip=sip_list->next()) {
+	if ( sip->id == id ) {
+	    sip_list->remove( sip_list->current() );
+	    return TRUE;
+	}
+    }
+
+    return FALSE;
+}
+
+
+//
+// ConfigureNotify (window move and resize) event translation
+
+bool QETWidget::translateConfigEvent( const XEvent *event )
+{
+    // config pending is only set on resize, see qwidget_x11.cpp, internalSetGeometry()
+    bool was_resize = testWState( WState_ConfigPending );
+
+    clearWState(WState_ConfigPending);
+
+    if ( isTopLevel() ) {
+	QPoint newCPos( geometry().topLeft() );
+	QSize  newSize( event->xconfigure.width, event->xconfigure.height );
+
+	bool trust = (topData()->parentWinId == None ||
+		      topData()->parentWinId == QPaintDevice::x11AppRootWindow());
+
+	if (event->xconfigure.send_event || trust ) {
+	    // if a ConfigureNotify comes from a real sendevent request, we can
+	    // trust its values.
+	    newCPos.rx() = event->xconfigure.x + event->xconfigure.border_width;
+	    newCPos.ry() = event->xconfigure.y + event->xconfigure.border_width;
+	}
+
+	if ( isVisible() )
+	    QApplication::syncX();
+
+        if (! extra || extra->compress_events) {
+            // ConfigureNotify compression for faster opaque resizing
+            XEvent otherEvent;
+            while ( XCheckTypedWindowEvent( x11Display(), winId(), ConfigureNotify,
+                                            &otherEvent ) ) {
+                if ( qt_x11EventFilter( &otherEvent ) )
+                    continue;
+
+                if (x11Event( &otherEvent ) )
+                    continue;
+
+                if ( otherEvent.xconfigure.event != otherEvent.xconfigure.window )
+                    continue;
+
+                newSize.setWidth( otherEvent.xconfigure.width );
+                newSize.setHeight( otherEvent.xconfigure.height );
+
+                if ( otherEvent.xconfigure.send_event || trust ) {
+                    newCPos.rx() = otherEvent.xconfigure.x +
+                                   otherEvent.xconfigure.border_width;
+                    newCPos.ry() = otherEvent.xconfigure.y +
+                                   otherEvent.xconfigure.border_width;
+                }
+            }
+        }
+
+	QRect cr ( geometry() );
+	if ( newSize != cr.size() ) { // size changed
+	    was_resize = TRUE;
+	    QSize oldSize = size();
+	    cr.setSize( newSize );
+	    crect = cr;
+
+	    if ( isVisible() ) {
+		QResizeEvent e( newSize, oldSize );
+		QApplication::sendSpontaneousEvent( this, &e );
+	    } else {
+		QResizeEvent * e = new QResizeEvent( newSize, oldSize );
+		QApplication::postEvent( this, e );
+	    }
+	}
+
+	if ( newCPos != cr.topLeft() ) { // compare with cpos (exluding frame)
+	    QPoint oldPos = geometry().topLeft();
+	    cr.moveTopLeft( newCPos );
+	    crect = cr;
+	    if ( isVisible() ) {
+		QMoveEvent e( newCPos, oldPos ); // pos (including frame), not cpos
+		QApplication::sendSpontaneousEvent( this, &e );
+	    } else {
+		QMoveEvent * e = new QMoveEvent( newCPos, oldPos );
+		QApplication::postEvent( this, e );
+	    }
+	}
+    } else {
+	XEvent xevent;
+	while ( XCheckTypedWindowEvent(x11Display(),winId(), ConfigureNotify,&xevent) &&
+		!qt_x11EventFilter(&xevent)  &&
+		!x11Event( &xevent ) ) // send event through filter
+	    ;
+    }
+
+    bool transbg = backgroundOrigin() != WidgetOrigin;
+    // we ignore NorthWestGravity at the moment for reversed layout
+    if ( transbg ||
+	 (!testWFlags( WStaticContents ) &&
+	  testWState( WState_Exposed ) && was_resize ) ||
+	 QApplication::reverseLayout() ) {
+	// remove unnecessary paint events from the queue
+	XEvent xevent;
+	while ( XCheckTypedWindowEvent( x11Display(), winId(), Expose, &xevent ) &&
+		! qt_x11EventFilter( &xevent )  &&
+		! x11Event( &xevent ) ) // send event through filter
+	    ;
+	repaint( !testWFlags(WResizeNoErase) || transbg );
+    }
+
+    return TRUE;
+}
+
+
+//
+// Close window event translation.
+//
+bool QETWidget::translateCloseEvent( const XEvent * )
+{
+    return close(FALSE);
+}
+
+
+/*!
+    Sets the text cursor's flash (blink) time to \a msecs
+    milliseconds. The flash time is the time required to display,
+    invert and restore the caret display. Usually the text cursor is
+    displayed for \a msecs/2 milliseconds, then hidden for \a msecs/2
+    milliseconds, but this may vary.
+
+    Note that on Microsoft Windows, calling this function sets the
+    cursor flash time for all windows.
+
+    \sa cursorFlashTime()
+*/
+void  QApplication::setCursorFlashTime( int msecs )
+{
+    cursor_flash_time = msecs;
+}
+
+
+/*!
+    Returns the text cursor's flash (blink) time in milliseconds. The
+    flash time is the time required to display, invert and restore the
+    caret display.
+
+    The default value on X11 is 1000 milliseconds. On Windows, the
+    control panel value is used.
+
+    Widgets should not cache this value since it may be changed at any
+    time by the user changing the global desktop settings.
+
+    \sa setCursorFlashTime()
+*/
+int QApplication::cursorFlashTime()
+{
+    return cursor_flash_time;
+}
+
+/*!
+    Sets the time limit that distinguishes a double click from two
+    consecutive mouse clicks to \a ms milliseconds.
+
+    Note that on Microsoft Windows, calling this function sets the
+    double click interval for all windows.
+
+    \sa doubleClickInterval()
+*/
+
+void QApplication::setDoubleClickInterval( int ms )
+{
+    mouse_double_click_time = ms;
+}
+
+
+/*!
+    Returns the maximum duration for a double click.
+
+    The default value on X11 is 400 milliseconds. On Windows, the
+    control panel value is used.
+
+    \sa setDoubleClickInterval()
+*/
+
+int QApplication::doubleClickInterval()
+{
+    return mouse_double_click_time;
+}
+
+
+/*!
+    Sets the number of lines to scroll when the mouse wheel is rotated
+    to \a n.
+
+    If this number exceeds the number of visible lines in a certain
+    widget, the widget should interpret the scroll operation as a
+    single page up / page down operation instead.
+
+    \sa wheelScrollLines()
+*/
+void QApplication::setWheelScrollLines( int n )
+{
+    wheel_scroll_lines = n;
+}
+
+/*!
+    Returns the number of lines to scroll when the mouse wheel is
+    rotated.
+
+    \sa setWheelScrollLines()
+*/
+int QApplication::wheelScrollLines()
+{
+    return wheel_scroll_lines;
+}
+
+/*!
+    Enables the UI effect \a effect if \a enable is TRUE, otherwise
+    the effect will not be used.
+
+    Note: All effects are disabled on screens running at less than
+    16-bit color depth.
+
+    \sa isEffectEnabled(), Qt::UIEffect, setDesktopSettingsAware()
+*/
+void QApplication::setEffectEnabled( Qt::UIEffect effect, bool enable )
+{
+    switch (effect) {
+    case UI_AnimateMenu:
+	if ( enable ) fade_menu = FALSE;
+	animate_menu = enable;
+	break;
+    case UI_FadeMenu:
+	if ( enable )
+	    animate_menu = TRUE;
+	fade_menu = enable;
+	break;
+    case UI_AnimateCombo:
+	animate_combo = enable;
+	break;
+    case UI_AnimateTooltip:
+	if ( enable ) fade_tooltip = FALSE;
+	animate_tooltip = enable;
+	break;
+    case UI_FadeTooltip:
+	if ( enable )
+	    animate_tooltip = TRUE;
+	fade_tooltip = enable;
+	break;
+    case UI_AnimateToolBox:
+	animate_toolbox = enable;
+	break;
+    default:
+	animate_ui = enable;
+	break;
+    }
+}
+
+/*!
+    Returns TRUE if \a effect is enabled; otherwise returns FALSE.
+
+    By default, Qt will try to use the desktop settings. Call
+    setDesktopSettingsAware(FALSE) to prevent this.
+
+    Note: All effects are disabled on screens running at less than
+    16-bit color depth.
+
+    \sa setEffectEnabled(), Qt::UIEffect
+*/
+bool QApplication::isEffectEnabled( Qt::UIEffect effect )
+{
+    if ( QColor::numBitPlanes() < 16 || !animate_ui )
+	return FALSE;
+
+    switch( effect ) {
+    case UI_AnimateMenu:
+	return animate_menu;
+    case UI_FadeMenu:
+	return fade_menu;
+    case UI_AnimateCombo:
+	return animate_combo;
+    case UI_AnimateTooltip:
+	return animate_tooltip;
+    case UI_FadeTooltip:
+	return fade_tooltip;
+    case UI_AnimateToolBox:
+	return animate_toolbox;
+    default:
+	return animate_ui;
+    }
+}
+
+/*****************************************************************************
+  Session management support
+ *****************************************************************************/
+
+#ifndef QT_NO_SM_SUPPORT
+
+#include <X11/SM/SMlib.h>
+
+class QSessionManagerData
+{
+public:
+    QSessionManagerData( QSessionManager* mgr, QString& id, QString& key )
+	: sm( mgr ), sessionId( id ), sessionKey( key ) {}
+    QSessionManager* sm;
+    QStringList restartCommand;
+    QStringList discardCommand;
+    QString& sessionId;
+    QString& sessionKey;
+    QSessionManager::RestartHint restartHint;
+};
+
+class QSmSocketReceiver : public QObject
+{
+    Q_OBJECT
+public:
+    QSmSocketReceiver( int socket )
+	: QObject(0,0)
+	{
+	    QSocketNotifier* sn = new QSocketNotifier( socket, QSocketNotifier::Read, this );
+	    connect( sn, SIGNAL( activated(int) ), this, SLOT( socketActivated(int) ) );
+	}
+
+public slots:
+     void socketActivated(int);
+};
+
+
+static SmcConn smcConnection = 0;
+static bool sm_interactionActive;
+static bool sm_smActive;
+static int sm_interactStyle;
+static int sm_saveType;
+static bool sm_cancel;
+// static bool sm_waitingForPhase2;  ### never used?!?
+static bool sm_waitingForInteraction;
+static bool sm_isshutdown;
+// static bool sm_shouldbefast;  ### never used?!?
+static bool sm_phase2;
+static bool sm_in_phase2;
+
+static QSmSocketReceiver* sm_receiver = 0;
+
+static void resetSmState();
+static void sm_setProperty( const char* name, const char* type,
+			    int num_vals, SmPropValue* vals);
+static void sm_saveYourselfCallback( SmcConn smcConn, SmPointer clientData,
+				  int saveType, Bool shutdown , int interactStyle, Bool fast);
+static void sm_saveYourselfPhase2Callback( SmcConn smcConn, SmPointer clientData ) ;
+static void sm_dieCallback( SmcConn smcConn, SmPointer clientData ) ;
+static void sm_shutdownCancelledCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_saveCompleteCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_interactCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_performSaveYourself( QSessionManagerData* );
+
+static void resetSmState()
+{
+//    sm_waitingForPhase2 = FALSE; ### never used?!?
+    sm_waitingForInteraction = FALSE;
+    sm_interactionActive = FALSE;
+    sm_interactStyle = SmInteractStyleNone;
+    sm_smActive = FALSE;
+    sm_blockUserInput = FALSE;
+    sm_isshutdown = FALSE;
+//    sm_shouldbefast = FALSE; ### never used?!?
+    sm_phase2 = FALSE;
+    sm_in_phase2 = FALSE;
+}
+
+
+// theoretically it's possible to set several properties at once. For
+// simplicity, however, we do just one property at a time
+static void sm_setProperty( const char* name, const char* type,
+			    int num_vals, SmPropValue* vals)
+{
+    if (num_vals ) {
+      SmProp prop;
+      prop.name = (char*)name;
+      prop.type = (char*)type;
+      prop.num_vals = num_vals;
+      prop.vals = vals;
+
+      SmProp* props[1];
+      props[0] = &prop;
+      SmcSetProperties( smcConnection, 1, props );
+    }
+    else {
+      char* names[1];
+      names[0] = (char*) name;
+      SmcDeleteProperties( smcConnection, 1, names );
+    }
+}
+
+static void sm_setProperty( const QString& name, const QString& value)
+{
+    SmPropValue prop;
+    prop.length = value.length();
+    prop.value = (SmPointer) value.latin1();
+    sm_setProperty( name.latin1(), SmARRAY8, 1, &prop );
+}
+
+static void sm_setProperty( const QString& name, const QStringList& value)
+{
+    SmPropValue *prop = new SmPropValue[ value.count() ];
+    int count = 0;
+    for ( QStringList::ConstIterator it = value.begin(); it != value.end(); ++it ) {
+      prop[ count ].length = (*it).length();
+      prop[ count ].value = (char*)(*it).latin1();
+      ++count;
+    }
+    sm_setProperty( name.latin1(), SmLISTofARRAY8, count, prop );
+    delete [] prop;
+}
+
+
+// workaround for broken libsm, see below
+struct QT_smcConn {
+    unsigned int save_yourself_in_progress : 1;
+    unsigned int shutdown_in_progress : 1;
+};
+
+static void sm_saveYourselfCallback( SmcConn smcConn, SmPointer clientData,
+				  int saveType, Bool shutdown , int interactStyle, Bool /*fast*/)
+{
+    if (smcConn != smcConnection )
+	return;
+    sm_cancel = FALSE;
+    sm_smActive = TRUE;
+    sm_isshutdown = shutdown;
+    sm_saveType = saveType;
+    sm_interactStyle = interactStyle;
+//    sm_shouldbefast = fast; ### never used?!?
+
+    // ugly workaround for broken libSM. libSM should do that _before_
+    // actually invoking the callback in sm_process.c
+    ( (QT_smcConn*)smcConn )->save_yourself_in_progress = TRUE;
+    if ( sm_isshutdown )
+	( (QT_smcConn*)smcConn )->shutdown_in_progress = TRUE;
+
+    sm_performSaveYourself( (QSessionManagerData*) clientData );
+    if ( !sm_isshutdown ) // we cannot expect a confirmation message in that case
+	resetSmState();
+}
+
+static void sm_performSaveYourself( QSessionManagerData* smd )
+{
+    if ( sm_isshutdown )
+	sm_blockUserInput = TRUE;
+
+    QSessionManager* sm = smd->sm;
+
+    // generate a new session key
+    timeval tv;
+    gettimeofday( &tv, 0 );
+    smd->sessionKey  = QString::number( tv.tv_sec ) + "_" + QString::number(tv.tv_usec);
+
+    // tell the session manager about our program in best POSIX style
+    sm_setProperty( SmProgram, QString( qApp->argv()[0] ) );
+    // tell the session manager about our user as well.
+    struct passwd* entry = getpwuid( geteuid() );
+    if ( entry )
+	sm_setProperty( SmUserID, QString::fromLatin1( entry->pw_name ) );
+
+    // generate a restart and discard command that makes sense
+    QStringList restart;
+    restart  << qApp->argv()[0] << "-session" << smd->sessionId + "_" + smd->sessionKey;
+    if (qstricmp(qAppName(), qAppClass()) != 0)
+	restart << "-name" << qAppName();
+    sm->setRestartCommand( restart );
+    QStringList discard;
+    sm->setDiscardCommand( discard );
+
+    switch ( sm_saveType ) {
+    case SmSaveBoth:
+	qApp->commitData( *sm );
+	if ( sm_isshutdown && sm_cancel)
+	    break; // we cancelled the shutdown, no need to save state
+    // fall through
+    case SmSaveLocal:
+	qApp->saveState( *sm );
+	break;
+    case SmSaveGlobal:
+	qApp->commitData( *sm );
+	break;
+    default:
+	break;
+    }
+
+    if ( sm_phase2 && !sm_in_phase2 ) {
+	SmcRequestSaveYourselfPhase2( smcConnection, sm_saveYourselfPhase2Callback, (SmPointer*) smd );
+	sm_blockUserInput = FALSE;
+    }
+    else {
+	// close eventual interaction monitors and cancel the
+	// shutdown, if required. Note that we can only cancel when
+	// performing a shutdown, it does not work for checkpoints
+	if ( sm_interactionActive ) {
+	    SmcInteractDone( smcConnection, sm_isshutdown && sm_cancel);
+	    sm_interactionActive = FALSE;
+	}
+	else if ( sm_cancel && sm_isshutdown ) {
+	    if ( sm->allowsErrorInteraction() ) {
+		SmcInteractDone( smcConnection, True );
+		sm_interactionActive = FALSE;
+	    }
+	}
+
+	// set restart and discard command in session manager
+	sm_setProperty( SmRestartCommand, sm->restartCommand() );
+	sm_setProperty( SmDiscardCommand, sm->discardCommand() );
+
+	// set the restart hint
+	SmPropValue prop;
+	prop.length = sizeof( int );
+	int value = sm->restartHint();
+	prop.value = (SmPointer) &value;
+	sm_setProperty( SmRestartStyleHint, SmCARD8, 1, &prop );
+
+	// we are done
+	SmcSaveYourselfDone( smcConnection, !sm_cancel );
+    }
+}
+
+static void sm_dieCallback( SmcConn smcConn, SmPointer /* clientData  */)
+{
+    if (smcConn != smcConnection )
+	return;
+    resetSmState();
+    QEvent quitEvent(QEvent::Quit);
+    QApplication::sendEvent(qApp, &quitEvent);
+}
+
+static void sm_shutdownCancelledCallback( SmcConn smcConn, SmPointer /* clientData */)
+{
+    if (smcConn != smcConnection )
+	return;
+    if ( sm_waitingForInteraction )
+	qApp->exit_loop();
+    resetSmState();
+}
+
+static void sm_saveCompleteCallback( SmcConn smcConn, SmPointer /*clientData */)
+{
+    if (smcConn != smcConnection )
+	return;
+    resetSmState();
+}
+
+static void sm_interactCallback( SmcConn smcConn, SmPointer /* clientData */ )
+{
+    if (smcConn != smcConnection )
+	return;
+    if ( sm_waitingForInteraction )
+	qApp->exit_loop();
+}
+
+static void sm_saveYourselfPhase2Callback( SmcConn smcConn, SmPointer clientData )
+{
+    if (smcConn != smcConnection )
+	return;
+    sm_in_phase2 = TRUE;
+    sm_performSaveYourself( (QSessionManagerData*) clientData );
+}
+
+
+void QSmSocketReceiver::socketActivated(int)
+{
+    IceProcessMessages( SmcGetIceConnection( smcConnection ), 0, 0);
+}
+
+
+#undef Bool
+#include "qapplication_x11.moc"
+
+QSessionManager::QSessionManager( QApplication * app, QString &id, QString& key )
+    : QObject( app, "session manager" )
+{
+    d = new QSessionManagerData( this, id, key );
+    d->restartHint = RestartIfRunning;
+
+    resetSmState();
+    char cerror[256];
+    char* myId = 0;
+    char* prevId = (char*)id.latin1(); // we know what we are doing
+
+    SmcCallbacks cb;
+    cb.save_yourself.callback = sm_saveYourselfCallback;
+    cb.save_yourself.client_data = (SmPointer) d;
+    cb.die.callback = sm_dieCallback;
+    cb.die.client_data = (SmPointer) d;
+    cb.save_complete.callback = sm_saveCompleteCallback;
+    cb.save_complete.client_data = (SmPointer) d;
+    cb.shutdown_cancelled.callback = sm_shutdownCancelledCallback;
+    cb.shutdown_cancelled.client_data = (SmPointer) d;
+
+    // avoid showing a warning message below
+    const char* session_manager = getenv("SESSION_MANAGER");
+    if ( !session_manager || !session_manager[0] )
+	return;
+
+    smcConnection = SmcOpenConnection( 0, 0, 1, 0,
+				       SmcSaveYourselfProcMask |
+				       SmcDieProcMask |
+				       SmcSaveCompleteProcMask |
+				       SmcShutdownCancelledProcMask,
+				       &cb,
+				       prevId,
+				       &myId,
+				       256, cerror );
+
+    id = QString::fromLatin1( myId );
+    ::free( myId ); // it was allocated by C
+
+    QString error = cerror;
+    if (!smcConnection ) {
+	qWarning("Session management error: %s", error.latin1() );
+    }
+    else {
+	sm_receiver = new QSmSocketReceiver(  IceConnectionNumber( SmcGetIceConnection( smcConnection ) ) );
+    }
+}
+
+QSessionManager::~QSessionManager()
+{
+    if ( smcConnection )
+      SmcCloseConnection( smcConnection, 0, 0 );
+    smcConnection = 0;
+    delete sm_receiver;
+    delete d;
+}
+
+QString QSessionManager::sessionId() const
+{
+    return d->sessionId;
+}
+
+QString QSessionManager::sessionKey() const
+{
+    return d->sessionKey;
+}
+
+
+void* QSessionManager::handle() const
+{
+    return (void*) smcConnection;
+}
+
+
+bool QSessionManager::allowsInteraction()
+{
+    if ( sm_interactionActive )
+	return TRUE;
+
+    if ( sm_waitingForInteraction )
+	return FALSE;
+
+    if ( sm_interactStyle == SmInteractStyleAny ) {
+	sm_waitingForInteraction =  SmcInteractRequest( smcConnection, SmDialogNormal,
+							sm_interactCallback, (SmPointer*) this );
+    }
+    if ( sm_waitingForInteraction ) {
+	qApp->enter_loop();
+	sm_waitingForInteraction = FALSE;
+	if ( sm_smActive ) { // not cancelled
+	    sm_interactionActive = TRUE;
+	    sm_blockUserInput = FALSE;
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+bool QSessionManager::allowsErrorInteraction()
+{
+    if ( sm_interactionActive )
+	return TRUE;
+
+    if ( sm_waitingForInteraction )
+	return FALSE;
+
+    if ( sm_interactStyle == SmInteractStyleAny || sm_interactStyle == SmInteractStyleErrors ) {
+	sm_waitingForInteraction =  SmcInteractRequest( smcConnection, SmDialogError,
+							sm_interactCallback, (SmPointer*) this );
+    }
+    if ( sm_waitingForInteraction ) {
+	qApp->enter_loop();
+	sm_waitingForInteraction = FALSE;
+	if ( sm_smActive ) { // not cancelled
+	    sm_interactionActive = TRUE;
+	    sm_blockUserInput = FALSE;
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+void QSessionManager::release()
+{
+    if ( sm_interactionActive ) {
+	SmcInteractDone( smcConnection, False );
+	sm_interactionActive = FALSE;
+	if ( sm_smActive && sm_isshutdown )
+	    sm_blockUserInput = TRUE;
+    }
+}
+
+void QSessionManager::cancel()
+{
+    sm_cancel = TRUE;
+}
+
+void QSessionManager::setRestartHint( QSessionManager::RestartHint hint)
+{
+    d->restartHint = hint;
+}
+
+QSessionManager::RestartHint QSessionManager::restartHint() const
+{
+    return d->restartHint;
+}
+
+void QSessionManager::setRestartCommand( const QStringList& command)
+{
+    d->restartCommand = command;
+}
+
+QStringList QSessionManager::restartCommand() const
+{
+    return d->restartCommand;
+}
+
+void QSessionManager::setDiscardCommand( const QStringList& command)
+{
+    d->discardCommand = command;
+}
+
+QStringList QSessionManager::discardCommand() const
+{
+    return d->discardCommand;
+}
+
+void QSessionManager::setManagerProperty( const QString& name, const QString& value)
+{
+    SmPropValue prop;
+    prop.length = value.length();
+    prop.value = (SmPointer) value.utf8().data();
+    sm_setProperty( name.latin1(), SmARRAY8, 1, &prop );
+}
+
+void QSessionManager::setManagerProperty( const QString& name, const QStringList& value)
+{
+    SmPropValue *prop = new SmPropValue[ value.count() ];
+    int count = 0;
+    for ( QStringList::ConstIterator it = value.begin(); it != value.end(); ++it ) {
+      prop[ count ].length = (*it).length();
+      prop[ count ].value = (char*)(*it).utf8().data();
+      ++count;
+    }
+    sm_setProperty( name.latin1(), SmLISTofARRAY8, count, prop );
+    delete [] prop;
+}
+
+bool QSessionManager::isPhase2() const
+{
+    return sm_in_phase2;
+}
+
+void QSessionManager::requestPhase2()
+{
+    sm_phase2 = TRUE;
+}
+
+
+#endif // QT_NO_SM_SUPPORT
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qevent.cpp qt-x11-free-3.3.8b/src/kernel/qevent.cpp
--- qt-x11-free-3.3.8b/src/kernel/qevent.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qevent.cpp	2009-10-18 14:38:39.155204693 -0700
@@ -736,4 +736,8 @@
     sequence or a keyboard macro, or due to key event compression).
 
+    Applications should not use the Qt latin 1 keycodes between 128
+    and 255, but should rather use the QKeyEvent::text(). This is
+    mainly for compatibility.
+
     \sa QWidget::setKeyCompression()
 */
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qevent.cpp.orig qt-x11-free-3.3.8b/src/kernel/qevent.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qevent.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qevent.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,2567 @@
+/****************************************************************************
+**
+** Implementation of event classes
+**
+** Created : 931029
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qevent.h"
+#include "qcursor.h"
+#include "qapplication.h"
+
+
+/*!
+    \class QEvent qevent.h
+    \brief The QEvent class is the base class of all
+    event classes. Event objects contain event parameters.
+
+    \ingroup events
+    \ingroup environment
+
+    Qt's main event loop (QApplication::exec()) fetches native window
+    system events from the event queue, translates them into QEvents
+    and sends the translated events to QObjects.
+
+    In general, events come from the underlying window system
+    (spontaneous() returns TRUE) but it is also possible to manually
+    send events using QApplication::sendEvent() and
+    QApplication::postEvent() (spontaneous() returns FALSE).
+
+    QObjects receive events by having their QObject::event() function
+    called. The function can be reimplemented in subclasses to
+    customize event handling and add additional event types;
+    QWidget::event() is a notable example. By default, events are
+    dispatched to event handlers like QObject::timerEvent() and
+    QWidget::mouseMoveEvent(). QObject::installEventFilter() allows an
+    object to intercept events destined for another object.
+
+    The basic QEvent contains only an event type parameter.
+    Subclasses of QEvent contain additional parameters that describe
+    the particular event.
+
+    \sa QObject::event() QObject::installEventFilter()
+    QWidget::event() QApplication::sendEvent()
+    QApplication::postEvent() QApplication::processEvents()
+*/
+
+
+/*!
+    \enum Qt::ButtonState
+
+    This enum type describes the state of the mouse and the modifier
+    buttons.
+
+    \value NoButton  used when the button state does not refer to any
+    button (see QMouseEvent::button()).
+    \value LeftButton  set if the left button is pressed, or if this
+    event refers to the left button. (The left button may be
+    the right button on left-handed mice.)
+    \value RightButton  the right button.
+    \value MidButton  the middle button.
+    \value ShiftButton  a Shift key on the keyboard is also pressed.
+    \value ControlButton  a Ctrl key on the keyboard is also pressed.
+    \value AltButton  an Alt key on the keyboard is also pressed.
+    \value MetaButton a Meta key on the keyboard is also pressed.
+    \value Keypad  a keypad button is pressed.
+    \value KeyButtonMask a mask for ShiftButton, ControlButton,
+    AltButton and MetaButton.
+    \value MouseButtonMask a mask for LeftButton, RightButton and MidButton.
+*/
+
+/*!
+    \enum QEvent::Type
+
+    This enum type defines the valid event types in Qt. The event
+    types and the specialized classes for each type are these:
+
+    \value None  Not an event.
+    \value Accessibility  Accessibility information is requested
+    \value Timer  Regular timer events, \l{QTimerEvent}.
+    \value MouseButtonPress  Mouse press, \l{QMouseEvent}.
+    \value MouseButtonRelease  Mouse release, \l{QMouseEvent}.
+    \value MouseButtonDblClick  Mouse press again, \l{QMouseEvent}.
+    \value MouseMove  Mouse move, \l{QMouseEvent}.
+    \value KeyPress  Key press (including Shift, for example), \l{QKeyEvent}.
+    \value KeyRelease  Key release, \l{QKeyEvent}.
+    \value IMStart  The start of input method composition, \l{QIMEvent}.
+    \value IMCompose  Input method composition is taking place, \l{QIMEvent}.
+    \value IMEnd  The end of input method composition, \l{QIMEvent}.
+    \value FocusIn  Widget gains keyboard focus, \l{QFocusEvent}.
+    \value FocusOut  Widget loses keyboard focus, \l{QFocusEvent}.
+    \value Enter  Mouse enters widget's boundaries.
+    \value Leave  Mouse leaves widget's boundaries.
+    \value Paint  Screen update necessary, \l{QPaintEvent}.
+    \value Move  Widget's position changed, \l{QMoveEvent}.
+    \value Resize  Widget's size changed, \l{QResizeEvent}.
+    \value Show  Widget was shown on screen, \l{QShowEvent}.
+    \value Hide  Widget was hidden, \l{QHideEvent}.
+    \value ShowToParent  A child widget has been shown.
+    \value HideToParent  A child widget has been hidden.
+    \value Close  Widget was closed (permanently), \l{QCloseEvent}.
+    \value ShowNormal  Widget should be shown normally (obsolete).
+    \value ShowMaximized  Widget should be shown maximized (obsolete).
+    \value ShowMinimized  Widget should be shown minimized (obsolete).
+    \value ShowFullScreen  Widget should be shown full-screen (obsolete).
+    \value ShowWindowRequest  Widget's window should be shown (obsolete).
+    \value DeferredDelete  The object will be deleted after it has
+    cleaned up.
+    \value Accel  Key press in child for shortcut key handling, \l{QKeyEvent}.
+    \value Wheel  Mouse wheel rolled, \l{QWheelEvent}.
+    \value ContextMenu  Context popup menu, \l{QContextMenuEvent}
+    \value AccelOverride  Key press in child, for overriding shortcut key handling, \l{QKeyEvent}.
+    \value AccelAvailable internal.
+    \value WindowActivate  Window was activated.
+    \value WindowDeactivate  Window was deactivated.
+    \value CaptionChange  Widget's caption changed.
+    \value IconChange  Widget's icon changed.
+    \value ParentFontChange  Font of the parent widget changed.
+    \value ApplicationFontChange  Default application font changed.
+    \value PaletteChange  Palette of the widget changed.
+    \value ParentPaletteChange  Palette of the parent widget changed.
+    \value ApplicationPaletteChange  Default application palette changed.
+    \value Clipboard  Clipboard contents have changed.
+    \value SockAct  Socket activated, used to implement \l{QSocketNotifier}.
+    \value DragEnter  A drag-and-drop enters widget, \l{QDragEnterEvent}.
+    \value DragMove  A drag-and-drop is in progress, \l{QDragMoveEvent}.
+    \value DragLeave  A drag-and-drop leaves widget, \l{QDragLeaveEvent}.
+    \value Drop  A drag-and-drop is completed, \l{QDropEvent}.
+    \value DragResponse  Internal event used by Qt on some platforms.
+    \value ChildInserted  Object gets a child, \l{QChildEvent}.
+    \value ChildRemoved  Object loses a child, \l{QChildEvent}.
+    \value LayoutHint  Widget child has changed layout properties.
+    \value ActivateControl  Internal event used by Qt on some platforms.
+    \value DeactivateControl  Internal event used by Qt on some platforms.
+    \value LanguageChange  The application translation changed, \l{QTranslator}
+    \value LayoutDirectionChange  The direction of layouts changed
+    \value LocaleChange  The system locale changed
+    \value Quit  Reserved.
+    \value Create  Reserved.
+    \value Destroy  Reserved.
+    \value Reparent  Reserved.
+    \value Speech  Reserved for speech input.
+    \value TabletMove  A Wacom Tablet Move Event.
+    \value Style  Internal use only
+    \value TabletPress  A Wacom Tablet Press Event
+    \value TabletRelease  A Wacom Tablet Release Event
+    \value OkRequest  Internal event used by Qt on some platforms.
+    \value HelpRequest  Internal event used by Qt on some platforms.
+    \value IconDrag     Internal event used by Qt on some platforms when proxy icon is dragged.
+    \value WindowStateChange The window's state, i.e. minimized,
+    maximized or full-screen, has changed. See \l{QWidget::windowState()}.
+    \value WindowBlocked The window is modally blocked
+    \value WindowUnblocked The window leaves modal blocking
+
+    \value User  User defined event.
+    \value MaxUser  Last user event id.
+
+    User events should have values between User and MaxUser inclusive.
+*/
+/*!
+    \fn QEvent::QEvent( Type type )
+
+    Contructs an event object of type \a type.
+*/
+
+/*!
+    \fn QEvent::Type QEvent::type() const
+
+    Returns the event type.
+*/
+
+/*!
+    \fn bool QEvent::spontaneous() const
+
+    Returns TRUE if the event originated outside the application, i.e.
+    it is a system event; otherwise returns FALSE.
+*/
+
+
+/*!
+    \class QTimerEvent qevent.h
+    \brief The QTimerEvent class contains parameters that describe a
+    timer event.
+
+    \ingroup events
+
+    Timer events are sent at regular intervals to objects that have
+    started one or more timers. Each timer has a unique identifier. A
+    timer is started with QObject::startTimer().
+
+    The QTimer class provides a high-level programming interface that
+    uses signals instead of events. It also provides one-shot timers.
+
+    The event handler QObject::timerEvent() receives timer events.
+
+    \sa QTimer, QObject::timerEvent(), QObject::startTimer(),
+    QObject::killTimer(), QObject::killTimers()
+*/
+
+/*!
+    \fn QTimerEvent::QTimerEvent( int timerId )
+
+    Constructs a timer event object with the timer identifier set to
+    \a timerId.
+*/
+
+/*!
+    \fn int QTimerEvent::timerId() const
+
+    Returns the unique timer identifier, which is the same identifier
+    as returned from QObject::startTimer().
+*/
+
+
+/*!
+    \class QMouseEvent qevent.h
+    \ingroup events
+
+    \brief The QMouseEvent class contains parameters that describe a mouse event.
+
+    Mouse events occur when a mouse button is pressed or released
+    inside a widget or when the mouse cursor is moved.
+
+    Mouse move events will occur only when a mouse button is pressed
+    down, unless mouse tracking has been enabled with
+    QWidget::setMouseTracking().
+
+    Qt automatically grabs the mouse when a mouse button is pressed
+    inside a widget; the widget will continue to receive mouse events
+    until the last mouse button is released.
+
+    A mouse event contains a special accept flag that indicates
+    whether the receiver wants the event. You should call
+    QMouseEvent::ignore() if the mouse event is not handled by your
+    widget. A mouse event is propagated up the parent widget chain
+    until a widget accepts it with QMouseEvent::accept() or an event
+    filter consumes it.
+
+    The functions pos(), x() and y() give the cursor position relative
+    to the widget that receives the mouse event. If you move the
+    widget as a result of the mouse event, use the global position
+    returned by globalPos() to avoid a shaking motion.
+
+    The QWidget::setEnabled() function can be used to enable or
+    disable mouse and keyboard events for a widget.
+
+    The event handlers QWidget::mousePressEvent(),
+    QWidget::mouseReleaseEvent(), QWidget::mouseDoubleClickEvent() and
+    QWidget::mouseMoveEvent() receive mouse events.
+
+    \sa QWidget::setMouseTracking(), QWidget::grabMouse(),
+    QCursor::pos()
+*/
+
+/*!
+    \fn QMouseEvent::QMouseEvent( Type type, const QPoint &pos, int button, int state )
+
+    Constructs a mouse event object.
+
+    The \a type parameter must be one of \c QEvent::MouseButtonPress,
+    \c QEvent::MouseButtonRelease, \c QEvent::MouseButtonDblClick or
+    \c QEvent::MouseMove.
+
+    The \a pos parameter specifies the position relative to the
+    receiving widget. \a button specifies the \link Qt::ButtonState
+    button\endlink that caused the event, which should be \c
+    Qt::NoButton (0), if \a type is \c MouseMove. \a state is the
+    \link Qt::ButtonState ButtonState\endlink at the time of the
+    event.
+
+    The globalPos() is initialized to QCursor::pos(), which may not be
+    appropriate. Use the other constructor to specify the global
+    position explicitly.
+*/
+
+QMouseEvent::QMouseEvent( Type type, const QPoint &pos, int button, int state )
+    : QEvent(type), p(pos), b(button),s((ushort)state), accpt(TRUE){
+	g = QCursor::pos();
+}
+
+
+/*!
+    \fn QMouseEvent::QMouseEvent( Type type, const QPoint &pos, const QPoint &globalPos,  int button, int state )
+
+    Constructs a mouse event object.
+
+    The \a type parameter must be \c QEvent::MouseButtonPress, \c
+    QEvent::MouseButtonRelease, \c QEvent::MouseButtonDblClick or \c
+    QEvent::MouseMove.
+
+    The \a pos parameter specifies the position relative to the
+    receiving widget. \a globalPos is the position in absolute
+    coordinates. \a button specifies the \link Qt::ButtonState
+    button\endlink that caused the event, which should be \c
+    Qt::NoButton (0), if \a type is \c MouseMove. \a state is the
+    \link Qt::ButtonState ButtonState\endlink at the time of the
+    event.
+
+*/
+
+/*!
+    \fn const QPoint &QMouseEvent::pos() const
+
+    Returns the position of the mouse pointer relative to the widget
+    that received the event.
+
+    If you move the widget as a result of the mouse event, use the
+    global position returned by globalPos() to avoid a shaking motion.
+
+    \sa x(), y(), globalPos()
+*/
+
+/*!
+    \fn const QPoint &QMouseEvent::globalPos() const
+
+    Returns the global position of the mouse pointer \e{at the time
+    of the event}. This is important on asynchronous window systems
+    like X11. Whenever you move your widgets around in response to
+    mouse events, globalPos() may differ a lot from the current
+    pointer position QCursor::pos(), and from QWidget::mapToGlobal(
+    pos() ).
+
+    \sa globalX(), globalY()
+*/
+
+/*!
+    \fn int QMouseEvent::x() const
+
+    Returns the x-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa y(), pos()
+*/
+
+/*!
+    \fn int QMouseEvent::y() const
+
+    Returns the y-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa x(), pos()
+*/
+
+/*!
+    \fn int QMouseEvent::globalX() const
+
+    Returns the global x-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalY(), globalPos()
+*/
+
+/*!
+    \fn int QMouseEvent::globalY() const
+
+    Returns the global y-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalX(), globalPos()
+*/
+
+/*!
+    \fn ButtonState QMouseEvent::button() const
+
+    Returns the button that caused the event.
+
+    Possible return values are \c LeftButton, \c RightButton, \c
+    MidButton and \c NoButton.
+
+    Note that the returned value is always \c NoButton for mouse move
+    events.
+
+    \sa state() Qt::ButtonState
+*/
+
+
+/*!
+    \fn ButtonState QMouseEvent::state() const
+
+    Returns the button state (a combination of mouse buttons and
+    keyboard modifiers), i.e. what buttons and keys were being pressed
+    immediately before the event was generated.
+
+    This means that if you have a \c QEvent::MouseButtonPress or a \c
+    QEvent::MouseButtonDblClick state() will \e not include the mouse
+    button that's pressed. But once the mouse button has been
+    released, the \c QEvent::MouseButtonRelease event will have the
+    button() that was pressed.
+
+    This value is mainly interesting for \c QEvent::MouseMove; for the
+    other cases, button() is more useful.
+
+    The returned value is \c LeftButton, \c RightButton, \c MidButton,
+    \c ShiftButton, \c ControlButton and \c AltButton OR'ed together.
+
+    \sa button() stateAfter() Qt::ButtonState
+*/
+
+/*!
+    \fn ButtonState QMouseEvent::stateAfter() const
+
+    Returns the state of buttons after the event.
+
+    \sa state() Qt::ButtonState
+*/
+Qt::ButtonState QMouseEvent::stateAfter() const
+{
+    return Qt::ButtonState(state()^button());
+}
+
+
+
+/*!
+    \fn bool QMouseEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event wants to keep the key;
+    otherwise returns FALSE.
+*/
+
+/*!
+    \fn void QMouseEvent::accept()
+
+    Sets the accept flag of the mouse event object.
+
+    Setting the accept parameter indicates that the receiver of the
+    event wants the mouse event. Unwanted mouse events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa ignore()
+*/
+
+
+/*!
+    \fn void QMouseEvent::ignore()
+
+    Clears the accept flag parameter of the mouse event object.
+
+    Clearing the accept parameter indicates that the event receiver
+    does not want the mouse event. Unwanted mouse events are sent to
+    the parent widget.
+
+    The accept flag is set by default.
+
+    \sa accept()
+*/
+
+
+/*!
+    \class QWheelEvent qevent.h
+    \brief The QWheelEvent class contains parameters that describe a wheel event.
+
+    \ingroup events
+
+    Wheel events are sent to the widget under the mouse, and if that widget
+    does not handle the event they are sent to the focus widget. The rotation
+    distance is provided by delta(). The functions pos() and globalPos() return
+    the mouse pointer location at the time of the event.
+
+    A wheel event contains a special accept flag that indicates
+    whether the receiver wants the event. You should call
+    QWheelEvent::accept() if you handle the wheel event; otherwise it
+    will be sent to the parent widget.
+
+    The QWidget::setEnable() function can be used to enable or disable
+    mouse and keyboard events for a widget.
+
+    The event handler QWidget::wheelEvent() receives wheel events.
+
+    \sa QMouseEvent, QWidget::grabMouse()
+*/
+
+/*!
+    \fn Orientation QWheelEvent::orientation() const
+
+    Returns the wheel's orientation.
+*/
+
+/*!
+    \fn QWheelEvent::QWheelEvent( const QPoint &pos, int delta, int state, Orientation orient = Vertical );
+
+    Constructs a wheel event object.
+
+    The globalPos() is initialized to QCursor::pos(), i.e. \a pos,
+    which is usually (but not always) right. Use the other constructor
+    if you need to specify the global position explicitly. \a delta
+    contains the rotation distance, \a state holds the keyboard
+    modifier flags at the time of the event and \a orient holds the
+    wheel's orientation.
+
+    \sa pos(), delta(), state()
+*/
+#ifndef QT_NO_WHEELEVENT
+QWheelEvent::QWheelEvent( const QPoint &pos, int delta, int state, Orientation orient )
+    : QEvent(Wheel), p(pos), d(delta), s((ushort)state),
+      accpt(TRUE), o(orient)
+{
+    g = QCursor::pos();
+}
+#endif
+/*!
+    \fn QWheelEvent::QWheelEvent( const QPoint &pos, const QPoint& globalPos, int delta, int state, Orientation orient = Vertical  )
+
+    Constructs a wheel event object. The position when the event
+    occurred is given in \a pos and \a globalPos. \a delta contains
+    the rotation distance, \a state holds the keyboard modifier flags
+    at the time of the event and \a orient holds the wheel's
+    orientation.
+
+    \sa pos(), globalPos(), delta(), state()
+*/
+
+/*!
+    \fn int QWheelEvent::delta() const
+
+    Returns the distance that the wheel is rotated expressed in
+    multiples or divisions of the \e{wheel delta}, which is currently
+    defined to be 120. A positive value indicates that the wheel was
+    rotated forwards away from the user; a negative value indicates
+    that the wheel was rotated backwards toward the user.
+
+    The \e{wheel delta} constant was defined to be 120 by wheel mouse
+    vendors to allow building finer-resolution wheels in the future,
+    including perhaps a freely rotating wheel with no notches. The
+    expectation is that such a device would send more messages per
+    rotation but with a smaller value in each message.
+*/
+
+/*!
+    \fn const QPoint &QWheelEvent::pos() const
+
+    Returns the position of the mouse pointer, relative to the widget
+    that received the event.
+
+    If you move your widgets around in response to mouse
+    events, use globalPos() instead of this function.
+
+    \sa x(), y(), globalPos()
+*/
+
+/*!
+    \fn int QWheelEvent::x() const
+
+    Returns the x-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa y(), pos()
+*/
+
+/*!
+    \fn int QWheelEvent::y() const
+
+    Returns the y-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa x(), pos()
+*/
+
+
+/*!
+    \fn const QPoint &QWheelEvent::globalPos() const
+
+    Returns the global position of the mouse pointer \e{at the time
+    of the event}. This is important on asynchronous window systems
+    such as X11; whenever you move your widgets around in response to
+    mouse events, globalPos() can differ a lot from the current
+    pointer position QCursor::pos().
+
+    \sa globalX(), globalY()
+*/
+
+/*!
+    \fn int QWheelEvent::globalX() const
+
+    Returns the global x-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalY(), globalPos()
+*/
+
+/*!
+    \fn int QWheelEvent::globalY() const
+
+    Returns the global y-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalX(), globalPos()
+*/
+
+
+/*!
+    \fn ButtonState QWheelEvent::state() const
+
+    Returns the keyboard modifier flags of the event.
+
+    The returned value is \c ShiftButton, \c ControlButton, and \c
+    AltButton OR'ed together.
+*/
+
+/*!
+    \fn bool QWheelEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event handles the wheel event;
+    otherwise returns FALSE.
+*/
+
+/*!
+    \fn void QWheelEvent::accept()
+
+    Sets the accept flag of the wheel event object.
+
+    Setting the accept parameter indicates that the receiver of the
+    event wants the wheel event. Unwanted wheel events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa ignore()
+*/
+
+/*!
+    \fn void QWheelEvent::ignore()
+
+    Clears the accept flag parameter of the wheel event object.
+
+    Clearing the accept parameter indicates that the event receiver
+    does not want the wheel event. Unwanted wheel events are sent to
+    the parent widget. The accept flag is set by default.
+
+    \sa accept()
+*/
+
+
+/*!
+    \enum Qt::Modifier
+
+    This enum type describes the keyboard modifier keys supported by
+    Qt.
+
+    \value SHIFT the Shift keys provided on all standard keyboards.
+    \value META the Meta keys.
+    \value CTRL the Ctrl keys.
+    \value ALT the normal Alt keys, but not e.g. AltGr.
+    \value MODIFIER_MASK is a mask of Shift, Ctrl, Alt and Meta.
+    \value UNICODE_ACCEL the accelerator is specified as a Unicode code
+    point, not as a Qt Key.
+*/
+
+/*!
+    \class QKeyEvent qevent.h
+    \brief The QKeyEvent class contains describes a key event.
+
+    \ingroup events
+
+    Key events occur when a key is pressed or released when a widget
+    has keyboard input focus.
+
+  A key event contains a special accept flag that indicates whether the
+  receiver wants the key event.  You should call QKeyEvent::ignore() if the
+  key press or release event is not handled by your widget. A key event is
+  propagated up the parent widget chain until a widget accepts it with
+  QKeyEvent::accept() or an event filter consumes it.
+  Key events for multi media keys are ignored by default. You should call
+  QKeyEvent::accept() if your widget handles those events.
+
+    The QWidget::setEnable() function can be used to enable or disable
+    mouse and keyboard events for a widget.
+
+    The event handlers QWidget::keyPressEvent() and
+    QWidget::keyReleaseEvent() receive key events.
+
+    \sa QFocusEvent, QWidget::grabKeyboard()
+*/
+
+/*!
+    \fn QKeyEvent::QKeyEvent( Type type, int key, int ascii, int state,
+			      const QString& text, bool autorep, ushort count )
+
+    Constructs a key event object.
+
+    The \a type parameter must be \c QEvent::KeyPress or \c
+    QEvent::KeyRelease. If \a key is 0 the event is not a result of a
+    known key (e.g. it may be the result of a compose sequence or
+    keyboard macro). \a ascii is the ASCII code of the key that was
+    pressed or released. \a state holds the keyboard modifiers. \a
+    text is the Unicode text that the key generated. If \a autorep is
+    TRUE, isAutoRepeat() will be TRUE. \a count is the number of
+    single keys.
+
+    The accept flag is set to TRUE.
+*/
+
+/*!
+    \fn int QKeyEvent::key() const
+
+    Returns the code of the key that was pressed or released.
+
+    See \l Qt::Key for the list of keyboard codes. These codes are
+    independent of the underlying window system.
+
+    A value of either 0 or Key_unknown means that the event is not
+    the result of a known key (e.g. it may be the result of a compose
+    sequence or a keyboard macro, or due to key event compression).
+
+    \sa QWidget::setKeyCompression()
+*/
+
+/*!
+    \fn int QKeyEvent::ascii() const
+
+    Returns the ASCII code of the key that was pressed or released. We
+    recommend using text() instead.
+
+    \sa text()
+*/
+
+/*!
+    \fn QString QKeyEvent::text() const
+
+    Returns the Unicode text that this key generated. The text returned
+    migth be empty, which is the case when pressing or
+    releasing modifying keys as Shift, Control, Alt and Meta. In these
+    cases key() will contain a valid value.
+
+    \sa QWidget::setKeyCompression()
+*/
+
+/*!
+    \fn ButtonState QKeyEvent::state() const
+
+    Returns the keyboard modifier flags that existed immediately
+    before the event occurred.
+
+    The returned value is \c ShiftButton, \c ControlButton, \c AltButton
+    and \c MetaButton OR'ed together.
+
+    \sa stateAfter()
+*/
+
+/*!
+    \fn ButtonState QKeyEvent::stateAfter() const
+
+    Returns the keyboard modifier flags that existed immediately after
+    the event occurred.
+
+    \warning This function cannot be trusted.
+
+    \sa state()
+*/
+//###### We must check with XGetModifierMapping
+Qt::ButtonState QKeyEvent::stateAfter() const
+{
+    if ( key() == Key_Shift )
+	return Qt::ButtonState(state()^ShiftButton);
+    if ( key() == Key_Control )
+	return Qt::ButtonState(state()^ControlButton);
+    if ( key() == Key_Alt )
+	return Qt::ButtonState(state()^AltButton);
+    if ( key() == Key_Meta )
+	return Qt::ButtonState(state()^MetaButton);
+    return state();
+}
+
+/*!
+    \fn bool QKeyEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event wants to keep the key;
+    otherwise returns FALSE
+*/
+
+/*!
+    \fn void QKeyEvent::accept()
+
+    Sets the accept flag of the key event object.
+
+    Setting the accept parameter indicates that the receiver of the
+    event wants the key event. Unwanted key events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa ignore()
+*/
+
+/*!
+    \fn bool QKeyEvent::isAutoRepeat() const
+
+    Returns TRUE if this event comes from an auto-repeating key and
+    FALSE if it comes from an initial key press.
+
+    Note that if the event is a multiple-key compressed event that is
+    partly due to auto-repeat, this function could return either TRUE
+    or FALSE indeterminately.
+*/
+
+/*!
+    \fn int QKeyEvent::count() const
+
+    Returns the number of single keys for this event. If text() is not
+    empty, this is simply the length of the string.
+
+    \sa QWidget::setKeyCompression()
+*/
+
+/*!
+    \fn void QKeyEvent::ignore()
+
+    Clears the accept flag parameter of the key event object.
+
+    Clearing the accept parameter indicates that the event receiver
+    does not want the key event. Unwanted key events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa accept()
+*/
+
+/*!
+    \enum Qt::Key
+
+    The key names used by Qt.
+
+    \value Key_Escape
+    \value Key_Tab
+    \value Key_Backtab
+    \value Key_Backspace
+    \value Key_Return
+    \value Key_Enter
+    \value Key_Insert
+    \value Key_Delete
+    \value Key_Pause
+    \value Key_Print
+    \value Key_SysReq
+    \value Key_Home
+    \value Key_End
+    \value Key_Left
+    \value Key_Up
+    \value Key_Right
+    \value Key_Down
+    \value Key_Prior
+    \value Key_Next
+    \value Key_Shift
+    \value Key_Control
+    \value Key_Meta
+    \value Key_Alt
+    \value Key_CapsLock
+    \value Key_NumLock
+    \value Key_ScrollLock
+    \value Key_Clear
+    \value Key_F1
+    \value Key_F2
+    \value Key_F3
+    \value Key_F4
+    \value Key_F5
+    \value Key_F6
+    \value Key_F7
+    \value Key_F8
+    \value Key_F9
+    \value Key_F10
+    \value Key_F11
+    \value Key_F12
+    \value Key_F13
+    \value Key_F14
+    \value Key_F15
+    \value Key_F16
+    \value Key_F17
+    \value Key_F18
+    \value Key_F19
+    \value Key_F20
+    \value Key_F21
+    \value Key_F22
+    \value Key_F23
+    \value Key_F24
+    \value Key_F25
+    \value Key_F26
+    \value Key_F27
+    \value Key_F28
+    \value Key_F29
+    \value Key_F30
+    \value Key_F31
+    \value Key_F32
+    \value Key_F33
+    \value Key_F34
+    \value Key_F35
+    \value Key_Super_L
+    \value Key_Super_R
+    \value Key_Menu
+    \value Key_Hyper_L
+    \value Key_Hyper_R
+    \value Key_Help
+    \value Key_Space
+    \value Key_Any
+    \value Key_Exclam
+    \value Key_QuoteDbl
+    \value Key_NumberSign
+    \value Key_Dollar
+    \value Key_Percent
+    \value Key_Ampersand
+    \value Key_Apostrophe
+    \value Key_ParenLeft
+    \value Key_ParenRight
+    \value Key_Asterisk
+    \value Key_Plus
+    \value Key_Comma
+    \value Key_Minus
+    \value Key_Period
+    \value Key_Slash
+    \value Key_0
+    \value Key_1
+    \value Key_2
+    \value Key_3
+    \value Key_4
+    \value Key_5
+    \value Key_6
+    \value Key_7
+    \value Key_8
+    \value Key_9
+    \value Key_Colon
+    \value Key_Semicolon
+    \value Key_Less
+    \value Key_Equal
+    \value Key_Greater
+    \value Key_Question
+    \value Key_At
+    \value Key_A
+    \value Key_B
+    \value Key_C
+    \value Key_D
+    \value Key_E
+    \value Key_F
+    \value Key_G
+    \value Key_H
+    \value Key_I
+    \value Key_J
+    \value Key_K
+    \value Key_L
+    \value Key_M
+    \value Key_N
+    \value Key_O
+    \value Key_P
+    \value Key_Q
+    \value Key_R
+    \value Key_S
+    \value Key_T
+    \value Key_U
+    \value Key_V
+    \value Key_W
+    \value Key_X
+    \value Key_Y
+    \value Key_Z
+    \value Key_BracketLeft
+    \value Key_Backslash
+    \value Key_BracketRight
+    \value Key_AsciiCircum
+    \value Key_Underscore
+    \value Key_QuoteLeft
+    \value Key_BraceLeft
+    \value Key_Bar
+    \value Key_BraceRight
+    \value Key_AsciiTilde
+
+    \value Key_nobreakspace
+    \value Key_exclamdown
+    \value Key_cent
+    \value Key_sterling
+    \value Key_currency
+    \value Key_yen
+    \value Key_brokenbar
+    \value Key_section
+    \value Key_diaeresis
+    \value Key_copyright
+    \value Key_ordfeminine
+    \value Key_guillemotleft
+    \value Key_notsign
+    \value Key_hyphen
+    \value Key_registered
+    \value Key_macron
+    \value Key_degree
+    \value Key_plusminus
+    \value Key_twosuperior
+    \value Key_threesuperior
+    \value Key_acute
+    \value Key_mu
+    \value Key_paragraph
+    \value Key_periodcentered
+    \value Key_cedilla
+    \value Key_onesuperior
+    \value Key_masculine
+    \value Key_guillemotright
+    \value Key_onequarter
+    \value Key_onehalf
+    \value Key_threequarters
+    \value Key_questiondown
+    \value Key_Agrave
+    \value Key_Aacute
+    \value Key_Acircumflex
+    \value Key_Atilde
+    \value Key_Adiaeresis
+    \value Key_Aring
+    \value Key_AE
+    \value Key_Ccedilla
+    \value Key_Egrave
+    \value Key_Eacute
+    \value Key_Ecircumflex
+    \value Key_Ediaeresis
+    \value Key_Igrave
+    \value Key_Iacute
+    \value Key_Icircumflex
+    \value Key_Idiaeresis
+    \value Key_ETH
+    \value Key_Ntilde
+    \value Key_Ograve
+    \value Key_Oacute
+    \value Key_Ocircumflex
+    \value Key_Otilde
+    \value Key_Odiaeresis
+    \value Key_multiply
+    \value Key_Ooblique
+    \value Key_Ugrave
+    \value Key_Uacute
+    \value Key_Ucircumflex
+    \value Key_Udiaeresis
+    \value Key_Yacute
+    \value Key_THORN
+    \value Key_ssharp
+    \value Key_agrave
+    \value Key_aacute
+    \value Key_acircumflex
+    \value Key_atilde
+    \value Key_adiaeresis
+    \value Key_aring
+    \value Key_ae
+    \value Key_ccedilla
+    \value Key_egrave
+    \value Key_eacute
+    \value Key_ecircumflex
+    \value Key_ediaeresis
+    \value Key_igrave
+    \value Key_iacute
+    \value Key_icircumflex
+    \value Key_idiaeresis
+    \value Key_eth
+    \value Key_ntilde
+    \value Key_ograve
+    \value Key_oacute
+    \value Key_ocircumflex
+    \value Key_otilde
+    \value Key_odiaeresis
+    \value Key_division
+    \value Key_oslash
+    \value Key_ugrave
+    \value Key_uacute
+    \value Key_ucircumflex
+    \value Key_udiaeresis
+    \value Key_yacute
+    \value Key_thorn
+    \value Key_ydiaeresis
+
+    Multimedia keys
+
+    \value Key_Back
+    \value Key_Forward
+    \value Key_Stop
+    \value Key_Refresh
+
+    \value Key_VolumeDown
+    \value Key_VolumeMute
+    \value Key_VolumeUp
+    \value Key_BassBoost
+    \value Key_BassUp
+    \value Key_BassDown
+    \value Key_TrebleUp
+    \value Key_TrebleDown
+
+    \value Key_MediaPlay
+    \value Key_MediaStop
+    \value Key_MediaPrev
+    \value Key_MediaNext
+    \value Key_MediaRecord
+
+    \value Key_HomePage
+    \value Key_Favorites
+    \value Key_Search
+    \value Key_Standby
+    \value Key_OpenUrl
+
+    \value Key_LaunchMail
+    \value Key_LaunchMedia
+    \value Key_Launch0
+    \value Key_Launch1
+    \value Key_Launch2
+    \value Key_Launch3
+    \value Key_Launch4
+    \value Key_Launch5
+    \value Key_Launch6
+    \value Key_Launch7
+    \value Key_Launch8
+    \value Key_Launch9
+    \value Key_LaunchA
+    \value Key_LaunchB
+    \value Key_LaunchC
+    \value Key_LaunchD
+    \value Key_LaunchE
+    \value Key_LaunchF
+
+    \value Key_MediaLast
+
+    \value Key_unknown
+
+    \value Key_Direction_L internal use only
+    \value Key_Direction_R internal use only
+
+*/
+
+
+/*!
+    \class QFocusEvent qevent.h
+    \brief The QFocusEvent class contains event parameters for widget focus
+    events.
+
+    \ingroup events
+
+    Focus events are sent to widgets when the keyboard input focus
+    changes. Focus events occur due to mouse actions, keypresses (e.g.
+    Tab or Backtab), the window system, popup menus, keyboard
+    shortcuts or other application specific reasons. The reason for a
+    particular focus event is returned by reason() in the appropriate
+    event handler.
+
+    The event handlers QWidget::focusInEvent() and
+    QWidget::focusOutEvent() receive focus events.
+
+    Use setReason() to set the reason for all focus events, and
+    resetReason() to set the reason for all focus events to the reason
+    in force before the last setReason() call.
+
+    \sa QWidget::setFocus(), QWidget::setFocusPolicy()
+*/
+
+/*!
+    \fn QFocusEvent::QFocusEvent( Type type )
+
+    Constructs a focus event object.
+
+    The \a type parameter must be either \c QEvent::FocusIn or \c
+    QEvent::FocusOut.
+*/
+
+
+
+QFocusEvent::Reason QFocusEvent::m_reason = QFocusEvent::Other;
+QFocusEvent::Reason QFocusEvent::prev_reason = QFocusEvent::Other;
+
+
+/*!
+    \enum QFocusEvent::Reason
+
+    This enum specifies why the focus changed.
+
+    \value Mouse  because of a mouse action.
+    \value Tab  because of a Tab press.
+    \value Backtab  because of a Backtab press
+	    (possibly including Shift/Control, e.g. Shift+Tab).
+    \value ActiveWindow  because the window system made this window (in)active.
+    \value Popup  because the application opened/closed a popup that grabbed/released focus.
+    \value Shortcut  because of a keyboard shortcut.
+    \value Other  any other reason, usually application-specific.
+
+    See the \link focus.html keyboard focus overview\endlink for more
+    about focus.
+*/
+
+/*!
+    Returns the reason for this focus event.
+
+    \sa setReason()
+ */
+QFocusEvent::Reason QFocusEvent::reason()
+{
+    return m_reason;
+}
+
+/*!
+    Sets the reason for all future focus events to \a reason.
+
+    \sa reason(), resetReason()
+ */
+void QFocusEvent::setReason( Reason reason )
+{
+    prev_reason = m_reason;
+    m_reason = reason;
+}
+
+/*!
+    Resets the reason for all future focus events to the value before
+    the last setReason() call.
+
+    \sa reason(), setReason()
+ */
+void QFocusEvent::resetReason()
+{
+    m_reason = prev_reason;
+}
+
+/*!
+    \fn bool QFocusEvent::gotFocus() const
+
+    Returns TRUE if the widget received the text input focus;
+    otherwise returns FALSE.
+*/
+
+/*!
+    \fn bool QFocusEvent::lostFocus() const
+
+    Returns TRUE if the widget lost the text input focus; otherwise
+    returns FALSE.
+*/
+
+
+/*!
+    \class QPaintEvent qevent.h
+    \brief The QPaintEvent class contains event parameters for paint events.
+
+    \ingroup events
+
+    Paint events are sent to widgets that need to update themselves,
+    for instance when part of a widget is exposed because a covering
+    widget is moved.
+
+    The event contains a region() that needs to be updated, and a
+    rect() that is the bounding rectangle of that region. Both are
+    provided because many widgets can't make much use of region(), and
+    rect() can be much faster than region().boundingRect(). Painting
+    is clipped to region() during processing of a paint event.
+
+    The erased() function returns TRUE if the region() has been
+    cleared to the widget's background (see
+    QWidget::backgroundMode()), and FALSE if the region's contents are
+    arbitrary.
+
+    \sa QPainter QWidget::update() QWidget::repaint()
+    QWidget::paintEvent() QWidget::backgroundMode() QRegion
+*/
+
+/*!
+    \fn QPaintEvent::QPaintEvent( const QRegion &paintRegion, bool erased=TRUE )
+
+    Constructs a paint event object with the region that should be
+    updated. The region is given by \a paintRegion. If \a erased is
+    TRUE the region will be cleared before repainting.
+*/
+
+/*!
+    \fn QPaintEvent::QPaintEvent( const QRect &paintRect, bool erased=TRUE )
+
+    Constructs a paint event object with the rectangle that should be
+    updated. The region is also given by \a paintRect. If \a erased is
+    TRUE the region will be cleared before repainting.
+*/
+
+/*!
+    \fn QPaintEvent::QPaintEvent( const QRegion &paintRegion, const QRect &paintRect, bool erased=TRUE )
+
+    Constructs a paint event object with the rectangle \a paintRect
+    that should be updated. The region is given by \a paintRegion. If
+    \a erased is TRUE the region will be cleared before repainting.
+*/
+
+/*!
+    \fn const QRect &QPaintEvent::rect() const
+
+    Returns the rectangle that should be updated.
+
+    \sa region(), QPainter::setClipRect()
+*/
+
+/*!
+    \fn const QRegion &QPaintEvent::region() const
+
+    Returns the region that should be updated.
+
+    \sa rect(), QPainter::setClipRegion()
+*/
+
+/*!
+    \fn bool QPaintEvent::erased() const
+
+    Returns TRUE if the paint event region (or rectangle) has been
+    erased with the widget's background; otherwise returns FALSE.
+*/
+
+/*!
+    \class QMoveEvent qevent.h
+    \brief The QMoveEvent class contains event parameters for move events.
+
+    \ingroup events
+
+    Move events are sent to widgets that have been moved to a new position
+    relative to their parent.
+
+    The event handler QWidget::moveEvent() receives move events.
+
+    \sa QWidget::move(), QWidget::setGeometry()
+*/
+
+/*!
+    \fn QMoveEvent::QMoveEvent( const QPoint &pos, const QPoint &oldPos )
+
+    Constructs a move event with the new and old widget positions, \a
+    pos and \a oldPos respectively.
+*/
+
+/*!
+    \fn const QPoint &QMoveEvent::pos() const
+
+    Returns the new position of the widget. This excludes the window
+    frame for top level widgets.
+*/
+
+/*!
+    \fn const QPoint &QMoveEvent::oldPos() const
+
+    Returns the old position of the widget.
+*/
+
+
+/*!
+    \class QResizeEvent qevent.h
+    \brief The QResizeEvent class contains event parameters for resize events.
+
+    \ingroup events
+
+    Resize events are sent to widgets that have been resized.
+
+    The event handler QWidget::resizeEvent() receives resize events.
+
+    \sa QWidget::resize(), QWidget::setGeometry()
+*/
+
+/*!
+    \fn QResizeEvent::QResizeEvent( const QSize &size, const QSize &oldSize )
+
+    Constructs a resize event with the new and old widget sizes, \a
+    size and \a oldSize respectively.
+*/
+
+/*!
+    \fn const QSize &QResizeEvent::size() const
+
+    Returns the new size of the widget, which is the same as
+    QWidget::size().
+*/
+
+/*!
+    \fn const QSize &QResizeEvent::oldSize() const
+
+    Returns the old size of the widget.
+*/
+
+
+/*!
+    \class QCloseEvent qevent.h
+    \brief The QCloseEvent class contains parameters that describe a close event.
+
+    \ingroup events
+
+    Close events are sent to widgets that the user wants to close,
+    usually by choosing "Close" from the window menu, or by clicking
+    the `X' titlebar button. They are also sent when you call
+    QWidget::close() to close a widget programmatically.
+
+    Close events contain a flag that indicates whether the receiver
+    wants the widget to be closed or not. When a widget accepts the
+    close event, it is hidden (and destroyed if it was created with
+    the \c WDestructiveClose flag). If it refuses to accept the close
+    event nothing happens. (Under X11 it is possible that the window
+    manager will forcibly close the window; but at the time of writing
+    we are not aware of any window manager that does this.)
+
+    The application's main widget -- QApplication::mainWidget() --
+    is a special case. When it accepts the close event, Qt leaves the
+    main event loop and the application is immediately terminated
+    (i.e. it returns from the call to QApplication::exec() in the
+    main() function).
+
+    The event handler QWidget::closeEvent() receives close events. The
+    default implementation of this event handler accepts the close
+    event. If you do not want your widget to be hidden, or want some
+    special handing, you should reimplement the event handler.
+
+    The \link simple-application.html#closeEvent closeEvent() in the
+    Application Walkthrough\endlink shows a close event handler that
+    asks whether to save a document before closing.
+
+    If you want the widget to be deleted when it is closed, create it
+    with the \c WDestructiveClose widget flag. This is very useful for
+    independent top-level windows in a multi-window application.
+
+    \l{QObject}s emits the \link QObject::destroyed()
+    destroyed()\endlink signal when they are deleted.
+
+    If the last top-level window is closed, the
+    QApplication::lastWindowClosed() signal is emitted.
+
+    The isAccepted() function returns TRUE if the event's receiver has
+    agreed to close the widget; call accept() to agree to close the
+    widget and call ignore() if the receiver of this event does not
+    want the widget to be closed.
+
+    \sa QWidget::close(), QWidget::hide(), QObject::destroyed(),
+    QApplication::setMainWidget(), QApplication::lastWindowClosed(),
+    QApplication::exec(), QApplication::quit()
+*/
+
+/*!
+    \fn QCloseEvent::QCloseEvent()
+
+    Constructs a close event object with the accept parameter flag set
+    to FALSE.
+
+    \sa accept()
+*/
+
+/*!
+    \fn bool QCloseEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event has agreed to close the
+    widget; otherwise returns FALSE.
+
+    \sa accept(), ignore()
+*/
+
+/*!
+    \fn void QCloseEvent::accept()
+
+    Sets the accept flag of the close event object.
+
+    Setting the accept flag indicates that the receiver of this event
+    agrees to close the widget.
+
+    The accept flag is \e not set by default.
+
+    If you choose to accept in QWidget::closeEvent(), the widget will
+    be hidden. If the widget's \c WDestructiveClose flag is set, it
+    will also be destroyed.
+
+    \sa ignore(), QWidget::hide()
+*/
+
+/*!
+    \fn void QCloseEvent::ignore()
+
+    Clears the accept flag of the close event object.
+
+    Clearing the accept flag indicates that the receiver of this event
+    does not want the widget to be closed.
+
+    The close event is constructed with the accept flag cleared.
+
+    \sa accept()
+*/
+
+/*!
+   \class QIconDragEvent qevent.h
+   \brief The QIconDragEvent class signals that a main icon drag has begun.
+
+    \ingroup events
+
+    Icon drag events are sent to widgets when the main icon of a window has been dragged away.
+    On Mac OS X this is fired when the proxy icon of a window is dragged off titlebar, in response to
+    this event is is normal to begin using drag and drop.
+*/
+
+/*!
+    \fn QIconDragEvent::QIconDragEvent()
+
+    Constructs an icon drag event object with the accept parameter
+    flag set to FALSE.
+
+    \sa accept()
+*/
+
+/*!
+    \fn bool QIconDragEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event has started a drag and
+    drop operation; otherwise returns FALSE.
+
+    \sa accept(), ignore()
+*/
+
+/*!
+    \fn void QIconDragEvent::accept()
+
+    Sets the accept flag of the icon drag event object.
+
+    Setting the accept flag indicates that the receiver of this event
+    has started a drag and drop oeration.
+
+    The accept flag is \e not set by default.
+
+    \sa ignore(), QWidget::hide()
+*/
+
+/*!
+    \fn void QIconDragEvent::ignore()
+
+    Clears the accept flag of the icon drag object.
+
+    Clearing the accept flag indicates that the receiver of this event
+    has not handled the icon drag as a result other events can be sent.
+
+    The icon drag event is constructed with the accept flag cleared.
+
+    \sa accept()
+*/
+
+/*!
+    \class QContextMenuEvent qevent.h
+    \brief The QContextMenuEvent class contains parameters that describe a context menu event.
+
+    \ingroup events
+
+    Context menu events are sent to widgets when a user triggers a
+    context menu. What triggers this is platform dependent. For
+    example, on Windows, pressing the menu button or releasing the
+    right mouse button will cause this event to be sent.
+
+    When this event occurs it is customary to show a QPopupMenu with a
+    context menu, if this is relevant to the context.
+
+    Context menu events contain a special accept flag that indicates
+    whether the receiver accepted the event. If the event handler does
+    not accept the event, then whatever triggered the event will be
+    handled as a regular input event if possible.
+
+    \sa QPopupMenu
+*/
+
+/*!
+    \fn QContextMenuEvent::QContextMenuEvent( Reason reason, const QPoint &pos, const QPoint &globalPos, int state )
+
+    Constructs a context menu event object with the accept parameter
+    flag set to FALSE.
+
+    The \a reason parameter must be \c QContextMenuEvent::Mouse or \c
+    QContextMenuEvent::Keyboard.
+
+    The \a pos parameter specifies the mouse position relative to the
+    receiving widget. \a globalPos is the mouse position in absolute
+    coordinates. \a state is the ButtonState at the time of the event.
+*/
+
+
+/*!
+    \fn QContextMenuEvent::QContextMenuEvent( Reason reason, const QPoint &pos, int state )
+
+    Constructs a context menu event object with the accept parameter
+    flag set to FALSE.
+
+    The \a reason parameter must be \c QContextMenuEvent::Mouse or \c
+    QContextMenuEvent::Keyboard.
+
+    The \a pos parameter specifies the mouse position relative to the
+    receiving widget. \a state is the ButtonState at the time of the
+    event.
+
+    The globalPos() is initialized to QCursor::pos(), which may not be
+    appropriate. Use the other constructor to specify the global
+    position explicitly.
+*/
+
+QContextMenuEvent::QContextMenuEvent( Reason reason, const QPoint &pos, int state )
+    : QEvent( ContextMenu ), p( pos ), accpt(TRUE), consum(TRUE),
+    reas( reason ), s((ushort)state)
+{
+    gp = QCursor::pos();
+}
+
+/*!
+    \fn const QPoint &QContextMenuEvent::pos() const
+
+    Returns the position of the mouse pointer relative to the widget
+    that received the event.
+
+    \sa x(), y(), globalPos()
+*/
+
+/*!
+    \fn int QContextMenuEvent::x() const
+
+    Returns the x-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa y(), pos()
+*/
+
+/*!
+    \fn int QContextMenuEvent::y() const
+
+    Returns the y-position of the mouse pointer, relative to the
+    widget that received the event.
+
+    \sa x(), pos()
+*/
+
+/*!
+    \fn const QPoint &QContextMenuEvent::globalPos() const
+
+    Returns the global position of the mouse pointer at the time of
+    the event.
+
+    \sa x(), y(), pos()
+*/
+
+/*!
+    \fn int QContextMenuEvent::globalX() const
+
+    Returns the global x-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalY(), globalPos()
+*/
+
+/*!
+    \fn int QContextMenuEvent::globalY() const
+
+    Returns the global y-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalX(), globalPos()
+*/
+
+/*!
+    \fn ButtonState QContextMenuEvent::state() const
+
+    Returns the button state (a combination of mouse buttons and
+    keyboard modifiers), i.e. what buttons and keys were being
+    pressed immediately before the event was generated.
+
+    The returned value is \c LeftButton, \c RightButton, \c MidButton,
+    \c ShiftButton, \c ControlButton and \c AltButton OR'ed together.
+*/
+
+/*!
+    \fn bool QContextMenuEvent::isConsumed() const
+
+    Returns TRUE (which stops propagation of the event) if the
+    receiver has blocked the event; otherwise returns FALSE.
+
+    \sa accept(), ignore(), consume()
+*/
+
+/*!
+    \fn void QContextMenuEvent::consume()
+
+    Sets the consume flag of the context event object.
+
+    Setting the consume flag indicates that the receiver of this event
+    does not want the event to be propagated further (i.e. not sent to
+    parent classes.)
+
+    The consumed flag is not set by default.
+
+    \sa ignore() accept()
+*/
+
+/*!
+    \fn bool QContextMenuEvent::isAccepted() const
+
+    Returns TRUE if the receiver has processed the event; otherwise
+    returns FALSE.
+
+    \sa accept(), ignore(), consume()
+*/
+
+/*!
+    \fn void QContextMenuEvent::accept()
+
+    Sets the accept flag of the context event object.
+
+    Setting the accept flag indicates that the receiver of this event
+    has processed the event. Processing the event means you did
+    something with it and it will be implicitly consumed.
+
+    The accept flag is not set by default.
+
+    \sa ignore() consume()
+*/
+
+/*!
+    \fn void QContextMenuEvent::ignore()
+
+    Clears the accept flag of the context event object.
+
+    Clearing the accept flag indicates that the receiver of this event
+    does not need to show a context menu. This will implicitly remove
+    the consumed flag as well.
+
+    The accept flag is not set by default.
+
+    \sa accept() consume()
+*/
+
+/*!
+    \enum QContextMenuEvent::Reason
+
+    This enum describes the reason the ContextMenuEvent was sent. The
+    values are:
+
+    \value Mouse The mouse caused the event to be sent. Normally this
+    means the right mouse button was clicked, but this is platform
+    specific.
+
+    \value Keyboard The keyboard caused this event to be sent. On
+    Windows this means the menu button was pressed.
+
+    \value Other The event was sent by some other means (i.e. not by
+    the mouse or keyboard).
+*/
+
+
+/*!
+    \fn QContextMenuEvent::Reason QContextMenuEvent::reason() const
+
+    Returns the reason for this context event.
+*/
+
+
+/*!
+    \class QIMEvent qevent.h
+    \brief The QIMEvent class provides parameters for input method events.
+
+    \ingroup events
+
+    Input method events are sent to widgets when an input method is
+    used to enter text into a widget. Input methods are widely used to
+    enter text in Asian and other complex languages.
+
+    The events are of interest to widgets that accept keyboard input
+    and want to be able to correctly handle complex languages. Text
+    input in such languages is usually a three step process.
+
+    \list 1
+    \i <b>Starting to Compose</b><br>
+    When the user presses the first key on a keyboard an input context
+    is created. This input context will contain a string with the
+    typed characters.
+
+    \i <b>Composing</b><br>
+    With every new key pressed, the input method will try to create a
+    matching string for the text typed so far. While the input context
+    is active, the user can only move the cursor inside the string
+    belonging to this input context.
+
+    \i <b>Completing</b><br>
+    At some point, e.g. when the user presses the Spacebar, they get
+    to this stage, where they can choose from a number of strings that
+    match the text they have typed so far. The user can press Enter to
+    confirm their choice or Escape to cancel the input; in either case
+    the input context will be closed.
+    \endlist
+
+    Note that the particular key presses used for a given input
+    context may differ from those we've mentioned here, i.e. they may
+    not be Spacebar, Enter and Escape.
+
+    These three stages are represented by three different types of
+    events. The IMStartEvent, IMComposeEvent and IMEndEvent. When a
+    new input context is created, an IMStartEvent will be sent to the
+    widget and delivered to the \l QWidget::imStartEvent() function.
+    The widget can then update internal data structures to reflect
+    this.
+
+    After this, an IMComposeEvent will be sent to the widget for
+    every key the user presses. It will contain the current
+    composition string the widget has to show and the current cursor
+    position within the composition string. This string is temporary
+    and can change with every key the user types, so the widget will
+    need to store the state before the composition started (the state
+    it had when it received the IMStartEvent). IMComposeEvents will be
+    delivered to the \l QWidget::imComposeEvent() function.
+
+    Usually, widgets try to mark the part of the text that is part of
+    the current composition in a way that is visible to the user. A
+    commonly used visual cue is to use a dotted underline.
+
+    After the user has selected the final string, an IMEndEvent will
+    be sent to the widget. The event contains the final string the
+    user selected, and could be empty if they canceled the
+    composition. This string should be accepted as the final text the
+    user entered, and the intermediate composition string should be
+    cleared. These events are delivered to \l QWidget::imEndEvent().
+
+    If the user clicks another widget, taking the focus out of the
+    widget where the composition is taking place the IMEndEvent will
+    be sent and the string it holds will be the result of the
+    composition up to that point (which may be an empty string).
+*/
+
+/*!
+    \fn  QIMEvent::QIMEvent( Type type, const QString &text, int cursorPosition )
+
+    Constructs a new QIMEvent with the accept flag set to FALSE. \a
+    type can be one of QEvent::IMStartEvent, QEvent::IMComposeEvent
+    or QEvent::IMEndEvent. \a text contains the current compostion
+    string and \a cursorPosition the current position of the cursor
+    inside \a text.
+*/
+
+/*!
+    \fn const QString &QIMEvent::text() const
+
+    Returns the composition text. This is a null string for an
+    IMStartEvent, and contains the final accepted string (which may be
+    empty) in the IMEndEvent.
+*/
+
+/*!
+    \fn int QIMEvent::cursorPos() const
+
+    Returns the current cursor position inside the composition string.
+    Will return -1 for IMStartEvent and IMEndEvent.
+*/
+
+/*!
+    \fn int QIMEvent::selectionLength() const
+
+    Returns the number of characters in the composition string (
+    starting at cursorPos() ) that should be marked as selected by the
+    input widget receiving the event.
+    Will return 0 for IMStartEvent and IMEndEvent.
+*/
+
+/*!
+    \fn bool QIMEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event processed the event;
+    otherwise returns FALSE.
+*/
+
+/*!
+    \fn void QIMEvent::accept()
+
+    Sets the accept flag of the input method event object.
+
+    Setting the accept parameter indicates that the receiver of the
+    event processed the input method event.
+
+    The accept flag is not set by default.
+
+    \sa ignore()
+*/
+
+
+/*!
+    \fn void QIMEvent::ignore()
+
+    Clears the accept flag parameter of the input method event object.
+
+    Clearing the accept parameter indicates that the event receiver
+    does not want the input method event.
+
+    The accept flag is cleared by default.
+
+    \sa accept()
+*/
+
+/*!
+    \class QTabletEvent qevent.h
+    \brief The QTabletEvent class contains parameters that describe a Tablet
+    event.
+
+    \ingroup events
+
+    Tablet Events are generated from a Wacom&copy; tablet. Most of
+    the time you will want to deal with events from the tablet as if
+    they were events from a mouse, for example retrieving the position
+    with x(), y(), pos(), globalX(), globalY() and globalPos(). In
+    some situations you may wish to retrieve the extra information
+    provided by the tablet device driver, for example, you might want
+    to adjust color brightness based on pressure. QTabletEvent allows
+    you to get the pressure(), the xTilt() and yTilt(), as well as the
+    type of device being used with device() (see \l{TabletDevice}).
+
+    A tablet event contains a special accept flag that indicates
+    whether the receiver wants the event. You should call
+    QTabletEvent::accept() if you handle the tablet event; otherwise
+    it will be sent to the parent widget.
+
+    The QWidget::setEnabled() function can be used to enable or
+    disable mouse and keyboard events for a widget.
+
+  The event handler QWidget::tabletEvent() receives all three types of tablet
+  events.  Qt will first send a tabletEvent and then, if it is not accepted,
+  it will send a mouse event.  This allows applications that don't utilize
+  tablets to use a tablet like a mouse while also enabling those who want to
+  use both tablets and mouses differently.
+
+*/
+
+/*!
+    \enum QTabletEvent::TabletDevice
+
+    This enum defines what type of device is generating the event.
+
+    \value NoDevice    No device, or an unknown device.
+    \value Puck    A Puck (a device that is similar to a flat mouse with
+    a transparent circle with cross-hairs).
+    \value Stylus  A Stylus (the narrow end of the pen).
+    \value Eraser  An Eraser (the broad end of the pen).
+    \omit
+    \value Menu  A menu button was pressed (currently unimplemented).
+*/
+
+/*!
+  \fn QTabletEvent::QTabletEvent( Type t, const QPoint &pos,
+                                  const QPoint &globalPos, int device,
+                                  int pressure, int xTilt, int yTilt,
+				  const QPair<int,int> &uId )
+  Construct a tablet event of type \a t.  The position of when the event occurred is given
+  int \a pos and \a globalPos.  \a device contains the \link TabletDevice device type\endlink,
+  \a pressure contains the pressure exerted on the \a device, \a xTilt and \a yTilt contain
+  \a device's degree of tilt from the X and Y axis respectively.  The \a uId contains an
+  event id.
+
+  On Irix, \a globalPos will contain the high-resolution coordinates received from the
+  tablet device driver, instead of from the windowing system.
+
+  \sa pos(), globalPos(), device(), pressure(), xTilt(), yTilt()
+*/
+
+QTabletEvent::QTabletEvent( Type t, const QPoint &pos, const QPoint &globalPos, int device,
+			    int pressure, int xTilt, int yTilt,
+			    const QPair<int, int> &uId )
+    : QEvent( t ),
+      mPos( pos ),
+      mGPos( globalPos ),
+      mDev( device ),
+      mPress( pressure ),
+      mXT( xTilt ),
+      mYT( yTilt ),
+      mType( uId.first ),
+      mPhy( uId.second ),
+      mbAcc(TRUE)
+{}
+
+/*!
+  \obsolete
+  \fn QTabletEvent::QTabletEvent( const QPoint &pos, const QPoint &globalPos, int device, int pressure, int xTilt, int yTilt, const QPair<int,int> &uId )
+
+    Constructs a tablet event object. The position when the event
+    occurred is is given in \a pos and \a globalPos. \a device
+    contains the \link TabletDevice device type\endlink, \a pressure
+    contains the pressure exerted on the \a device, \a xTilt and \a
+    yTilt contain the \a device's degrees of tilt from the X and Y
+    axis respectively. The \a uId contains an event id.
+
+    On Irix, \a globalPos will contain the high-resolution coordinates
+    received from the tablet device driver, instead of from the
+    windowing system.
+
+  \sa pos(), globalPos(), device(), pressure(), xTilt(), yTilt()
+*/
+
+/*!
+    \fn TabletDevices QTabletEvent::device() const
+
+    Returns the type of device that generated the event. Useful if you
+    want one end of the pen to do something different than the other.
+
+    \sa TabletDevice
+*/
+
+/*!
+    \fn int QTabletEvent::pressure() const
+
+    Returns the pressure that is exerted on the device. This number is
+    a value from 0 (no pressure) to 255 (maximum pressure). The
+    pressure is always scaled to be within this range no matter how
+    many pressure levels the underlying hardware supports.
+*/
+
+/*!
+    \fn int QTabletEvent::xTilt() const
+
+    Returns the difference from the perpendicular in the X Axis.
+    Positive values are towards the tablet's physical right. The angle
+    is in the range -60 to +60 degrees.
+
+    \sa yTilt()
+*/
+
+/*!
+    \fn int QTabletEvent::yTilt() const
+
+    Returns the difference from the perpendicular in the Y Axis.
+    Positive values are towards the bottom of the tablet. The angle is
+    within the range -60 to +60 degrees.
+
+    \sa xTilt()
+*/
+
+/*!
+    \fn const QPoint &QTabletEvent::pos() const
+
+    Returns the position of the device, relative to the widget that
+    received the event.
+
+    If you move widgets around in response to mouse events, use
+    globalPos() instead of this function.
+
+    \sa x(), y(), globalPos()
+*/
+
+/*!
+    \fn int QTabletEvent::x() const
+
+    Returns the x-position of the device, relative to the widget that
+    received the event.
+
+    \sa y(), pos()
+*/
+
+/*!
+    \fn int QTabletEvent::y() const
+
+    Returns the y-position of the device, relative to the widget that
+    received the event.
+
+    \sa x(), pos()
+*/
+
+/*!
+    \fn const QPoint &QTabletEvent::globalPos() const
+
+    Returns the global position of the device \e{at the time of the
+    event}. This is important on asynchronous windows systems like X11;
+    whenever you move your widgets around in response to mouse events,
+    globalPos() can differ significantly from the current position
+    QCursor::pos().
+
+    \sa globalX(), globalY()
+*/
+
+/*!
+    \fn int QTabletEvent::globalX() const
+
+    Returns the global x-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalY(), globalPos()
+*/
+
+/*!
+    \fn int QTabletEvent::globalY() const
+
+    Returns the global y-position of the mouse pointer at the time of
+    the event.
+
+    \sa globalX(), globalPos()
+*/
+
+/*!
+    \fn bool QTabletEvent::isAccepted() const
+
+    Returns TRUE if the receiver of the event handles the tablet
+    event; otherwise returns FALSE.
+*/
+
+/*!
+    \fn void QTabletEvent::accept()
+
+    Sets the accept flag of the tablet event object.
+
+    Setting the accept flag indicates that the receiver of the event
+    wants the tablet event. Unwanted tablet events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa ignore()
+*/
+
+/*!
+    \fn void QTabletEvent::ignore()
+
+    Clears the accept flag parameter of the tablet event object.
+
+    Clearing the accept flag indicates that the event receiver does
+    not want the tablet event. Unwanted tablet events are sent to the
+    parent widget.
+
+    The accept flag is set by default.
+
+    \sa accept()
+*/
+
+/*!
+    \fn QPair<int, int> QTabletEvent::uniqueId()
+
+    Returns a unique ID for the current device. It is possible to
+    generate a unique ID for any Wacom&copy; device. This makes it
+    possible to differentiate between multiple devices being used at
+    the same time on the tablet. The \c first member contains a value
+    for the type, the \c second member contains a physical ID obtained
+    from the device. Each combination of these values is unique. Note:
+    for different platforms, the \c first value is different due to
+    different driver implementations.
+*/
+
+/*!
+    \class QChildEvent qevent.h
+    \brief The QChildEvent class contains event parameters for child object
+    events.
+
+    \ingroup events
+
+    Child events are sent to objects when children are inserted or
+    removed.
+
+    A \c ChildRemoved event is sent immediately, but a \c
+    ChildInserted event is \e posted (with QApplication::postEvent()).
+
+    Note that if a child is removed immediately after it is inserted,
+    the \c ChildInserted event may be suppressed, but the \c
+    ChildRemoved event will always be sent. In this case there will be
+    a \c ChildRemoved event without a corresponding \c ChildInserted
+    event.
+
+    The handler for these events is QObject::childEvent().
+*/
+
+/*!
+    \fn QChildEvent::QChildEvent( Type type, QObject *child )
+
+    Constructs a child event object. The \a child is the object that
+    is to be removed or inserted.
+
+    The \a type parameter must be either \c QEvent::ChildInserted or
+    \c QEvent::ChildRemoved.
+*/
+
+/*!
+    \fn QObject *QChildEvent::child() const
+
+    Returns the child widget that was inserted or removed.
+*/
+
+/*!
+    \fn bool QChildEvent::inserted() const
+
+    Returns TRUE if the widget received a new child; otherwise returns
+    FALSE.
+*/
+
+/*!
+    \fn bool QChildEvent::removed() const
+
+    Returns TRUE if the object lost a child; otherwise returns FALSE.
+*/
+
+
+
+
+/*!
+    \class QCustomEvent qevent.h
+    \brief The QCustomEvent class provides support for custom events.
+
+    \ingroup events
+
+    QCustomEvent is a generic event class for user-defined events.
+    User defined events can be sent to widgets or other QObject
+    instances using QApplication::postEvent() or
+    QApplication::sendEvent(). Subclasses of QObject can easily
+    receive custom events by implementing the QObject::customEvent()
+    event handler function.
+
+    QCustomEvent objects should be created with a type ID that
+    uniquely identifies the event type. To avoid clashes with the
+    Qt-defined events types, the value should be at least as large as
+    the value of the "User" entry in the QEvent::Type enum.
+
+    QCustomEvent contains a generic void* data member that may be used
+    for transferring event-specific data to the receiver. Note that
+    since events are normally delivered asynchronously, the data
+    pointer, if used, must remain valid until the event has been
+    received and processed.
+
+    QCustomEvent can be used as-is for simple user-defined event
+    types, but normally you will want to make a subclass of it for
+    your event types. In a subclass, you can add data members that are
+    suitable for your event type.
+
+    Example:
+    \code
+    class ColorChangeEvent : public QCustomEvent
+    {
+    public:
+	ColorChangeEvent( QColor color )
+	    : QCustomEvent( 65432 ), c( color ) {}
+	QColor color() const { return c; }
+    private:
+	QColor c;
+    };
+
+    // To send an event of this custom event type:
+
+    ColorChangeEvent* ce = new ColorChangeEvent( blue );
+    QApplication::postEvent( receiver, ce );  // Qt will delete it when done
+
+    // To receive an event of this custom event type:
+
+    void MyWidget::customEvent( QCustomEvent * e )
+    {
+	if ( e->type() == 65432 ) {  // It must be a ColorChangeEvent
+	    ColorChangeEvent* ce = (ColorChangeEvent*)e;
+	    newColor = ce->color();
+	}
+    }
+    \endcode
+
+    \sa QWidget::customEvent(), QApplication::notify()
+*/
+
+
+/*!
+    Constructs a custom event object with event type \a type. The
+    value of \a type must be at least as large as QEvent::User. The
+    data pointer is set to 0.
+*/
+
+QCustomEvent::QCustomEvent( int type )
+    : QEvent( (QEvent::Type)type ), d( 0 )
+{
+}
+
+
+/*!
+    \fn QCustomEvent::QCustomEvent( Type type, void *data )
+
+    Constructs a custom event object with the event type \a type and a
+    pointer to \a data. (Note that any int value may safely be cast to
+    QEvent::Type).
+*/
+
+
+/*!
+    \fn void QCustomEvent::setData( void* data )
+
+    Sets the generic data pointer to \a data.
+
+    \sa data()
+*/
+
+/*!
+    \fn void *QCustomEvent::data() const
+
+    Returns a pointer to the generic event data.
+
+    \sa setData()
+*/
+
+
+
+/*!
+    \fn QDragMoveEvent::QDragMoveEvent( const QPoint& pos, Type type )
+
+    Creates a QDragMoveEvent for which the mouse is at point \a pos,
+    and the event is of type \a type.
+
+    \warning Do not create a QDragMoveEvent yourself since these
+    objects rely on Qt's internal state.
+*/
+
+/*!
+    \fn void QDragMoveEvent::accept( const QRect & r )
+
+    The same as accept(), but also notifies that future moves will
+    also be acceptable if they remain within the rectangle \a r on the
+    widget: this can improve performance, but may also be ignored by
+    the underlying system.
+
+    If the rectangle is \link QRect::isEmpty() empty\endlink, then
+    drag move events will be sent continuously. This is useful if the
+    source is scrolling in a timer event.
+*/
+
+/*!
+    \fn void QDragMoveEvent::ignore( const QRect & r)
+
+    The opposite of accept(const QRect&), i.e. says that moves within
+    rectangle \a r are not acceptable (will be ignored).
+*/
+
+/*!
+    \fn QRect QDragMoveEvent::answerRect() const
+
+    Returns the rectangle for which the acceptance of the move event
+    applies.
+*/
+
+
+
+/*!
+    \fn const QPoint& QDropEvent::pos() const
+
+    Returns the position where the drop was made.
+*/
+
+/*!
+    \fn bool QDropEvent::isAccepted () const
+
+    Returns TRUE if the drop target accepts the event; otherwise
+    returns FALSE.
+*/
+
+/*!
+    \fn void QDropEvent::accept(bool y=TRUE)
+
+    Call this function to indicate whether the event provided data
+    which your widget processed. Set \a y to TRUE (the default) if
+    your widget could process the data, otherwise set \a y to FALSE.
+    To get the data, use encodedData(), or preferably, the decode()
+    methods of existing QDragObject subclasses, such as
+    QTextDrag::decode(), or your own subclasses.
+
+    \sa acceptAction()
+*/
+
+/*!
+    \fn void QDropEvent::acceptAction(bool y=TRUE)
+
+    Call this to indicate that the action described by action() is
+    accepted (i.e. if \a y is TRUE, which is the default), not merely
+    the default copy action. If you call acceptAction(TRUE), there is
+    no need to also call accept(TRUE).
+*/
+
+/*!
+  \fn void QDragMoveEvent::accept( bool y )
+  \reimp
+  \internal
+  Remove in 3.0
+*/
+
+/*!
+  \fn void QDragMoveEvent::ignore()
+  \reimp
+  \internal
+  Remove in 3.0
+*/
+
+
+/*!
+    \enum QDropEvent::Action
+
+    This enum describes the action which a source requests that a
+    target perform with dropped data.
+
+    \value Copy The default action. The source simply uses the data
+		provided in the operation.
+    \value Link The source should somehow create a link to the
+		location specified by the data.
+    \value Move The source should somehow move the object from the
+		location specified by the data to a new location.
+    \value Private  The target has special knowledge of the MIME type,
+		which the source should respond to in a similar way to
+		a Copy.
+    \value UserAction  The source and target can co-operate using
+		special actions. This feature is not currently
+		supported.
+
+    The Link and Move actions only makes sense if the data is a
+    reference, for example, text/uri-list file lists (see QUriDrag).
+*/
+
+/*!
+    \fn void QDropEvent::setAction( Action a )
+
+    Sets the action to \a a. This is used internally, you should not
+    need to call this in your code: the \e source decides the action,
+    not the target.
+*/
+
+/*!
+    \fn Action QDropEvent::action() const
+
+    Returns the Action which the target is requesting to be performed
+    with the data. If your application understands the action and can
+    process the supplied data, call acceptAction(); if your
+    application can process the supplied data but can only perform the
+    Copy action, call accept().
+*/
+
+/*!
+    \fn void QDropEvent::ignore()
+
+    The opposite of accept(), i.e. you have ignored the drop event.
+*/
+
+/*!
+    \fn bool QDropEvent::isActionAccepted () const
+
+    Returns TRUE if the drop action was accepted by the drop site;
+    otherwise returns FALSE.
+*/
+
+
+/*!
+    \fn void QDropEvent::setPoint (const QPoint & np)
+
+    Sets the drop to happen at point \a np. You do not normally need
+    to use this as it will be set internally before your widget
+    receives the drop event.
+*/ // ### here too - what coordinate system?
+
+
+/*!
+    \class QDragEnterEvent qevent.h
+    \brief The QDragEnterEvent class provides an event which is sent to the widget when a drag and drop first drags onto the widget.
+
+    \ingroup events
+    \ingroup draganddrop
+
+    This event is always immediately followed by a QDragMoveEvent, so
+    you only need to respond to one or the other event. This class
+    inherits most of its functionality from QDragMoveEvent, which in
+    turn inherits most of its functionality from QDropEvent.
+
+    \sa QDragLeaveEvent, QDragMoveEvent, QDropEvent
+*/
+
+/*!
+    \fn QDragEnterEvent::QDragEnterEvent (const QPoint & pos)
+
+    Constructs a QDragEnterEvent entering at the given point, \a pos.
+
+    \warning Do not create a QDragEnterEvent yourself since these
+    objects rely on Qt's internal state.
+*/
+
+/*!
+    \class QDragLeaveEvent qevent.h
+    \brief The QDragLeaveEvent class provides an event which is sent to the widget when a drag and drop leaves the widget.
+
+    \ingroup events
+    \ingroup draganddrop
+
+    This event is always preceded by a QDragEnterEvent and a series of
+    \l{QDragMoveEvent}s. It is not sent if a QDropEvent is sent
+    instead.
+
+    \sa QDragEnterEvent, QDragMoveEvent, QDropEvent
+*/
+
+/*!
+    \fn QDragLeaveEvent::QDragLeaveEvent()
+
+    Constructs a QDragLeaveEvent.
+
+    \warning Do not create a QDragLeaveEvent yourself since these
+    objects rely on Qt's internal state.
+*/
+
+/*!
+    \class QHideEvent qevent.h
+    \brief The QHideEvent class provides an event which is sent after a widget is hidden.
+
+    \ingroup events
+
+    This event is sent just before QWidget::hide() returns, and also
+    when a top-level window has been hidden (iconified) by the user.
+
+    If spontaneous() is TRUE the event originated outside the
+    application, i.e. the user hid the window using the window manager
+    controls, either by iconifying the window or by switching to
+    another virtual desktop where the window isn't visible. The window
+    will become hidden but not withdrawn. If the window was iconified,
+    QWidget::isMinimized() returns TRUE.
+
+    \sa QShowEvent
+*/
+
+/*!
+    \fn QHideEvent::QHideEvent()
+
+    Constructs a QHideEvent.
+*/
+
+/*!
+    \class QShowEvent qevent.h
+    \brief The QShowEvent class provides an event which is sent when a widget is shown.
+
+    \ingroup events
+
+    There are two kinds of show events: show events caused by the
+    window system (spontaneous) and internal show events. Spontaneous
+    show events are sent just after the window system shows the
+    window, including after a top-level window has been shown
+    (un-iconified) by the user. Internal show events are delivered
+    just before the widget becomes visible.
+
+    \sa QHideEvent
+*/
+
+/*!
+    \fn QShowEvent::QShowEvent()
+
+    Constructs a QShowEvent.
+*/
+
+
+/*!
+  \fn QByteArray QDropEvent::data(const char* f) const
+
+  \obsolete
+
+  Use QDropEvent::encodedData().
+*/
+
+
+/*!
+  Destroys the event. If it was \link
+  QApplication::postEvent() posted \endlink,
+  it will be removed from the list of events to be posted.
+*/
+
+QEvent::~QEvent()
+{
+    if ( posted && qApp )
+	QApplication::removePostedEvent( this );
+}
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qinputcontext.cpp qt-x11-free-3.3.8b/src/kernel/qinputcontext.cpp
--- qt-x11-free-3.3.8b/src/kernel/qinputcontext.cpp	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qinputcontext.cpp	2009-10-18 14:38:39.171866096 -0700
@@ -0,0 +1,856 @@
+/****************************************************************************
+** $Id: qinputcontext.cpp,v 1.6 2004/06/22 06:47:30 daisuke Exp $
+**
+** Implementation of QInputContext class
+**
+** Copyright (C) 2000-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses for Unix/X11 may use this file in accordance with the Qt Commercial
+** License Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+//#define QT_NO_IM_PREEDIT_RELOCATION
+
+#include "qinputcontext.h"
+
+#ifndef QT_NO_IM
+
+#include "qplatformdefs.h"
+
+#include "qapplication.h"
+#include "qwidget.h"
+#include "qpopupmenu.h"
+
+#include <stdlib.h>
+#include <limits.h>
+
+class QInputContextPrivate
+{
+public:
+    QInputContextPrivate()
+	: holderWidget( 0 ), composingWidget( 0 ), hasFocus( FALSE ),
+	  isComposing( FALSE ) 
+#if !defined(QT_NO_IM_PREEDIT_RELOCATION)
+	  , preeditString( QString::null ),
+	  cursorPosition( -1 ), selLength ( 0 )
+#endif
+    {}
+
+    QWidget *holderWidget; // widget to which QInputContext instance belongs.
+    QWidget *composingWidget;
+    bool hasFocus;
+    bool isComposing;
+
+    void updateComposingState( const QString &text,
+			       int newCursorPosition, int newSelLength ) {
+#if !defined(QT_NO_IM_PREEDIT_RELOCATION)
+	preeditString = text;
+	cursorPosition = newCursorPosition;
+	selLength = newSelLength;
+#endif
+    }
+
+    void resetComposingState() {
+	isComposing = FALSE;
+#if !defined(QT_NO_IM_PREEDIT_RELOCATION)
+	preeditString = QString::null;
+	cursorPosition = -1;
+	selLength = 0;
+#endif
+    }
+
+#if !defined(QT_NO_IM_PREEDIT_RELOCATION)
+    QString preeditString;
+    int cursorPosition;
+    int selLength;
+#endif
+};
+
+
+// UPDATED COMMENT REQUIRED -- 2004-07-08 YamaKen
+/*!
+    \class QInputContext qinputcontext.h
+    \brief The QInputContext class abstracts the input method dependent data and composing state.
+
+    \ingroup i18n
+
+    An input method is responsible to input complex text that cannot
+    be inputted via simple keymap. It converts a sequence of input
+    events (typically key events) into a text string through the input
+    method specific converting process. The class of the processes are
+    widely ranging from simple finite state machine to complex text
+    translator that pools a whole paragraph of a text with text
+    editing capability to perform grammar and semantic analysis.
+
+    To abstract such different input method specific intermediate
+    information, Qt offers the QInputContext as base class. The
+    concept is well known as 'input context' in the input method
+    domain. an input context is created for a text widget in response
+    to a demand. It is ensured that an input context is prepared for
+    an input method before input to a text widget.
+
+    Multiple input contexts that is belonging to a single input method
+    may concurrently coexist. Suppose multi-window text editor. Each
+    text widget of window A and B holds different QInputContext
+    instance which contains different state information such as
+    partially composed text.
+
+    \section1 Groups of functions:
+
+    \table
+    \header \i Context \i Functions
+
+    \row \i Receiving information \i
+	x11FilterEvent(),
+	filterEvent(),
+	setMicroFocus(),
+	mouseHandler()
+
+    \row \i Sending back composed text \i
+	sendIMEvent(),
+
+    \row \i State change notification \i
+	setFocus(),
+	unsetFocus(),
+	reset()
+
+    \row \i Context information \i
+	identifierName(),
+	language(),
+	font(),
+	isComposing(),
+
+    \endtable
+
+
+    \section1 Sharing input context between text widgets
+
+    Any input context can be shared between several text widgets to
+    reduce resource consumption. In ideal case, each text widgets
+    should be allocated dedicated input context. But some complex
+    input contexts require slightly heavy resource such as 100
+    kilobytes of memory. It prevents quite many text widgets from
+    being used concurrently.
+
+    To resolve such problem, we can share an input context. There is
+    one 'input context holder widget' per text widgets that shares
+    identical input context. In this model, the holder widget owns the
+    shared input context. Other text widgets access the input context
+    via QApplication::locateICHolderWidget(). But the access
+    convention is transparently hidden into QWidget, so developers are
+    not required to aware of it.
+
+    What developer should know is only the mapping function
+    QApplication::locateICHolderWidget(). It accepts a widget as
+    argument and returns its holder widget. Default implementation
+    returns the top-level widget of the widget as reasonable
+    assumption.  But some applications should reimplement the function
+    to fit application specific usability. See
+    QApplication::locateICHolderWidget() for further information.
+
+
+    \section1 Preedit preservation
+
+    As described above, input contexts have wide variety of amount of
+    the state information in accordance with belonging input
+    method. It is ranging from 2-3 keystrokes of sequence in
+    deterministic input methods to hundreds of keystrokes with
+    semantic text refinement in complex input methods such as ordinary
+    Japanese input method. The difference requires the different reset
+    policies in losing input focus.
+
+    The former simple input method case, users will prefer resetting
+    the context to back to the neutral state when something
+    happened. Suppose a web browsing. The user scroll the page by
+    scrollbar after he or she has typed a half of the valid key
+    sequence into a text widget. In the case, the input context should
+    be reset in losing focus when he or she has dragged the
+    scrollbar. He or she will be confused if the input context is
+    still preserved until focused back to the text widget because he
+    or she will restart typing with first key of the sequence as a
+    habitual operation.
+
+    On the other hand, we should choose completely different policy
+    for the latter complex input method case. Suppose same situation
+    as above but he or she is using a complex input method. In the
+    case, he or she will be angry if the input context has been lost
+    when he or she has dragged the scrollbar because the input context
+    contained a valuably composed text made up by considerable input
+    cost. So we should not reset the input context in the case. And
+    the input context should be preserved until focused back to the
+    text widget. This behavior is named as 'preedit preservation'.
+
+    The two policies can be switched by calling or not calling reset()
+    in unsetFocus(). Default implementation of unsetFocus() calls
+    reset() to fit the simple input methods. The implementation is
+    expressed as 'preedit preservation is disabled'.
+
+
+    \section1 Preedit relocation
+
+    Although the most case of the preedit preservation problem for
+    complex input methods is resolved as described above, there is a
+    special case. Suppose the case that matches all of the following
+    conditions.
+
+    \list
+
+    \i a input focus has been moved from a text widget to another text
+    widget directly
+
+    \i the input context is shared between the two text widgets
+
+    \i preedit preservation is enabled for the input context
+
+    \endlist
+
+    In the case, there are the following two requirements that
+    contradicts each other. The input context sharing causes it.
+
+    \list
+
+    \i the input context has to be reset to prepare to input to the
+    newly focused text widget
+
+    \i the input context has to be preserved until focused back to the
+    previous text widget
+
+    \endlist
+
+    A intrinsic feature named 'preedit relocation' is available to
+    compromise the requirements. If the feature is enabled for the
+    input context, it is simply moved to the new text widget with the
+    preedit string. The user continues the input on the new text
+    widget, or relocate it to another text widget. The preedit of
+    previous text widget is automatically cleared to back to the
+    neutral state of the widget.
+
+    This strange behavior is just a compromise. As described in
+    previous section, complex input method user should not be exposed
+    to the risk losing the input context because it contains valuable
+    long text made up with considerable input cost. The user will
+    immediately focus back to the previous text widget to continue the
+    input in the correct text widget if the preedit relocation
+    occurred. The feature is mainly existing as safety.
+
+    The feature properly works even if the focus is moved as
+    following. Input method developers are not required to be aware of
+    the relocation protocol since QInputContext transparently handles
+    it.
+
+    a text widget -> a non-text widget -> another text widget
+
+    To enable the preedit relocation feature, the input context class
+    have to reimplement isPreeditRelocationEnabled() as returns TRUE.
+    The implementation requires that the preedit preservation is also
+    enabled since preedit relocation is a special case of the preedit
+    preservation. If the preedit relocation is disabled, the input
+    context is simply reset in the relocation case.
+
+
+    \section1 Input context instanciation
+    \section1 Input method switching
+
+    \section1 Text widget implementor's guide
+
+    Add following code fragment into createPopupMenu() to add input
+    method dependent submenus.
+
+    \code
+    #ifndef QT_NO_IM
+        QInputContext *qic = getInputContext();
+        if ( qic )
+            qic->addMenusTo( popup );
+    #endif
+    \endcode
+
+    \sa QInputContextPlugin, QInputContextFactory, QApplication::locateICHolderWidget(), QApplication::defaultInputMethod()
+*/
+
+
+/*!
+    Constructs an input context.
+
+    holderWidget is set immediately after this constructor has been
+    returned on the X11 platform.
+*/
+QInputContext::QInputContext( QObject *parent )
+    : QObject( parent )
+{
+    d = new QInputContextPrivate;
+}
+
+
+/*!
+    Destroys the input context.
+*/
+QInputContext::~QInputContext()
+{
+    delete d;
+}
+
+#if defined(Q_WS_X11)
+/*!
+    \internal
+    Returns the owner of this input context. Ordinary input methods
+    should not call this function directly to keep platform
+    independence and flexible configuration possibility.
+
+    The return value may differ from focusWidget() if the input
+    context is shared between several text widgets.
+
+    \sa setHolderWidget(), focusWidget()
+*/
+QWidget *QInputContext::holderWidget() const
+{
+    return d->holderWidget;
+}
+
+/*!
+    \internal
+    Sets the owner of this input context. Ordinary input methods
+    must not call this function directly.
+
+    \sa holderWidget()
+*/
+void QInputContext::setHolderWidget( QWidget *w )
+{
+    d->holderWidget = w;
+}
+
+/*!
+    \internal
+    Returns the widget that has an input focus for this input
+    context. Ordinary input methods should not call this function
+    directly to keep platform independence and flexible configuration
+    possibility.
+
+    The return value may differ from holderWidget() if the input
+    context is shared between several text widgets.
+
+    \sa setFocusWidget(), holderWidget()
+*/
+QWidget *QInputContext::focusWidget() const
+{
+    return d->hasFocus ? d->composingWidget : 0;
+}
+
+
+/*!
+    \internal
+    Sets the widget that has an input focus for this input
+    context. Ordinary input methods must not call this function
+    directly.
+
+    \sa focusWidget()
+*/
+void QInputContext::setFocusWidget( QWidget *w )
+{
+    if ( w ) {
+	bool isFocusingBack = ( w == d->composingWidget );
+	bool isPreeditRelocation = ( ! isFocusingBack  && isComposing() &&
+				     d->composingWidget );
+	// invoke sendIMEventInternal() rather than sendIMEvent() to
+	// avoid altering the composing state
+	if ( isPreeditRelocation == TRUE ) {
+	    // clear preedit of previously focused text
+	    // widget. preserved preedit may be exist even if
+	    // isPreeditRelocationEnabled() == FALSE.
+	    sendIMEventInternal( QEvent::IMEnd );
+	}
+	d->composingWidget = w;  // changes recipient of QIMEvent
+	if ( isPreeditRelocation == TRUE ) {
+#if !defined(QT_NO_IM_PREEDIT_RELOCATION)
+	    if ( isPreeditRelocationEnabled() ) {
+		// copy preedit state to the widget that gaining focus
+		sendIMEventInternal( QEvent::IMStart );
+		sendIMEventInternal( QEvent::IMCompose, d->preeditString,
+				     d->cursorPosition, d->selLength );
+	    } else
+#endif
+	    {
+		// reset input context when the shared context has
+		// focused on another text widget
+		reset();
+	    }
+	}
+    }
+    d->hasFocus = w ? TRUE : FALSE;
+}
+
+
+/*!
+    \internal
+    This function is called from QWidget to keep input state
+    consistency. Ordinary input method must not call this function
+    directly.
+*/
+void QInputContext::releaseComposingWidget( QWidget *w )
+{
+    if ( d->composingWidget == w ) {
+	d->composingWidget = 0;
+	d->hasFocus = FALSE;
+    }
+}
+#endif  // Q_WS_X11
+
+/*!
+    \internal
+    This function can be reimplemented in a subclass as returning TRUE
+    if you want making your input method enable the preedit
+    relocation. See the description for preedit relocation of
+    QInputContext.
+
+    /sa QInputContext
+*/
+bool QInputContext::isPreeditRelocationEnabled()
+{
+    return FALSE;
+}
+
+/*!
+    This function indicates whether IMStart event had been sent to the
+    text widget. It is ensured that an input context can send IMCompose
+    or IMEnd event safely if this function returned TRUE.
+
+    The state is automatically being tracked through sendIMEvent().
+
+    \sa sendIMEvent()
+*/
+bool QInputContext::isComposing() const
+{
+    return d->isComposing;
+}
+
+
+/*!
+    This function can be reimplemented in a subclass to filter input
+    events.
+
+    Return TRUE if the \a event has been consumed. Otherwise, the
+    unfiltered \a event will be forwarded to widgets as ordinary
+    way. Although the input events have accept() and ignore()
+    methods, leave it untouched.
+
+    \a event is currently restricted to QKeyEvent. But some input
+    method related events such as QWheelEvent or QTabletEvent may be
+    added in future.
+
+    The filtering opportunity is always given to the input context as
+    soon as possible. It has to be taken place before any other key
+    event consumers such as eventfilters and accelerators because some
+    input methods require quite various key combination and
+    sequences. It often conflicts with accelerators and so on, so we
+    must give the input context the filtering opportunity first to
+    ensure all input methods work properly regardless of application
+    design.
+
+    Ordinary input methods require discrete key events to work
+    properly, so Qt's key compression is always disabled for any input
+    contexts.
+
+    \sa QKeyEvent, x11FilterEvent()
+*/
+bool QInputContext::filterEvent( const QEvent *event )
+{
+    return FALSE;
+}
+
+
+/*!
+    \fn void QInputContext::deletionRequested()
+
+    Emit this signal when a fatal error has been caused in the input
+    context. The input context will be deleted by the owner which is
+    usually the holder widget.
+*/
+
+/*!
+    \fn void QInputContext::imEventGenerated( QObject *receiver, QIMEvent *e )
+
+    \internal
+    This signal is emitted when the user has sent a QIMEvent through
+    sendIMEvent(). Ordinary input methods should not emit this signal
+    directly.
+
+    \a receiver is a platform dependent destination of the \a e.
+
+    \sa QIMEvent, sendIMEvent(), sendIMEventInternal(), 
+*/
+
+/*!
+    \internal
+    Sends a QIMEvent to the client via imEventGenerated()
+    signal. Ordinary input method should not call this function
+    directly.
+
+    \sa QIMEvent, QIMComposeEvent, sendIMEvent(), imEventGenerated()
+*/
+void QInputContext::sendIMEventInternal( QEvent::Type type,
+					 const QString &text,
+					 int cursorPosition, int selLength )
+{
+    QObject *receiver = 0;
+    QIMEvent *event = 0;
+
+#if defined(Q_WS_X11)
+    receiver = d->composingWidget;
+#elif defined(Q_WS_QWS)
+    // just a placeholder
+#endif
+    if ( ! receiver )
+	return;
+
+    if ( type == QEvent::IMStart ) {
+	qDebug( "sending IMStart with %d chars to %p",
+		text.length(), receiver );
+	event = new QIMEvent( type, text, cursorPosition );
+    } else if ( type == QEvent::IMEnd ) {
+	qDebug( "sending IMEnd with %d chars to %p, text=%s",
+		text.length(), receiver, (const char*)text.local8Bit() );
+	event = new QIMEvent( type, text, cursorPosition );
+    } else if ( type == QEvent::IMCompose ) {
+	qDebug( "sending IMCompose to %p with %d chars, cpos=%d, sellen=%d, text=%s",
+		receiver, text.length(), cursorPosition, selLength,
+		(const char*)text.local8Bit() );
+	event = new QIMComposeEvent( type, text, cursorPosition, selLength );
+    }
+
+    if ( event )
+        emit imEventGenerated( receiver, event );
+}
+
+
+/*!
+    Call this function to send QIMEvent to the text widget. This
+    function constructs a QIMEvent based on the arguments and send it
+    to the appropriate widget. Ordinary input method should not
+    reimplement this function.
+
+    \a type is either \c QEvent::IMStart or \c QEvent::IMCompose or \c
+    QEvent::IMEnd. You have to send a \c QEvent::IMStart to start
+    composing, then send several \c QEvent::IMCompose to update the
+    preedit of the widget, and finalize the composition with sending
+    \c QEvent::IMEnd.
+
+    \c QEvent::IMStart should always be sent without arguments as:
+    \code
+    sendIMEvent( QEvent::IMStart )
+    \endcode
+
+    And \c QEvent::IMCompose can be sent without cursor:
+    \code
+    sendIMEvent( QEvent::IMCompose, QString( "a text" ) )
+    \endcode
+
+    Or optionally with cursor with \a cursorPosition:
+    \code
+    sendIMEvent( QEvent::IMCompose, QString( "a text with cursor" ), 12 )
+    \endcode
+    Note that \a cursorPosition also specifies microfocus position.
+
+    Or optionally with selection text:
+    \code
+    sendIMEvent( QEvent::IMCompose, QString( "a text with selection" ), 12, 9 )
+    \endcode
+    \a cursorPosition and \a selLength must be within the \a text. The
+    \a cursorPosition also specifies microfocus position in the case:
+
+    \c QEvent::IMEnd can be sent without arguments to terminate the
+    composition with null string:
+    \code
+    sendIMEvent( QEvent::IMEnd )
+    \endcode
+
+    Or optionally accepts \a text to commit a string:
+    \code
+    sendIMEvent( QEvent::IMEnd, QString( "a text" ) )
+    \endcode
+
+    \sa QIMEvent, QIMComposeEvent, setMicroFocus()
+*/
+void QInputContext::sendIMEvent( QEvent::Type type, const QString &text,
+                                 int cursorPosition, int selLength )
+{
+#if defined(Q_WS_X11)
+    if ( !focusWidget() )
+	return;
+#endif
+
+    if ( type == QEvent::IMStart ) {
+	sendIMEventInternal( type, text, cursorPosition, selLength );
+	d->isComposing = TRUE;
+    } else if ( type == QEvent::IMEnd ) {
+	d->resetComposingState();
+	sendIMEventInternal( type, text, cursorPosition, selLength );
+    } else if ( type == QEvent::IMCompose ) {
+	d->updateComposingState( text, cursorPosition, selLength );
+	sendIMEventInternal( type, text, cursorPosition, selLength );
+    }
+}
+
+
+/*!
+    This function can be reimplemented in a subclass to detect
+    that the input context has been focused on.
+
+    The input context will receive input events through
+    x11FilterEvent() and filterEvent() after setFocus() until
+    unsetFocus() has been called.
+
+    an input context is ensured that setFocus() is called exactly once
+    until unsetFocus() has been called even if preedit relocation has
+    occurred. This means that an input focus will survive between
+    several widgets that sharing the input context.
+
+    On the X11 platform, focusWidget is already set before this
+    function has been called.
+
+    \sa unsetFocus()
+*/
+void QInputContext::setFocus()
+{
+}
+
+
+/*!
+    This function can be reimplemented in a subclass to detect
+    that the input context has lost the focus.
+
+    an input context is ensured that unsetFocus() is not called during
+    preedit relocation. This means that an input focus will survive
+    between several widgets that sharing the input context.
+
+    Default implementation that calls reset() is sufficient for simple
+    input methods. You can override this function to alter the
+    behavior. For example, most Japanese input contexts should not be
+    reset on losing focus. The context sometimes contains a whole
+    paragraph and has minutes of lifetime different to ephemeral one
+    in other languages. The piled input context should be survived
+    until focused again since Japanese user naturally expects so.
+
+    On the X11 platform, focusWidget is valid until this function has
+    been returned.
+
+    \sa setFocus()
+*/
+void QInputContext::unsetFocus()
+{
+    reset();
+}
+
+
+/*!
+    This function can be implemented in a subclass to handle
+    microfocus changes.
+
+    'microfocus' stands for the input method focus point in the
+    preedit (XIM "spot" point) for complex language input handling. It
+    can be used to place auxiliary GUI widgets such as candidate
+    selection window.
+
+    \a x, \a y, \a w and \a h represents the position and size of the
+    cursor in the preedit string. \a f is the font on the location of
+    the cursor.
+*/
+void QInputContext::setMicroFocus( int x, int y, int w, int h, QFont *f )
+{
+}
+
+
+/*!
+    This function can be reimplemented in a subclass to handle mouse
+    presses/releases/doubleclicks/moves within the preedit text. You
+    can use the function to implement mouse-oriented user interface
+    such as text selection or popup menu for candidate selection.
+
+    The parameter \a x is the offset within the string that was sent
+    with the IMCompose event. The alteration boundary of \a x is
+    ensured as character boundary of preedit string accurately.
+
+    \a type is either \c QEvent::MouseButtonPress or \c
+    QEvent::MouseButtonRelease or \c QEvent::MouseButtonDblClick or \c
+    QEvent::MouseButtonMove. Refer \a button and \a state to determine
+    what operation has performed.
+
+    The method interface is imported from
+    QWSInputMethod::mouseHandler() of Qt/Embedded 2.3.7 and extended
+    for desktop system.
+ */
+void QInputContext::mouseHandler( int x, QEvent::Type type,
+				  Qt::ButtonState button,
+				  Qt::ButtonState state )
+{
+    // Default behavior for simple ephemeral input contexts. Some
+    // complex input contexts should not be reset here.
+    if ( type == QEvent::MouseButtonPress ||
+	 type == QEvent::MouseButtonDblClick )
+	reset();
+}
+
+
+/*!
+    Returns the font of the current input widget
+ */
+QFont QInputContext::font() const
+{
+    if ( !focusWidget() )
+        return QApplication::font(); //### absolutely last resort
+
+    return focusWidget()->font();
+}
+
+
+/*!
+    This function can be reimplemented in a subclass to reset the
+    state of the input method.
+
+    This function is called by several widgets to reset input
+    state. For example, a text widget call this function before
+    inserting a text to make widget ready to accept a text.
+
+    Default implementation is sufficient for simple input method. You
+    can override this function to reset external input method engines
+    in complex input method. In the case, call QInputContext::reset()
+    to ensure proper termination of inputting.
+
+    You must not send any QIMEvent except empty IMEnd event using
+    QInputContext::reset() at reimplemented reset(). It will break
+    input state consistency.
+*/
+void QInputContext::reset()
+{
+    if ( isComposing() )
+        sendIMEvent( QEvent::IMEnd );
+}
+
+
+/*!
+    This function must be implemented in any subclasses to return the
+    identifier name of the input method.
+
+    Return value is the name to identify and specify input methods for
+    the input method switching mechanism and so on. The name has to be
+    consistent with QInputContextPlugin::keys(). The name has to
+    consist of ASCII characters only.
+
+    There are two different names with different responsibility in the
+    input method domain. This function returns one of them. Another
+    name is called 'display name' that stands for the name for
+    endusers appeared in a menu and so on.
+
+    \sa QInputContextPlugin::keys(), QInputContextPlugin::displayName()
+*/
+QString QInputContext::identifierName()
+{
+    return "";
+}
+
+
+/*!
+    This function must be implemented in any subclasses to return a
+    language code (e.g. "zh_CN", "zh_TW", "zh_HK", "ja", "ko", ...)
+    of the input context. If the input context can handle multiple
+    languages, return the currently used one. The name has to be
+    consistent with QInputContextPlugin::language().
+
+    This information will be used by language tagging feature in
+    QIMEvent. It is required to distinguish unified han characters
+    correctly. It enables proper font and character code
+    handling. Suppose CJK-awared multilingual web browser
+    (that automatically modifies fonts in CJK-mixed text) and XML editor
+    (that automatically inserts lang attr).
+
+    \sa QInputContextPlugin::language()
+*/
+QString QInputContext::language()
+{
+    return "";
+}
+
+
+#if (QT_VERSION-0 >= 0x040000)
+/*!
+    This is a preliminary interface for Qt4
+ */
+QList<QAction *> QInputContext::actions()
+{
+}
+#else
+/*!
+    This function can be reimplemented in a subclass to provide input
+    method dependent popup menus. Return 0 if the menus are
+    unnecessary.
+
+    Ownership of the object and children are transferred to the
+    caller, and the result must not be called
+    setAutoDelete(). QInputContextMenu::title is used for label text
+    of the popup menu as submenu.
+
+    \sa addMenusTo()
+*/
+QPtrList<QInputContextMenu> *QInputContext::menus()
+{
+    return 0;
+}
+#endif
+
+/*!
+    Appends input method dependent submenus into \a popup. A separator
+    is also inserted into \a popup if \a action is InsertSeparator.
+
+    This is an utility function only for convenience in limited
+    situation. This function is used by input context owner such as
+    text widgets to add the submenus to its own context menu. If you
+    want to insert the submenus in more flexible way, use
+    QInputContext::menus() manually. \a popup is not restricted to
+    context menu of a text widget. For example, the owner may be a
+    input method menu of Qtopia taskbar in Qt/Embedded platform.
+
+    \sa menus(), QInputContextMenu::Action
+*/
+void QInputContext::addMenusTo( QPopupMenu *popup, QInputContextMenu::Action action )
+{
+    if ( ! popup )
+	return;
+
+    QPtrList<QInputContextMenu> *imMenus = menus();
+    if ( imMenus ) {
+	if ( action == QInputContextMenu::InsertSeparator )
+	    popup->insertSeparator();
+	for ( QPtrList<QInputContextMenu>::Iterator it = imMenus->begin();
+	      it != imMenus->end();
+	      ++it ) {
+	    QInputContextMenu *imMenu = *it;
+	    popup->insertItem( imMenu->title, imMenu->popup );
+	}
+	imMenus->clear();
+	delete imMenus;
+    }
+}
+
+#endif //Q_NO_IM
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qinputcontext.h qt-x11-free-3.3.8b/src/kernel/qinputcontext.h
--- qt-x11-free-3.3.8b/src/kernel/qinputcontext.h	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qinputcontext.h	2009-10-18 14:38:39.171866096 -0700
@@ -0,0 +1,143 @@
+/****************************************************************************
+** $Id: qinputcontext.h,v 1.8 2004/06/22 06:47:30 daisuke Exp $
+**
+** Definition of QInputContext
+**
+** Copyright (C) 1992-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QINPUTCONTEXT_H
+#define QINPUTCONTEXT_H
+
+#ifndef QT_NO_IM
+
+#ifndef QT_H
+#include "qobject.h"
+#include "qglobal.h"
+#include "qevent.h"
+#include "qstring.h"
+#if (QT_VERSION-0 >= 0x040000)
+#include "qlist.h"
+#include "qaction.h"
+#else
+#include "qptrlist.h"
+#endif
+#endif
+
+class QWidget;
+class QFont;
+class QPopupMenu;
+class QInputContextPrivate;
+
+
+struct QInputContextMenu {
+    enum Action {
+	NoSeparator,
+	InsertSeparator
+    };
+#if !(QT_VERSION-0 >= 0x040000)
+    QString title;
+    QPopupMenu *popup;
+#endif
+};
+
+
+class QInputContext : public QObject
+{
+    Q_OBJECT
+public:
+    QInputContext( QObject *parent = 0 );
+    virtual ~QInputContext();
+
+    virtual QString identifierName();
+    virtual QString language();
+
+#if defined(Q_WS_X11)
+    virtual bool x11FilterEvent( QWidget *keywidget, XEvent *event );
+#endif // Q_WS_X11
+    virtual bool filterEvent( const QEvent *event );
+    virtual void reset();
+
+    virtual void setFocus();
+    virtual void unsetFocus();
+    virtual void setMicroFocus( int x, int y, int w, int h, QFont *f = 0 );
+    virtual void mouseHandler( int x, QEvent::Type type,
+			       Qt::ButtonState button, Qt::ButtonState state );
+    virtual QFont font() const;
+    virtual bool isComposing() const;
+    virtual bool isPreeditRelocationEnabled();
+
+#if (QT_VERSION-0 >= 0x040000)
+    virtual QList<QAction *> actions();
+    void addActionsTo( QMenu *menu, QInputContextMenu::Action action = QInputContextMenu::InsertSeparator );
+#else
+    virtual QPtrList<QInputContextMenu> *menus();
+    void addMenusTo( QPopupMenu *popup, QInputContextMenu::Action action = QInputContextMenu::InsertSeparator );
+#endif
+
+#if defined(Q_WS_X11)
+    // these functions are not recommended for ordinary use 
+    virtual QWidget *focusWidget() const;
+    virtual QWidget *holderWidget() const;
+
+    // these functions must not be used by ordinary input method
+    virtual void setFocusWidget( QWidget *w );
+    virtual void setHolderWidget( QWidget *w );
+    virtual void releaseComposingWidget( QWidget *w );
+#endif
+
+signals:
+    void deletionRequested();
+    void imEventGenerated( QObject *receiver, QIMEvent *e );
+
+protected:
+    virtual void sendIMEvent( QEvent::Type type,
+			      const QString &text = QString::null,
+			      int cursorPosition = -1, int selLength = 0 );
+
+private:
+    void sendIMEventInternal( QEvent::Type type,
+			      const QString &text = QString::null,
+			      int cursorPosition = -1, int selLength = 0 );
+
+    QInputContextPrivate *d;
+
+    friend class QWidget;
+    friend class QInputContextFactory;
+
+private:   // Disabled copy constructor and operator=
+    QInputContext( const QInputContext & );
+    QInputContext &operator=( const QInputContext & );
+
+};
+
+#endif //Q_NO_IM
+
+#endif // QINPUTCONTEXT_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp
--- qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp	2009-10-18 14:38:39.178534571 -0700
@@ -37,499 +37,37 @@
 **********************************************************************/
 
+#include "qinputcontext.h"
+
+#ifndef QT_NO_IM
+
 #include "qplatformdefs.h"
 
 #include "qapplication.h"
 #include "qwidget.h"
-#include "qinputcontext_p.h"
-
-#include <stdlib.h>
-#include <limits.h>
 
+#include "qt_x11_p.h"
 
-bool qt_compose_emptied = FALSE;
+/*!
+    This function may be overridden only if input method is depending
+    on X11 and you need raw XEvent. Otherwise, this function must not.
 
-#if !defined(QT_NO_XIM)
+    This function is designed to filter raw key events for XIM, but
+    other input methods may use this to implement some special
+    features such as distinguishing Shift_L and Shift_R.
 
-#define XK_MISCELLANY
-#define XK_LATIN1
-#include <X11/keysymdef.h>
+    Return TRUE if the \a event has been consumed. Otherwise, the
+    unfiltered \a event will be translated into QEvent and forwarded
+    to filterEvent(). Filtering at both x11FilterEvent() and
+    filterEvent() in single input method is allowed.
 
-// #define QT_XIM_DEBUG
+    \a keywidget is a client widget into which a text is inputted. \a
+    event is inputted XEvent.
 
-// from qapplication_x11.cpp
-extern XIM	qt_xim;
-extern XIMStyle	qt_xim_style;
-
-/* The cache here is needed, as X11 leaks a few kb for every
-   XFreeFontSet call, so we avoid creating and deletion of fontsets as
-   much as possible
+    \sa filterEvent()
 */
-static XFontSet fontsetCache[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-static int fontsetRefCount = 0;
-
-static const char * const fontsetnames[] = {
-    "-*-fixed-medium-r-*-*-16-*,-*-*-medium-r-*-*-16-*",
-    "-*-fixed-medium-i-*-*-16-*,-*-*-medium-i-*-*-16-*",
-    "-*-fixed-bold-r-*-*-16-*,-*-*-bold-r-*-*-16-*",
-    "-*-fixed-bold-i-*-*-16-*,-*-*-bold-i-*-*-16-*",
-    "-*-fixed-medium-r-*-*-24-*,-*-*-medium-r-*-*-24-*",
-    "-*-fixed-medium-i-*-*-24-*,-*-*-medium-i-*-*-24-*",
-    "-*-fixed-bold-r-*-*-24-*,-*-*-bold-r-*-*-24-*",
-    "-*-fixed-bold-i-*-*-24-*,-*-*-bold-i-*-*-24-*"
-};
-
-static XFontSet getFontSet( const QFont &f )
-{
-    int i = 0;
-    if (f.italic())
-	i |= 1;
-    if (f.bold())
-	i |= 2;
-
-    if ( f.pointSize() > 20 )
-	i += 4;
-
-    if ( !fontsetCache[i] ) {
-	Display* dpy = QPaintDevice::x11AppDisplay();
-	int missCount;
-	char** missList;
-	fontsetCache[i] = XCreateFontSet(dpy, fontsetnames[i], &missList, &missCount, 0);
-	if(missCount > 0)
-	    XFreeStringList(missList);
-	if ( !fontsetCache[i] ) {
-	    fontsetCache[i] = XCreateFontSet(dpy,  "-*-fixed-*-*-*-*-16-*", &missList, &missCount, 0);
-	    if(missCount > 0)
-		XFreeStringList(missList);
-	    if ( !fontsetCache[i] )
-		fontsetCache[i] = (XFontSet)-1;
-	}
-    }
-    return (fontsetCache[i] == (XFontSet)-1) ? 0 : fontsetCache[i];
-}
-
-
-#ifdef Q_C_CALLBACKS
-extern "C" {
-#endif // Q_C_CALLBACKS
-
-    static int xic_start_callback(XIC, XPointer client_data, XPointer) {
-	QInputContext *qic = (QInputContext *) client_data;
-	if (! qic) {
-#ifdef QT_XIM_DEBUG
-	    qDebug("compose start: no qic");
-#endif // QT_XIM_DEBUG
-
-	    return 0;
-	}
-
-	qic->composing = TRUE;
-	qic->text = QString::null;
-	qic->focusWidget = 0;
-
-	if ( qic->selectedChars.size() < 128 )
-	    qic->selectedChars.resize( 128 );
-	qic->selectedChars.fill( 0 );
-
-#ifdef QT_XIM_DEBUG
-	qDebug("compose start");
-#endif // QT_XIM_DEBUG
-
-	return 0;
-    }
-
-    static int xic_draw_callback(XIC, XPointer client_data, XPointer call_data) {
-	QInputContext *qic = (QInputContext *) client_data;
-	if (! qic) {
-#ifdef QT_XIM_DEBUG
-	    qDebug("compose event: invalid compose event %p", qic);
-#endif // QT_XIM_DEBUG
-
-	    return 0;
-	}
-
-	bool send_imstart = FALSE;
-	if (qApp->focusWidget() != qic->focusWidget && qic->text.isEmpty()) {
-	    if (qic->focusWidget) {
-#ifdef QT_XIM_DEBUG
-		qDebug( "sending IMEnd (empty) to %p", qic->focusWidget );
-#endif // QT_XIM_DEBUG
-
-		QIMEvent endevent(QEvent::IMEnd, QString::null, -1);
-		QApplication::sendEvent(qic->focusWidget, &endevent);
-	    }
-
-	    qic->text = QString::null;
-	    qic->focusWidget = qApp->focusWidget();
-	    qic->composing = FALSE;
-
-	    if ( qic->selectedChars.size() < 128 )
-		qic->selectedChars.resize( 128 );
-	    qic->selectedChars.fill( 0 );
-
-	    if (qic->focusWidget) {
-		qic->composing = TRUE;
-		send_imstart = TRUE;
-	    }
-	}
-
-	if (! qic->composing || ! qic->focusWidget) {
-#ifdef QT_XIM_DEBUG
-	    qDebug("compose event: invalid compose event %d %p",
-		   qic->composing, qic->focusWidget);
-#endif // QT_XIM_DEBUG
-
-	    return 0;
-	}
-
-	if ( send_imstart ) {
-#ifdef QT_XIM_DEBUG
-            qDebug( "sending IMStart to %p", qic->focusWidget );
-#endif // QT_XIM_DEBUG
-
-	    qt_compose_emptied = FALSE;
-	    QIMEvent startevent(QEvent::IMStart, QString::null, -1);
-	    QApplication::sendEvent(qic->focusWidget, &startevent);
-	}
-
-	XIMPreeditDrawCallbackStruct *drawstruct =
-	    (XIMPreeditDrawCallbackStruct *) call_data;
-	XIMText *text = (XIMText *) drawstruct->text;
-	int cursor = drawstruct->caret, sellen = 0;
-
-	if ( ! drawstruct->caret && ! drawstruct->chg_first &&
-	     ! drawstruct->chg_length && ! text ) {
-	    // nothing to do
-	    return 0;
-	}
-
-	if (text) {
-	    char *str = 0;
-	    if (text->encoding_is_wchar) {
-		int l = wcstombs(NULL, text->string.wide_char, text->length);
-		if (l != -1) {
-		    str = new char[l + 1];
-		    wcstombs(str, text->string.wide_char, l);
-		    str[l] = 0;
-		}
-	    } else
-		str = text->string.multi_byte;
-
-	    if (! str)
-		return 0;
-
-	    QString s = QString::fromLocal8Bit(str);
-
-	    if (text->encoding_is_wchar)
-		delete [] str;
-
-	    if (drawstruct->chg_length < 0)
-		qic->text.replace(drawstruct->chg_first, UINT_MAX, s);
-	    else
-		qic->text.replace(drawstruct->chg_first, drawstruct->chg_length, s);
-
-	    if ( qic->selectedChars.size() < qic->text.length() ) {
-		// expand the selectedChars array if the compose string is longer
-		uint from = qic->selectedChars.size();
-		qic->selectedChars.resize( qic->text.length() );
-		for ( uint x = from; from < qic->selectedChars.size(); ++x )
-		    qic->selectedChars[x] = 0;
-	    }
-
-	    uint x;
-	    bool *p = qic->selectedChars.data() + drawstruct->chg_first;
-	    // determine if the changed chars are selected based on text->feedback
-	    for ( x = 0; x < s.length(); ++x )
-		*p++ = ( text->feedback ? ( text->feedback[x] & XIMReverse ) : 0 );
-
-	    // figure out where the selection starts, and how long it is
-	    p = qic->selectedChars.data();
-	    bool started = FALSE;
-	    for ( x = 0; x < QMIN(qic->text.length(), qic->selectedChars.size()); ++x ) {
-		if ( started ) {
-		    if ( *p ) ++sellen;
-		    else break;
-		} else {
-		    if ( *p ) {
-			cursor = x;
-			started = TRUE;
-			sellen = 1;
-		    }
-		}
-		++p;
-	    }
-	} else {
-	    if (drawstruct->chg_length == 0)
-		drawstruct->chg_length = -1;
-
-	    qic->text.remove(drawstruct->chg_first, drawstruct->chg_length);
-	    qt_compose_emptied = qic->text.isEmpty();
-	    if ( qt_compose_emptied ) {
-#ifdef QT_XIM_DEBUG
-		qDebug( "compose emptied" );
-#endif // QT_XIM_DEBUG
-
-		// don't send an empty compose, since we will send an IMEnd with
-		// either the correct compose text (or null text if the user has
-		// cancelled the compose or deleted all chars).
-		return 0;
-	    }
-	}
-
-#ifdef QT_XIM_DEBUG
-	qDebug( "sending IMCompose to %p with %d chars",
-                qic->focusWidget, qic->text.length() );
-#endif // QT_XIM_DEBUG
-
-	QIMComposeEvent event( QEvent::IMCompose, qic->text, cursor, sellen );
-	QApplication::sendEvent(qic->focusWidget, &event);
-	return 0;
-    }
-
-    static int xic_done_callback(XIC, XPointer client_data, XPointer) {
-	QInputContext *qic = (QInputContext *) client_data;
-	if (! qic)
-	    return 0;
-
-	if (qic->composing && qic->focusWidget) {
-#ifdef QT_XIM_DEBUG
-	    qDebug( "sending IMEnd (empty) to %p", qic->focusWidget );
-#endif // QT_XIM_DEBUG
-
-       	    QIMEvent event(QEvent::IMEnd, QString::null, -1);
-	    QApplication::sendEvent(qic->focusWidget, &event);
-	}
-
-	qic->composing = FALSE;
-	qic->focusWidget = 0;
-
-	if ( qic->selectedChars.size() < 128 )
-	    qic->selectedChars.resize( 128 );
-	qic->selectedChars.fill( 0 );
-
-	return 0;
-    }
-
-#ifdef Q_C_CALLBACKS
-}
-#endif // Q_C_CALLBACKS
-
-#endif // !QT_NO_XIM
-
-
-
-QInputContext::QInputContext(QWidget *widget)
-    : ic(0), focusWidget(0), composing(FALSE), fontset(0)
-{
-#if !defined(QT_NO_XIM)
-    fontsetRefCount++;
-    if (! qt_xim) {
-	qWarning("QInputContext: no input method context available");
-	return;
-    }
-
-    if (! widget->isTopLevel()) {
-	qWarning("QInputContext: cannot create input context for non-toplevel widgets");
-	return;
-    }
-
-    XPoint spot;
-    XRectangle rect;
-    XVaNestedList preedit_attr = 0;
-    XIMCallback startcallback, drawcallback, donecallback;
-
-    font = widget->font();
-    fontset = getFontSet( font );
-
-    if (qt_xim_style & XIMPreeditArea) {
-	rect.x = 0;
-	rect.y = 0;
-	rect.width = widget->width();
-	rect.height = widget->height();
-
-	preedit_attr = XVaCreateNestedList(0,
-					   XNArea, &rect,
-					   XNFontSet, fontset,
-					   (char *) 0);
-    } else if (qt_xim_style & XIMPreeditPosition) {
-	spot.x = 1;
-	spot.y = 1;
-
-	preedit_attr = XVaCreateNestedList(0,
-					   XNSpotLocation, &spot,
-					   XNFontSet, fontset,
-					   (char *) 0);
-    } else if (qt_xim_style & XIMPreeditCallbacks) {
-	startcallback.client_data = (XPointer) this;
-	startcallback.callback = (XIMProc) xic_start_callback;
-	drawcallback.client_data = (XPointer) this;
-	drawcallback.callback = (XIMProc)xic_draw_callback;
-	donecallback.client_data = (XPointer) this;
-	donecallback.callback = (XIMProc) xic_done_callback;
-
-	preedit_attr = XVaCreateNestedList(0,
-					   XNPreeditStartCallback, &startcallback,
-					   XNPreeditDrawCallback, &drawcallback,
-					   XNPreeditDoneCallback, &donecallback,
-					   (char *) 0);
-    }
-
-    if (preedit_attr) {
-	ic = XCreateIC(qt_xim,
-		       XNInputStyle, qt_xim_style,
-		       XNClientWindow, widget->winId(),
-		       XNPreeditAttributes, preedit_attr,
-		       (char *) 0);
-	XFree(preedit_attr);
-    } else
-	ic = XCreateIC(qt_xim,
-		       XNInputStyle, qt_xim_style,
-		       XNClientWindow, widget->winId(),
-		       (char *) 0);
-
-    if (! ic)
-	qFatal("Failed to create XIM input context!");
-
-    // when resetting the input context, preserve the input state
-    (void) XSetICValues((XIC) ic, XNResetState, XIMPreserveState, (char *) 0);
-#endif // !QT_NO_XIM
-}
-
-
-QInputContext::~QInputContext()
-{
-
-#if !defined(QT_NO_XIM)
-    if (ic)
-	XDestroyIC((XIC) ic);
-
-    if ( --fontsetRefCount == 0 ) {
-	Display *dpy = QPaintDevice::x11AppDisplay();
-	for ( int i = 0; i < 8; i++ ) {
-	    if ( fontsetCache[i] && fontsetCache[i] != (XFontSet)-1 ) {
-		XFreeFontSet(dpy, fontsetCache[i]);
-		fontsetCache[i] = 0;
-	    }
-	}
-    }
-
-#endif // !QT_NO_XIM
-
-    ic = 0;
-    focusWidget = 0;
-    composing = FALSE;
-}
-
-
-void QInputContext::reset()
-{
-#if !defined(QT_NO_XIM)
-    if (focusWidget && composing && ! text.isNull()) {
-#ifdef QT_XIM_DEBUG
-	qDebug("QInputContext::reset: composing - sending IMEnd (empty) to %p",
-	       focusWidget);
-#endif // QT_XIM_DEBUG
-
-	QIMEvent endevent(QEvent::IMEnd, QString::null, -1);
-	QApplication::sendEvent(focusWidget, &endevent);
-	focusWidget = 0;
-	text = QString::null;
-	if ( selectedChars.size() < 128 )
-	    selectedChars.resize( 128 );
-	selectedChars.fill( 0 );
-
-	char *mb = XmbResetIC((XIC) ic);
-	if (mb)
-	    XFree(mb);
-    }
-#endif // !QT_NO_XIM
-}
-
-
-void QInputContext::setComposePosition(int x, int y)
-{
-#if !defined(QT_NO_XIM)
-    if (qt_xim && ic) {
-	XPoint point;
-	point.x = x;
-	point.y = y;
-
-	XVaNestedList preedit_attr =
-	    XVaCreateNestedList(0,
-				XNSpotLocation, &point,
-
-				(char *) 0);
-	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
-	XFree(preedit_attr);
-    }
-#endif // !QT_NO_XIM
-}
-
-
-void QInputContext::setComposeArea(int x, int y, int w, int h)
+bool QInputContext::x11FilterEvent( QWidget *keywidget, XEvent *event )
 {
-#if !defined(QT_NO_XIM)
-    if (qt_xim && ic) {
-	XRectangle rect;
-	rect.x = x;
-	rect.y = y;
-	rect.width = w;
-	rect.height = h;
-
-	XVaNestedList preedit_attr = XVaCreateNestedList(0,
-							 XNArea, &rect,
-
-							 (char *) 0);
-	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
-	XFree(preedit_attr);
-    }
-#endif
+    return FALSE;
 }
 
-
-int QInputContext::lookupString(XKeyEvent *event, QCString &chars,
-				KeySym *key, Status *status) const
-{
-    int count = 0;
-
-#if !defined(QT_NO_XIM)
-    if (qt_xim && ic) {
-	count = XmbLookupString((XIC) ic, event, chars.data(),
-				chars.size(), key, status);
-
-	if ((*status) == XBufferOverflow ) {
-	    chars.resize(count + 1);
-	    count = XmbLookupString((XIC) ic, event, chars.data(),
-				    chars.size(), key, status);
-	}
-    }
-
-#endif // QT_NO_XIM
-
-    return count;
-}
-
-void QInputContext::setFocus()
-{
-#if !defined(QT_NO_XIM)
-    if (qt_xim && ic)
-	XSetICFocus((XIC) ic);
-#endif // !QT_NO_XIM
-}
-
-void QInputContext::setXFontSet(const QFont &f)
-{
-#if !defined(QT_NO_XIM)
-    if (font == f) return; // nothing to do
-    font = f;
-
-    XFontSet fs = getFontSet(font);
-    if (fontset == fs) return; // nothing to do
-    fontset = fs;
-
-    XVaNestedList preedit_attr = XVaCreateNestedList(0, XNFontSet, fontset, (char *) 0);
-    XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
-    XFree(preedit_attr);
-#else
-    Q_UNUSED( f );
-#endif
-}
+#endif //Q_NO_IM
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp.orig qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qinputcontext_x11.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,535 @@
+/****************************************************************************
+**
+** Implementation of QInputContext class
+**
+** Copyright (C) 2000-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qplatformdefs.h"
+
+#include "qapplication.h"
+#include "qwidget.h"
+#include "qinputcontext_p.h"
+
+#include <stdlib.h>
+#include <limits.h>
+
+
+bool qt_compose_emptied = FALSE;
+
+#if !defined(QT_NO_XIM)
+
+#define XK_MISCELLANY
+#define XK_LATIN1
+#include <X11/keysymdef.h>
+
+// #define QT_XIM_DEBUG
+
+// from qapplication_x11.cpp
+extern XIM	qt_xim;
+extern XIMStyle	qt_xim_style;
+
+/* The cache here is needed, as X11 leaks a few kb for every
+   XFreeFontSet call, so we avoid creating and deletion of fontsets as
+   much as possible
+*/
+static XFontSet fontsetCache[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+static int fontsetRefCount = 0;
+
+static const char * const fontsetnames[] = {
+    "-*-fixed-medium-r-*-*-16-*,-*-*-medium-r-*-*-16-*",
+    "-*-fixed-medium-i-*-*-16-*,-*-*-medium-i-*-*-16-*",
+    "-*-fixed-bold-r-*-*-16-*,-*-*-bold-r-*-*-16-*",
+    "-*-fixed-bold-i-*-*-16-*,-*-*-bold-i-*-*-16-*",
+    "-*-fixed-medium-r-*-*-24-*,-*-*-medium-r-*-*-24-*",
+    "-*-fixed-medium-i-*-*-24-*,-*-*-medium-i-*-*-24-*",
+    "-*-fixed-bold-r-*-*-24-*,-*-*-bold-r-*-*-24-*",
+    "-*-fixed-bold-i-*-*-24-*,-*-*-bold-i-*-*-24-*"
+};
+
+static XFontSet getFontSet( const QFont &f )
+{
+    int i = 0;
+    if (f.italic())
+	i |= 1;
+    if (f.bold())
+	i |= 2;
+
+    if ( f.pointSize() > 20 )
+	i += 4;
+
+    if ( !fontsetCache[i] ) {
+	Display* dpy = QPaintDevice::x11AppDisplay();
+	int missCount;
+	char** missList;
+	fontsetCache[i] = XCreateFontSet(dpy, fontsetnames[i], &missList, &missCount, 0);
+	if(missCount > 0)
+	    XFreeStringList(missList);
+	if ( !fontsetCache[i] ) {
+	    fontsetCache[i] = XCreateFontSet(dpy,  "-*-fixed-*-*-*-*-16-*", &missList, &missCount, 0);
+	    if(missCount > 0)
+		XFreeStringList(missList);
+	    if ( !fontsetCache[i] )
+		fontsetCache[i] = (XFontSet)-1;
+	}
+    }
+    return (fontsetCache[i] == (XFontSet)-1) ? 0 : fontsetCache[i];
+}
+
+
+#ifdef Q_C_CALLBACKS
+extern "C" {
+#endif // Q_C_CALLBACKS
+
+    static int xic_start_callback(XIC, XPointer client_data, XPointer) {
+	QInputContext *qic = (QInputContext *) client_data;
+	if (! qic) {
+#ifdef QT_XIM_DEBUG
+	    qDebug("compose start: no qic");
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	qic->composing = TRUE;
+	qic->text = QString::null;
+	qic->focusWidget = 0;
+
+	if ( qic->selectedChars.size() < 128 )
+	    qic->selectedChars.resize( 128 );
+	qic->selectedChars.fill( 0 );
+
+#ifdef QT_XIM_DEBUG
+	qDebug("compose start");
+#endif // QT_XIM_DEBUG
+
+	return 0;
+    }
+
+    static int xic_draw_callback(XIC, XPointer client_data, XPointer call_data) {
+	QInputContext *qic = (QInputContext *) client_data;
+	if (! qic) {
+#ifdef QT_XIM_DEBUG
+	    qDebug("compose event: invalid compose event %p", qic);
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	bool send_imstart = FALSE;
+	if (qApp->focusWidget() != qic->focusWidget && qic->text.isEmpty()) {
+	    if (qic->focusWidget) {
+#ifdef QT_XIM_DEBUG
+		qDebug( "sending IMEnd (empty) to %p", qic->focusWidget );
+#endif // QT_XIM_DEBUG
+
+		QIMEvent endevent(QEvent::IMEnd, QString::null, -1);
+		QApplication::sendEvent(qic->focusWidget, &endevent);
+	    }
+
+	    qic->text = QString::null;
+	    qic->focusWidget = qApp->focusWidget();
+	    qic->composing = FALSE;
+
+	    if ( qic->selectedChars.size() < 128 )
+		qic->selectedChars.resize( 128 );
+	    qic->selectedChars.fill( 0 );
+
+	    if (qic->focusWidget) {
+		qic->composing = TRUE;
+		send_imstart = TRUE;
+	    }
+	}
+
+	if (! qic->composing || ! qic->focusWidget) {
+#ifdef QT_XIM_DEBUG
+	    qDebug("compose event: invalid compose event %d %p",
+		   qic->composing, qic->focusWidget);
+#endif // QT_XIM_DEBUG
+
+	    return 0;
+	}
+
+	if ( send_imstart ) {
+#ifdef QT_XIM_DEBUG
+            qDebug( "sending IMStart to %p", qic->focusWidget );
+#endif // QT_XIM_DEBUG
+
+	    qt_compose_emptied = FALSE;
+	    QIMEvent startevent(QEvent::IMStart, QString::null, -1);
+	    QApplication::sendEvent(qic->focusWidget, &startevent);
+	}
+
+	XIMPreeditDrawCallbackStruct *drawstruct =
+	    (XIMPreeditDrawCallbackStruct *) call_data;
+	XIMText *text = (XIMText *) drawstruct->text;
+	int cursor = drawstruct->caret, sellen = 0;
+
+	if ( ! drawstruct->caret && ! drawstruct->chg_first &&
+	     ! drawstruct->chg_length && ! text ) {
+	    // nothing to do
+	    return 0;
+	}
+
+	if (text) {
+	    char *str = 0;
+	    if (text->encoding_is_wchar) {
+		int l = wcstombs(NULL, text->string.wide_char, text->length);
+		if (l != -1) {
+		    str = new char[l + 1];
+		    wcstombs(str, text->string.wide_char, l);
+		    str[l] = 0;
+		}
+	    } else
+		str = text->string.multi_byte;
+
+	    if (! str)
+		return 0;
+
+	    QString s = QString::fromLocal8Bit(str);
+
+	    if (text->encoding_is_wchar)
+		delete [] str;
+
+	    if (drawstruct->chg_length < 0)
+		qic->text.replace(drawstruct->chg_first, UINT_MAX, s);
+	    else
+		qic->text.replace(drawstruct->chg_first, drawstruct->chg_length, s);
+
+	    if ( qic->selectedChars.size() < qic->text.length() ) {
+		// expand the selectedChars array if the compose string is longer
+		uint from = qic->selectedChars.size();
+		qic->selectedChars.resize( qic->text.length() );
+		for ( uint x = from; from < qic->selectedChars.size(); ++x )
+		    qic->selectedChars[x] = 0;
+	    }
+
+	    uint x;
+	    bool *p = qic->selectedChars.data() + drawstruct->chg_first;
+	    // determine if the changed chars are selected based on text->feedback
+	    for ( x = 0; x < s.length(); ++x )
+		*p++ = ( text->feedback ? ( text->feedback[x] & XIMReverse ) : 0 );
+
+	    // figure out where the selection starts, and how long it is
+	    p = qic->selectedChars.data();
+	    bool started = FALSE;
+	    for ( x = 0; x < QMIN(qic->text.length(), qic->selectedChars.size()); ++x ) {
+		if ( started ) {
+		    if ( *p ) ++sellen;
+		    else break;
+		} else {
+		    if ( *p ) {
+			cursor = x;
+			started = TRUE;
+			sellen = 1;
+		    }
+		}
+		++p;
+	    }
+	} else {
+	    if (drawstruct->chg_length == 0)
+		drawstruct->chg_length = -1;
+
+	    qic->text.remove(drawstruct->chg_first, drawstruct->chg_length);
+	    qt_compose_emptied = qic->text.isEmpty();
+	    if ( qt_compose_emptied ) {
+#ifdef QT_XIM_DEBUG
+		qDebug( "compose emptied" );
+#endif // QT_XIM_DEBUG
+
+		// don't send an empty compose, since we will send an IMEnd with
+		// either the correct compose text (or null text if the user has
+		// cancelled the compose or deleted all chars).
+		return 0;
+	    }
+	}
+
+#ifdef QT_XIM_DEBUG
+	qDebug( "sending IMCompose to %p with %d chars",
+                qic->focusWidget, qic->text.length() );
+#endif // QT_XIM_DEBUG
+
+	QIMComposeEvent event( QEvent::IMCompose, qic->text, cursor, sellen );
+	QApplication::sendEvent(qic->focusWidget, &event);
+	return 0;
+    }
+
+    static int xic_done_callback(XIC, XPointer client_data, XPointer) {
+	QInputContext *qic = (QInputContext *) client_data;
+	if (! qic)
+	    return 0;
+
+	if (qic->composing && qic->focusWidget) {
+#ifdef QT_XIM_DEBUG
+	    qDebug( "sending IMEnd (empty) to %p", qic->focusWidget );
+#endif // QT_XIM_DEBUG
+
+       	    QIMEvent event(QEvent::IMEnd, QString::null, -1);
+	    QApplication::sendEvent(qic->focusWidget, &event);
+	}
+
+	qic->composing = FALSE;
+	qic->focusWidget = 0;
+
+	if ( qic->selectedChars.size() < 128 )
+	    qic->selectedChars.resize( 128 );
+	qic->selectedChars.fill( 0 );
+
+	return 0;
+    }
+
+#ifdef Q_C_CALLBACKS
+}
+#endif // Q_C_CALLBACKS
+
+#endif // !QT_NO_XIM
+
+
+
+QInputContext::QInputContext(QWidget *widget)
+    : ic(0), focusWidget(0), composing(FALSE), fontset(0)
+{
+#if !defined(QT_NO_XIM)
+    fontsetRefCount++;
+    if (! qt_xim) {
+	qWarning("QInputContext: no input method context available");
+	return;
+    }
+
+    if (! widget->isTopLevel()) {
+	qWarning("QInputContext: cannot create input context for non-toplevel widgets");
+	return;
+    }
+
+    XPoint spot;
+    XRectangle rect;
+    XVaNestedList preedit_attr = 0;
+    XIMCallback startcallback, drawcallback, donecallback;
+
+    font = widget->font();
+    fontset = getFontSet( font );
+
+    if (qt_xim_style & XIMPreeditArea) {
+	rect.x = 0;
+	rect.y = 0;
+	rect.width = widget->width();
+	rect.height = widget->height();
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNArea, &rect,
+					   XNFontSet, fontset,
+					   (char *) 0);
+    } else if (qt_xim_style & XIMPreeditPosition) {
+	spot.x = 1;
+	spot.y = 1;
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNSpotLocation, &spot,
+					   XNFontSet, fontset,
+					   (char *) 0);
+    } else if (qt_xim_style & XIMPreeditCallbacks) {
+	startcallback.client_data = (XPointer) this;
+	startcallback.callback = (XIMProc) xic_start_callback;
+	drawcallback.client_data = (XPointer) this;
+	drawcallback.callback = (XIMProc)xic_draw_callback;
+	donecallback.client_data = (XPointer) this;
+	donecallback.callback = (XIMProc) xic_done_callback;
+
+	preedit_attr = XVaCreateNestedList(0,
+					   XNPreeditStartCallback, &startcallback,
+					   XNPreeditDrawCallback, &drawcallback,
+					   XNPreeditDoneCallback, &donecallback,
+					   (char *) 0);
+    }
+
+    if (preedit_attr) {
+	ic = XCreateIC(qt_xim,
+		       XNInputStyle, qt_xim_style,
+		       XNClientWindow, widget->winId(),
+		       XNPreeditAttributes, preedit_attr,
+		       (char *) 0);
+	XFree(preedit_attr);
+    } else
+	ic = XCreateIC(qt_xim,
+		       XNInputStyle, qt_xim_style,
+		       XNClientWindow, widget->winId(),
+		       (char *) 0);
+
+    if (! ic)
+	qFatal("Failed to create XIM input context!");
+
+    // when resetting the input context, preserve the input state
+    (void) XSetICValues((XIC) ic, XNResetState, XIMPreserveState, (char *) 0);
+#endif // !QT_NO_XIM
+}
+
+
+QInputContext::~QInputContext()
+{
+
+#if !defined(QT_NO_XIM)
+    if (ic)
+	XDestroyIC((XIC) ic);
+
+    if ( --fontsetRefCount == 0 ) {
+	Display *dpy = QPaintDevice::x11AppDisplay();
+	for ( int i = 0; i < 8; i++ ) {
+	    if ( fontsetCache[i] && fontsetCache[i] != (XFontSet)-1 ) {
+		XFreeFontSet(dpy, fontsetCache[i]);
+		fontsetCache[i] = 0;
+	    }
+	}
+    }
+
+#endif // !QT_NO_XIM
+
+    ic = 0;
+    focusWidget = 0;
+    composing = FALSE;
+}
+
+
+void QInputContext::reset()
+{
+#if !defined(QT_NO_XIM)
+    if (focusWidget && composing && ! text.isNull()) {
+#ifdef QT_XIM_DEBUG
+	qDebug("QInputContext::reset: composing - sending IMEnd (empty) to %p",
+	       focusWidget);
+#endif // QT_XIM_DEBUG
+
+	QIMEvent endevent(QEvent::IMEnd, QString::null, -1);
+	QApplication::sendEvent(focusWidget, &endevent);
+	focusWidget = 0;
+	text = QString::null;
+	if ( selectedChars.size() < 128 )
+	    selectedChars.resize( 128 );
+	selectedChars.fill( 0 );
+
+	char *mb = XmbResetIC((XIC) ic);
+	if (mb)
+	    XFree(mb);
+    }
+#endif // !QT_NO_XIM
+}
+
+
+void QInputContext::setComposePosition(int x, int y)
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	XPoint point;
+	point.x = x;
+	point.y = y;
+
+	XVaNestedList preedit_attr =
+	    XVaCreateNestedList(0,
+				XNSpotLocation, &point,
+
+				(char *) 0);
+	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+	XFree(preedit_attr);
+    }
+#endif // !QT_NO_XIM
+}
+
+
+void QInputContext::setComposeArea(int x, int y, int w, int h)
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	XRectangle rect;
+	rect.x = x;
+	rect.y = y;
+	rect.width = w;
+	rect.height = h;
+
+	XVaNestedList preedit_attr = XVaCreateNestedList(0,
+							 XNArea, &rect,
+
+							 (char *) 0);
+	XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+	XFree(preedit_attr);
+    }
+#endif
+}
+
+
+int QInputContext::lookupString(XKeyEvent *event, QCString &chars,
+				KeySym *key, Status *status) const
+{
+    int count = 0;
+
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic) {
+	count = XmbLookupString((XIC) ic, event, chars.data(),
+				chars.size(), key, status);
+
+	if ((*status) == XBufferOverflow ) {
+	    chars.resize(count + 1);
+	    count = XmbLookupString((XIC) ic, event, chars.data(),
+				    chars.size(), key, status);
+	}
+    }
+
+#endif // QT_NO_XIM
+
+    return count;
+}
+
+void QInputContext::setFocus()
+{
+#if !defined(QT_NO_XIM)
+    if (qt_xim && ic)
+	XSetICFocus((XIC) ic);
+#endif // !QT_NO_XIM
+}
+
+void QInputContext::setXFontSet(const QFont &f)
+{
+#if !defined(QT_NO_XIM)
+    if (font == f) return; // nothing to do
+    font = f;
+
+    XFontSet fs = getFontSet(font);
+    if (fontset == fs) return; // nothing to do
+    fontset = fs;
+
+    XVaNestedList preedit_attr = XVaCreateNestedList(0, XNFontSet, fontset, (char *) 0);
+    XSetICValues((XIC) ic, XNPreeditAttributes, preedit_attr, (char *) 0);
+    XFree(preedit_attr);
+#else
+    Q_UNUSED( f );
+#endif
+}
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qnamespace.h qt-x11-free-3.3.8b/src/kernel/qnamespace.h
--- qt-x11-free-3.3.8b/src/kernel/qnamespace.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qnamespace.h	2009-10-18 14:38:39.181875955 -0700
@@ -401,4 +401,85 @@
 	Key_Direction_L = 0x1059,
 	Key_Direction_R = 0x1060,
+
+	// International input method support (X keycode - 0xEE00, the
+	// definition follows Qt/Embedded 2.3.7) Only interesting if
+	// you are writing your own input method
+        
+	// International & multi-key character composition
+	Key_Multi_key           = 0x1120,  // Multi-key character compose
+	Key_Codeinput           = 0x1137,
+	Key_SingleCandidate     = 0x113c,
+	Key_MultipleCandidate   = 0x113d,
+	Key_PreviousCandidate   = 0x113e,
+
+	// Misc Functions
+	Key_Mode_switch         = 0x117e,  // Character set switch
+	//Key_script_switch       = 0x117e,  // Alias for mode_switch
+
+	// Japanese keyboard support
+	Key_Kanji               = 0x1121,  // Kanji, Kanji convert
+	Key_Muhenkan            = 0x1122,  // Cancel Conversion
+	//Key_Henkan_Mode         = 0x1123,  // Start/Stop Conversion
+	Key_Henkan              = 0x1123,  // Alias for Henkan_Mode
+	Key_Romaji              = 0x1124,  // to Romaji
+	Key_Hiragana            = 0x1125,  // to Hiragana
+	Key_Katakana            = 0x1126,  // to Katakana
+	Key_Hiragana_Katakana   = 0x1127,  // Hiragana/Katakana toggle
+	Key_Zenkaku             = 0x1128,  // to Zenkaku
+	Key_Hankaku             = 0x1129,  // to Hankaku
+	Key_Zenkaku_Hankaku     = 0x112a,  // Zenkaku/Hankaku toggle
+	Key_Touroku             = 0x112b,  // Add to Dictionary
+	Key_Massyo              = 0x112c,  // Delete from Dictionary
+	Key_Kana_Lock           = 0x112d,  // Kana Lock
+	Key_Kana_Shift          = 0x112e,  // Kana Shift
+	Key_Eisu_Shift          = 0x112f,  // Alphanumeric Shift
+	Key_Eisu_toggle         = 0x1130,  // Alphanumeric toggle
+	//Key_Kanji_Bangou        = 0x1137,  // Codeinput
+	//Key_Zen_Koho            = 0x113d,  // Multiple/All Candidate(s)
+	//Key_Mae_Koho            = 0x113e,  // Previous Candidate
+
+	// Korean keyboard support
+	//
+	// In fact, many Korean users need only 2 keys, Key_Hangul and
+	// Key_Hangul_Hanja. But rest of the keys are good for future.
+
+	Key_Hangul              = 0x1131,  // Hangul start/stop(toggle)
+	Key_Hangul_Start        = 0x1132,  // Hangul start
+	Key_Hangul_End          = 0x1133,  // Hangul end, English start
+	Key_Hangul_Hanja        = 0x1134,  // Start Hangul->Hanja Conversion
+	Key_Hangul_Jamo         = 0x1135,  // Hangul Jamo mode
+	Key_Hangul_Romaja       = 0x1136,  // Hangul Romaja mode
+	//Key_Hangul_Codeinput    = 0x1137,  // Hangul code input mode
+	Key_Hangul_Jeonja       = 0x1138,  // Jeonja mode
+	Key_Hangul_Banja        = 0x1139,  // Banja mode
+	Key_Hangul_PreHanja     = 0x113a,  // Pre Hanja conversion
+	Key_Hangul_PostHanja    = 0x113b,  // Post Hanja conversion
+	//Key_Hangul_SingleCandidate   = 0x113c,  // Single candidate
+	//Key_Hangul_MultipleCandidate = 0x113d,  // Multiple candidate
+	//Key_Hangul_PreviousCandidate = 0x113e,  // Previous candidate
+	Key_Hangul_Special      = 0x113f,  // Special symbols
+	//Key_Hangul_switch       = 0x117e,  // Alias for mode_switch
+
+        // dead keys (X keycode - 0xED00 to avoid the conflict)
+        Key_Dead_Grave          = 0x1250,
+        Key_Dead_Acute          = 0x1251,
+        Key_Dead_Circumflex     = 0x1252,
+        Key_Dead_Tilde          = 0x1253,
+        Key_Dead_Macron         = 0x1254,
+        Key_Dead_Breve          = 0x1255,
+        Key_Dead_Abovedot       = 0x1256,
+        Key_Dead_Diaeresis      = 0x1257,
+        Key_Dead_Abovering      = 0x1258,
+        Key_Dead_Doubleacute    = 0x1259,
+        Key_Dead_Caron          = 0x125a,
+        Key_Dead_Cedilla        = 0x125b,
+        Key_Dead_Ogonek         = 0x125c,
+        Key_Dead_Iota           = 0x125d,
+        Key_Dead_Voiced_Sound   = 0x125e,
+        Key_Dead_Semivoiced_Sound = 0x125f,
+        Key_Dead_Belowdot       = 0x1260,
+        Key_Dead_Hook           = 0x1261,
+        Key_Dead_Horn           = 0x1262,
+
 	Key_Space = 0x20,		// 7 bit printable ASCII
 	Key_Any = Key_Space,
@@ -473,4 +554,9 @@
 
 	// Latin 1 codes adapted from X: keysymdef.h,v 1.21 94/08/28 16:17:06
+	//
+	// This is mainly for compatibility - applications and input
+	// methods should not use the Qt keycodes between 128 and 255,
+	// but should rather use the QKeyEvent::text(). See
+	// QETWidget::translateKeyEventInternal() for more details.
 
 	Key_nobreakspace = 0x0a0,
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qnamespace.h.orig qt-x11-free-3.3.8b/src/kernel/qnamespace.h.orig
--- qt-x11-free-3.3.8b/src/kernel/qnamespace.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qnamespace.h.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,920 @@
+/****************************************************************************
+**
+** Definition of Qt namespace (as class for compiler compatibility)
+**
+** Created : 980927
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QNAMESPACE_H
+#define QNAMESPACE_H
+
+#ifndef QT_H
+#include "qglobal.h"
+#endif // QT_H
+
+
+class QColor;
+class QCursor;
+
+
+class Q_EXPORT Qt {
+public:
+    QT_STATIC_CONST QColor & color0;
+    QT_STATIC_CONST QColor & color1;
+    QT_STATIC_CONST QColor & black;
+    QT_STATIC_CONST QColor & white;
+    QT_STATIC_CONST QColor & darkGray;
+    QT_STATIC_CONST QColor & gray;
+    QT_STATIC_CONST QColor & lightGray;
+    QT_STATIC_CONST QColor & red;
+    QT_STATIC_CONST QColor & green;
+    QT_STATIC_CONST QColor & blue;
+    QT_STATIC_CONST QColor & cyan;
+    QT_STATIC_CONST QColor & magenta;
+    QT_STATIC_CONST QColor & yellow;
+    QT_STATIC_CONST QColor & darkRed;
+    QT_STATIC_CONST QColor & darkGreen;
+    QT_STATIC_CONST QColor & darkBlue;
+    QT_STATIC_CONST QColor & darkCyan;
+    QT_STATIC_CONST QColor & darkMagenta;
+    QT_STATIC_CONST QColor & darkYellow;
+
+    // documented in qevent.cpp
+    enum ButtonState {				// mouse/keyboard state values
+	NoButton	= 0x0000,
+	LeftButton	= 0x0001,
+	RightButton	= 0x0002,
+	MidButton	= 0x0004,
+	MouseButtonMask = 0x0007,
+	ShiftButton	= 0x0100,
+	ControlButton   = 0x0200,
+	AltButton	= 0x0400,
+	MetaButton	= 0x0800,
+	KeyButtonMask	= 0x0f00,
+	Keypad		= 0x4000
+    };
+
+    // documented in qobject.cpp
+    // ideally would start at 1, as in QSizePolicy, but that breaks other things
+    enum Orientation {
+        Horizontal = 0,
+	Vertical
+    };
+
+    // documented in qlistview.cpp
+    enum SortOrder {
+	Ascending,
+	Descending
+    };
+
+    // Text formatting flags for QPainter::drawText and QLabel
+    // the following four enums can be combined to one integer which
+    // is passed as textflag to drawText and qt_format_text.
+
+    // documented in qpainter.cpp
+    enum AlignmentFlags {
+	AlignAuto		= 0x0000, 	// text alignment
+	AlignLeft		= 0x0001,
+	AlignRight		= 0x0002,
+	AlignHCenter		= 0x0004,
+	AlignJustify		= 0x0008,
+	AlignHorizontal_Mask	= AlignLeft | AlignRight | AlignHCenter | AlignJustify,
+	AlignTop		= 0x0010,
+	AlignBottom		= 0x0020,
+	AlignVCenter		= 0x0040,
+	AlignVertical_Mask 	= AlignTop | AlignBottom | AlignVCenter,
+	AlignCenter		= AlignVCenter | AlignHCenter
+    };
+
+    // documented in qpainter.cpp
+    enum TextFlags {
+	SingleLine	= 0x0080,		// misc. flags
+	DontClip	= 0x0100,
+	ExpandTabs	= 0x0200,
+	ShowPrefix	= 0x0400,
+	WordBreak	= 0x0800,
+	BreakAnywhere = 0x1000,
+#ifndef Q_QDOC
+	DontPrint	= 0x2000,
+	Underline = 0x01000000,
+	Overline  = 0x02000000,
+	StrikeOut = 0x04000000,
+	IncludeTrailingSpaces = 0x08000000,
+#endif
+	NoAccel = 0x4000
+    };
+
+    // Widget flags; documented in qwidget.cpp
+    typedef uint WState;
+
+    // QWidget state flags (internal, barely documented in qwidget.cpp)
+    enum WidgetState {
+	WState_Created		= 0x00000001,
+	WState_Disabled		= 0x00000002,
+	WState_Visible		= 0x00000004,
+	WState_ForceHide	= 0x00000008,
+	WState_OwnCursor	= 0x00000010,
+	WState_MouseTracking	= 0x00000020,
+	WState_CompressKeys	= 0x00000040,
+	WState_BlockUpdates	= 0x00000080,
+	WState_InPaintEvent	= 0x00000100,
+	WState_Reparented	= 0x00000200,
+	WState_ConfigPending	= 0x00000400,
+	WState_Resized		= 0x00000800,
+	WState_AutoMask		= 0x00001000,
+	WState_Polished		= 0x00002000,
+	WState_DND		= 0x00004000,
+	WState_Reserved0	= 0x00008000,
+	WState_FullScreen	= 0x00010000,
+	WState_OwnSizePolicy	= 0x00020000,
+	WState_CreatedHidden	= 0x00040000,
+	WState_Maximized	= 0x00080000,
+	WState_Minimized	= 0x00100000,
+	WState_ForceDisabled	= 0x00200000,
+	WState_Exposed		= 0x00400000,
+	WState_HasMouse		= 0x00800000
+    };
+
+    // Widget flags2; documented in qwidget.cpp
+    typedef uint WFlags;
+
+    // documented in qwidget.cpp
+    enum WidgetFlags {
+	WType_TopLevel		= 0x00000001,	// widget type flags
+	WType_Dialog		= 0x00000002,
+	WType_Popup		= 0x00000004,
+	WType_Desktop		= 0x00000008,
+	WType_Mask		= 0x0000000f,
+
+	WStyle_Customize	= 0x00000010,	// window style flags
+	WStyle_NormalBorder	= 0x00000020,
+	WStyle_DialogBorder	= 0x00000040, // MS-Windows only
+	WStyle_NoBorder		= 0x00002000,
+	WStyle_Title		= 0x00000080,
+	WStyle_SysMenu		= 0x00000100,
+	WStyle_Minimize		= 0x00000200,
+	WStyle_Maximize		= 0x00000400,
+	WStyle_MinMax		= WStyle_Minimize | WStyle_Maximize,
+	WStyle_Tool		= 0x00000800,
+	WStyle_StaysOnTop	= 0x00001000,
+	WStyle_ContextHelp	= 0x00004000,
+	WStyle_Reserved		= 0x00008000,
+	WStyle_Mask		= 0x0000fff0,
+
+	WDestructiveClose	= 0x00010000,	// misc flags
+	WPaintDesktop		= 0x00020000,
+	WPaintUnclipped		= 0x00040000,
+	WPaintClever		= 0x00080000,
+	WResizeNoErase		= 0x00100000, // OBSOLETE
+	WMouseNoMask		= 0x00200000,
+	WStaticContents		= 0x00400000,
+	WRepaintNoErase		= 0x00800000, // OBSOLETE
+#if defined(Q_WS_X11)
+	WX11BypassWM		= 0x01000000,
+	WWinOwnDC		= 0x00000000,
+	WMacNoSheet             = 0x00000000,
+        WMacDrawer              = 0x00000000,
+#elif defined(Q_WS_MAC)
+	WX11BypassWM		= 0x00000000,
+	WWinOwnDC		= 0x00000000,
+	WMacNoSheet             = 0x01000000,
+        WMacDrawer              = 0x20000000,
+#else
+	WX11BypassWM		= 0x00000000,
+	WWinOwnDC		= 0x01000000,
+	WMacNoSheet             = 0x00000000,
+        WMacDrawer              = 0x00000000,
+#endif
+	WGroupLeader		= 0x02000000,
+	WShowModal		= 0x04000000,
+	WNoMousePropagation	= 0x08000000,
+	WSubWindow              = 0x10000000,
+#if defined(Q_WS_X11)
+        WStyle_Splash           = 0x20000000,
+#else
+	WStyle_Splash           = WStyle_NoBorder | WMacNoSheet | WStyle_Tool | WWinOwnDC,
+#endif
+	WNoAutoErase		= WRepaintNoErase | WResizeNoErase
+#ifndef QT_NO_COMPAT
+	,
+	WNorthWestGravity	= WStaticContents,
+	WType_Modal		= WType_Dialog | WShowModal,
+	WStyle_Dialog		= WType_Dialog,
+	WStyle_NoBorderEx	= WStyle_NoBorder
+#endif
+    };
+
+    enum WindowState {
+	WindowNoState   = 0x00000000,
+	WindowMinimized = 0x00000001,
+	WindowMaximized = 0x00000002,
+	WindowFullScreen = 0x00000004,
+	WindowActive = 0x00000008
+    };
+
+
+    // Image conversion flags.  The unusual ordering is caused by
+    // compatibility and default requirements.
+    // Documented in qimage.cpp
+
+    enum ImageConversionFlags {
+	ColorMode_Mask		= 0x00000003,
+	AutoColor		= 0x00000000,
+	ColorOnly		= 0x00000003,
+	MonoOnly		= 0x00000002,
+	//	  Reserved	= 0x00000001,
+
+	AlphaDither_Mask	= 0x0000000c,
+	ThresholdAlphaDither	= 0x00000000,
+	OrderedAlphaDither	= 0x00000004,
+	DiffuseAlphaDither	= 0x00000008,
+	NoAlpha			= 0x0000000c, // Not supported
+
+	Dither_Mask		= 0x00000030,
+	DiffuseDither		= 0x00000000,
+	OrderedDither		= 0x00000010,
+	ThresholdDither		= 0x00000020,
+	//	  ReservedDither= 0x00000030,
+
+	DitherMode_Mask		= 0x000000c0,
+	AutoDither		= 0x00000000,
+	PreferDither		= 0x00000040,
+	AvoidDither		= 0x00000080
+    };
+
+    // documented in qpainter.cpp
+    enum BGMode	{				// background mode
+	TransparentMode,
+	OpaqueMode
+    };
+
+#ifndef QT_NO_COMPAT
+    // documented in qpainter.cpp
+    enum PaintUnit {				// paint unit
+	PixelUnit,
+	LoMetricUnit, // OBSOLETE
+	HiMetricUnit, // OBSOLETE
+	LoEnglishUnit, // OBSOLETE
+	HiEnglishUnit, // OBSOLETE
+	TwipsUnit // OBSOLETE
+    };
+#endif
+
+    // documented in qstyle.cpp
+#ifdef QT_NO_COMPAT
+    enum GUIStyle {
+	WindowsStyle = 1,     // ### Qt 4.0: either remove the obsolete enums or clean up compat vs.
+	MotifStyle = 4        // ### QT_NO_COMPAT by reordering or combination into one enum.
+    };
+#else
+    enum GUIStyle {
+	MacStyle, // OBSOLETE
+	WindowsStyle,
+	Win3Style, // OBSOLETE
+	PMStyle, // OBSOLETE
+	MotifStyle
+    };
+#endif
+
+    // documented in qkeysequence.cpp
+    enum SequenceMatch {
+	NoMatch,
+	PartialMatch,
+	Identical
+    };
+
+    // documented in qevent.cpp
+    enum Modifier {		// accelerator modifiers
+	META          = 0x00100000,
+	SHIFT         = 0x00200000,
+	CTRL          = 0x00400000,
+	ALT           = 0x00800000,
+	MODIFIER_MASK = 0x00f00000,
+	UNICODE_ACCEL = 0x10000000,
+
+	ASCII_ACCEL = UNICODE_ACCEL // 1.x compat
+    };
+
+    // documented in qevent.cpp
+    enum Key {
+	Key_Escape = 0x1000,		// misc keys
+	Key_Tab = 0x1001,
+	Key_Backtab = 0x1002, Key_BackTab = Key_Backtab,
+	Key_Backspace = 0x1003, Key_BackSpace = Key_Backspace,
+	Key_Return = 0x1004,
+	Key_Enter = 0x1005,
+	Key_Insert = 0x1006,
+	Key_Delete = 0x1007,
+	Key_Pause = 0x1008,
+	Key_Print = 0x1009,
+	Key_SysReq = 0x100a,
+	Key_Clear = 0x100b,
+	Key_Home = 0x1010,		// cursor movement
+	Key_End = 0x1011,
+	Key_Left = 0x1012,
+	Key_Up = 0x1013,
+	Key_Right = 0x1014,
+	Key_Down = 0x1015,
+	Key_Prior = 0x1016, Key_PageUp = Key_Prior,
+	Key_Next = 0x1017, Key_PageDown = Key_Next,
+	Key_Shift = 0x1020,		// modifiers
+	Key_Control = 0x1021,
+	Key_Meta = 0x1022,
+	Key_Alt = 0x1023,
+	Key_CapsLock = 0x1024,
+	Key_NumLock = 0x1025,
+	Key_ScrollLock = 0x1026,
+	Key_F1 = 0x1030,		// function keys
+	Key_F2 = 0x1031,
+	Key_F3 = 0x1032,
+	Key_F4 = 0x1033,
+	Key_F5 = 0x1034,
+	Key_F6 = 0x1035,
+	Key_F7 = 0x1036,
+	Key_F8 = 0x1037,
+	Key_F9 = 0x1038,
+	Key_F10 = 0x1039,
+	Key_F11 = 0x103a,
+	Key_F12 = 0x103b,
+	Key_F13 = 0x103c,
+	Key_F14 = 0x103d,
+	Key_F15 = 0x103e,
+	Key_F16 = 0x103f,
+	Key_F17 = 0x1040,
+	Key_F18 = 0x1041,
+	Key_F19 = 0x1042,
+	Key_F20 = 0x1043,
+	Key_F21 = 0x1044,
+	Key_F22 = 0x1045,
+	Key_F23 = 0x1046,
+	Key_F24 = 0x1047,
+	Key_F25 = 0x1048,		// F25 .. F35 only on X11
+	Key_F26 = 0x1049,
+	Key_F27 = 0x104a,
+	Key_F28 = 0x104b,
+	Key_F29 = 0x104c,
+	Key_F30 = 0x104d,
+	Key_F31 = 0x104e,
+	Key_F32 = 0x104f,
+	Key_F33 = 0x1050,
+	Key_F34 = 0x1051,
+	Key_F35 = 0x1052,
+	Key_Super_L = 0x1053, 		// extra keys
+	Key_Super_R = 0x1054,
+	Key_Menu = 0x1055,
+	Key_Hyper_L = 0x1056,
+	Key_Hyper_R = 0x1057,
+	Key_Help = 0x1058,
+	Key_Direction_L = 0x1059,
+	Key_Direction_R = 0x1060,
+	Key_Space = 0x20,		// 7 bit printable ASCII
+	Key_Any = Key_Space,
+	Key_Exclam = 0x21,
+	Key_QuoteDbl = 0x22,
+	Key_NumberSign = 0x23,
+	Key_Dollar = 0x24,
+	Key_Percent = 0x25,
+	Key_Ampersand = 0x26,
+	Key_Apostrophe = 0x27,
+	Key_ParenLeft = 0x28,
+	Key_ParenRight = 0x29,
+	Key_Asterisk = 0x2a,
+	Key_Plus = 0x2b,
+	Key_Comma = 0x2c,
+	Key_Minus = 0x2d,
+	Key_Period = 0x2e,
+	Key_Slash = 0x2f,
+	Key_0 = 0x30,
+	Key_1 = 0x31,
+	Key_2 = 0x32,
+	Key_3 = 0x33,
+	Key_4 = 0x34,
+	Key_5 = 0x35,
+	Key_6 = 0x36,
+	Key_7 = 0x37,
+	Key_8 = 0x38,
+	Key_9 = 0x39,
+	Key_Colon = 0x3a,
+	Key_Semicolon = 0x3b,
+	Key_Less = 0x3c,
+	Key_Equal = 0x3d,
+	Key_Greater = 0x3e,
+	Key_Question = 0x3f,
+	Key_At = 0x40,
+	Key_A = 0x41,
+	Key_B = 0x42,
+	Key_C = 0x43,
+	Key_D = 0x44,
+	Key_E = 0x45,
+	Key_F = 0x46,
+	Key_G = 0x47,
+	Key_H = 0x48,
+	Key_I = 0x49,
+	Key_J = 0x4a,
+	Key_K = 0x4b,
+	Key_L = 0x4c,
+	Key_M = 0x4d,
+	Key_N = 0x4e,
+	Key_O = 0x4f,
+	Key_P = 0x50,
+	Key_Q = 0x51,
+	Key_R = 0x52,
+	Key_S = 0x53,
+	Key_T = 0x54,
+	Key_U = 0x55,
+	Key_V = 0x56,
+	Key_W = 0x57,
+	Key_X = 0x58,
+	Key_Y = 0x59,
+	Key_Z = 0x5a,
+	Key_BracketLeft = 0x5b,
+	Key_Backslash = 0x5c,
+	Key_BracketRight = 0x5d,
+	Key_AsciiCircum = 0x5e,
+	Key_Underscore = 0x5f,
+	Key_QuoteLeft = 0x60,
+	Key_BraceLeft = 0x7b,
+	Key_Bar = 0x7c,
+	Key_BraceRight = 0x7d,
+	Key_AsciiTilde = 0x7e,
+
+	// Latin 1 codes adapted from X: keysymdef.h,v 1.21 94/08/28 16:17:06
+
+	Key_nobreakspace = 0x0a0,
+	Key_exclamdown = 0x0a1,
+	Key_cent = 0x0a2,
+	Key_sterling = 0x0a3,
+	Key_currency = 0x0a4,
+	Key_yen = 0x0a5,
+	Key_brokenbar = 0x0a6,
+	Key_section = 0x0a7,
+	Key_diaeresis = 0x0a8,
+	Key_copyright = 0x0a9,
+	Key_ordfeminine = 0x0aa,
+	Key_guillemotleft = 0x0ab,	// left angle quotation mark
+	Key_notsign = 0x0ac,
+	Key_hyphen = 0x0ad,
+	Key_registered = 0x0ae,
+	Key_macron = 0x0af,
+	Key_degree = 0x0b0,
+	Key_plusminus = 0x0b1,
+	Key_twosuperior = 0x0b2,
+	Key_threesuperior = 0x0b3,
+	Key_acute = 0x0b4,
+	Key_mu = 0x0b5,
+	Key_paragraph = 0x0b6,
+	Key_periodcentered = 0x0b7,
+	Key_cedilla = 0x0b8,
+	Key_onesuperior = 0x0b9,
+	Key_masculine = 0x0ba,
+	Key_guillemotright = 0x0bb,	// right angle quotation mark
+	Key_onequarter = 0x0bc,
+	Key_onehalf = 0x0bd,
+	Key_threequarters = 0x0be,
+	Key_questiondown = 0x0bf,
+	Key_Agrave = 0x0c0,
+	Key_Aacute = 0x0c1,
+	Key_Acircumflex = 0x0c2,
+	Key_Atilde = 0x0c3,
+	Key_Adiaeresis = 0x0c4,
+	Key_Aring = 0x0c5,
+	Key_AE = 0x0c6,
+	Key_Ccedilla = 0x0c7,
+	Key_Egrave = 0x0c8,
+	Key_Eacute = 0x0c9,
+	Key_Ecircumflex = 0x0ca,
+	Key_Ediaeresis = 0x0cb,
+	Key_Igrave = 0x0cc,
+	Key_Iacute = 0x0cd,
+	Key_Icircumflex = 0x0ce,
+	Key_Idiaeresis = 0x0cf,
+	Key_ETH = 0x0d0,
+	Key_Ntilde = 0x0d1,
+	Key_Ograve = 0x0d2,
+	Key_Oacute = 0x0d3,
+	Key_Ocircumflex = 0x0d4,
+	Key_Otilde = 0x0d5,
+	Key_Odiaeresis = 0x0d6,
+	Key_multiply = 0x0d7,
+	Key_Ooblique = 0x0d8,
+	Key_Ugrave = 0x0d9,
+	Key_Uacute = 0x0da,
+	Key_Ucircumflex = 0x0db,
+	Key_Udiaeresis = 0x0dc,
+	Key_Yacute = 0x0dd,
+	Key_THORN = 0x0de,
+	Key_ssharp = 0x0df,
+	Key_agrave = 0x0e0,
+	Key_aacute = 0x0e1,
+	Key_acircumflex = 0x0e2,
+	Key_atilde = 0x0e3,
+	Key_adiaeresis = 0x0e4,
+	Key_aring = 0x0e5,
+	Key_ae = 0x0e6,
+	Key_ccedilla = 0x0e7,
+	Key_egrave = 0x0e8,
+	Key_eacute = 0x0e9,
+	Key_ecircumflex = 0x0ea,
+	Key_ediaeresis = 0x0eb,
+	Key_igrave = 0x0ec,
+	Key_iacute = 0x0ed,
+	Key_icircumflex = 0x0ee,
+	Key_idiaeresis = 0x0ef,
+	Key_eth = 0x0f0,
+	Key_ntilde = 0x0f1,
+	Key_ograve = 0x0f2,
+	Key_oacute = 0x0f3,
+	Key_ocircumflex = 0x0f4,
+	Key_otilde = 0x0f5,
+	Key_odiaeresis = 0x0f6,
+	Key_division = 0x0f7,
+	Key_oslash = 0x0f8,
+	Key_ugrave = 0x0f9,
+	Key_uacute = 0x0fa,
+	Key_ucircumflex = 0x0fb,
+	Key_udiaeresis = 0x0fc,
+	Key_yacute = 0x0fd,
+	Key_thorn = 0x0fe,
+	Key_ydiaeresis = 0x0ff,
+
+	// multimedia/internet keys - ignored by default - see QKeyEvent c'tor
+
+	Key_Back  = 0x1061,
+	Key_Forward  = 0x1062,
+	Key_Stop  = 0x1063,
+	Key_Refresh  = 0x1064,
+
+	Key_VolumeDown = 0x1070,
+	Key_VolumeMute  = 0x1071,
+	Key_VolumeUp = 0x1072,
+	Key_BassBoost = 0x1073,
+	Key_BassUp = 0x1074,
+	Key_BassDown = 0x1075,
+	Key_TrebleUp = 0x1076,
+	Key_TrebleDown = 0x1077,
+
+	Key_MediaPlay  = 0x1080,
+	Key_MediaStop  = 0x1081,
+	Key_MediaPrev  = 0x1082,
+	Key_MediaNext  = 0x1083,
+	Key_MediaRecord = 0x1084,
+
+	Key_HomePage  = 0x1090,
+	Key_Favorites  = 0x1091,
+	Key_Search  = 0x1092,
+	Key_Standby = 0x1093,
+	Key_OpenUrl = 0x1094,
+
+	Key_LaunchMail  = 0x10a0,
+	Key_LaunchMedia = 0x10a1,
+	Key_Launch0  = 0x10a2,
+	Key_Launch1  = 0x10a3,
+	Key_Launch2  = 0x10a4,
+	Key_Launch3  = 0x10a5,
+	Key_Launch4  = 0x10a6,
+	Key_Launch5  = 0x10a7,
+	Key_Launch6  = 0x10a8,
+	Key_Launch7  = 0x10a9,
+	Key_Launch8  = 0x10aa,
+	Key_Launch9  = 0x10ab,
+	Key_LaunchA  = 0x10ac,
+	Key_LaunchB  = 0x10ad,
+	Key_LaunchC  = 0x10ae,
+	Key_LaunchD  = 0x10af,
+	Key_LaunchE  = 0x10b0,
+	Key_LaunchF  = 0x10b1,
+
+	Key_MediaLast = 0x1fff,
+
+	Key_unknown = 0xffff
+    };
+
+    // documented in qcommonstyle.cpp
+    enum ArrowType {
+	UpArrow,
+	DownArrow,
+	LeftArrow,
+	RightArrow
+    };
+
+    // documented in qpainter.cpp
+    enum RasterOp { // raster op mode
+	CopyROP,
+	OrROP,
+	XorROP,
+	NotAndROP, EraseROP=NotAndROP,
+	NotCopyROP,
+	NotOrROP,
+	NotXorROP,
+	AndROP,	NotEraseROP=AndROP,
+	NotROP,
+	ClearROP,
+	SetROP,
+	NopROP,
+	AndNotROP,
+	OrNotROP,
+	NandROP,
+	NorROP,	LastROP=NorROP
+    };
+
+    // documented in qpainter.cpp
+    enum PenStyle { // pen style
+	NoPen,
+	SolidLine,
+	DashLine,
+	DotLine,
+	DashDotLine,
+	DashDotDotLine,
+	MPenStyle = 0x0f
+    };
+
+    // documented in qpainter.cpp
+    enum PenCapStyle { // line endcap style
+	FlatCap = 0x00,
+	SquareCap = 0x10,
+	RoundCap = 0x20,
+	MPenCapStyle = 0x30
+    };
+
+    // documented in qpainter.cpp
+    enum PenJoinStyle { // line join style
+	MiterJoin = 0x00,
+	BevelJoin = 0x40,
+	RoundJoin = 0x80,
+	MPenJoinStyle = 0xc0
+    };
+
+    // documented in qpainter.cpp
+    enum BrushStyle { // brush style
+	NoBrush,
+	SolidPattern,
+	Dense1Pattern,
+	Dense2Pattern,
+	Dense3Pattern,
+	Dense4Pattern,
+	Dense5Pattern,
+	Dense6Pattern,
+	Dense7Pattern,
+	HorPattern,
+	VerPattern,
+	CrossPattern,
+	BDiagPattern,
+	FDiagPattern,
+	DiagCrossPattern,
+	CustomPattern=24
+    };
+
+    // documented in qapplication_mac.cpp
+    enum MacintoshVersion {
+	//Unknown
+	MV_Unknown      = 0x0000,
+
+	//Version numbers
+	MV_9            = 0x0001,
+	MV_10_DOT_0     = 0x0002,
+	MV_10_DOT_1     = 0x0003,
+	MV_10_DOT_2     = 0x0004,
+	MV_10_DOT_3     = 0x0005,
+	MV_10_DOT_4     = 0x0006,
+
+	//Code names
+	MV_CHEETAH      = MV_10_DOT_0,
+	MV_PUMA         = MV_10_DOT_1,
+	MV_JAGUAR       = MV_10_DOT_2,
+	MV_PANTHER      = MV_10_DOT_3,
+	MV_TIGER        = MV_10_DOT_4
+    };
+
+    // documented in qapplication_win.cpp
+    enum WindowsVersion {
+	WV_32s 		= 0x0001,
+	WV_95 		= 0x0002,
+	WV_98		= 0x0003,
+	WV_Me		= 0x0004,
+	WV_DOS_based	= 0x000f,
+
+	WV_NT 		= 0x0010,
+	WV_2000 	= 0x0020,
+	WV_XP		= 0x0030,
+	WV_2003		= 0x0040,
+	WV_VISTA 	= 0x0080,
+	WV_NT_based	= 0x00f0,
+
+	WV_CE           = 0x0100,
+	WV_CENET	= 0x0200,
+	WV_CE_based	= 0x0f00
+    };
+
+    // documented in qstyle.cpp
+    enum UIEffect {
+	UI_General,
+	UI_AnimateMenu,
+	UI_FadeMenu,
+	UI_AnimateCombo,
+	UI_AnimateTooltip,
+	UI_FadeTooltip,
+	UI_AnimateToolBox
+    };
+
+    // documented in qcursor.cpp
+    enum CursorShape {
+	ArrowCursor,
+	UpArrowCursor,
+	CrossCursor,
+	WaitCursor,
+	IbeamCursor,
+	SizeVerCursor,
+	SizeHorCursor,
+	SizeBDiagCursor,
+	SizeFDiagCursor,
+	SizeAllCursor,
+	BlankCursor,
+	SplitVCursor,
+	SplitHCursor,
+	PointingHandCursor,
+	ForbiddenCursor,
+	WhatsThisCursor,
+	BusyCursor,
+	LastCursor	= BusyCursor,
+	BitmapCursor	= 24
+    };
+
+    // Global cursors
+
+    QT_STATIC_CONST QCursor & arrowCursor;	// standard arrow cursor
+    QT_STATIC_CONST QCursor & upArrowCursor;	// upwards arrow
+    QT_STATIC_CONST QCursor & crossCursor;	// crosshair
+    QT_STATIC_CONST QCursor & waitCursor;	// hourglass/watch
+    QT_STATIC_CONST QCursor & ibeamCursor;	// ibeam/text entry
+    QT_STATIC_CONST QCursor & sizeVerCursor;	// vertical resize
+    QT_STATIC_CONST QCursor & sizeHorCursor;	// horizontal resize
+    QT_STATIC_CONST QCursor & sizeBDiagCursor;	// diagonal resize (/)
+    QT_STATIC_CONST QCursor & sizeFDiagCursor;	// diagonal resize (\)
+    QT_STATIC_CONST QCursor & sizeAllCursor;	// all directions resize
+    QT_STATIC_CONST QCursor & blankCursor;	// blank/invisible cursor
+    QT_STATIC_CONST QCursor & splitVCursor;	// vertical bar with left-right
+						// arrows
+    QT_STATIC_CONST QCursor & splitHCursor;	// horizontal bar with up-down
+						// arrows
+    QT_STATIC_CONST QCursor & pointingHandCursor;	// pointing hand
+    QT_STATIC_CONST QCursor & forbiddenCursor;	// forbidden cursor (slashed circle)
+    QT_STATIC_CONST QCursor & whatsThisCursor;  // arrow with a question mark
+    QT_STATIC_CONST QCursor & busyCursor;	// arrow with hourglass
+
+
+    enum TextFormat {
+	PlainText,
+	RichText,
+	AutoText,
+	LogText
+    };
+
+    // Documented in qtextedit.cpp
+    enum AnchorAttribute {
+	AnchorName,
+	AnchorHref
+    };
+
+    // Documented in qmainwindow.cpp
+    enum Dock {
+	DockUnmanaged,
+	DockTornOff,
+	DockTop,
+	DockBottom,
+	DockRight,
+	DockLeft,
+	DockMinimized
+#ifndef QT_NO_COMPAT
+        ,
+	Unmanaged = DockUnmanaged,
+	TornOff = DockTornOff,
+	Top = DockTop,
+	Bottom = DockBottom,
+	Right = DockRight,
+	Left = DockLeft,
+	Minimized = DockMinimized
+#endif
+    };
+    // compatibility
+    typedef Dock ToolBarDock;
+
+    // documented in qdatetime.cpp
+    enum DateFormat {
+	TextDate,      // default Qt
+	ISODate,       // ISO 8601
+	LocalDate      // locale dependent
+    };
+
+    // documented in qdatetime.cpp
+    enum TimeSpec {
+	LocalTime,
+	UTC
+    };
+
+    // documented in qwidget.cpp
+    enum BackgroundMode {
+	FixedColor,
+	FixedPixmap,
+	NoBackground,
+	PaletteForeground,
+	PaletteButton,
+	PaletteLight,
+	PaletteMidlight,
+	PaletteDark,
+	PaletteMid,
+	PaletteText,
+	PaletteBrightText,
+	PaletteBase,
+	PaletteBackground,
+	PaletteShadow,
+	PaletteHighlight,
+	PaletteHighlightedText,
+	PaletteButtonText,
+	PaletteLink,
+	PaletteLinkVisited,
+	X11ParentRelative
+    };
+
+    typedef uint ComparisonFlags;
+
+    // Documented in qstring.cpp
+    enum StringComparisonMode {
+        CaseSensitive   = 0x00001, // 0 0001
+        BeginsWith      = 0x00002, // 0 0010
+        EndsWith        = 0x00004, // 0 0100
+        Contains        = 0x00008, // 0 1000
+        ExactMatch      = 0x00010  // 1 0000
+    };
+
+    // Documented in qtabwidget.cpp
+    enum Corner {
+	TopLeft     = 0x00000,
+	TopRight    = 0x00001,
+	BottomLeft  = 0x00002,
+	BottomRight = 0x00003
+    };
+
+    // "handle" type for system objects. Documented as \internal in
+    // qapplication.cpp
+#if defined(Q_WS_MAC)
+    typedef void * HANDLE;
+#elif defined(Q_WS_WIN)
+    typedef void *HANDLE;
+#elif defined(Q_WS_X11)
+    typedef unsigned long HANDLE;
+#elif defined(Q_WS_QWS)
+    typedef void * HANDLE;
+#endif
+};
+
+
+class Q_EXPORT QInternal {
+public:
+    enum PaintDeviceFlags {
+	UndefinedDevice = 0x00,
+	Widget = 0x01,
+	Pixmap = 0x02,
+	Printer = 0x03,
+	Picture = 0x04,
+	System = 0x05,
+	DeviceTypeMask = 0x0f,
+	ExternalDevice = 0x10,
+	// used to emulate some of the behaviour different between Qt2 and Qt3 (mainly for printing)
+	CompatibilityMode = 0x20
+    };
+};
+
+#endif // QNAMESPACE_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp
--- qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp	2009-10-18 14:38:39.225208819 -0700
@@ -666,5 +666,5 @@
 }
 
-bool QTextCursor::place( const QPoint &p, QTextParagraph *s, bool link )
+bool QTextCursor::place( const QPoint &p, QTextParagraph *s, bool link, bool loosePlacing, bool matchBetweenCharacters )
 {
     QPoint pos( p );
@@ -684,5 +684,5 @@
 	if ( pos.y() >= r.y() && pos.y() <= r.y() + r.height() )
 	    break;
-	if ( !s->next() ) {
+	if ( loosePlacing == TRUE && !s->next() ) {
 #ifdef Q_WS_MACX
 	    pos.setX( s->rect().x() + s->rect().width() );
@@ -725,5 +725,5 @@
 	pos.setX( x + 1 );
     int cw;
-    int curpos = s->length()-1;
+    int curpos = -1;
     int dist = 10000000;
     bool inCustom = FALSE;
@@ -747,7 +747,8 @@
 	    int d = cpos - pos.x();
 	    bool dm = d < 0 ? !chr->rightToLeft : chr->rightToLeft;
-	    if ( (QABS( d ) < dist || (dist == d && dm == TRUE )) && para->string()->validCursorPosition( i ) ) {
+	    if ( ( matchBetweenCharacters == TRUE && (QABS( d ) < dist || (dist == d && dm == TRUE )) && para->string()->validCursorPosition( i ) ) ||
+		 ( matchBetweenCharacters == FALSE && ( d == 0 || dm == TRUE ) ) ) {
 		dist = QABS( d );
-		if ( !link || pos.x() >= x + chr->x )
+		if ( !link || ( pos.x() >= x + chr->x && ( loosePlacing == TRUE || pos.x() < cpos ) ) )
 		    curpos = i;
 	    }
@@ -755,4 +756,10 @@
 	i++;
     }
+    if ( curpos == -1 ) {
+	if ( loosePlacing == TRUE )
+	    curpos = s->length()-1;
+	else
+	    return FALSE;
+    }
     setIndex( curpos );
 
@@ -4880,4 +4887,7 @@
 		painter.fillRect( xleft, y, tmpw, h, color );
 		painter.drawText( xstart, y + baseLine, str, start, len, dir );
+                // draw preedit's underline
+                if (selection == QTextDocument::IMCompositionText)
+                    painter.drawLine(xstart, y + baseLine + 1, xstart + w, y + baseLine + 1);
 		if (selStart != start || selEnd != start + len || selWrap)
 		    painter.restore();
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp.orig qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qrichtext.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,8248 @@
+/****************************************************************************
+**
+** Implementation of the internal Qt classes dealing with rich text
+**
+** Created : 990101
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qrichtext_p.h"
+
+#ifndef QT_NO_RICHTEXT
+
+
+#include "qstringlist.h"
+#include "qfont.h"
+#include "qtextstream.h"
+#include "qfile.h"
+#include "qapplication.h"
+#include "qmap.h"
+#include "qfileinfo.h"
+#include "qstylesheet.h"
+#include "qmime.h"
+#include "qimage.h"
+#include "qdragobject.h"
+#include "qpaintdevicemetrics.h"
+#include "qpainter.h"
+#include "qdrawutil.h"
+#include "qcursor.h"
+#include "qptrstack.h"
+#include "qptrdict.h"
+#include "qstyle.h"
+#include "qcleanuphandler.h"
+#include "qtextengine_p.h"
+#include <private/qunicodetables_p.h>
+
+#include <stdlib.h>
+
+static QTextCursor* richTextExportStart = 0;
+static QTextCursor* richTextExportEnd = 0;
+
+class QTextFormatCollection;
+
+const int border_tolerance = 2;
+
+#ifdef Q_WS_WIN
+#include "qt_windows.h"
+#endif
+
+#define QChar_linesep QChar(0x2028U)
+
+static inline bool is_printer( QPainter *p )
+{
+    if ( !p || !p->device() )
+	return FALSE;
+    return p->device()->devType() == QInternal::Printer;
+}
+
+static inline int scale( int value, QPainter *painter )
+{
+    if ( is_printer( painter ) ) {
+	QPaintDeviceMetrics metrics( painter->device() );
+#if defined(Q_WS_X11)
+	value = value * metrics.logicalDpiY() /
+		QPaintDevice::x11AppDpiY( painter->device()->x11Screen() );
+#elif defined (Q_WS_WIN)
+	HDC hdc = GetDC( 0 );
+	int gdc = GetDeviceCaps( hdc, LOGPIXELSY );
+	if ( gdc )
+	    value = value * metrics.logicalDpiY() / gdc;
+	ReleaseDC( 0, hdc );
+#elif defined (Q_WS_MAC)
+	value = value * metrics.logicalDpiY() / 75; // ##### FIXME
+#elif defined (Q_WS_QWS)
+	value = value * metrics.logicalDpiY() / 75;
+#endif
+    }
+    return value;
+}
+
+
+inline bool isBreakable( QTextString *string, int pos )
+{
+    if (string->at(pos).nobreak)
+	return FALSE;
+    return (pos < string->length()-1 && string->at(pos+1).softBreak);
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+void QTextCommandHistory::addCommand( QTextCommand *cmd )
+{
+    if ( current < (int)history.count() - 1 ) {
+	QPtrList<QTextCommand> commands;
+	commands.setAutoDelete( FALSE );
+
+	for( int i = 0; i <= current; ++i ) {
+	    commands.insert( i, history.at( 0 ) );
+	    history.take( 0 );
+	}
+
+	commands.append( cmd );
+	history.clear();
+	history = commands;
+	history.setAutoDelete( TRUE );
+    } else {
+	history.append( cmd );
+    }
+
+    if ( (int)history.count() > steps )
+	history.removeFirst();
+    else
+	++current;
+}
+
+QTextCursor *QTextCommandHistory::undo( QTextCursor *c )
+{
+    if ( current > -1 ) {
+	QTextCursor *c2 = history.at( current )->unexecute( c );
+	--current;
+	return c2;
+    }
+    return 0;
+}
+
+QTextCursor *QTextCommandHistory::redo( QTextCursor *c )
+{
+    if ( current > -1 ) {
+	if ( current < (int)history.count() - 1 ) {
+	    ++current;
+	    return history.at( current )->execute( c );
+	}
+    } else {
+	if ( history.count() > 0 ) {
+	    ++current;
+	    return history.at( current )->execute( c );
+	}
+    }
+    return 0;
+}
+
+bool QTextCommandHistory::isUndoAvailable()
+{
+    return current > -1;
+}
+
+bool QTextCommandHistory::isRedoAvailable()
+{
+   return current > -1 && current < (int)history.count() - 1 || current == -1 && history.count() > 0;
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextDeleteCommand::QTextDeleteCommand( QTextDocument *d, int i, int idx, const QMemArray<QTextStringChar> &str,
+					const QByteArray& oldStyleInfo )
+    : QTextCommand( d ), id( i ), index( idx ), parag( 0 ), text( str ), styleInformation( oldStyleInfo )
+{
+    for ( int j = 0; j < (int)text.size(); ++j ) {
+	if ( text[ j ].format() )
+	    text[ j ].format()->addRef();
+    }
+}
+
+QTextDeleteCommand::QTextDeleteCommand( QTextParagraph *p, int idx, const QMemArray<QTextStringChar> &str )
+    : QTextCommand( 0 ), id( -1 ), index( idx ), parag( p ), text( str )
+{
+    for ( int i = 0; i < (int)text.size(); ++i ) {
+	if ( text[ i ].format() )
+	    text[ i ].format()->addRef();
+    }
+}
+
+QTextDeleteCommand::~QTextDeleteCommand()
+{
+    for ( int i = 0; i < (int)text.size(); ++i ) {
+	if ( text[ i ].format() )
+	    text[ i ].format()->removeRef();
+    }
+    text.resize( 0 );
+}
+
+QTextCursor *QTextDeleteCommand::execute( QTextCursor *c )
+{
+    QTextParagraph *s = doc ? doc->paragAt( id ) : parag;
+    if ( !s ) {
+	qWarning( "can't locate parag at %d, last parag: %d", id, doc->lastParagraph()->paragId() );
+	return 0;
+    }
+
+    cursor.setParagraph( s );
+    cursor.setIndex( index );
+    int len = text.size();
+    if ( c )
+	*c = cursor;
+    if ( doc ) {
+	doc->setSelectionStart( QTextDocument::Temp, cursor );
+	for ( int i = 0; i < len; ++i )
+	    cursor.gotoNextLetter();
+	doc->setSelectionEnd( QTextDocument::Temp, cursor );
+	doc->removeSelectedText( QTextDocument::Temp, &cursor );
+	if ( c )
+	    *c = cursor;
+    } else {
+	s->remove( index, len );
+    }
+
+    return c;
+}
+
+QTextCursor *QTextDeleteCommand::unexecute( QTextCursor *c )
+{
+    QTextParagraph *s = doc ? doc->paragAt( id ) : parag;
+    if ( !s ) {
+	qWarning( "can't locate parag at %d, last parag: %d", id, doc->lastParagraph()->paragId() );
+	return 0;
+    }
+
+    cursor.setParagraph( s );
+    cursor.setIndex( index );
+    QString str = QTextString::toString( text );
+    cursor.insert( str, TRUE, &text );
+    if ( c )
+	*c = cursor;
+    cursor.setParagraph( s );
+    cursor.setIndex( index );
+
+#ifndef QT_NO_DATASTREAM
+    if ( !styleInformation.isEmpty() ) {
+	QDataStream styleStream( styleInformation, IO_ReadOnly );
+	int num;
+	styleStream >> num;
+	QTextParagraph *p = s;
+	while ( num-- && p ) {
+	    p->readStyleInformation( styleStream );
+	    p = p->next();
+	}
+    }
+#endif
+    s = cursor.paragraph();
+    while ( s ) {
+	s->format();
+	s->setChanged( TRUE );
+	if ( s == c->paragraph() )
+	    break;
+	s = s->next();
+    }
+
+    return &cursor;
+}
+
+QTextFormatCommand::QTextFormatCommand( QTextDocument *d, int sid, int sidx, int eid, int eidx,
+					const QMemArray<QTextStringChar> &old, QTextFormat *f, int fl )
+    : QTextCommand( d ), startId( sid ), startIndex( sidx ), endId( eid ), endIndex( eidx ), format( f ), oldFormats( old ), flags( fl )
+{
+    format = d->formatCollection()->format( f );
+    for ( int j = 0; j < (int)oldFormats.size(); ++j ) {
+	if ( oldFormats[ j ].format() )
+	    oldFormats[ j ].format()->addRef();
+    }
+}
+
+QTextFormatCommand::~QTextFormatCommand()
+{
+    format->removeRef();
+    for ( int j = 0; j < (int)oldFormats.size(); ++j ) {
+	if ( oldFormats[ j ].format() )
+	    oldFormats[ j ].format()->removeRef();
+    }
+}
+
+QTextCursor *QTextFormatCommand::execute( QTextCursor *c )
+{
+    QTextParagraph *sp = doc->paragAt( startId );
+    QTextParagraph *ep = doc->paragAt( endId );
+    if ( !sp || !ep )
+	return c;
+
+    QTextCursor start( doc );
+    start.setParagraph( sp );
+    start.setIndex( startIndex );
+    QTextCursor end( doc );
+    end.setParagraph( ep );
+    end.setIndex( endIndex );
+
+    doc->setSelectionStart( QTextDocument::Temp, start );
+    doc->setSelectionEnd( QTextDocument::Temp, end );
+    doc->setFormat( QTextDocument::Temp, format, flags );
+    doc->removeSelection( QTextDocument::Temp );
+    if ( endIndex == ep->length() )
+	end.gotoLeft();
+    *c = end;
+    return c;
+}
+
+QTextCursor *QTextFormatCommand::unexecute( QTextCursor *c )
+{
+    QTextParagraph *sp = doc->paragAt( startId );
+    QTextParagraph *ep = doc->paragAt( endId );
+    if ( !sp || !ep )
+	return 0;
+
+    int idx = startIndex;
+    int fIndex = 0;
+    while ( fIndex < int(oldFormats.size()) ) {
+	if ( oldFormats.at( fIndex ).c == '\n' ) {
+	    if ( idx > 0 ) {
+		if ( idx < sp->length() && fIndex > 0 )
+		    sp->setFormat( idx, 1, oldFormats.at( fIndex - 1 ).format() );
+		if ( sp == ep )
+		    break;
+		sp = sp->next();
+		idx = 0;
+	    }
+	    fIndex++;
+	}
+	if ( oldFormats.at( fIndex ).format() )
+	    sp->setFormat( idx, 1, oldFormats.at( fIndex ).format() );
+	idx++;
+	fIndex++;
+        if ( fIndex >= (int)oldFormats.size() )
+            break;
+	if ( idx >= sp->length() ) {
+	    if ( sp == ep )
+		break;
+	    sp = sp->next();
+	    idx = 0;
+	}
+    }
+
+    QTextCursor end( doc );
+    end.setParagraph( ep );
+    end.setIndex( endIndex );
+    if ( endIndex == ep->length() )
+	end.gotoLeft();
+    *c = end;
+    return c;
+}
+
+QTextStyleCommand::QTextStyleCommand( QTextDocument *d, int fParag, int lParag, const QByteArray& beforeChange )
+    : QTextCommand( d ), firstParag( fParag ), lastParag( lParag ), before( beforeChange )
+{
+    after = readStyleInformation(  d, fParag, lParag );
+}
+
+
+QByteArray QTextStyleCommand::readStyleInformation(  QTextDocument* doc, int fParag, int lParag )
+{
+    QByteArray style;
+#ifndef QT_NO_DATASTREAM
+    QTextParagraph *p = doc->paragAt( fParag );
+    if ( !p )
+	return style;
+    QDataStream styleStream( style, IO_WriteOnly );
+    int num = lParag - fParag + 1;
+    styleStream << num;
+    while ( num -- && p ) {
+	p->writeStyleInformation( styleStream );
+	p = p->next();
+    }
+#endif
+    return style;
+}
+
+void QTextStyleCommand::writeStyleInformation(  QTextDocument* doc, int fParag, const QByteArray& style )
+{
+#ifndef QT_NO_DATASTREAM
+    QTextParagraph *p = doc->paragAt( fParag );
+    if ( !p )
+	return;
+    QDataStream styleStream( style, IO_ReadOnly );
+    int num;
+    styleStream >> num;
+    while ( num-- && p ) {
+	p->readStyleInformation( styleStream );
+	p = p->next();
+    }
+#endif
+}
+
+QTextCursor *QTextStyleCommand::execute( QTextCursor *c )
+{
+    writeStyleInformation( doc, firstParag, after );
+    return c;
+}
+
+QTextCursor *QTextStyleCommand::unexecute( QTextCursor *c )
+{
+    writeStyleInformation( doc, firstParag, before );
+    return c;
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextCursor::QTextCursor( QTextDocument *d )
+    : idx( 0 ), tmpX( -1 ), ox( 0 ), oy( 0 ),
+      valid( TRUE )
+{
+    para = d ? d->firstParagraph() : 0;
+}
+
+QTextCursor::QTextCursor( const QTextCursor &c )
+{
+    ox = c.ox;
+    oy = c.oy;
+    idx = c.idx;
+    para = c.para;
+    tmpX = c.tmpX;
+    indices = c.indices;
+    paras = c.paras;
+    xOffsets = c.xOffsets;
+    yOffsets = c.yOffsets;
+    valid = c.valid;
+}
+
+QTextCursor &QTextCursor::operator=( const QTextCursor &c )
+{
+    ox = c.ox;
+    oy = c.oy;
+    idx = c.idx;
+    para = c.para;
+    tmpX = c.tmpX;
+    indices = c.indices;
+    paras = c.paras;
+    xOffsets = c.xOffsets;
+    yOffsets = c.yOffsets;
+    valid = c.valid;
+
+    return *this;
+}
+
+bool QTextCursor::operator==( const QTextCursor &c ) const
+{
+    return para == c.para && idx == c.idx;
+}
+
+int QTextCursor::totalOffsetX() const
+{
+    int xoff = ox;
+    for ( QValueStack<int>::ConstIterator xit = xOffsets.begin(); xit != xOffsets.end(); ++xit )
+	xoff += *xit;
+    return xoff;
+}
+
+int QTextCursor::totalOffsetY() const
+{
+    int yoff = oy;
+    for ( QValueStack<int>::ConstIterator yit = yOffsets.begin(); yit != yOffsets.end(); ++yit )
+	yoff += *yit;
+    return yoff;
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+void QTextCursor::gotoIntoNested( const QPoint &globalPos )
+{
+    if ( !para )
+	return;
+    Q_ASSERT( para->at( idx )->isCustom() );
+    push();
+    ox = 0;
+    int bl, y;
+    para->lineHeightOfChar( idx, &bl, &y );
+    oy = y + para->rect().y();
+    ox = para->at( idx )->x;
+    QTextDocument* doc = document();
+    para->at( idx )->customItem()->enterAt( this, doc, para, idx, ox, oy, globalPos-QPoint(ox,oy) );
+}
+#endif
+
+void QTextCursor::invalidateNested()
+{
+    if ( nestedDepth() ) {
+	QValueStack<QTextParagraph*>::Iterator it = paras.begin();
+	QValueStack<int>::Iterator it2 = indices.begin();
+	for ( ; it != paras.end(); ++it, ++it2 ) {
+	    if ( *it == para )
+		continue;
+	    (*it)->invalidate( 0 );
+#ifndef QT_NO_TEXTCUSTOMITEM
+	    if ( (*it)->at( *it2 )->isCustom() )
+		(*it)->at( *it2 )->customItem()->invalidate();
+#endif
+	}
+    }
+}
+
+void QTextCursor::insert( const QString &str, bool checkNewLine, QMemArray<QTextStringChar> *formatting )
+{
+    tmpX = -1;
+    bool justInsert = TRUE;
+    QString s( str );
+#if defined(Q_WS_WIN)
+    if ( checkNewLine ) {
+	int i = 0;
+	while ( ( i = s.find( '\r', i ) ) != -1 )
+	    s.remove( i ,1 );
+    }
+#endif
+    if ( checkNewLine )
+	justInsert = s.find( '\n' ) == -1;
+    if ( justInsert ) { // we ignore new lines and insert all in the current para at the current index
+	para->insert( idx, s.unicode(), s.length() );
+	if ( formatting ) {
+	    for ( int i = 0; i < (int)s.length(); ++i ) {
+		if ( formatting->at( i ).format() ) {
+		    formatting->at( i ).format()->addRef();
+		    para->string()->setFormat( idx + i, formatting->at( i ).format(), TRUE );
+		}
+	    }
+	}
+	idx += s.length();
+    } else { // we split at new lines
+	int start = -1;
+	int end;
+	int y = para->rect().y() + para->rect().height();
+	int lastIndex = 0;
+	do {
+	    end = s.find( '\n', start + 1 ); // find line break
+	    if ( end == -1 ) // didn't find one, so end of line is end of string
+		end = s.length();
+	    int len = (start == -1 ? end : end - start - 1);
+	    if ( len > 0 ) // insert the line
+		para->insert( idx, s.unicode() + start + 1, len );
+	    else
+		para->invalidate( 0 );
+	    if ( formatting ) { // set formats to the chars of the line
+		for ( int i = 0; i < len; ++i ) {
+		    if ( formatting->at( i + lastIndex ).format() ) {
+			formatting->at( i + lastIndex ).format()->addRef();
+			para->string()->setFormat( i + idx, formatting->at( i + lastIndex ).format(), TRUE );
+		    }
+		}
+		lastIndex += len;
+	    }
+	    start = end; // next start is at the end of this line
+	    idx += len; // increase the index of the cursor to the end of the inserted text
+	    if ( s[end] == '\n' ) { // if at the end was a line break, break the line
+		splitAndInsertEmptyParagraph( FALSE, TRUE );
+		para->setEndState( -1 );
+		para->prev()->format( -1, FALSE );
+		lastIndex++;
+	    }
+
+	} while ( end < (int)s.length() );
+
+	para->format( -1, FALSE );
+	int dy = para->rect().y() + para->rect().height() - y;
+	QTextParagraph *p = para;
+	p->setParagId( p->prev() ? p->prev()->paragId() + 1 : 0 );
+	p = p->next();
+	while ( p ) {
+	    p->setParagId( p->prev()->paragId() + 1 );
+	    p->move( dy );
+	    p->invalidate( 0 );
+	    p->setEndState( -1 );
+	    p = p->next();
+	}
+    }
+
+    int h = para->rect().height();
+    para->format( -1, TRUE );
+    if ( h != para->rect().height() )
+	invalidateNested();
+    else if ( para->document() && para->document()->parent() )
+	para->document()->nextDoubleBuffered = TRUE;
+
+    fixCursorPosition();
+}
+
+void QTextCursor::gotoLeft()
+{
+    if ( para->string()->isRightToLeft() )
+	gotoNextLetter();
+    else
+	gotoPreviousLetter();
+}
+
+void QTextCursor::gotoPreviousLetter()
+{
+    tmpX = -1;
+
+    if ( idx > 0 ) {
+	idx = para->string()->previousCursorPosition( idx );
+#ifndef QT_NO_TEXTCUSTOMITEM
+	const QTextStringChar *tsc = para->at( idx );
+	if ( tsc && tsc->isCustom() && tsc->customItem()->isNested() )
+	    processNesting( EnterEnd );
+#endif
+    } else if ( para->prev() ) {
+	para = para->prev();
+	while ( !para->isVisible() && para->prev() )
+	    para = para->prev();
+	idx = para->length() - 1;
+    } else if ( nestedDepth() ) {
+	pop();
+	processNesting( Prev );
+	if ( idx == -1 ) {
+	    pop();
+	    if ( idx > 0 ) {
+		idx = para->string()->previousCursorPosition( idx );
+#ifndef QT_NO_TEXTCUSTOMITEM
+                const QTextStringChar *tsc = para->at( idx );
+                if ( tsc && tsc->isCustom() && tsc->customItem()->isNested() )
+                    processNesting( EnterEnd );
+#endif
+	    } else if ( para->prev() ) {
+		para = para->prev();
+		idx = para->length() - 1;
+	    }
+	}
+    }
+}
+
+void QTextCursor::push()
+{
+    indices.push( idx );
+    paras.push( para );
+    xOffsets.push( ox );
+    yOffsets.push( oy );
+}
+
+void QTextCursor::pop()
+{
+    if ( indices.isEmpty() )
+	return;
+    idx = indices.pop();
+    para = paras.pop();
+    ox = xOffsets.pop();
+    oy = yOffsets.pop();
+}
+
+void QTextCursor::restoreState()
+{
+    while ( !indices.isEmpty() )
+	pop();
+}
+
+bool QTextCursor::place( const QPoint &p, QTextParagraph *s, bool link )
+{
+    QPoint pos( p );
+    QRect r;
+    QTextParagraph *str = s;
+    if ( pos.y() < s->rect().y() ) {
+	pos.setY( s->rect().y() );
+#ifdef Q_WS_MACX
+	pos.setX( s->rect().x() );
+#endif
+    }
+    while ( s ) {
+	r = s->rect();
+	r.setWidth( document() ? document()->width() : QWIDGETSIZE_MAX );
+	if ( s->isVisible() )
+	    str = s;
+	if ( pos.y() >= r.y() && pos.y() <= r.y() + r.height() )
+	    break;
+	if ( !s->next() ) {
+#ifdef Q_WS_MACX
+	    pos.setX( s->rect().x() + s->rect().width() );
+#endif
+	    break;
+	}
+	s = s->next();
+    }
+
+    if ( !s || !str )
+	return FALSE;
+
+    s = str;
+
+    setParagraph( s );
+    int y = s->rect().y();
+    int lines = s->lines();
+    QTextStringChar *chr = 0;
+    int index = 0;
+    int i = 0;
+    int cy = 0;
+    int ch = 0;
+    for ( ; i < lines; ++i ) {
+	chr = s->lineStartOfLine( i, &index );
+	cy = s->lineY( i );
+	ch = s->lineHeight( i );
+	if ( !chr )
+	    return FALSE;
+	if ( pos.y() <= y + cy + ch )
+	    break;
+    }
+    int nextLine;
+    if ( i < lines - 1 )
+	s->lineStartOfLine( i+1, &nextLine );
+    else
+	nextLine = s->length();
+    i = index;
+    int x = s->rect().x();
+    if ( pos.x() < x )
+	pos.setX( x + 1 );
+    int cw;
+    int curpos = s->length()-1;
+    int dist = 10000000;
+    bool inCustom = FALSE;
+    while ( i < nextLine ) {
+	chr = s->at(i);
+	int cpos = x + chr->x;
+	cw = s->string()->width( i );
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( chr->isCustom() && chr->customItem()->isNested() ) {
+	    if ( pos.x() >= cpos && pos.x() <= cpos + cw &&
+		 pos.y() >= y + cy && pos.y() <= y + cy + chr->height() ) {
+		inCustom = TRUE;
+		curpos = i;
+		break;
+	    }
+	} else
+#endif
+	{
+	    if( chr->rightToLeft )
+		cpos += cw;
+	    int d = cpos - pos.x();
+	    bool dm = d < 0 ? !chr->rightToLeft : chr->rightToLeft;
+	    if ( (QABS( d ) < dist || (dist == d && dm == TRUE )) && para->string()->validCursorPosition( i ) ) {
+		dist = QABS( d );
+		if ( !link || pos.x() >= x + chr->x )
+		    curpos = i;
+	    }
+	}
+	i++;
+    }
+    setIndex( curpos );
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if ( inCustom && para->document() && para->at( curpos )->isCustom() && para->at( curpos )->customItem()->isNested() ) {
+	QTextDocument *oldDoc = para->document();
+	gotoIntoNested( pos );
+	if ( oldDoc == para->document() )
+	    return TRUE;
+	QPoint p( pos.x() - offsetX(), pos.y() - offsetY() );
+	if ( !place( p, document()->firstParagraph(), link ) )
+	    pop();
+    }
+#endif
+    return TRUE;
+}
+
+bool QTextCursor::processNesting( Operation op )
+{
+    if ( !para->document() )
+	return FALSE;
+    QTextDocument* doc = para->document();
+    push();
+    ox = para->at( idx )->x;
+    int bl, y;
+    para->lineHeightOfChar( idx, &bl, &y );
+    oy = y + para->rect().y();
+    bool ok = FALSE;
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    switch ( op ) {
+    case EnterBegin:
+	ok = para->at( idx )->customItem()->enter( this, doc, para, idx, ox, oy );
+	break;
+    case EnterEnd:
+	ok = para->at( idx )->customItem()->enter( this, doc, para, idx, ox, oy, TRUE );
+	break;
+    case Next:
+	ok = para->at( idx )->customItem()->next( this, doc, para, idx, ox, oy );
+	break;
+    case Prev:
+	ok = para->at( idx )->customItem()->prev( this, doc, para, idx, ox, oy );
+	break;
+    case Down:
+	ok = para->at( idx )->customItem()->down( this, doc, para, idx, ox, oy );
+	break;
+    case Up:
+	ok = para->at( idx )->customItem()->up( this, doc, para, idx, ox, oy );
+	break;
+    }
+    if ( !ok )
+#endif
+	pop();
+    return ok;
+}
+
+void QTextCursor::gotoRight()
+{
+    if ( para->string()->isRightToLeft() )
+	gotoPreviousLetter();
+    else
+	gotoNextLetter();
+}
+
+void QTextCursor::gotoNextLetter()
+{
+   tmpX = -1;
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    const QTextStringChar *tsc = para->at( idx );
+    if ( tsc && tsc->isCustom() && tsc->customItem()->isNested() ) {
+	if ( processNesting( EnterBegin ) )
+	    return;
+    }
+#endif
+
+    if ( idx < para->length() - 1 ) {
+	idx = para->string()->nextCursorPosition( idx );
+    } else if ( para->next() ) {
+	para = para->next();
+	while ( !para->isVisible() && para->next() )
+	    para = para->next();
+	idx = 0;
+    } else if ( nestedDepth() ) {
+	pop();
+	processNesting( Next );
+	if ( idx == -1 ) {
+	    pop();
+	    if ( idx < para->length() - 1 ) {
+		idx = para->string()->nextCursorPosition( idx );
+	    } else if ( para->next() ) {
+		para = para->next();
+		idx = 0;
+	    }
+	}
+    }
+}
+
+void QTextCursor::gotoUp()
+{
+    int indexOfLineStart;
+    int line;
+    QTextStringChar *c = para->lineStartOfChar( idx, &indexOfLineStart, &line );
+    if ( !c )
+	return;
+
+    if (tmpX < 0)
+	tmpX = x();
+
+    if ( indexOfLineStart == 0 ) {
+	if ( !para->prev() ) {
+	    if ( !nestedDepth() )
+		return;
+	    pop();
+	    processNesting( Up );
+	    if ( idx == -1 ) {
+		pop();
+		if ( !para->prev() )
+		    return;
+		idx = tmpX = 0;
+	    } else {
+		tmpX = -1;
+		return;
+	    }
+	}
+	QTextParagraph *p = para->prev();
+	while ( p && !p->isVisible() )
+	    p = p->prev();
+	if ( p )
+	    para = p;
+	int lastLine = para->lines() - 1;
+	if ( !para->lineStartOfLine( lastLine, &indexOfLineStart ) )
+	    return;
+	idx = indexOfLineStart;
+	while (idx < para->length()-1 && para->at(idx)->x < tmpX)
+	    ++idx;
+	if (idx > indexOfLineStart &&
+	    para->at(idx)->x - tmpX > tmpX - para->at(idx-1)->x)
+	    --idx;
+    } else {
+	--line;
+	int oldIndexOfLineStart = indexOfLineStart;
+	if ( !para->lineStartOfLine( line, &indexOfLineStart ) )
+	    return;
+	idx = indexOfLineStart;
+	while (idx < oldIndexOfLineStart-1 && para->at(idx)->x < tmpX)
+	    ++idx;
+	if (idx > indexOfLineStart &&
+	    para->at(idx)->x - tmpX > tmpX - para->at(idx-1)->x)
+	    --idx;
+    }
+    fixCursorPosition();
+}
+
+void QTextCursor::gotoDown()
+{
+    int indexOfLineStart;
+    int line;
+    QTextStringChar *c = para->lineStartOfChar( idx, &indexOfLineStart, &line );
+    if ( !c )
+	return;
+
+    if (tmpX < 0)
+	tmpX = x();
+    if ( line == para->lines() - 1 ) {
+	if ( !para->next() ) {
+	    if ( !nestedDepth() )
+		return;
+	    pop();
+	    processNesting( Down );
+	    if ( idx == -1 ) {
+		pop();
+		if ( !para->next() )
+		    return;
+		idx = tmpX = 0;
+	    } else {
+		tmpX = -1;
+		return;
+	    }
+	}
+	QTextParagraph *s = para->next();
+	while ( s && !s->isVisible() )
+	    s = s->next();
+	if ( s )
+	    para = s;
+	if ( !para->lineStartOfLine( 0, &indexOfLineStart ) )
+	    return;
+	int end;
+	if ( para->lines() == 1 )
+	    end = para->length();
+	else
+	    para->lineStartOfLine( 1, &end );
+
+	idx = indexOfLineStart;
+	while (idx < end-1 && para->at(idx)->x < tmpX)
+	    ++idx;
+	if (idx > indexOfLineStart &&
+	    para->at(idx)->x - tmpX > tmpX - para->at(idx-1)->x)
+	    --idx;
+    } else {
+	++line;
+	int end;
+	if ( line == para->lines() - 1 )
+	    end = para->length();
+	else
+	    para->lineStartOfLine( line + 1, &end );
+	if ( !para->lineStartOfLine( line, &indexOfLineStart ) )
+	    return;
+	idx = indexOfLineStart;
+	while (idx < end-1 && para->at(idx)->x < tmpX)
+	    ++idx;
+	if (idx > indexOfLineStart &&
+	    para->at(idx)->x - tmpX > tmpX - para->at(idx-1)->x)
+	    --idx;
+    }
+    fixCursorPosition();
+}
+
+void QTextCursor::gotoLineEnd()
+{
+    tmpX = -1;
+    int indexOfLineStart;
+    int line;
+    QTextStringChar *c = para->lineStartOfChar( idx, &indexOfLineStart, &line );
+    if ( !c )
+	return;
+
+    if ( line == para->lines() - 1 ) {
+	idx = para->length() - 1;
+    } else {
+	c = para->lineStartOfLine( ++line, &indexOfLineStart );
+	indexOfLineStart--;
+	idx = indexOfLineStart;
+    }
+}
+
+void QTextCursor::gotoLineStart()
+{
+    tmpX = -1;
+    int indexOfLineStart;
+    int line;
+    QTextStringChar *c = para->lineStartOfChar( idx, &indexOfLineStart, &line );
+    if ( !c )
+	return;
+
+    idx = indexOfLineStart;
+}
+
+void QTextCursor::gotoHome()
+{
+    if ( topParagraph()->document() )
+	gotoPosition( topParagraph()->document()->firstParagraph() );
+    else
+	gotoLineStart();
+}
+
+void QTextCursor::gotoEnd()
+{
+    if ( topParagraph()->document() && topParagraph()->document()->lastParagraph()->isValid() )
+	gotoPosition( topParagraph()->document()->lastParagraph(),
+		      topParagraph()->document()->lastParagraph()->length() - 1);
+    else
+	gotoLineEnd();
+}
+
+void QTextCursor::gotoPageUp( int visibleHeight )
+{
+    int targetY  = globalY() - visibleHeight;
+    QTextParagraph* old; int index;
+    do {
+	old = para; index = idx;
+	gotoUp();
+    } while ( (old != para || index != idx)  && globalY() > targetY );
+}
+
+void QTextCursor::gotoPageDown( int visibleHeight )
+{
+    int targetY  = globalY() + visibleHeight;
+    QTextParagraph* old; int index;
+    do {
+	old = para; index = idx;
+	gotoDown();
+    } while ( (old != para || index != idx) && globalY() < targetY );
+}
+
+void QTextCursor::gotoWordRight()
+{
+    if ( para->string()->isRightToLeft() )
+	gotoPreviousWord();
+    else
+	gotoNextWord();
+}
+
+void QTextCursor::gotoWordLeft()
+{
+    if ( para->string()->isRightToLeft() )
+	gotoNextWord();
+    else
+	gotoPreviousWord();
+}
+
+static bool is_seperator( const QChar &c, bool onlySpace )
+{
+    if ( onlySpace )
+	return c.isSpace();
+    return c.isSpace() ||
+	c == '\t' ||
+	c == '.' ||
+	c == ',' ||
+	c == ':' ||
+	c == ';' ||
+	c == '-' ||
+	c == '<' ||
+	c == '>' ||
+	c == '[' ||
+	c == ']' ||
+	c == '(' ||
+	c == ')' ||
+	c == '{' ||
+	c == '}';
+}
+
+void QTextCursor::gotoPreviousWord( bool onlySpace )
+{
+    gotoPreviousLetter();
+    tmpX = -1;
+    QTextString *s = para->string();
+    bool allowSame = FALSE;
+    if ( idx == ((int)s->length()-1) )
+	return;
+    for ( int i = idx; i >= 0; --i ) {
+	if ( is_seperator( s->at( i ).c, onlySpace ) ) {
+	    if ( !allowSame )
+		continue;
+	    idx = i + 1;
+	    return;
+	}
+	if ( !allowSame && !is_seperator( s->at( i ).c, onlySpace ) )
+	    allowSame = TRUE;
+    }
+    idx = 0;
+}
+
+void QTextCursor::gotoNextWord( bool onlySpace )
+{
+    tmpX = -1;
+    QTextString *s = para->string();
+    bool allowSame = FALSE;
+    for ( int i = idx; i < (int)s->length(); ++i ) {
+	if ( !is_seperator( s->at( i ).c, onlySpace ) ) {
+	    if ( !allowSame )
+		continue;
+	    idx = i;
+	    return;
+	}
+	if ( !allowSame && is_seperator( s->at( i ).c, onlySpace ) )
+	    allowSame = TRUE;
+
+    }
+
+    if ( idx < ((int)s->length()-1) ) {
+	gotoLineEnd();
+    } else if ( para->next() ) {
+	QTextParagraph *p = para->next();
+	while ( p  && !p->isVisible() )
+	    p = p->next();
+	if ( s ) {
+	    para = p;
+	    idx = 0;
+	}
+    } else {
+	gotoLineEnd();
+    }
+}
+
+bool QTextCursor::atParagStart()
+{
+    return idx == 0;
+}
+
+bool QTextCursor::atParagEnd()
+{
+    return idx == para->length() - 1;
+}
+
+void QTextCursor::splitAndInsertEmptyParagraph( bool ind, bool updateIds )
+{
+    if ( !para->document() )
+	return;
+    tmpX = -1;
+    QTextFormat *f = 0;
+    if ( para->document()->useFormatCollection() ) {
+	f = para->at( idx )->format();
+	if ( idx == para->length() - 1 && idx > 0 )
+	    f = para->at( idx - 1 )->format();
+	if ( f->isMisspelled() ) {
+	    f->removeRef();
+	    f = para->document()->formatCollection()->format( f->font(), f->color() );
+	}
+    }
+
+    if ( atParagEnd() ) {
+	QTextParagraph *n = para->next();
+	QTextParagraph *s = para->document()->createParagraph( para->document(), para, n, updateIds );
+	if ( f )
+	    s->setFormat( 0, 1, f, TRUE );
+	s->copyParagData( para );
+	if ( ind ) {
+	    int oi, ni;
+	    s->indent( &oi, &ni );
+	    para = s;
+	    idx = ni;
+	} else {
+	    para = s;
+	    idx = 0;
+	}
+    } else if ( atParagStart() ) {
+	QTextParagraph *p = para->prev();
+	QTextParagraph *s = para->document()->createParagraph( para->document(), p, para, updateIds );
+	if ( f )
+	    s->setFormat( 0, 1, f, TRUE );
+	s->copyParagData( para );
+	if ( ind ) {
+	    s->indent();
+	    s->format();
+	    indent();
+	    para->format();
+	}
+    } else {
+	QString str = para->string()->toString().mid( idx, 0xFFFFFF );
+	QTextParagraph *n = para->next();
+	QTextParagraph *s = para->document()->createParagraph( para->document(), para, n, updateIds );
+	s->copyParagData( para );
+	s->remove( 0, 1 );
+	s->append( str, TRUE );
+	for ( uint i = 0; i < str.length(); ++i ) {
+	    QTextStringChar* tsc = para->at( idx + i );
+	    s->setFormat( i, 1, tsc->format(), TRUE );
+#ifndef QT_NO_TEXTCUSTOMITEM
+	    if ( tsc->isCustom() ) {
+		QTextCustomItem * item = tsc->customItem();
+		s->at( i )->setCustomItem( item );
+		tsc->loseCustomItem();
+	    }
+#endif
+	    if ( tsc->isAnchor() )
+		s->at( i )->setAnchor( tsc->anchorName(),
+				       tsc->anchorHref() );
+	}
+	para->truncate( idx );
+	if ( ind ) {
+	    int oi, ni;
+	    s->indent( &oi, &ni );
+	    para = s;
+	    idx = ni;
+	} else {
+	    para = s;
+	    idx = 0;
+	}
+    }
+
+    invalidateNested();
+}
+
+bool QTextCursor::remove()
+{
+    tmpX = -1;
+    if ( !atParagEnd() ) {
+	int next = para->string()->nextCursorPosition( idx );
+	para->remove( idx, next-idx );
+	int h = para->rect().height();
+	para->format( -1, TRUE );
+	if ( h != para->rect().height() )
+	    invalidateNested();
+	else if ( para->document() && para->document()->parent() )
+	    para->document()->nextDoubleBuffered = TRUE;
+	return FALSE;
+    } else if ( para->next() ) {
+	para->join( para->next() );
+	invalidateNested();
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/* needed to implement backspace the correct way */
+bool QTextCursor::removePreviousChar()
+{
+    tmpX = -1;
+    if ( !atParagStart() ) {
+	para->remove( idx-1, 1 );
+	int h = para->rect().height();
+	idx--;
+	// shouldn't be needed, just to make sure.
+	fixCursorPosition();
+	para->format( -1, TRUE );
+	if ( h != para->rect().height() )
+	    invalidateNested();
+	else if ( para->document() && para->document()->parent() )
+	    para->document()->nextDoubleBuffered = TRUE;
+	return FALSE;
+    } else if ( para->prev() ) {
+	para = para->prev();
+	para->join( para->next() );
+	invalidateNested();
+	return TRUE;
+    }
+    return FALSE;
+}
+
+void QTextCursor::indent()
+{
+    int oi = 0, ni = 0;
+    para->indent( &oi, &ni );
+    if ( oi == ni )
+	return;
+
+    if ( idx >= oi )
+	idx += ni - oi;
+    else
+	idx = ni;
+}
+
+void QTextCursor::fixCursorPosition()
+{
+    // searches for the closest valid cursor position
+    if ( para->string()->validCursorPosition( idx ) )
+	return;
+
+    int lineIdx;
+    QTextStringChar *start = para->lineStartOfChar( idx, &lineIdx, 0 );
+    int x = para->string()->at( idx ).x;
+    int diff = QABS(start->x - x);
+    int best = lineIdx;
+
+    QTextStringChar *c = start;
+    ++c;
+
+    QTextStringChar *end = &para->string()->at( para->length()-1 );
+    while ( c <= end && !c->lineStart ) {
+	int xp = c->x;
+	if ( c->rightToLeft )
+	    xp += para->string()->width( lineIdx + (c-start) );
+	int ndiff = QABS(xp - x);
+	if ( ndiff < diff && para->string()->validCursorPosition(lineIdx + (c-start)) ) {
+	    diff = ndiff;
+	    best = lineIdx + (c-start);
+	}
+	++c;
+    }
+    idx = best;
+}
+
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextDocument::QTextDocument( QTextDocument *p )
+    : par( p ), parentPar( 0 )
+#ifndef QT_NO_TEXTCUSTOMITEM
+    , tc( 0 )
+#endif
+    , tArray( 0 ), tStopWidth( 0 )
+{
+    fCollection = par ? par->fCollection : new QTextFormatCollection;
+    init();
+}
+
+void QTextDocument::init()
+{
+    oTextValid = TRUE;
+    mightHaveCustomItems = FALSE;
+    if ( par )
+	par->insertChild( this );
+    pProcessor = 0;
+    useFC = TRUE;
+    pFormatter = 0;
+    indenter = 0;
+    fParag = 0;
+    txtFormat = Qt::AutoText;
+    preferRichText = FALSE;
+    pages = FALSE;
+    focusIndicator.parag = 0;
+    minw = 0;
+    wused = 0;
+    minwParag = curParag = 0;
+    align = AlignAuto;
+    nSelections = 1;
+
+    setStyleSheet( QStyleSheet::defaultSheet() );
+#ifndef QT_NO_MIME
+    factory_ = QMimeSourceFactory::defaultFactory();
+#endif
+    contxt = QString::null;
+
+    underlLinks = par ? par->underlLinks : TRUE;
+    backBrush = 0;
+    buf_pixmap = 0;
+    nextDoubleBuffered = FALSE;
+
+    if ( par )
+	withoutDoubleBuffer = par->withoutDoubleBuffer;
+    else
+	withoutDoubleBuffer = FALSE;
+
+    lParag = fParag = createParagraph( this, 0, 0 );
+
+    cx = 0;
+    cy = 2;
+    if ( par )
+	cx = cy = 0;
+    cw = 600;
+    vw = 0;
+    flow_ = new QTextFlow;
+    flow_->setWidth( cw );
+
+    leftmargin = rightmargin = 4;
+    scaleFontsFactor = 1;
+
+
+    selectionColors[ Standard ] = QApplication::palette().color( QPalette::Active, QColorGroup::Highlight );
+    selectionText[ Standard ] = TRUE;
+    selectionText[ IMSelectionText ] = TRUE;
+    selectionText[ IMCompositionText ] = FALSE;
+    commandHistory = new QTextCommandHistory( 100 );
+    tStopWidth = formatCollection()->defaultFormat()->width( 'x' ) * 8;
+}
+
+QTextDocument::~QTextDocument()
+{
+    delete commandHistory;
+    if ( par )
+	par->removeChild( this );
+    clear();
+    delete flow_;
+    if ( !par ) {
+	delete pFormatter;
+        delete fCollection;
+    }
+    delete pProcessor;
+    delete buf_pixmap;
+    delete indenter;
+    delete backBrush;
+    delete [] tArray;
+}
+
+void QTextDocument::clear( bool createEmptyParag )
+{
+    while ( fParag ) {
+	QTextParagraph *p = fParag->next();
+	delete fParag;
+	fParag = p;
+    }
+    if ( flow_ )
+	flow_->clear();
+    fParag = lParag = 0;
+    if ( createEmptyParag )
+	fParag = lParag = createParagraph( this );
+    focusIndicator.parag = 0;
+    selections.clear();
+    oText = QString::null;
+    oTextValid = FALSE;
+}
+
+int QTextDocument::widthUsed() const
+{
+    return wused + 2*border_tolerance;
+}
+
+int QTextDocument::height() const
+{
+    int h = 0;
+    if ( lParag )
+	h = lParag->rect().top() + lParag->rect().height() + 1;
+    int fh = flow_->boundingRect().bottom();
+    return QMAX( h, fh );
+}
+
+
+
+QTextParagraph *QTextDocument::createParagraph( QTextDocument *d, QTextParagraph *pr, QTextParagraph *nx, bool updateIds )
+{
+    return new QTextParagraph( d, pr, nx, updateIds );
+}
+
+bool QTextDocument::setMinimumWidth( int needed, int used, QTextParagraph *p )
+{
+    if ( needed == -1 ) {
+	minw = 0;
+	wused = 0;
+	p = 0;
+    }
+    if ( p == minwParag ) {
+	if (minw > needed) {
+	    QTextParagraph *tp = fParag;
+	    while (tp) {
+		if (tp != p && tp->minwidth > needed) {
+		    needed = tp->minwidth;
+		    minwParag = tp;
+		}
+		tp = tp->n;
+	    }
+	}
+	minw = needed;
+	emit minimumWidthChanged( minw );
+    } else if ( needed > minw ) {
+	minw = needed;
+	minwParag = p;
+	emit minimumWidthChanged( minw );
+    }
+    wused = QMAX( wused, used );
+    wused = QMAX( wused, minw );
+    cw = QMAX( minw, cw );
+    return TRUE;
+}
+
+void QTextDocument::setPlainText( const QString &text )
+{
+    preferRichText = FALSE;
+    clear();
+    oTextValid = TRUE;
+    oText = text;
+
+    int lastNl = 0;
+    int nl = text.find( '\n' );
+    if ( nl == -1 ) {
+	lParag = createParagraph( this, lParag, 0 );
+	if ( !fParag )
+	    fParag = lParag;
+	QString s = text;
+	if ( !s.isEmpty() ) {
+	    if ( s[ (int)s.length() - 1 ] == '\r' )
+		s.remove( s.length() - 1, 1 );
+	    lParag->append( s );
+	}
+    } else {
+	for (;;) {
+	    lParag = createParagraph( this, lParag, 0 );
+	    if ( !fParag )
+		fParag = lParag;
+	    int l = nl - lastNl;
+	    if ( l > 0 ) {
+		if (text.unicode()[nl-1] == '\r')
+		    l--;
+		QConstString cs(text.unicode()+lastNl, l);
+		lParag->append( cs.string() );
+	    }
+	    if ( nl == (int)text.length() )
+		break;
+	    lastNl = nl + 1;
+	    nl = text.find( '\n', nl + 1 );
+	    if ( nl == -1 )
+		nl = text.length();
+	}
+    }
+    if ( !lParag )
+	lParag = fParag = createParagraph( this, 0, 0 );
+}
+
+struct Q_EXPORT QTextDocumentTag {
+    QTextDocumentTag(){}
+    QTextDocumentTag( const QString&n, const QStyleSheetItem* s, const QTextFormat& f )
+	:name(n),style(s), format(f), alignment(Qt::AlignAuto), direction(QChar::DirON),liststyle(QStyleSheetItem::ListDisc) {
+	    wsm = QStyleSheetItem::WhiteSpaceNormal;
+    }
+    QString name;
+    const QStyleSheetItem* style;
+    QString anchorHref;
+    QStyleSheetItem::WhiteSpaceMode wsm;
+    QTextFormat format;
+    int alignment : 16;
+    int direction : 5;
+    QStyleSheetItem::ListStyle liststyle;
+
+    QTextDocumentTag(  const QTextDocumentTag& t ) {
+	name = t.name;
+	style = t.style;
+	anchorHref = t.anchorHref;
+	wsm = t.wsm;
+	format = t.format;
+	alignment = t.alignment;
+	direction = t.direction;
+	liststyle = t.liststyle;
+    }
+    QTextDocumentTag& operator=(const QTextDocumentTag& t) {
+	name = t.name;
+	style = t.style;
+	anchorHref = t.anchorHref;
+	wsm = t.wsm;
+	format = t.format;
+	alignment = t.alignment;
+	direction = t.direction;
+	liststyle = t.liststyle;
+	return *this;
+    }
+
+    Q_DUMMY_COMPARISON_OPERATOR(QTextDocumentTag)
+};
+
+
+#define NEWPAR       do{ if ( !hasNewPar) { \
+		    if ( !textEditMode && curpar && curpar->length()>1 && curpar->at( curpar->length()-2)->c == QChar_linesep ) \
+			curpar->remove( curpar->length()-2, 1 ); \
+		    curpar = createParagraph( this, curpar, curpar->next() ); styles.append( vec ); vec = 0;} \
+		    hasNewPar = TRUE; \
+		    curpar->rtext = TRUE;  \
+		    curpar->align = curtag.alignment; \
+		    curpar->lstyle = curtag.liststyle; \
+		    curpar->litem = ( curtag.style->displayMode() == QStyleSheetItem::DisplayListItem ); \
+		    curpar->str->setDirection( (QChar::Direction)curtag.direction ); \
+		    space = TRUE; \
+		    tabExpansionColumn = 0; \
+		    delete vec; vec = new QPtrVector<QStyleSheetItem>( (uint)tags.count() + 1); \
+		    int i = 0; \
+		    for ( QValueStack<QTextDocumentTag>::Iterator it = tags.begin(); it != tags.end(); ++it ) \
+			vec->insert( i++, (*it).style ); \
+		    vec->insert( i, curtag.style ); \
+		    }while(FALSE);
+
+
+void QTextDocument::setRichText( const QString &text, const QString &context, const QTextFormat *initialFormat )
+{
+    preferRichText = TRUE;
+    if ( !context.isEmpty() )
+	setContext( context );
+    clear();
+    fParag = lParag = createParagraph( this );
+    oTextValid = TRUE;
+    oText = text;
+    setRichTextInternal( text, 0, initialFormat );
+    fParag->rtext = TRUE;
+}
+
+void QTextDocument::setRichTextInternal( const QString &text, QTextCursor* cursor, const QTextFormat *initialFormat )
+{
+    QTextParagraph* curpar = lParag;
+    int pos = 0;
+    QValueStack<QTextDocumentTag> tags;
+    if ( !initialFormat )
+        initialFormat = formatCollection()->defaultFormat();
+    QTextDocumentTag initag( "", sheet_->item(""), *initialFormat );
+    if ( bodyText.isValid() )
+	initag.format.setColor( bodyText );
+    QTextDocumentTag curtag = initag;
+    bool space = TRUE;
+    bool canMergeLi = FALSE;
+
+    bool textEditMode = FALSE;
+    int tabExpansionColumn = 0;
+
+    const QChar* doc = text.unicode();
+    int length = text.length();
+    bool hasNewPar = curpar->length() <= 1;
+    QString anchorName;
+
+    // style sheet handling for margin and line spacing calculation below
+    QTextParagraph* stylesPar = curpar;
+    QPtrVector<QStyleSheetItem>* vec = 0;
+    QPtrList< QPtrVector<QStyleSheetItem> > styles;
+    styles.setAutoDelete( TRUE );
+
+    if ( cursor ) {
+	cursor->splitAndInsertEmptyParagraph();
+	QTextCursor tmp = *cursor;
+	tmp.gotoPreviousLetter();
+	stylesPar = curpar = tmp.paragraph();
+	hasNewPar = TRUE;
+	textEditMode = TRUE;
+    } else {
+	NEWPAR;
+    }
+
+    // set rtext spacing to FALSE for the initial paragraph.
+    curpar->rtext = FALSE;
+
+    QString wellKnownTags = "br hr wsp table qt body meta title";
+
+    while ( pos < length ) {
+	if ( hasPrefix(doc, length, pos, '<' ) ){
+	    if ( !hasPrefix( doc, length, pos+1, QChar('/') ) ) {
+		// open tag
+		QMap<QString, QString> attr;
+		bool emptyTag = FALSE;
+		QString tagname = parseOpenTag(doc, length, pos, attr, emptyTag);
+		if ( tagname.isEmpty() )
+		    continue; // nothing we could do with this, probably parse error
+
+		const QStyleSheetItem* nstyle = sheet_->item(tagname);
+
+		if ( nstyle ) {
+		    // we might have to close some 'forgotten' tags
+		    while ( !nstyle->allowedInContext( curtag.style ) ) {
+			QString msg;
+			msg.sprintf( "QText Warning: Document not valid ( '%s' not allowed in '%s' #%d)",
+				     tagname.ascii(), curtag.style->name().ascii(), pos);
+			sheet_->error( msg );
+			if ( tags.isEmpty() )
+			    break;
+			curtag = tags.pop();
+		    }
+
+		    /* special handling for p and li for HTML
+		       compatibility. We do not want to embed blocks in
+		       p, and we do not want new blocks inside non-empty
+		       lis. Plus we want to merge empty lis sometimes. */
+		    if( nstyle->displayMode() == QStyleSheetItem::DisplayListItem ) {
+			canMergeLi = TRUE;
+		    } else if ( nstyle->displayMode() == QStyleSheetItem::DisplayBlock ) {
+			while ( curtag.style->name() == "p" ) {
+			    if ( tags.isEmpty() )
+				break;
+			    curtag = tags.pop();
+			}
+
+	   		if ( curtag.style->displayMode() == QStyleSheetItem::DisplayListItem ) {
+			    // we are in a li and a new block comes along
+			    if ( nstyle->name() == "ul" || nstyle->name() == "ol" )
+				hasNewPar = FALSE; // we want an empty li (like most browsers)
+			    if ( !hasNewPar ) {
+				/* do not add new blocks inside
+				   non-empty lis */
+				while ( curtag.style->displayMode() == QStyleSheetItem::DisplayListItem ) {
+				    if ( tags.isEmpty() )
+					break;
+				    curtag = tags.pop();
+				}
+			    } else if ( canMergeLi ) {
+				/* we have an empty li and a block
+				   comes along, merge them */
+				nstyle = curtag.style;
+			    }
+			    canMergeLi = FALSE;
+			}
+		    }
+		}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+		QTextCustomItem* custom =  0;
+#else
+		bool custom = FALSE;
+#endif
+
+		// some well-known tags, some have a nstyle, some not
+		if ( wellKnownTags.find( tagname ) != -1 ) {
+		    if ( tagname == "br" ) {
+			emptyTag = space = TRUE;
+			int index = QMAX( curpar->length(),1) - 1;
+			QTextFormat format = curtag.format.makeTextFormat( nstyle, attr, scaleFontsFactor );
+			curpar->append( QChar_linesep );
+			curpar->setFormat( index, 1, &format );
+                        hasNewPar = false;
+		    }  else if ( tagname == "hr" ) {
+			emptyTag = space = TRUE;
+#ifndef QT_NO_TEXTCUSTOMITEM
+			custom = sheet_->tag( tagname, attr, contxt, *factory_ , emptyTag, this );
+#endif
+		    } else if ( tagname == "table" ) {
+			emptyTag = space = TRUE;
+#ifndef QT_NO_TEXTCUSTOMITEM
+			QTextFormat format = curtag.format.makeTextFormat(  nstyle, attr, scaleFontsFactor );
+			curpar->setAlignment( curtag.alignment );
+			custom = parseTable( attr, format, doc, length, pos, curpar );
+#endif
+		    } else if ( tagname == "qt" || tagname == "body" ) {
+			if ( attr.contains( "bgcolor" ) ) {
+			    QBrush *b = new QBrush( QColor( attr["bgcolor"] ) );
+			    setPaper( b );
+			}
+			if ( attr.contains( "background" ) ) {
+#ifndef QT_NO_MIME
+			    QImage img;
+			    QString bg = attr["background"];
+			    const QMimeSource* m = factory_->data( bg, contxt );
+			    if ( !m ) {
+				qWarning("QRichText: no mimesource for %s", bg.latin1() );
+			    } else {
+				if ( !QImageDrag::decode( m, img ) ) {
+				    qWarning("QTextImage: cannot decode %s", bg.latin1() );
+				}
+			    }
+			    if ( !img.isNull() ) {
+				QBrush *b = new QBrush( QColor(), QPixmap( img ) );
+				setPaper( b );
+			    }
+#endif
+			}
+			if ( attr.contains( "text" ) ) {
+			    QColor c( attr["text"] );
+			    initag.format.setColor( c );
+			    curtag.format.setColor( c );
+			    bodyText = c;
+			}
+			if ( attr.contains( "link" ) )
+			    linkColor = QColor( attr["link"] );
+			if ( attr.contains( "title" ) )
+			    attribs.replace( "title", attr["title"] );
+
+			if ( textEditMode ) {
+			    if ( attr.contains("style" ) ) {
+				QString a = attr["style"];
+				for ( int s = 0; s < a.contains(';')+1; s++ ) {
+				    QString style = a.section( ';', s, s );
+				    if ( style.startsWith("font-size:" ) && style.endsWith("pt") ) {
+					scaleFontsFactor = double( formatCollection()->defaultFormat()->fn.pointSize() ) /
+							   style.mid( 10, style.length() - 12 ).toInt();
+				    }
+				}
+			    }
+			    nstyle = 0; // ignore body in textEditMode
+			}
+			// end qt- and body-tag handling
+		    } else if ( tagname == "meta" ) {
+			if ( attr["name"] == "qrichtext" && attr["content"] == "1" )
+			    textEditMode = TRUE;
+		    } else if ( tagname == "title" ) {
+			QString title;
+			while ( pos < length ) {
+			    if ( hasPrefix( doc, length, pos, QChar('<') ) && hasPrefix( doc, length, pos+1, QChar('/') ) &&
+				 parseCloseTag( doc, length, pos ) == "title" )
+				break;
+			    title += doc[ pos ];
+			    ++pos;
+			}
+			attribs.replace( "title", title );
+		    }
+		} // end of well-known tag handling
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+		if ( !custom ) // try generic custom item
+		    custom = sheet_->tag( tagname, attr, contxt, *factory_ , emptyTag, this );
+#endif
+		if ( !nstyle && !custom ) // we have no clue what this tag could be, ignore it
+		    continue;
+
+		if ( custom ) {
+#ifndef QT_NO_TEXTCUSTOMITEM
+		    int index = QMAX( curpar->length(),1) - 1;
+		    QTextFormat format = curtag.format.makeTextFormat( nstyle, attr, scaleFontsFactor );
+		    curpar->append( QChar('*') );
+		    QTextFormat* f = formatCollection()->format( &format );
+		    curpar->setFormat( index, 1, f );
+		    curpar->at( index )->setCustomItem( custom );
+		    if ( !curtag.anchorHref.isEmpty() )
+ 			curpar->at(index)->setAnchor( QString::null, curtag.anchorHref );
+ 		    if ( !anchorName.isEmpty()  ) {
+ 			curpar->at(index)->setAnchor( anchorName, curpar->at(index)->anchorHref() );
+ 			anchorName = QString::null;
+ 		    }
+		    registerCustomItem( custom, curpar );
+		    hasNewPar = FALSE;
+#endif
+		} else if ( !emptyTag ) {
+		    /* if we do nesting, push curtag on the stack,
+		       otherwise reinint curag. */
+ 		    if ( curtag.style->name() != tagname || nstyle->selfNesting() ) {
+			tags.push( curtag );
+		    } else {
+			if ( !tags.isEmpty() )
+			    curtag = tags.top();
+			else
+			    curtag = initag;
+		    }
+
+		    curtag.name = tagname;
+		    curtag.style = nstyle;
+		    curtag.name = tagname;
+		    curtag.style = nstyle;
+		    if ( nstyle->whiteSpaceMode()  != QStyleSheetItem::WhiteSpaceModeUndefined )
+			curtag.wsm = nstyle->whiteSpaceMode();
+
+		    /* netscape compatibility: eat a newline and only a newline if a pre block starts */
+		    if ( curtag.wsm == QStyleSheetItem::WhiteSpacePre &&
+			 nstyle->displayMode() == QStyleSheetItem::DisplayBlock )
+			eat( doc, length, pos, '\n' );
+
+		    /* ignore whitespace for inline elements if there
+		       was already one*/
+		    if ( !textEditMode &&
+			 (curtag.wsm == QStyleSheetItem::WhiteSpaceNormal
+			  || curtag.wsm == QStyleSheetItem::WhiteSpaceNoWrap)
+			 && ( space || nstyle->displayMode() != QStyleSheetItem::DisplayInline ) )
+			eatSpace( doc, length, pos );
+
+		    curtag.format = curtag.format.makeTextFormat( nstyle, attr, scaleFontsFactor );
+		    if ( nstyle->isAnchor() ) {
+			if ( !anchorName.isEmpty() )
+			    anchorName += "#" + attr["name"];
+			else
+			    anchorName = attr["name"];
+			curtag.anchorHref = attr["href"];
+		    }
+
+		    if ( nstyle->alignment() != QStyleSheetItem::Undefined )
+			curtag.alignment = nstyle->alignment();
+
+		    if ( nstyle->listStyle() != QStyleSheetItem::ListStyleUndefined )
+			curtag.liststyle = nstyle->listStyle();
+
+		    if ( nstyle->displayMode() == QStyleSheetItem::DisplayBlock
+			 || nstyle->displayMode() == QStyleSheetItem::DisplayListItem ) {
+
+			if ( nstyle->name() == "ol" || nstyle->name() == "ul" || nstyle->name() == "li") {
+			    QString type = attr["type"];
+			    if ( !type.isEmpty() ) {
+				if ( type == "1" ) {
+				    curtag.liststyle = QStyleSheetItem::ListDecimal;
+				} else if ( type == "a" ) {
+				    curtag.liststyle = QStyleSheetItem::ListLowerAlpha;
+				} else if ( type == "A" ) {
+				    curtag.liststyle = QStyleSheetItem::ListUpperAlpha;
+				} else {
+				    type = type.lower();
+				    if ( type == "square" )
+					curtag.liststyle = QStyleSheetItem::ListSquare;
+				    else if ( type == "disc" )
+					curtag.liststyle = QStyleSheetItem::ListDisc;
+				    else if ( type == "circle" )
+					curtag.liststyle = QStyleSheetItem::ListCircle;
+				}
+			    }
+			}
+
+
+			/* Internally we treat ordered and bullet
+			  lists the same for margin calculations. In
+			  order to have fast pointer compares in the
+			  xMargin() functions we restrict ourselves to
+			  <ol>. Once we calculate the margins in the
+			  parser rathern than later, the unelegance of
+			  this approach goes awy
+			 */
+			if ( nstyle->name() == "ul" )
+			    curtag.style = sheet_->item( "ol" );
+
+			if ( attr.contains( "align" ) ) {
+			    QString align = attr["align"].lower();
+			    if ( align == "center" )
+				curtag.alignment = Qt::AlignCenter;
+			    else if ( align == "right" )
+				curtag.alignment = Qt::AlignRight;
+			    else if ( align == "justify" )
+				curtag.alignment = Qt::AlignJustify;
+			}
+			if ( attr.contains( "dir" ) ) {
+			    QString dir = attr["dir"];
+			    if ( dir == "rtl" )
+				curtag.direction = QChar::DirR;
+			    else if ( dir == "ltr" )
+				curtag.direction = QChar::DirL;
+			}
+
+			NEWPAR;
+
+			if ( curtag.style->displayMode() == QStyleSheetItem::DisplayListItem ) {
+			    if ( attr.contains( "value " ) )
+				curpar->setListValue( attr["value"].toInt() );
+			}
+
+			if ( attr.contains( "style" ) ) {
+			    QString a = attr["style"];
+			    bool ok = TRUE;
+			    for ( int s = 0; ok && s < a.contains(';')+1; s++ ) {
+				QString style = a.section( ';', s, s );
+				if ( style.startsWith("margin-top:" ) && style.endsWith("px") )
+				    curpar->utm = 1+style.mid(11, style.length() - 13).toInt(&ok);
+				else if ( style.startsWith("margin-bottom:" ) && style.endsWith("px") )
+				    curpar->ubm = 1+style.mid(14, style.length() - 16).toInt(&ok);
+				else if ( style.startsWith("margin-left:" ) && style.endsWith("px") )
+				    curpar->ulm = 1+style.mid(12, style.length() - 14).toInt(&ok);
+				else if ( style.startsWith("margin-right:" ) && style.endsWith("px") )
+				    curpar->urm = 1+style.mid(13, style.length() - 15).toInt(&ok);
+				else if ( style.startsWith("text-indent:" ) && style.endsWith("px") )
+				    curpar->uflm = 1+style.mid(12, style.length() - 14).toInt(&ok);
+			    }
+			    if ( !ok ) // be pressmistic
+				curpar->utm = curpar->ubm = curpar->urm = curpar->ulm = 0;
+			}
+		    }
+		}
+	    } else {
+		QString tagname = parseCloseTag( doc, length, pos );
+		if ( tagname.isEmpty() )
+		    continue; // nothing we could do with this, probably parse error
+		if ( !sheet_->item( tagname ) ) // ignore unknown tags
+		    continue;
+		if ( tagname == "li" )
+		    continue;
+
+		// we close a block item. Since the text may continue, we need to have a new paragraph
+		bool needNewPar = curtag.style->displayMode() == QStyleSheetItem::DisplayBlock
+				 || curtag.style->displayMode() == QStyleSheetItem::DisplayListItem;
+
+
+		// html slopiness: handle unbalanched tag closing
+		while ( curtag.name != tagname ) {
+		    QString msg;
+		    msg.sprintf( "QText Warning: Document not valid ( '%s' not closed before '%s' #%d)",
+				 curtag.name.ascii(), tagname.ascii(), pos);
+		    sheet_->error( msg );
+		    if ( tags.isEmpty() )
+			break;
+		    curtag = tags.pop();
+		}
+
+
+		// close the tag
+		if ( !tags.isEmpty() )
+		    curtag = tags.pop();
+		else
+		    curtag = initag;
+
+ 		if ( needNewPar ) {
+		    if ( textEditMode && (tagname == "p" || tagname == "div" ) ) // preserve empty paragraphs
+			hasNewPar = FALSE;
+		    NEWPAR;
+		}
+	    }
+	} else {
+	    // normal contents
+	    QString s;
+	    QChar c;
+	    while ( pos < length && !hasPrefix(doc, length, pos, QChar('<') ) ){
+		if ( textEditMode ) {
+		    // text edit mode: we handle all white space but ignore newlines
+		    c = parseChar( doc, length, pos, QStyleSheetItem::WhiteSpacePre );
+		    if ( c == QChar_linesep )
+			break;
+		} else {
+		    int l = pos;
+		    c = parseChar( doc, length, pos, curtag.wsm );
+
+		    // in white space pre mode: treat any space as non breakable
+		    // and expand tabs to eight character wide columns.
+		    if ( curtag.wsm == QStyleSheetItem::WhiteSpacePre ) {
+			if  ( c == '\t' ) {
+			    c = ' ';
+			    while( (++tabExpansionColumn)%8 )
+				s += c;
+			}
+			if ( c == QChar_linesep )
+			    tabExpansionColumn = 0;
+			else
+			    tabExpansionColumn++;
+
+		    }
+		    if ( c == ' ' || c == QChar_linesep ) {
+			/* avoid overlong paragraphs by forcing a new
+			       paragraph after 4096 characters. This case can
+			       occur when loading undiscovered plain text
+			       documents in rich text mode. Instead of hanging
+			       forever, we do the trick.
+			    */
+			if ( curtag.wsm == QStyleSheetItem::WhiteSpaceNormal && s.length() > 4096 ) do {
+			    if ( doc[l] == '\n' ) {
+				hasNewPar = FALSE; // for a new paragraph ...
+				NEWPAR;
+				hasNewPar = FALSE; // ... and make it non-reusable
+				c = '\n';  // make sure we break below
+				break;
+			    }
+			} while ( ++l < pos );
+		    }
+		}
+
+		if ( c == '\n' )
+		    break;  // break on  newlines, pre delievers a QChar_linesep
+
+		bool c_isSpace = c.isSpace() && c.unicode() != 0x00a0U && !textEditMode;
+
+		if ( curtag.wsm == QStyleSheetItem::WhiteSpaceNormal && c_isSpace && space )
+		    continue;
+		if ( c == '\r' )
+		    continue;
+		space = c_isSpace;
+		s += c;
+	    }
+	    if ( !s.isEmpty() && curtag.style->displayMode() != QStyleSheetItem::DisplayNone ) {
+		hasNewPar = FALSE;
+		int index = QMAX( curpar->length(),1) - 1;
+		curpar->append( s );
+		if (curtag.wsm != QStyleSheetItem::WhiteSpaceNormal) {
+		    QTextString *str = curpar->string();
+		    for (uint i = index; i < index + s.length(); ++i)
+			str->at(i).nobreak = TRUE;
+		}
+
+		QTextFormat* f = formatCollection()->format( &curtag.format );
+		curpar->setFormat( index, s.length(), f, FALSE ); // do not use collection because we have done that already
+		f->ref += s.length() -1; // that what friends are for...
+		if ( !curtag.anchorHref.isEmpty() ) {
+		    for ( int i = 0; i < int(s.length()); i++ )
+			curpar->at(index + i)->setAnchor( QString::null, curtag.anchorHref );
+		}
+		if ( !anchorName.isEmpty()  ) {
+		    for ( int i = 0; i < int(s.length()); i++ )
+			curpar->at(index + i)->setAnchor( anchorName, curpar->at(index + i)->anchorHref() );
+		    anchorName = QString::null;
+		}
+	    }
+	}
+    }
+
+    if ( hasNewPar && curpar != fParag && !cursor && stylesPar != curpar ) {
+	// cleanup unused last paragraphs
+	curpar = curpar->p;
+	delete curpar->n;
+    }
+
+    if ( !anchorName.isEmpty()  ) {
+	curpar->at(curpar->length() - 1)->setAnchor( anchorName, curpar->at( curpar->length() - 1 )->anchorHref() );
+	anchorName = QString::null;
+    }
+
+
+    setRichTextMarginsInternal( styles, stylesPar );
+
+    if ( cursor ) {
+ 	cursor->gotoPreviousLetter();
+  	cursor->remove();
+     }
+    delete vec;
+}
+
+void QTextDocument::setRichTextMarginsInternal( QPtrList< QPtrVector<QStyleSheetItem> >& styles, QTextParagraph* stylesPar )
+{
+    // margin and line spacing calculation
+    QPtrVector<QStyleSheetItem>* prevStyle = 0;
+    QPtrVector<QStyleSheetItem>* curStyle = styles.first();
+    QPtrVector<QStyleSheetItem>* nextStyle = styles.next();
+    while ( stylesPar ) {
+	if ( !curStyle ) {
+	    stylesPar = stylesPar->next();
+	    prevStyle = curStyle;
+	    curStyle = nextStyle;
+	    nextStyle = styles.next();
+	    continue;
+	}
+
+	int i, mar;
+	QStyleSheetItem* mainStyle = curStyle->size() ? (*curStyle)[curStyle->size()-1] : 0;
+	if ( mainStyle && mainStyle->displayMode() == QStyleSheetItem::DisplayListItem )
+	    stylesPar->setListItem( TRUE );
+	int numLists = 0;
+	for ( i = 0; i < (int)curStyle->size(); ++i ) {
+	    if ( (*curStyle)[ i ]->displayMode() == QStyleSheetItem::DisplayBlock
+		 && (*curStyle)[ i ]->listStyle() != QStyleSheetItem::ListStyleUndefined )
+		numLists++;
+	}
+	stylesPar->ldepth = numLists;
+	if ( stylesPar->next() && nextStyle ) {
+	    // also set the depth of the next paragraph, required for the margin calculation
+	    numLists = 0;
+	    for ( i = 0; i < (int)nextStyle->size(); ++i ) {
+		if ( (*nextStyle)[ i ]->displayMode() == QStyleSheetItem::DisplayBlock
+		     && (*nextStyle)[ i ]->listStyle() != QStyleSheetItem::ListStyleUndefined )
+		    numLists++;
+	    }
+	    stylesPar->next()->ldepth = numLists;
+	}
+
+	// do the top margin
+	QStyleSheetItem* item = mainStyle;
+	int m;
+	if (stylesPar->utm > 0 ) {
+	    m = stylesPar->utm-1;
+	    stylesPar->utm = 0;
+	} else {
+	    m = QMAX(0, item->margin( QStyleSheetItem::MarginTop ) );
+	    if ( stylesPar->ldepth )
+		if ( item->displayMode() == QStyleSheetItem::DisplayListItem )
+		    m /= stylesPar->ldepth * stylesPar->ldepth;
+		else
+		    m = 0;
+	}
+	for ( i = (int)curStyle->size() - 2 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    if ( prevStyle && i < (int) prevStyle->size() &&
+		 (  item->displayMode() == QStyleSheetItem::DisplayBlock &&
+		    (*prevStyle)[ i ] == item ) )
+		break;
+	    // emulate CSS2' standard 0 vertical margin for multiple ul or ol tags
+ 	    if ( item->listStyle() != QStyleSheetItem::ListStyleUndefined  &&
+		 ( (  i> 0 && (*curStyle)[ i-1 ] == item ) || (*curStyle)[i+1] == item ) )
+		continue;
+	    mar = QMAX( 0, item->margin( QStyleSheetItem::MarginTop ) );
+	    m = QMAX( m, mar );
+	}
+	stylesPar->utm = m - stylesPar->topMargin();
+
+	// do the bottom margin
+	item = mainStyle;
+	if (stylesPar->ubm > 0 ) {
+	    m = stylesPar->ubm-1;
+	    stylesPar->ubm = 0;
+	} else {
+	    m = QMAX(0, item->margin( QStyleSheetItem::MarginBottom ) );
+	    if ( stylesPar->ldepth )
+		if ( item->displayMode() == QStyleSheetItem::DisplayListItem )
+		    m /= stylesPar->ldepth * stylesPar->ldepth;
+		else
+		    m = 0;
+	}
+	for ( i = (int)curStyle->size() - 2 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    if ( nextStyle && i < (int) nextStyle->size() &&
+		 (  item->displayMode() == QStyleSheetItem::DisplayBlock &&
+		    (*nextStyle)[ i ] == item ) )
+		break;
+	    // emulate CSS2' standard 0 vertical margin for multiple ul or ol tags
+ 	    if ( item->listStyle() != QStyleSheetItem::ListStyleUndefined  &&
+		 ( (  i> 0 && (*curStyle)[ i-1 ] == item ) || (*curStyle)[i+1] == item ) )
+		continue;
+	    mar = QMAX(0, item->margin( QStyleSheetItem::MarginBottom ) );
+	    m = QMAX( m, mar );
+	}
+	stylesPar->ubm = m - stylesPar->bottomMargin();
+
+	// do the left margin, simplyfied
+	item = mainStyle;
+	if (stylesPar->ulm > 0 ) {
+	    m = stylesPar->ulm-1;
+	    stylesPar->ulm = 0;
+	} else {
+	    m = QMAX( 0, item->margin( QStyleSheetItem::MarginLeft ) );
+	}
+	for ( i = (int)curStyle->size() - 2 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    m += QMAX( 0, item->margin( QStyleSheetItem::MarginLeft ) );
+	}
+	stylesPar->ulm = m - stylesPar->leftMargin();
+
+	// do the right margin, simplyfied
+	item = mainStyle;
+	if (stylesPar->urm > 0 ) {
+	    m = stylesPar->urm-1;
+	    stylesPar->urm = 0;
+	} else {
+	    m = QMAX( 0, item->margin( QStyleSheetItem::MarginRight ) );
+	}
+	for ( i = (int)curStyle->size() - 2 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    m += QMAX( 0, item->margin( QStyleSheetItem::MarginRight ) );
+	}
+	stylesPar->urm = m - stylesPar->rightMargin();
+
+	// do the first line margin, which really should be called text-indent
+	item = mainStyle;
+	if (stylesPar->uflm > 0 ) {
+	    m = stylesPar->uflm-1;
+	    stylesPar->uflm = 0;
+	} else {
+	    m = QMAX( 0, item->margin( QStyleSheetItem::MarginFirstLine ) );
+	}
+	for ( i = (int)curStyle->size() - 2 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    mar = QMAX( 0, item->margin( QStyleSheetItem::MarginFirstLine ) );
+	    m = QMAX( m, mar );
+	}
+	stylesPar->uflm =m - stylesPar->firstLineMargin();
+
+	// do the bogus line "spacing", which really is just an extra margin
+	item = mainStyle;
+	for ( i = (int)curStyle->size() - 1 ; i >= 0; --i ) {
+	    item = (*curStyle)[ i ];
+	    if ( item->lineSpacing() != QStyleSheetItem::Undefined ) {
+		stylesPar->ulinespacing = item->lineSpacing();
+		if ( formatCollection() &&
+		     stylesPar->ulinespacing < formatCollection()->defaultFormat()->height() )
+		    stylesPar->ulinespacing += formatCollection()->defaultFormat()->height();
+		break;
+	    }
+	}
+
+	stylesPar = stylesPar->next();
+	prevStyle = curStyle;
+	curStyle = nextStyle;
+	nextStyle = styles.next();
+    }
+}
+
+void QTextDocument::setText( const QString &text, const QString &context )
+{
+    focusIndicator.parag = 0;
+    selections.clear();
+    if ( txtFormat == Qt::AutoText && QStyleSheet::mightBeRichText( text ) ||
+	 txtFormat == Qt::RichText )
+	setRichText( text, context );
+    else
+	setPlainText( text );
+}
+
+QString QTextDocument::plainText() const
+{
+    QString buffer;
+    QString s;
+    QTextParagraph *p = fParag;
+    while ( p ) {
+	if ( !p->mightHaveCustomItems ) {
+	    const QTextString *ts = p->string(); // workaround VC++ and Borland
+	    s = ts->toString(); // with FALSE we don't fix spaces (nbsp)
+	} else {
+	    for ( int i = 0; i < p->length() - 1; ++i ) {
+#ifndef QT_NO_TEXTCUSTOMITEM
+		if ( p->at( i )->isCustom() ) {
+		    if ( p->at( i )->customItem()->isNested() ) {
+			s += "\n";
+			QTextTable *t = (QTextTable*)p->at( i )->customItem();
+			QPtrList<QTextTableCell> cells = t->tableCells();
+			for ( QTextTableCell *c = cells.first(); c; c = cells.next() )
+			    s += c->richText()->plainText() + "\n";
+			s += "\n";
+		    }
+		} else
+#endif
+		{
+		    s += p->at( i )->c;
+		}
+	    }
+	}
+	s.remove( s.length() - 1, 1 );
+	if ( p->next() )
+	    s += "\n";
+	buffer += s;
+	p = p->next();
+    }
+    return buffer;
+}
+
+static QString align_to_string( int a )
+{
+    if ( a & Qt::AlignRight )
+	return " align=\"right\"";
+    if ( a & Qt::AlignHCenter )
+	return " align=\"center\"";
+    if ( a & Qt::AlignJustify )
+	return " align=\"justify\"";
+    return QString::null;
+}
+
+static QString direction_to_string( int d )
+{
+    if ( d != QChar::DirON )
+	return ( d == QChar::DirL? " dir=\"ltr\"" : " dir=\"rtl\"" );
+    return QString::null;
+}
+
+static QString list_value_to_string( int v )
+{
+    if ( v != -1 )
+	return " listvalue=\"" + QString::number( v ) + "\"";
+    return QString::null;
+}
+
+static QString list_style_to_string( int v )
+{
+    switch( v ) {
+    case QStyleSheetItem::ListDecimal: return "\"1\"";
+    case QStyleSheetItem::ListLowerAlpha: return "\"a\"";
+    case QStyleSheetItem::ListUpperAlpha: return "\"A\"";
+    case QStyleSheetItem::ListDisc: return "\"disc\"";
+    case QStyleSheetItem::ListSquare: return "\"square\"";
+    case QStyleSheetItem::ListCircle: return "\"circle\"";
+    default:
+	return QString::null;
+    }
+}
+
+static inline bool list_is_ordered( int v )
+{
+    return v == QStyleSheetItem::ListDecimal ||
+	   v == QStyleSheetItem::ListLowerAlpha ||
+	   v == QStyleSheetItem::ListUpperAlpha;
+}
+
+
+static QString margin_to_string( QStyleSheetItem* style, int t, int b, int l, int r, int fl )
+{
+    QString s;
+    if ( l > 0 )
+	s += QString(!!s?";":"") + "margin-left:" + QString::number(l+QMAX(0,style->margin(QStyleSheetItem::MarginLeft))) + "px";
+    if ( r > 0 )
+	s += QString(!!s?";":"") + "margin-right:" + QString::number(r+QMAX(0,style->margin(QStyleSheetItem::MarginRight))) + "px";
+    if ( t > 0 )
+	s += QString(!!s?";":"") + "margin-top:" + QString::number(t+QMAX(0,style->margin(QStyleSheetItem::MarginTop))) + "px";
+    if ( b > 0 )
+	s += QString(!!s?";":"") + "margin-bottom:" + QString::number(b+QMAX(0,style->margin(QStyleSheetItem::MarginBottom))) + "px";
+    if ( fl > 0 )
+	s += QString(!!s?";":"") + "text-indent:" + QString::number(fl+QMAX(0,style->margin(QStyleSheetItem::MarginFirstLine))) + "px";
+    if ( !!s )
+	return " style=\"" + s + "\"";
+    return QString::null;
+}
+
+QString QTextDocument::richText() const
+{
+    QString s = "";
+    if ( !par ) {
+	s += "<html><head><meta name=\"qrichtext\" content=\"1\" /></head><body style=\"font-size:" ;
+	s += QString::number( formatCollection()->defaultFormat()->font().pointSize() );
+	s += "pt;font-family:";
+	s += formatCollection()->defaultFormat()->font().family();
+	s +="\">";
+    }
+    QTextParagraph* p = fParag;
+
+    QStyleSheetItem* item_p = styleSheet()->item("p");
+    QStyleSheetItem* item_div = styleSheet()->item("div");
+    QStyleSheetItem* item_ul = styleSheet()->item("ul");
+    QStyleSheetItem* item_ol = styleSheet()->item("ol");
+    QStyleSheetItem* item_li = styleSheet()->item("li");
+    if ( !item_p || !item_div || !item_ul || !item_ol || !item_li ) {
+	qWarning( "QTextEdit: cannot export HTML due to insufficient stylesheet (lack of p, div, ul, ol, or li)" );
+	return QString::null;
+    }
+    int pastListDepth = 0;
+    int listDepth = 0;
+#if 0
+    int futureListDepth = 0;
+#endif
+    QMemArray<int> listStyles(10);
+
+    while ( p ) {
+	listDepth = p->listDepth();
+	if ( listDepth < pastListDepth )  {
+	    for ( int i = pastListDepth; i > listDepth; i-- )
+		s += list_is_ordered( listStyles[i] ) ? "</ol>" : "</ul>";
+	    s += '\n';
+	} else if ( listDepth > pastListDepth ) {
+	    s += '\n';
+	    listStyles.resize( QMAX( (int)listStyles.size(), listDepth+1 ) );
+	    QString list_type;
+	    listStyles[listDepth] = p->listStyle();
+	    if ( !list_is_ordered( p->listStyle() ) || item_ol->listStyle() != p->listStyle() )
+		list_type = " type=" + list_style_to_string( p->listStyle() );
+	    for ( int i = pastListDepth; i < listDepth; i++ ) {
+		s += list_is_ordered( p->listStyle() ) ? "<ol" : "<ul" ;
+		s += list_type + ">";
+	    }
+	} else {
+	    s += '\n';
+	}
+
+	QString ps = p->richText();
+
+#if 0
+	  // for the bottom margin we need to know whether we are at the end of a list
+	futureListDepth = 0;
+	if ( listDepth > 0 && p->next() )
+	    futureListDepth = p->next()->listDepth();
+#endif
+
+	if ( richTextExportStart && richTextExportStart->paragraph() ==p &&
+	     richTextExportStart->index() == 0 )
+	    s += "<!--StartFragment-->";
+
+	if ( p->isListItem() ) {
+	    s += "<li";
+	    if ( p->listStyle() != listStyles[listDepth] )
+		s += " type=" + list_style_to_string( p->listStyle() );
+	    s +=align_to_string( p->alignment() );
+	    s += margin_to_string( item_li, p->utm, p->ubm, p->ulm, p->urm, p->uflm );
+	    s +=  list_value_to_string( p->listValue() );
+	    s += direction_to_string( p->direction() );
+	    s +=">";
+	    s += ps;
+	    s += "</li>";
+	} else if ( p->listDepth() ) {
+	    s += "<div";
+	    s += align_to_string( p->alignment() );
+	    s += margin_to_string( item_div, p->utm, p->ubm, p->ulm, p->urm, p->uflm );
+	    s +=direction_to_string( p->direction() );
+	    s += ">";
+	    s += ps;
+	    s += "</div>";
+	} else {
+	    // normal paragraph item
+	    s += "<p";
+	    s += align_to_string( p->alignment() );
+	    s += margin_to_string( item_p, p->utm, p->ubm, p->ulm, p->urm, p->uflm );
+	    s +=direction_to_string( p->direction() );
+	    s += ">";
+	    s += ps;
+	    s += "</p>";
+	}
+	pastListDepth = listDepth;
+	p = p->next();
+    }
+    while ( listDepth > 0 ) {
+	s += list_is_ordered( listStyles[listDepth] ) ? "</ol>" : "</ul>";
+	listDepth--;
+    }
+
+    if ( !par )
+	s += "\n</body></html>\n";
+
+    return s;
+}
+
+QString QTextDocument::text() const
+{
+    if ( txtFormat == Qt::AutoText && preferRichText || txtFormat == Qt::RichText )
+	return richText();
+    return plainText();
+}
+
+QString QTextDocument::text( int parag ) const
+{
+    QTextParagraph *p = paragAt( parag );
+    if ( !p )
+	return QString::null;
+
+    if ( txtFormat == Qt::AutoText && preferRichText || txtFormat == Qt::RichText )
+	return p->richText();
+    else
+	return p->string()->toString();
+}
+
+void QTextDocument::invalidate()
+{
+    QTextParagraph *s = fParag;
+    while ( s ) {
+	s->invalidate( 0 );
+	s = s->next();
+    }
+}
+
+void QTextDocument::selectionStart( int id, int &paragId, int &index )
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return;
+    QTextDocumentSelection &sel = *it;
+    paragId = !sel.swapped ? sel.startCursor.paragraph()->paragId() : sel.endCursor.paragraph()->paragId();
+    index = !sel.swapped ? sel.startCursor.index() : sel.endCursor.index();
+}
+
+QTextCursor QTextDocument::selectionStartCursor( int id)
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return QTextCursor( this );
+    QTextDocumentSelection &sel = *it;
+    if ( sel.swapped )
+	return sel.endCursor;
+    return sel.startCursor;
+}
+
+QTextCursor QTextDocument::selectionEndCursor( int id)
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return QTextCursor( this );
+    QTextDocumentSelection &sel = *it;
+    if ( !sel.swapped )
+	return sel.endCursor;
+    return sel.startCursor;
+}
+
+void QTextDocument::selectionEnd( int id, int &paragId, int &index )
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return;
+    QTextDocumentSelection &sel = *it;
+    paragId = sel.swapped ? sel.startCursor.paragraph()->paragId() : sel.endCursor.paragraph()->paragId();
+    index = sel.swapped ? sel.startCursor.index() : sel.endCursor.index();
+}
+
+void QTextDocument::addSelection( int id )
+{
+    nSelections = QMAX( nSelections, id + 1 );
+}
+
+static void setSelectionEndHelper( int id, QTextDocumentSelection &sel, QTextCursor &start, QTextCursor &end )
+{
+    QTextCursor c1 = start;
+    QTextCursor c2 = end;
+    if ( sel.swapped ) {
+	c1 = end;
+	c2 = start;
+    }
+
+    c1.paragraph()->removeSelection( id );
+    c2.paragraph()->removeSelection( id );
+    if ( c1.paragraph() != c2.paragraph() ) {
+	c1.paragraph()->setSelection( id, c1.index(), c1.paragraph()->length() - 1 );
+	c2.paragraph()->setSelection( id, 0, c2.index() );
+    } else {
+	c1.paragraph()->setSelection( id, QMIN( c1.index(), c2.index() ), QMAX( c1.index(), c2.index() ) );
+    }
+
+    sel.startCursor = start;
+    sel.endCursor = end;
+    if ( sel.startCursor.paragraph() == sel.endCursor.paragraph() )
+	sel.swapped = sel.startCursor.index() > sel.endCursor.index();
+}
+
+bool QTextDocument::setSelectionEnd( int id, const QTextCursor &cursor )
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return FALSE;
+    QTextDocumentSelection &sel = *it;
+
+    QTextCursor start = sel.startCursor;
+    QTextCursor end = cursor;
+
+    if ( start == end ) {
+	removeSelection( id );
+	setSelectionStart( id, cursor );
+	return TRUE;
+    }
+
+    if ( sel.endCursor.paragraph() == end.paragraph() ) {
+	setSelectionEndHelper( id, sel, start, end );
+	return TRUE;
+    }
+
+    bool inSelection = FALSE;
+    QTextCursor c( this );
+    QTextCursor tmp = sel.startCursor;
+    if ( sel.swapped )
+	tmp = sel.endCursor;
+    tmp.restoreState();
+    QTextCursor tmp2 = cursor;
+    tmp2.restoreState();
+    c.setParagraph( tmp.paragraph()->paragId() < tmp2.paragraph()->paragId() ? tmp.paragraph() : tmp2.paragraph() );
+    bool hadStart = FALSE;
+    bool hadEnd = FALSE;
+    bool hadStartParag = FALSE;
+    bool hadEndParag = FALSE;
+    bool hadOldStart = FALSE;
+    bool hadOldEnd = FALSE;
+    bool leftSelection = FALSE;
+    sel.swapped = FALSE;
+    for ( ;; ) {
+	if ( c == start )
+	    hadStart = TRUE;
+	if ( c == end )
+	    hadEnd = TRUE;
+	if ( c.paragraph() == start.paragraph() )
+	    hadStartParag = TRUE;
+	if ( c.paragraph() == end.paragraph() )
+	    hadEndParag = TRUE;
+	if ( c == sel.startCursor )
+	    hadOldStart = TRUE;
+	if ( c == sel.endCursor )
+	    hadOldEnd = TRUE;
+
+	if ( !sel.swapped &&
+	     ( hadEnd && !hadStart ||
+	       hadEnd && hadStart && start.paragraph() == end.paragraph() && start.index() > end.index() ) )
+	    sel.swapped = TRUE;
+
+	if ( c == end && hadStartParag ||
+	     c == start && hadEndParag ) {
+	    QTextCursor tmp = c;
+	    tmp.restoreState();
+	    if ( tmp.paragraph() != c.paragraph() ) {
+		int sstart = tmp.paragraph()->selectionStart( id );
+		tmp.paragraph()->removeSelection( id );
+		tmp.paragraph()->setSelection( id, sstart, tmp.index() );
+	    }
+	}
+
+	if ( inSelection &&
+	     ( c == end && hadStart || c == start && hadEnd ) )
+	     leftSelection = TRUE;
+	else if ( !leftSelection && !inSelection && ( hadStart || hadEnd ) )
+	    inSelection = TRUE;
+
+	bool noSelectionAnymore = hadOldStart && hadOldEnd && leftSelection && !inSelection && !c.paragraph()->hasSelection( id ) && c.atParagEnd();
+	c.paragraph()->removeSelection( id );
+	if ( inSelection ) {
+	    if ( c.paragraph() == start.paragraph() && start.paragraph() == end.paragraph() ) {
+		c.paragraph()->setSelection( id, QMIN( start.index(), end.index() ), QMAX( start.index(), end.index() ) );
+	    } else if ( c.paragraph() == start.paragraph() && !hadEndParag ) {
+		c.paragraph()->setSelection( id, start.index(), c.paragraph()->length() - 1 );
+	    } else if ( c.paragraph() == end.paragraph() && !hadStartParag ) {
+		c.paragraph()->setSelection( id, end.index(), c.paragraph()->length() - 1 );
+	    } else if ( c.paragraph() == end.paragraph() && hadEndParag ) {
+		c.paragraph()->setSelection( id, 0, end.index() );
+	    } else if ( c.paragraph() == start.paragraph() && hadStartParag ) {
+		c.paragraph()->setSelection( id, 0, start.index() );
+	    } else {
+		c.paragraph()->setSelection( id, 0, c.paragraph()->length() - 1 );
+	    }
+	}
+
+	if ( leftSelection )
+	    inSelection = FALSE;
+
+	if ( noSelectionAnymore )
+	    break;
+	// *ugle*hack optimization
+	QTextParagraph *p = c.paragraph();
+	if (  p->mightHaveCustomItems || p == start.paragraph() || p == end.paragraph() || p == lastParagraph() ) {
+	    c.gotoNextLetter();
+	    if ( p == lastParagraph() && c.atParagEnd() )
+		break;
+	} else {
+	    if ( p->document()->parent() )
+		do {
+		    c.gotoNextLetter();
+		} while ( c.paragraph() == p );
+	    else
+		c.setParagraph( p->next() );
+	}
+    }
+
+    if ( !sel.swapped )
+	sel.startCursor.paragraph()->setSelection( id, sel.startCursor.index(), sel.startCursor.paragraph()->length() - 1 );
+
+    sel.startCursor = start;
+    sel.endCursor = end;
+    if ( sel.startCursor.paragraph() == sel.endCursor.paragraph() )
+	sel.swapped = sel.startCursor.index() > sel.endCursor.index();
+
+    setSelectionEndHelper( id, sel, start, end );
+
+    return TRUE;
+}
+
+void QTextDocument::selectAll( int id )
+{
+    removeSelection( id );
+
+    QTextDocumentSelection sel;
+    sel.swapped = FALSE;
+    QTextCursor c( this );
+
+    c.setParagraph( fParag );
+    c.setIndex( 0 );
+    sel.startCursor = c;
+
+    c.setParagraph( lParag );
+    c.setIndex( lParag->length() - 1 );
+    sel.endCursor = c;
+
+    selections.insert( id, sel );
+
+    QTextParagraph *p = fParag;
+    while ( p ) {
+	p->setSelection( id, 0, p->length() - 1 );
+	p = p->next();
+    }
+
+    for ( QTextDocument *d = childList.first(); d; d = childList.next() )
+	d->selectAll( id );
+}
+
+bool QTextDocument::removeSelection( int id )
+{
+    if ( !selections.contains( id ) )
+	return FALSE;
+
+    QTextDocumentSelection &sel = selections[ id ];
+
+    QTextCursor start = sel.swapped ? sel.endCursor : sel.startCursor;
+    QTextCursor end = sel.swapped ? sel.startCursor : sel.endCursor;
+    QTextParagraph* p = 0;
+    while ( start != end ) {
+	if ( p != start.paragraph() ) {
+	    p = start.paragraph();
+	    p->removeSelection( id );
+	    //### avoid endless loop by all means necessary, did somebody mention refactoring?
+	    if ( !parent() && p == lParag )
+		break;
+	}
+	start.gotoNextLetter();
+    }
+    p = start.paragraph();
+    p->removeSelection( id );
+    selections.remove( id );
+    return TRUE;
+}
+
+QString QTextDocument::selectedText( int id, bool asRichText ) const
+{
+    QMap<int, QTextDocumentSelection>::ConstIterator it = selections.find( id );
+    if ( it == selections.end() )
+	return QString::null;
+
+    QTextDocumentSelection sel = *it;
+
+
+    QTextCursor c1 = sel.startCursor;
+    QTextCursor c2 = sel.endCursor;
+    if ( sel.swapped ) {
+	c2 = sel.startCursor;
+	c1 = sel.endCursor;
+    }
+
+    /* 3.0.3 improvement: Make it possible to get a reasonable
+       selection inside a table.  This approach is very conservative:
+       make sure that both cursors have the same depth level and point
+       to paragraphs within the same text document.
+
+       Meaning if you select text in two table cells, you will get the
+       entire table. This is still far better than the 3.0.2, where
+       you always got the entire table.
+
+       ### Fix this properly when refactoring
+     */
+    while ( c2.nestedDepth() > c1.nestedDepth() )
+	c2.oneUp();
+    while ( c1.nestedDepth() > c2.nestedDepth() )
+	c1.oneUp();
+    while ( c1.nestedDepth() && c2.nestedDepth() &&
+	    c1.paragraph()->document() != c2.paragraph()->document() ) {
+	c1.oneUp();
+	c2.oneUp();
+    }
+    // do not trust sel_swapped with tables. Fix this properly when refactoring as well
+    if ( c1.paragraph()->paragId() > c2.paragraph()->paragId() ||
+	 (c1.paragraph() == c2.paragraph() && c1.index() > c2.index() ) ) {
+	QTextCursor tmp = c1;
+	c2 = c1;
+	c1 = tmp;
+    }
+
+    // end selection 3.0.3 improvement
+
+    if ( asRichText && !parent() ) {
+	richTextExportStart = &c1;
+	richTextExportEnd = &c2;
+
+	QString sel = richText();
+	int from = sel.find( "<!--StartFragment-->" );
+	if ( from >= 0 ) {
+	    from += 20;
+	    // find the previous span and move it into the start fragment before we clip it
+	    QString prevspan;
+	    int pspan = sel.findRev( "<span", from-21 );
+	    if ( pspan > sel.findRev( "</span", from-21 ) ) {
+		int spanend = sel.find( '>', pspan );
+		prevspan = sel.mid( pspan, spanend - pspan + 1 );
+	    }
+	    int to = sel.findRev( "<!--EndFragment-->" );
+	    if ( from <= to )
+		sel = "<!--StartFragment-->" + prevspan + sel.mid( from, to - from );
+	}
+	richTextExportStart = richTextExportEnd = 0;
+	return sel;
+    }
+
+    QString s;
+    if ( c1.paragraph() == c2.paragraph() ) {
+	QTextParagraph *p = c1.paragraph();
+	int end = c2.index();
+	if ( p->at( QMAX( 0, end - 1 ) )->isCustom() )
+	    ++end;
+	if ( !p->mightHaveCustomItems ) {
+	    s += p->string()->toString().mid( c1.index(), end - c1.index() );
+	} else {
+	    for ( int i = c1.index(); i < end; ++i ) {
+#ifndef QT_NO_TEXTCUSTOMITEM
+		if ( p->at( i )->isCustom() ) {
+		    if ( p->at( i )->customItem()->isNested() ) {
+			s += "\n";
+			QTextTable *t = (QTextTable*)p->at( i )->customItem();
+			QPtrList<QTextTableCell> cells = t->tableCells();
+			for ( QTextTableCell *c = cells.first(); c; c = cells.next() )
+			    s += c->richText()->plainText() + "\n";
+			s += "\n";
+		    }
+		} else
+#endif
+		{
+		    s += p->at( i )->c;
+		}
+	    }
+	}
+    } else {
+	QTextParagraph *p = c1.paragraph();
+	int start = c1.index();
+	while ( p ) {
+	    int end = p == c2.paragraph() ? c2.index() : p->length() - 1;
+	    if ( p == c2.paragraph() && p->at( QMAX( 0, end - 1 ) )->isCustom() )
+		++end;
+	    if ( !p->mightHaveCustomItems ) {
+		s += p->string()->toString().mid( start, end - start );
+		if ( p != c2.paragraph() )
+		    s += "\n";
+	    } else {
+		for ( int i = start; i < end; ++i ) {
+#ifndef QT_NO_TEXTCUSTOMITEM
+		    if ( p->at( i )->isCustom() ) {
+			if ( p->at( i )->customItem()->isNested() ) {
+			    s += "\n";
+			    QTextTable *t = (QTextTable*)p->at( i )->customItem();
+			    QPtrList<QTextTableCell> cells = t->tableCells();
+			    for ( QTextTableCell *c = cells.first(); c; c = cells.next() )
+				s += c->richText()->plainText() + "\n";
+			    s += "\n";
+			}
+		    } else
+#endif
+		    {
+			s += p->at( i )->c;
+		    }
+		}
+	    }
+	    start = 0;
+	    if ( p == c2.paragraph() )
+		break;
+	    p = p->next();
+	}
+    }
+    // ### workaround for plain text export until we get proper
+    // mime types: turn unicode line seperators into the more
+    // widely understood \n. Makes copy and pasting code snipplets
+    // from within Assistent possible
+    QChar* uc = (QChar*) s.unicode();
+    for ( uint ii = 0; ii < s.length(); ii++ ) {
+	if ( uc[(int)ii] == QChar_linesep )
+	    uc[(int)ii] = QChar('\n');
+        else if ( uc[(int)ii] == QChar::nbsp )
+	    uc[(int)ii] = QChar(' ');
+    }
+    return s;
+}
+
+void QTextDocument::setFormat( int id, QTextFormat *f, int flags )
+{
+    QMap<int, QTextDocumentSelection>::ConstIterator it = selections.find( id );
+    if ( it == selections.end() )
+	return;
+
+    QTextDocumentSelection sel = *it;
+
+    QTextCursor c1 = sel.startCursor;
+    QTextCursor c2 = sel.endCursor;
+    if ( sel.swapped ) {
+	c2 = sel.startCursor;
+	c1 = sel.endCursor;
+    }
+
+    c2.restoreState();
+    c1.restoreState();
+
+    if ( c1.paragraph() == c2.paragraph() ) {
+	c1.paragraph()->setFormat( c1.index(), c2.index() - c1.index(), f, TRUE, flags );
+	return;
+    }
+
+    c1.paragraph()->setFormat( c1.index(), c1.paragraph()->length() - c1.index(), f, TRUE, flags );
+    QTextParagraph *p = c1.paragraph()->next();
+    while ( p && p != c2.paragraph() ) {
+	p->setFormat( 0, p->length(), f, TRUE, flags );
+	p = p->next();
+    }
+    c2.paragraph()->setFormat( 0, c2.index(), f, TRUE, flags );
+}
+
+void QTextDocument::removeSelectedText( int id, QTextCursor *cursor )
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return;
+
+    QTextDocumentSelection sel = *it;
+    QTextCursor c1 = sel.startCursor;
+    QTextCursor c2 = sel.endCursor;
+    if ( sel.swapped ) {
+	c2 = sel.startCursor;
+	c1 = sel.endCursor;
+    }
+
+    // ### no support for editing tables yet
+    if ( c1.nestedDepth() || c2.nestedDepth() )
+	return;
+
+    c2.restoreState();
+    c1.restoreState();
+
+    *cursor = c1;
+    removeSelection( id );
+
+    if ( c1.paragraph() == c2.paragraph() ) {
+	c1.paragraph()->remove( c1.index(), c2.index() - c1.index() );
+	return;
+    }
+
+    if ( c1.paragraph() == fParag && c1.index() == 0 &&
+	 c2.paragraph() == lParag && c2.index() == lParag->length() - 1 )
+	cursor->setValid( FALSE );
+
+    bool didGoLeft = FALSE;
+    if (  c1.index() == 0 && c1.paragraph() != fParag ) {
+	cursor->gotoPreviousLetter();
+	didGoLeft = cursor->isValid();
+    }
+
+    c1.paragraph()->remove( c1.index(), c1.paragraph()->length() - 1 - c1.index() );
+    QTextParagraph *p = c1.paragraph()->next();
+    int dy = 0;
+    QTextParagraph *tmp;
+    while ( p && p != c2.paragraph() ) {
+	tmp = p->next();
+	dy -= p->rect().height();
+	delete p;
+	p = tmp;
+    }
+    c2.paragraph()->remove( 0, c2.index() );
+    while ( p ) {
+	p->move( dy );
+	p->invalidate( 0 );
+	p->setEndState( -1 );
+	p = p->next();
+    }
+
+
+    c1.paragraph()->join( c2.paragraph() );
+
+    if ( didGoLeft )
+	cursor->gotoNextLetter();
+}
+
+void QTextDocument::indentSelection( int id )
+{
+    QMap<int, QTextDocumentSelection>::Iterator it = selections.find( id );
+    if ( it == selections.end() )
+	return;
+
+    QTextDocumentSelection sel = *it;
+    QTextParagraph *startParag = sel.startCursor.paragraph();
+    QTextParagraph *endParag = sel.endCursor.paragraph();
+    if ( sel.endCursor.paragraph()->paragId() < sel.startCursor.paragraph()->paragId() ) {
+	endParag = sel.startCursor.paragraph();
+	startParag = sel.endCursor.paragraph();
+    }
+
+    QTextParagraph *p = startParag;
+    while ( p && p != endParag ) {
+	p->indent();
+	p = p->next();
+    }
+}
+
+void QTextDocument::addCommand( QTextCommand *cmd )
+{
+    commandHistory->addCommand( cmd );
+}
+
+QTextCursor *QTextDocument::undo( QTextCursor *c )
+{
+    return commandHistory->undo( c );
+}
+
+QTextCursor *QTextDocument::redo( QTextCursor *c )
+{
+    return commandHistory->redo( c );
+}
+
+bool QTextDocument::find( QTextCursor& cursor, const QString &expr, bool cs, bool wo, bool forward )
+{
+    removeSelection( Standard );
+    QTextParagraph *p = 0;
+    if ( expr.isEmpty() )
+	return FALSE;
+    for (;;) {
+	if ( p != cursor.paragraph() ) {
+	    p = cursor.paragraph();
+	    QString s = cursor.paragraph()->string()->toString();
+	    int start = cursor.index();
+	    for ( ;; ) {
+		int res = forward ? s.find( expr, start, cs ) : s.findRev( expr, start, cs );
+		int end = res + expr.length();
+		if ( res == -1 || ( !forward && start <= res ) )
+		    break;
+		if ( !wo || ( ( res == 0 || s[ res - 1 ].isSpace() || s[ res - 1 ].isPunct() ) &&
+			      ( end == (int)s.length() || s[ end ].isSpace() || s[ end ].isPunct() ) ) ) {
+		    removeSelection( Standard );
+		    cursor.setIndex( forward ? end : res );
+		    setSelectionStart( Standard, cursor );
+		    cursor.setIndex( forward ? res : end );
+		    setSelectionEnd( Standard, cursor );
+		    if ( !forward )
+			cursor.setIndex( res );
+		    return TRUE;
+		}
+		start = res + (forward ? 1 : -1);
+	    }
+	}
+	if ( forward ) {
+	    if ( cursor.paragraph() == lastParagraph() && cursor.atParagEnd() )
+		 break;
+	    cursor.gotoNextLetter();
+	} else {
+	    if ( cursor.paragraph() == firstParagraph() && cursor.atParagStart() )
+		 break;
+	    cursor.gotoPreviousLetter();
+	}
+    }
+    return FALSE;
+}
+
+void QTextDocument::setTextFormat( Qt::TextFormat f )
+{
+    txtFormat = f;
+    if ( fParag == lParag && fParag->length() <= 1 )
+	fParag->rtext = ( f == Qt::RichText );
+}
+
+Qt::TextFormat QTextDocument::textFormat() const
+{
+    return txtFormat;
+}
+
+bool QTextDocument::inSelection( int selId, const QPoint &pos ) const
+{
+    QMap<int, QTextDocumentSelection>::ConstIterator it = selections.find( selId );
+    if ( it == selections.end() )
+	return FALSE;
+
+    QTextDocumentSelection sel = *it;
+    QTextParagraph *startParag = sel.startCursor.paragraph();
+    QTextParagraph *endParag = sel.endCursor.paragraph();
+    if ( sel.startCursor.paragraph() == sel.endCursor.paragraph() &&
+	 sel.startCursor.paragraph()->selectionStart( selId ) == sel.endCursor.paragraph()->selectionEnd( selId ) )
+	return FALSE;
+    if ( sel.endCursor.paragraph()->paragId() < sel.startCursor.paragraph()->paragId() ) {
+	endParag = sel.startCursor.paragraph();
+	startParag = sel.endCursor.paragraph();
+    }
+
+    QTextParagraph *p = startParag;
+    while ( p ) {
+	if ( p->rect().contains( pos ) ) {
+	    bool inSel = FALSE;
+	    int selStart = p->selectionStart( selId );
+	    int selEnd = p->selectionEnd( selId );
+	    int y = 0;
+	    int h = 0;
+	    for ( int i = 0; i < p->length(); ++i ) {
+		if ( i == selStart )
+		    inSel = TRUE;
+		if ( i == selEnd )
+		    break;
+		if ( p->at( i )->lineStart ) {
+		    y = (*p->lineStarts.find( i ))->y;
+		    h = (*p->lineStarts.find( i ))->h;
+		}
+		if ( pos.y() - p->rect().y() >= y && pos.y() - p->rect().y() <= y + h ) {
+		    if ( inSel && pos.x() >= p->at( i )->x &&
+			 pos.x() <= p->at( i )->x + p->at( i )->format()->width( p->at( i )->c ) )
+			return TRUE;
+		}
+	    }
+	}
+	if ( pos.y() < p->rect().y() )
+	    break;
+	if ( p == endParag )
+	    break;
+	p = p->next();
+    }
+
+    return FALSE;
+}
+
+void QTextDocument::doLayout( QPainter *p, int w )
+{
+    minw = wused = 0;
+    if ( !is_printer( p ) )
+	p = 0;
+    withoutDoubleBuffer = ( p != 0 );
+    QPainter * oldPainter = QTextFormat::painter();
+    QTextFormat::setPainter( p );
+    tStopWidth = formatCollection()->defaultFormat()->width( 'x' ) * 8;
+    flow_->setWidth( w );
+    cw = w;
+    vw = w;
+    QTextParagraph *parag = fParag;
+    while ( parag ) {
+	parag->invalidate( 0 );
+	if ( p )
+	    parag->adjustToPainter( p );
+	parag->format();
+	parag = parag->next();
+    }
+    QTextFormat::setPainter( oldPainter );
+}
+
+QPixmap *QTextDocument::bufferPixmap( const QSize &s )
+{
+    if ( !buf_pixmap )
+	buf_pixmap = new QPixmap( s.expandedTo( QSize(1,1) ) );
+    else if ( buf_pixmap->size() != s )
+	buf_pixmap->resize( s.expandedTo( buf_pixmap->size() ) );
+    return buf_pixmap;
+}
+
+void QTextDocument::draw( QPainter *p, const QRect &rect, const QColorGroup &cg, const QBrush *paper )
+{
+    if ( !firstParagraph() )
+	return;
+
+    if ( paper ) {
+	p->setBrushOrigin( -int( p->translationX() ),
+			   -int( p->translationY() ) );
+
+	p->fillRect( rect, *paper );
+    }
+
+    QPainter * oldPainter = QTextFormat::painter();
+    QTextFormat::setPainter( p );
+
+    if ( formatCollection()->defaultFormat()->color() != cg.text() )
+	setDefaultFormat( formatCollection()->defaultFormat()->font(), cg.text() );
+
+    QTextParagraph *parag = firstParagraph();
+    while ( parag ) {
+	if ( !parag->isValid() )
+	    parag->format();
+	int y = parag->rect().y();
+	QRect pr( parag->rect() );
+	pr.setX( 0 );
+	pr.setWidth( QWIDGETSIZE_MAX );
+	if ( !rect.isNull() && !rect.intersects( pr ) ) {
+	    parag = parag->next();
+	    continue;
+	}
+	p->translate( 0, y );
+	if ( rect.isValid() )
+	    parag->paint( *p, cg, 0, FALSE, rect.x(), rect.y(), rect.width(), rect.height() );
+	else
+	    parag->paint( *p, cg, 0, FALSE );
+	p->translate( 0, -y );
+	parag = parag->next();
+	if ( !flow()->isEmpty() )
+	    flow()->drawFloatingItems( p, rect.x(), rect.y(), rect.width(), rect.height(), cg, FALSE );
+    }
+    QTextFormat::setPainter(oldPainter);
+}
+
+void QTextDocument::drawParagraph( QPainter *p, QTextParagraph *parag, int cx, int cy, int cw, int ch,
+			       QPixmap *&doubleBuffer, const QColorGroup &cg,
+			       bool drawCursor, QTextCursor *cursor, bool resetChanged )
+{
+    QPainter *painter = 0;
+    if ( resetChanged )
+	parag->setChanged( FALSE );
+    QRect ir( parag->rect() );
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if (!parag->tableCell())
+#endif
+	ir.setWidth(width());
+
+    bool uDoubleBuffer = useDoubleBuffer( parag, p );
+
+    if ( uDoubleBuffer  ) {
+	painter = new QPainter;
+	if ( cx >= 0 && cy >= 0 )
+	    ir = ir.intersect( QRect( cx, cy, cw, ch ) );
+	if ( !doubleBuffer ||
+	     ir.width() > doubleBuffer->width() ||
+	     ir.height() > doubleBuffer->height() ) {
+	    doubleBuffer = bufferPixmap( ir.size() );
+	    painter->begin( doubleBuffer );
+	} else {
+	    painter->begin( doubleBuffer );
+	}
+    } else {
+	painter = p;
+	painter->translate( ir.x(), ir.y() );
+    }
+
+    painter->setBrushOrigin( -ir.x(), -ir.y() );
+
+    if ( uDoubleBuffer || is_printer( painter ) )
+	painter->fillRect( QRect( 0, 0, ir.width(), ir.height() ), parag->backgroundBrush( cg ) );
+    else if ( cursor && cursor->paragraph() == parag )
+	painter->fillRect( QRect( parag->at( cursor->index() )->x, 0, 2, ir.height() ),
+			   parag->backgroundBrush( cg ) );
+
+    painter->translate( -( ir.x() - parag->rect().x() ),
+			-( ir.y() - parag->rect().y() ) );
+    parag->paint( *painter, cg, drawCursor ? cursor : 0, TRUE, cx, cy, cw, ch );
+
+    if ( uDoubleBuffer ) {
+	delete painter;
+	painter = 0;
+	p->drawPixmap( ir.topLeft(), *doubleBuffer, QRect( QPoint( 0, 0 ), ir.size() ) );
+    } else {
+	painter->translate( -ir.x(), -ir.y() );
+    }
+
+    parag->document()->nextDoubleBuffered = FALSE;
+}
+
+QTextParagraph *QTextDocument::draw( QPainter *p, int cx, int cy, int cw, int ch, const QColorGroup &cg,
+				 bool onlyChanged, bool drawCursor, QTextCursor *cursor, bool resetChanged )
+{
+    if ( withoutDoubleBuffer || par && par->withoutDoubleBuffer ) {
+	withoutDoubleBuffer = TRUE;
+	QRect r;
+	draw( p, r, cg );
+	return 0;
+    }
+    withoutDoubleBuffer = FALSE;
+
+    if ( !firstParagraph() )
+	return 0;
+
+    QPainter * oldPainter = QTextFormat::painter();
+    QTextFormat::setPainter( p );
+    if ( formatCollection()->defaultFormat()->color() != cg.text() )
+	setDefaultFormat( formatCollection()->defaultFormat()->font(), cg.text() );
+
+    if ( cx < 0 && cy < 0 ) {
+	cx = 0;
+	cy = 0;
+	cw = width();
+	ch = height();
+    }
+
+    QTextParagraph *lastFormatted = 0;
+    QTextParagraph *parag = firstParagraph();
+
+    QPixmap *doubleBuffer = 0;
+
+    while ( parag ) {
+	lastFormatted = parag;
+	if ( !parag->isValid() )
+	    parag->format();
+
+	QRect pr = parag->rect();
+	pr.setWidth( parag->document()->width() );
+	if ( pr.y() > cy + ch )
+	    goto floating;
+	QRect clipr( cx, cy, cw, ch );
+	if ( !pr.intersects( clipr ) || ( onlyChanged && !parag->hasChanged() ) ) {
+	    pr.setWidth( parag->document()->width() );
+	    parag = parag->next();
+	    continue;
+	}
+
+	drawParagraph( p, parag, cx, cy, cw, ch, doubleBuffer, cg, drawCursor, cursor, resetChanged );
+	parag = parag->next();
+    }
+
+    parag = lastParagraph();
+
+ floating:
+    if ( parag->rect().y() + parag->rect().height() < parag->document()->height() ) {
+	if ( !parag->document()->parent() ) {
+	    QRect fillRect = QRect( 0, parag->rect().y() + parag->rect().height(), parag->document()->width(),
+		parag->document()->height() - ( parag->rect().y() + parag->rect().height() ) );
+	    if ( QRect( cx, cy, cw, ch ).intersects( fillRect ) )
+		p->fillRect( fillRect, cg.brush( QColorGroup::Base ) );
+	}
+	if ( !flow()->isEmpty() ) {
+	    QRect cr( cx, cy, cw, ch );
+	    flow()->drawFloatingItems( p, cr.x(), cr.y(), cr.width(), cr.height(), cg, FALSE );
+	}
+    }
+
+    if ( buf_pixmap && buf_pixmap->height() > 300 ) {
+	delete buf_pixmap;
+	buf_pixmap = 0;
+    }
+
+    QTextFormat::setPainter(oldPainter);
+    return lastFormatted;
+}
+
+/*
+  #### this function only sets the default font size in the format collection
+ */
+void QTextDocument::setDefaultFormat( const QFont &font, const QColor &color )
+{
+    bool reformat = font != fCollection->defaultFormat()->font();
+    for ( QTextDocument *d = childList.first(); d; d = childList.next() )
+	d->setDefaultFormat( font, color );
+    fCollection->updateDefaultFormat( font, color, sheet_ );
+
+    if ( !reformat )
+	return;
+    tStopWidth = formatCollection()->defaultFormat()->width( 'x' ) * 8;
+
+    // invalidate paragraphs and custom items
+    QTextParagraph *p = fParag;
+    while ( p ) {
+	p->invalidate( 0 );
+#ifndef QT_NO_TEXTCUSTOMITEM
+	for ( int i = 0; i < p->length() - 1; ++i )
+	    if ( p->at( i )->isCustom() )
+		p->at( i )->customItem()->invalidate();
+#endif
+	p = p->next();
+    }
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+void QTextDocument::registerCustomItem( QTextCustomItem *i, QTextParagraph *p )
+{
+    if ( i && i->placement() != QTextCustomItem::PlaceInline ) {
+	flow_->registerFloatingItem( i );
+	p->registerFloatingItem( i );
+    }
+    if (i) i->setParagraph( p );
+    p->mightHaveCustomItems = mightHaveCustomItems = TRUE;
+}
+
+void QTextDocument::unregisterCustomItem( QTextCustomItem *i, QTextParagraph *p )
+{
+    p->unregisterFloatingItem( i );
+    i->setParagraph( 0 );
+    flow_->unregisterFloatingItem( i );
+}
+#endif
+
+bool QTextDocument::hasFocusParagraph() const
+{
+    return !!focusIndicator.parag;
+}
+
+QString QTextDocument::focusHref() const
+{
+    return focusIndicator.href;
+}
+
+QString QTextDocument::focusName() const
+{
+    return focusIndicator.name;
+}
+
+bool QTextDocument::focusNextPrevChild( bool next )
+{
+    if ( !focusIndicator.parag ) {
+	if ( next ) {
+	    focusIndicator.parag = fParag;
+	    focusIndicator.start = 0;
+	    focusIndicator.len = 0;
+	} else {
+	    focusIndicator.parag = lParag;
+	    focusIndicator.start = lParag->length();
+	    focusIndicator.len = 0;
+	}
+    } else {
+	focusIndicator.parag->setChanged( TRUE );
+    }
+    focusIndicator.href = QString::null;
+    focusIndicator.name = QString::null;
+
+    if ( next ) {
+	QTextParagraph *p = focusIndicator.parag;
+	int index = focusIndicator.start + focusIndicator.len;
+	while ( p ) {
+	    for ( int i = index; i < p->length(); ++i ) {
+		if ( p->at( i )->isAnchor() ) {
+		    p->setChanged( TRUE );
+		    focusIndicator.parag = p;
+		    focusIndicator.start = i;
+		    focusIndicator.len = 0;
+		    focusIndicator.href = p->at( i )->anchorHref();
+		    focusIndicator.name = p->at( i )->anchorName();
+		    while ( i < p->length() ) {
+			if ( !p->at( i )->isAnchor() )
+			    return TRUE;
+			focusIndicator.len++;
+			i++;
+		    }
+#ifndef QT_NO_TEXTCUSTOMITEM
+		} else if ( p->at( i )->isCustom() ) {
+		    if ( p->at( i )->customItem()->isNested() ) {
+			QTextTable *t = (QTextTable*)p->at( i )->customItem();
+			QPtrList<QTextTableCell> cells = t->tableCells();
+			// first try to continue
+			QTextTableCell *c;
+			bool resetCells = TRUE;
+			for ( c = cells.first(); c; c = cells.next() ) {
+			    if ( c->richText()->hasFocusParagraph() ) {
+				if ( c->richText()->focusNextPrevChild( next ) ) {
+				    p->setChanged( TRUE );
+				    focusIndicator.parag = p;
+				    focusIndicator.start = i;
+				    focusIndicator.len = 0;
+				    focusIndicator.href = c->richText()->focusHref();
+				    focusIndicator.name = c->richText()->focusName();
+				    return TRUE;
+				} else {
+				    resetCells = FALSE;
+				    c = cells.next();
+				    break;
+				}
+			    }
+			}
+			// now really try
+			if ( resetCells )
+			    c = cells.first();
+			for ( ; c; c = cells.next() ) {
+			    if ( c->richText()->focusNextPrevChild( next ) ) {
+				p->setChanged( TRUE );
+				focusIndicator.parag = p;
+				focusIndicator.start = i;
+				focusIndicator.len = 0;
+				focusIndicator.href = c->richText()->focusHref();
+				focusIndicator.name = c->richText()->focusName();
+				return TRUE;
+			    }
+			}
+		    }
+#endif
+		}
+	    }
+	    index = 0;
+	    p = p->next();
+	}
+    } else {
+	QTextParagraph *p = focusIndicator.parag;
+	int index = focusIndicator.start - 1;
+	if ( focusIndicator.len == 0 && index < focusIndicator.parag->length() - 1 )
+	    index++;
+	while ( p ) {
+	    for ( int i = index; i >= 0; --i ) {
+		if ( p->at( i )->isAnchor() ) {
+		    p->setChanged( TRUE );
+		    focusIndicator.parag = p;
+		    focusIndicator.start = i;
+		    focusIndicator.len = 0;
+		    focusIndicator.href = p->at( i )->anchorHref();
+		    focusIndicator.name = p->at( i )->anchorName();
+		    while ( i >= -1 ) {
+			if ( i < 0 || !p->at( i )->isAnchor() ) {
+			    focusIndicator.start++;
+			    return TRUE;
+			}
+			if ( i < 0 )
+			    break;
+			focusIndicator.len++;
+			focusIndicator.start--;
+			i--;
+		    }
+#ifndef QT_NO_TEXTCUSTOMITEM
+		} else if ( p->at( i )->isCustom() ) {
+		    if ( p->at( i )->customItem()->isNested() ) {
+			QTextTable *t = (QTextTable*)p->at( i )->customItem();
+			QPtrList<QTextTableCell> cells = t->tableCells();
+			// first try to continue
+			QTextTableCell *c;
+			bool resetCells = TRUE;
+			for ( c = cells.last(); c; c = cells.prev() ) {
+			    if ( c->richText()->hasFocusParagraph() ) {
+				if ( c->richText()->focusNextPrevChild( next ) ) {
+				    p->setChanged( TRUE );
+				    focusIndicator.parag = p;
+				    focusIndicator.start = i;
+				    focusIndicator.len = 0;
+				    focusIndicator.href = c->richText()->focusHref();
+				    focusIndicator.name = c->richText()->focusName();
+				    return TRUE;
+				} else {
+				    resetCells = FALSE;
+				    c = cells.prev();
+				    break;
+				}
+			    }
+			    if ( cells.at() == 0 )
+				break;
+			}
+			// now really try
+			if ( resetCells )
+			    c = cells.last();
+			for ( ; c; c = cells.prev() ) {
+			    if ( c->richText()->focusNextPrevChild( next ) ) {
+				p->setChanged( TRUE );
+				focusIndicator.parag = p;
+				focusIndicator.start = i;
+				focusIndicator.len = 0;
+				focusIndicator.href = c->richText()->focusHref();
+				focusIndicator.name = c->richText()->focusName();
+				return TRUE;
+			    }
+			    if ( cells.at() == 0 )
+				break;
+			}
+		    }
+#endif
+		}
+	    }
+	    p = p->prev();
+	    if ( p )
+		index = p->length() - 1;
+	}
+    }
+
+    focusIndicator.parag = 0;
+
+    return FALSE;
+}
+
+int QTextDocument::length() const
+{
+    int l = -1;
+    QTextParagraph *p = fParag;
+    while ( p ) {
+	l += p->length();
+	p = p->next();
+    }
+    return QMAX(0,l);
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+int QTextFormat::width( const QChar &c ) const
+{
+    if ( c.unicode() == 0xad ) // soft hyphen
+	return 0;
+    if ( !pntr || !pntr->isActive() ) {
+	if ( c == '\t' )
+	    return fm.width( ' ' );
+	if ( ha == AlignNormal ) {
+	    int w;
+	    if ( c.row() )
+		w = fm.width( c );
+	    else
+		w = widths[ c.unicode() ];
+	    if ( w == 0 && !c.row() ) {
+		w = fm.width( c );
+		( (QTextFormat*)this )->widths[ c.unicode() ] = w;
+	    }
+	    return w;
+	} else {
+	    QFont f( fn );
+	    if ( usePixelSizes )
+		f.setPixelSize( ( f.pixelSize() * 2 ) / 3 );
+	    else
+		f.setPointSize( ( f.pointSize() * 2 ) / 3 );
+	    QFontMetrics fm_( f );
+	    return fm_.width( c );
+	}
+    }
+
+    QFont f( fn );
+    if ( ha != AlignNormal ) {
+	if ( usePixelSizes )
+	    f.setPixelSize( ( f.pixelSize() * 2 ) / 3 );
+	else
+	    f.setPointSize( ( f.pointSize() * 2 ) / 3 );
+    }
+    applyFont( f );
+
+    return pntr_fm->width( c );
+}
+
+int QTextFormat::width( const QString &str, int pos ) const
+{
+    int w = 0;
+    if ( str.unicode()[ pos ].unicode() == 0xad )
+	return w;
+    if ( !pntr || !pntr->isActive() ) {
+	if ( ha == AlignNormal ) {
+	    w = fm.charWidth( str, pos );
+	} else {
+	    QFont f( fn );
+	    if ( usePixelSizes )
+		f.setPixelSize( ( f.pixelSize() * 2 ) / 3 );
+	    else
+		f.setPointSize( ( f.pointSize() * 2 ) / 3 );
+	    QFontMetrics fm_( f );
+	    w = fm_.charWidth( str, pos );
+	}
+    } else {
+	QFont f( fn );
+	if ( ha != AlignNormal ) {
+	    if ( usePixelSizes )
+		f.setPixelSize( ( f.pixelSize() * 2 ) / 3 );
+	    else
+		f.setPointSize( ( f.pointSize() * 2 ) / 3 );
+	}
+	applyFont( f );
+	w = pntr_fm->charWidth( str, pos );
+    }
+    return w;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextString::QTextString()
+{
+    bidiDirty = TRUE;
+    bidi = FALSE;
+    rightToLeft = FALSE;
+    dir = QChar::DirON;
+}
+
+QTextString::QTextString( const QTextString &s )
+{
+    bidiDirty = TRUE;
+    bidi = s.bidi;
+    rightToLeft = s.rightToLeft;
+    dir = s.dir;
+    data = s.data;
+    data.detach();
+    for ( int i = 0; i < (int)data.size(); ++i ) {
+	QTextFormat *f = data[i].format();
+	if ( f )
+	    f->addRef();
+    }
+}
+
+void QTextString::insert( int index, const QString &s, QTextFormat *f )
+{
+    insert( index, s.unicode(), s.length(), f );
+}
+
+void QTextString::insert( int index, const QChar *unicode, int len, QTextFormat *f )
+{
+    int os = data.size();
+    data.resize( data.size() + len, QGArray::SpeedOptim );
+    if ( index < os ) {
+	memmove( data.data() + index + len, data.data() + index,
+		 sizeof( QTextStringChar ) * ( os - index ) );
+    }
+    QTextStringChar *ch = data.data() + index;
+    for ( int i = 0; i < len; ++i ) {
+	ch->x = 0;
+	ch->lineStart = 0;
+	ch->d.format = 0;
+	ch->nobreak = FALSE;
+	ch->type = QTextStringChar::Regular;
+ 	ch->d.format = f;
+	ch->rightToLeft = 0;
+	ch->c = unicode[i];
+	++ch;
+    }
+    bidiDirty = TRUE;
+}
+
+QTextString::~QTextString()
+{
+    clear();
+}
+
+void QTextString::insert( int index, QTextStringChar *c, bool doAddRefFormat  )
+{
+    int os = data.size();
+    data.resize( data.size() + 1, QGArray::SpeedOptim );
+    if ( index < os ) {
+	memmove( data.data() + index + 1, data.data() + index,
+		 sizeof( QTextStringChar ) * ( os - index ) );
+    }
+    QTextStringChar &ch = data[ (int)index ];
+    ch.c = c->c;
+    ch.x = 0;
+    ch.lineStart = 0;
+    ch.rightToLeft = 0;
+    ch.d.format = 0;
+    ch.type = QTextStringChar::Regular;
+    ch.nobreak = FALSE;
+    if ( doAddRefFormat && c->format() )
+	c->format()->addRef();
+    ch.setFormat( c->format() );
+    bidiDirty = TRUE;
+}
+
+int QTextString::appendParagraphs( QTextParagraph *start, QTextParagraph *end )
+{
+    int paragCount = 0;
+    int newLength = data.size();
+    QTextParagraph *p = start;
+    for (; p != end; p = p->next()) {
+        newLength += p->length();
+        ++paragCount;
+    }
+
+    const int oldLength = data.size();
+    data.resize(newLength, QGArray::SpeedOptim);
+
+    QTextStringChar *d = &data[oldLength];
+    for (p = start; p != end; p = p->next()) {
+        const QTextStringChar * const src = p->at(0);
+        int i = 0;
+        for (; i < p->length() - 1; ++i) {
+            d[i].c = src[i].c;
+            d[i].x = 0;
+            d[i].lineStart = 0;
+            d[i].rightToLeft = 0;
+            d[i].type = QTextStringChar::Regular;
+            d[i].nobreak = FALSE;
+            d[i].d.format = src[i].format();
+            if (d[i].d.format)
+                d[i].d.format->addRef();
+        }
+        d[i].x = 0;
+        d[i].lineStart = 0;
+        d[i].nobreak = FALSE;
+        d[i].type = QTextStringChar::Regular;
+        d[i].d.format = 0;
+        d[i].rightToLeft = 0;
+        d[i].c = '\n';
+        d += p->length();
+    }
+
+    bidiDirty = TRUE;
+    return paragCount;
+}
+
+void QTextString::truncate( int index )
+{
+    index = QMAX( index, 0 );
+    index = QMIN( index, (int)data.size() - 1 );
+    if ( index < (int)data.size() ) {
+	for ( int i = index + 1; i < (int)data.size(); ++i ) {
+	    QTextStringChar &ch = data[ i ];
+#ifndef QT_NO_TEXTCUSTOMITEM
+	    if ( !(ch.type == QTextStringChar::Regular) ) {
+		delete ch.customItem();
+		if ( ch.d.custom->format )
+		    ch.d.custom->format->removeRef();
+		delete ch.d.custom;
+		ch.d.custom = 0;
+	    } else
+#endif
+		if ( ch.format() ) {
+		    ch.format()->removeRef();
+		}
+	}
+    }
+    data.truncate( index );
+    bidiDirty = TRUE;
+}
+
+void QTextString::remove( int index, int len )
+{
+    for ( int i = index; i < (int)data.size() && i - index < len; ++i ) {
+	QTextStringChar &ch = data[ i ];
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( !(ch.type == QTextStringChar::Regular) ) {
+	    delete ch.customItem();
+	    if ( ch.d.custom->format )
+		ch.d.custom->format->removeRef();
+	    delete ch.d.custom;
+	    ch.d.custom = 0;
+	} else
+#endif
+	    if ( ch.format() ) {
+		ch.format()->removeRef();
+	    }
+    }
+    memmove( data.data() + index, data.data() + index + len,
+	     sizeof( QTextStringChar ) * ( data.size() - index - len ) );
+    data.resize( data.size() - len, QGArray::SpeedOptim );
+    bidiDirty = TRUE;
+}
+
+void QTextString::clear()
+{
+    for ( int i = 0; i < (int)data.count(); ++i ) {
+	QTextStringChar &ch = data[ i ];
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( !(ch.type == QTextStringChar::Regular) ) {
+	    if ( ch.customItem() && ch.customItem()->placement() == QTextCustomItem::PlaceInline )
+		delete ch.customItem();
+	    if ( ch.d.custom->format )
+		ch.d.custom->format->removeRef();
+	    delete ch.d.custom;
+	    ch.d.custom = 0;
+	} else
+#endif
+	    if ( ch.format() ) {
+		ch.format()->removeRef();
+	    }
+    }
+    data.resize( 0 );
+    bidiDirty = TRUE;
+}
+
+void QTextString::setFormat( int index, QTextFormat *f, bool useCollection )
+{
+    QTextStringChar &ch = data[ index ];
+    if ( useCollection && ch.format() )
+	ch.format()->removeRef();
+    ch.setFormat( f );
+}
+
+void QTextString::checkBidi() const
+{
+    QTextString *that = (QTextString *)this;
+    that->bidiDirty = FALSE;
+    int length = data.size();
+    if ( !length ) {
+	that->bidi = FALSE;
+	that->rightToLeft = dir == QChar::DirR;
+	return;
+    }
+    const QTextStringChar *start = data.data();
+    const QTextStringChar *end = start + length;
+
+    ((QTextString *)this)->stringCache = toString(data);
+
+
+    // determines the properties we need for layouting
+    QTextEngine textEngine( toString(), 0 );
+    textEngine.direction = (QChar::Direction) dir;
+    textEngine.itemize(QTextEngine::SingleLine);
+    const QCharAttributes *ca = textEngine.attributes() + length-1;
+    QTextStringChar *ch = (QTextStringChar *)end - 1;
+    QScriptItem *item = &textEngine.items[textEngine.items.size()-1];
+    unsigned char bidiLevel = item->analysis.bidiLevel;
+    if ( bidiLevel )
+	that->bidi = TRUE;
+    int pos = length-1;
+    while ( ch >= start ) {
+	if ( item->position > pos ) {
+	    --item;
+	    Q_ASSERT( item >= &textEngine.items[0] );
+	    Q_ASSERT( item < &textEngine.items[textEngine.items.size()] );
+	    bidiLevel = item->analysis.bidiLevel;
+	    if ( bidiLevel )
+		that->bidi = TRUE;
+	}
+	ch->softBreak = ca->softBreak;
+	ch->whiteSpace = ca->whiteSpace;
+	ch->charStop = ca->charStop;
+	ch->wordStop = ca->wordStop;
+	ch->bidiLevel = bidiLevel;
+	ch->rightToLeft = (bidiLevel%2);
+	--ch;
+	--ca;
+	--pos;
+    }
+
+    if ( dir == QChar::DirR ) {
+	that->bidi = TRUE;
+	that->rightToLeft = TRUE;
+    } else if ( dir == QChar::DirL ) {
+	that->rightToLeft = FALSE;
+    } else {
+	that->rightToLeft = (textEngine.direction == QChar::DirR);
+    }
+}
+
+void QTextDocument::setStyleSheet( QStyleSheet *s )
+{
+    if ( !s )
+	return;
+    sheet_ = s;
+    list_tm = list_bm = par_tm = par_bm = 12;
+    list_lm = 40;
+    li_tm = li_bm = 0;
+    QStyleSheetItem* item = s->item( "ol" );
+    if ( item ) {
+	list_tm = QMAX(0,item->margin( QStyleSheetItem::MarginTop ));
+	list_bm = QMAX(0,item->margin( QStyleSheetItem::MarginBottom ));
+	list_lm = QMAX(0,item->margin( QStyleSheetItem::MarginLeft ));
+    }
+    if ( (item = s->item( "li" ) ) ) {
+	li_tm = QMAX(0,item->margin( QStyleSheetItem::MarginTop ));
+	li_bm = QMAX(0,item->margin( QStyleSheetItem::MarginBottom ));
+    }
+    if ( (item = s->item( "p" ) ) ) {
+	par_tm = QMAX(0,item->margin( QStyleSheetItem::MarginTop ));
+	par_bm = QMAX(0,item->margin( QStyleSheetItem::MarginBottom ));
+    }
+}
+
+void QTextDocument::setUnderlineLinks( bool b ) {
+    underlLinks = b;
+    for ( QTextDocument *d = childList.first(); d; d = childList.next() )
+	d->setUnderlineLinks( b );
+}
+
+void QTextStringChar::setFormat( QTextFormat *f )
+{
+    if ( type == Regular ) {
+ 	d.format = f;
+    } else {
+#ifndef QT_NO_TEXTCUSTOMITEM
+ 	if ( !d.custom ) {
+ 	    d.custom = new CustomData;
+ 	    d.custom->custom = 0;
+ 	}
+ 	d.custom->format = f;
+#endif
+    }
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+void QTextStringChar::setCustomItem( QTextCustomItem *i )
+{
+    if ( type == Regular ) {
+	QTextFormat *f = format();
+	d.custom = new CustomData;
+	d.custom->format = f;
+    } else {
+	delete d.custom->custom;
+    }
+    d.custom->custom = i;
+    type = (type == Anchor ? CustomAnchor : Custom);
+}
+
+void QTextStringChar::loseCustomItem()
+{
+    if ( type == Custom ) {
+	QTextFormat *f = d.custom->format;
+	d.custom->custom = 0;
+	delete d.custom;
+	type = Regular;
+	d.format = f;
+    } else if ( type == CustomAnchor ) {
+	d.custom->custom = 0;
+	type = Anchor;
+    }
+}
+
+#endif
+
+QString QTextStringChar::anchorName() const
+{
+    if ( type == Regular )
+	return QString::null;
+    else
+	return d.custom->anchorName;
+}
+
+QString QTextStringChar::anchorHref() const
+{
+    if ( type == Regular )
+	return QString::null;
+    else
+	return d.custom->anchorHref;
+}
+
+void QTextStringChar::setAnchor( const QString& name, const QString& href )
+{
+    if ( type == Regular ) {
+	QTextFormat *f = format();
+	d.custom = new CustomData;
+#ifndef QT_NO_TEXTCUSTOMITEM
+	d.custom->custom = 0;
+#endif
+	d.custom->format = f;
+	type = Anchor;
+    } else if ( type == Custom ) {
+	type = CustomAnchor;
+    }
+    d.custom->anchorName = name;
+    d.custom->anchorHref = href;
+}
+
+
+int QTextString::width( int idx ) const
+{
+     int w = 0;
+     QTextStringChar *c = &at( idx );
+     if ( !c->charStop || c->c.unicode() == 0xad || c->c.unicode() == 0x2028 )
+	 return 0;
+#ifndef QT_NO_TEXTCUSTOMITEM
+     if( c->isCustom() ) {
+	 if( c->customItem()->placement() == QTextCustomItem::PlaceInline )
+	     w = c->customItem()->width;
+     } else
+#endif
+     {
+	 int r = c->c.row();
+         if(r < 0x06
+#ifndef Q_WS_WIN
+             // Uniscribe's handling of Asian makes the condition below fail.
+             || (r > 0x1f && !(r > 0xd7 && r < 0xe0))
+#endif
+             ) {
+	     w = c->format()->width( c->c );
+	 } else {
+             w = c->format()->width(toString(), idx);
+	 }
+     }
+     return w;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextParagraph::QTextParagraph( QTextDocument *d, QTextParagraph *pr, QTextParagraph *nx, bool updateIds )
+    : p( pr ), n( nx ), docOrPseudo( d ),
+      changed(FALSE), firstFormat(TRUE), firstPProcess(TRUE), needPreProcess(FALSE), fullWidth(TRUE),
+      lastInFrame(FALSE), visible(TRUE), breakable(TRUE), movedDown(FALSE),
+      mightHaveCustomItems(FALSE), hasdoc( d != 0 ), litem(FALSE), rtext(FALSE),
+      align( 0 ), lstyle( QStyleSheetItem::ListDisc ), invalid( 0 ), mSelections( 0 ),
+#ifndef QT_NO_TEXTCUSTOMITEM
+      mFloatingItems( 0 ),
+#endif
+      utm( 0 ), ubm( 0 ), ulm( 0 ), urm( 0 ), uflm( 0 ), ulinespacing( 0 ),
+      tabStopWidth(0), minwidth(0), tArray(0), eData( 0 ), ldepth( 0 )
+{
+    lstyle = QStyleSheetItem::ListDisc;
+    if ( !hasdoc )
+	docOrPseudo = new QTextParagraphPseudoDocument;
+    bgcol = 0;
+    list_val = -1;
+    paintdevice = 0;
+    QTextFormat* defFormat = formatCollection()->defaultFormat();
+    if ( !hasdoc ) {
+	tabStopWidth = defFormat->width( 'x' ) * 8;
+	pseudoDocument()->commandHistory = new QTextCommandHistory( 100 );
+    }
+
+    if ( p )
+	p->n = this;
+    if ( n )
+	n->p = this;
+
+    if ( !p && hasdoc )
+	document()->setFirstParagraph( this );
+    if ( !n && hasdoc )
+	document()->setLastParagraph( this );
+
+    state = -1;
+
+    if ( p )
+	id = p->id + 1;
+    else
+	id = 0;
+    if ( n && updateIds ) {
+	QTextParagraph *s = n;
+	while ( s ) {
+	    s->id = s->p->id + 1;
+	    s->invalidateStyleCache();
+	    s = s->n;
+	}
+    }
+
+    str = new QTextString();
+    QChar ch(' ');
+    str->insert( 0, &ch, 1, formatCollection()->defaultFormat() );
+}
+
+QTextParagraph::~QTextParagraph()
+{
+    delete str;
+    if ( hasdoc ) {
+	register QTextDocument *doc = document();
+	if ( this == doc->minwParag ) {
+	    doc->minwParag = 0;
+	    doc->minw = 0;
+	}
+	if ( this == doc->curParag )
+	    doc->curParag = 0;
+    } else {
+	delete pseudoDocument();
+    }
+    delete [] tArray;
+    delete eData;
+    QMap<int, QTextLineStart*>::Iterator it = lineStarts.begin();
+    for ( ; it != lineStarts.end(); ++it )
+	delete *it;
+    if ( mSelections )
+	delete mSelections;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if ( mFloatingItems )
+	delete mFloatingItems;
+#endif
+    if ( p )
+	p->setNext( n );
+    if ( n )
+	n->setPrev( p );
+    delete bgcol;
+}
+
+void QTextParagraph::setNext( QTextParagraph *s )
+{
+    n = s;
+    if ( !n && hasdoc )
+	document()->setLastParagraph( this );
+}
+
+void QTextParagraph::setPrev( QTextParagraph *s )
+{
+    p = s;
+    if ( !p && hasdoc )
+	document()->setFirstParagraph( this );
+}
+
+void QTextParagraph::invalidate( int chr )
+{
+    if ( invalid < 0 )
+	invalid = chr;
+    else
+	invalid = QMIN( invalid, chr );
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if ( mFloatingItems ) {
+	for ( QTextCustomItem *i = mFloatingItems->first(); i; i = mFloatingItems->next() )
+	    i->ypos = -1;
+    }
+#endif
+    invalidateStyleCache();
+}
+
+void QTextParagraph::invalidateStyleCache()
+{
+    if ( list_val < 0 )
+	list_val = -1;
+}
+
+
+void QTextParagraph::insert( int index, const QString &s )
+{
+    insert( index, s.unicode(), s.length() );
+}
+
+void QTextParagraph::insert( int index, const QChar *unicode, int len )
+{
+    if ( hasdoc && !document()->useFormatCollection() && document()->preProcessor() )
+	str->insert( index, unicode, len,
+		     document()->preProcessor()->format( QTextPreProcessor::Standard ) );
+    else
+	str->insert( index, unicode, len, formatCollection()->defaultFormat() );
+    invalidate( index );
+    needPreProcess = TRUE;
+}
+
+void QTextParagraph::truncate( int index )
+{
+    str->truncate( index );
+    insert( length(), " " );
+    needPreProcess = TRUE;
+}
+
+void QTextParagraph::remove( int index, int len )
+{
+    if ( index + len - str->length() > 0 )
+	return;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    for ( int i = index; i < index + len; ++i ) {
+	QTextStringChar *c = at( i );
+	if ( hasdoc && c->isCustom() ) {
+	    document()->unregisterCustomItem( c->customItem(), this );
+	}
+    }
+#endif
+    str->remove( index, len );
+    invalidate( 0 );
+    needPreProcess = TRUE;
+}
+
+void QTextParagraph::join( QTextParagraph *s )
+{
+    int oh = r.height() + s->r.height();
+    n = s->n;
+    if ( n )
+	n->p = this;
+    else if ( hasdoc )
+	document()->setLastParagraph( this );
+
+    int start = str->length();
+    if ( length() > 0 && at( length() - 1 )->c == ' ' ) {
+	remove( length() - 1, 1 );
+	--start;
+    }
+    append( s->str->toString(), TRUE );
+
+    for ( int i = 0; i < s->length(); ++i ) {
+	if ( !hasdoc || document()->useFormatCollection() ) {
+	    s->str->at( i ).format()->addRef();
+	    str->setFormat( i + start, s->str->at( i ).format(), TRUE );
+	}
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( s->str->at( i ).isCustom() ) {
+	    QTextCustomItem * item = s->str->at( i ).customItem();
+	    str->at( i + start ).setCustomItem( item );
+	    s->str->at( i ).loseCustomItem();
+	    if ( hasdoc ) {
+		document()->unregisterCustomItem( item, s );
+		document()->registerCustomItem( item, this );
+	    }
+	}
+	if ( s->str->at( i ).isAnchor() ) {
+	    str->at( i + start ).setAnchor( s->str->at( i ).anchorName(),
+			    s->str->at( i ).anchorHref() );
+	}
+#endif
+    }
+
+    if ( !extraData() && s->extraData() ) {
+	setExtraData( s->extraData() );
+	s->setExtraData( 0 );
+    } else if ( extraData() && s->extraData() ) {
+	extraData()->join( s->extraData() );
+    }
+    delete s;
+    invalidate( 0 );
+    r.setHeight( oh );
+    needPreProcess = TRUE;
+    if ( n ) {
+	QTextParagraph *s = n;
+	s->invalidate( 0 );
+	while ( s ) {
+	    s->id = s->p->id + 1;
+	    s->state = -1;
+	    s->needPreProcess = TRUE;
+	    s->changed = TRUE;
+	    s->invalidateStyleCache();
+	    s = s->n;
+	}
+    }
+    format();
+    state = -1;
+}
+
+void QTextParagraph::move( int &dy )
+{
+    if ( dy == 0 )
+	return;
+    changed = TRUE;
+    r.moveBy( 0, dy );
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if ( mFloatingItems ) {
+	for ( QTextCustomItem *i = mFloatingItems->first(); i; i = mFloatingItems->next() )
+	    i->ypos += dy;
+    }
+#endif
+    if ( p )
+	p->lastInFrame = TRUE;
+
+    // do page breaks if required
+    if ( hasdoc && document()->isPageBreakEnabled() ) {
+	int shift;
+	if ( ( shift = document()->formatter()->formatVertically(  document(), this ) ) ) {
+	    if ( p )
+		p->setChanged( TRUE );
+	    dy += shift;
+	}
+    }
+}
+
+void QTextParagraph::format( int start, bool doMove )
+{
+    if ( !str || str->length() == 0 || !formatter() )
+	return;
+
+    if ( hasdoc &&
+	 document()->preProcessor() &&
+	 ( needPreProcess || state == -1 ) )
+	document()->preProcessor()->process( document(), this, invalid <= 0 ? 0 : invalid );
+    needPreProcess = FALSE;
+
+    if ( invalid == -1 )
+	return;
+
+    r.moveTopLeft( QPoint( documentX(), p ? p->r.y() + p->r.height() : documentY() ) );
+    if ( p )
+	p->lastInFrame = FALSE;
+
+    movedDown = FALSE;
+    bool formattedAgain = FALSE;
+
+ formatAgain:
+
+    r.setWidth( documentWidth() );
+#ifndef QT_NO_TEXTCUSTOMITEM
+    if ( hasdoc && mFloatingItems ) {
+	for ( QTextCustomItem *i = mFloatingItems->first(); i; i = mFloatingItems->next() ) {
+	    i->ypos = r.y();
+	    if ( i->placement() == QTextCustomItem::PlaceRight ) {
+		i->xpos = r.x() + r.width() - i->width;
+	    }
+	}
+    }
+#endif
+    QMap<int, QTextLineStart*> oldLineStarts = lineStarts;
+    lineStarts.clear();
+    int y = formatter()->format( document(), this, start, oldLineStarts );
+
+
+    r.setWidth( QMAX( r.width(), formatter()->minimumWidth() ) );
+
+
+    QMap<int, QTextLineStart*>::Iterator it = oldLineStarts.begin();
+
+    for ( ; it != oldLineStarts.end(); ++it )
+	delete *it;
+
+    if ( !hasdoc ) { // qt_format_text bounding rect handling
+	it = lineStarts.begin();
+	int usedw = 0;
+	for ( ; it != lineStarts.end(); ++it )
+	    usedw = QMAX( usedw, (*it)->w );
+	if ( r.width() <= 0 ) {
+	    // if the user specifies an invalid rect, this means that the
+	    // bounding box should grow to the width that the text actually
+	    // needs
+	    r.setWidth( usedw );
+	} else {
+	    r.setWidth( QMIN( usedw, r.width() ) );
+	}
+    }
+
+    if ( y != r.height() )
+	r.setHeight( y );
+
+    if ( !visible ) {
+	r.setHeight( 0 );
+    } else {
+	int minw = minwidth = formatter()->minimumWidth();
+	int wused = formatter()->widthUsed();
+	wused = QMAX( minw, wused );
+	if ( hasdoc ) {
+	    document()->setMinimumWidth( minw, wused, this );
+	}  else {
+	    pseudoDocument()->minw = QMAX( pseudoDocument()->minw, minw );
+	    pseudoDocument()->wused = QMAX( pseudoDocument()->wused, wused );
+	}
+    }
+
+    // do page breaks if required
+    if ( hasdoc && document()->isPageBreakEnabled() ) {
+        int shift = document()->formatter()->formatVertically( document(), this );
+        if ( shift && !formattedAgain ) {
+            formattedAgain = TRUE;
+            goto formatAgain;
+        }
+    }
+
+    if ( n && doMove && n->invalid == -1 && r.y() + r.height() != n->r.y() ) {
+	int dy = ( r.y() + r.height() ) - n->r.y();
+	QTextParagraph *s = n;
+	bool makeInvalid = p && p->lastInFrame;
+	while ( s && dy ) {
+	    if ( !s->isFullWidth() )
+		makeInvalid = TRUE;
+	    if ( makeInvalid )
+		s->invalidate( 0 );
+	    s->move( dy );
+	    if ( s->lastInFrame )
+		makeInvalid = TRUE;
+  	    s = s->n;
+	}
+    }
+
+    firstFormat = FALSE;
+    changed = TRUE;
+    invalid = -1;
+    //#####   string()->setTextChanged( FALSE );
+}
+
+int QTextParagraph::lineHeightOfChar( int i, int *bl, int *y ) const
+{
+    if ( !isValid() )
+	( (QTextParagraph*)this )->format();
+
+    QMap<int, QTextLineStart*>::ConstIterator it = lineStarts.end();
+    --it;
+    for ( ;; ) {
+	if ( i >= it.key() ) {
+	    if ( bl )
+		*bl = ( *it )->baseLine;
+	    if ( y )
+		*y = ( *it )->y;
+	    return ( *it )->h;
+	}
+	if ( it == lineStarts.begin() )
+	    break;
+	--it;
+    }
+
+    qWarning( "QTextParagraph::lineHeightOfChar: couldn't find lh for %d", i );
+    return 15;
+}
+
+QTextStringChar *QTextParagraph::lineStartOfChar( int i, int *index, int *line ) const
+{
+    if ( !isValid() )
+	( (QTextParagraph*)this )->format();
+
+    int l = (int)lineStarts.count() - 1;
+    QMap<int, QTextLineStart*>::ConstIterator it = lineStarts.end();
+    --it;
+    for ( ;; ) {
+	if ( i >= it.key() ) {
+	    if ( index )
+		*index = it.key();
+	    if ( line )
+		*line = l;
+	    return &str->at( it.key() );
+	}
+	if ( it == lineStarts.begin() )
+	    break;
+	--it;
+	--l;
+    }
+
+    qWarning( "QTextParagraph::lineStartOfChar: couldn't find %d", i );
+    return 0;
+}
+
+int QTextParagraph::lines() const
+{
+    if ( !isValid() )
+	( (QTextParagraph*)this )->format();
+
+    return (int)lineStarts.count();
+}
+
+QTextStringChar *QTextParagraph::lineStartOfLine( int line, int *index ) const
+{
+    if ( !isValid() )
+	( (QTextParagraph*)this )->format();
+
+    if ( line >= 0 && line < (int)lineStarts.count() ) {
+	QMap<int, QTextLineStart*>::ConstIterator it = lineStarts.begin();
+	while ( line-- > 0 )
+	    ++it;
+	int i = it.key();
+	if ( index )
+	    *index = i;
+	return &str->at( i );
+    }
+
+    qWarning( "QTextParagraph::lineStartOfLine: couldn't find %d", line );
+    return 0;
+}
+
+int QTextParagraph::leftGap() const
+{
+    if ( !isValid() )
+	( (QTextParagraph*)this )->format();
+
+    if ( str->length() == 0)
+	return 0;
+
+    int line = 0;
+    int x = str->length() ? str->at(0).x : 0;  /* set x to x of first char */
+    if ( str->isBidi() ) {
+	for ( int i = 1; i < str->length()-1; ++i )
+	    x = QMIN(x, str->at(i).x);
+	return x;
+    }
+
+    QMap<int, QTextLineStart*>::ConstIterator it = lineStarts.begin();
+    while (line < (int)lineStarts.count()) {
+	int i = it.key(); /* char index */
+	x = QMIN(x, str->at(i).x);
+	++it;
+	++line;
+    }
+    return x;
+}
+
+void QTextParagraph::setFormat( int index, int len, QTextFormat *f, bool useCollection, int flags )
+{
+    if ( !f )
+	return;
+    if ( index < 0 )
+	index = 0;
+    if ( index > str->length() - 1 )
+	index = str->length() - 1;
+    if ( index + len >= str->length() )
+	len = str->length() - index;
+
+    QTextFormatCollection *fc = 0;
+    if ( useCollection )
+	fc = formatCollection();
+    QTextFormat *of;
+    for ( int i = 0; i < len; ++i ) {
+	of = str->at( i + index ).format();
+	if ( !changed && ( !of || f->key() != of->key() ) )
+	    changed = TRUE;
+	if ( invalid == -1 &&
+	     ( f->font().family() != of->font().family() ||
+	       f->font().pointSize() != of->font().pointSize() ||
+	       f->font().weight() != of->font().weight() ||
+	       f->font().italic() != of->font().italic() ||
+	       f->vAlign() != of->vAlign() ) ) {
+	    invalidate( 0 );
+	}
+	if ( flags == -1 || flags == QTextFormat::Format || !fc ) {
+	    if ( fc )
+		f = fc->format( f );
+	    str->setFormat( i + index, f, useCollection );
+	} else {
+	    QTextFormat *fm = fc->format( of, f, flags );
+	    str->setFormat( i + index, fm, useCollection );
+	}
+    }
+}
+
+void QTextParagraph::indent( int *oldIndent, int *newIndent )
+{
+    if ( !hasdoc || !document()->indent() || isListItem() ) {
+	if ( oldIndent )
+	    *oldIndent = 0;
+	if ( newIndent )
+	    *newIndent = 0;
+	if ( oldIndent && newIndent )
+	    *newIndent = *oldIndent;
+	return;
+    }
+    document()->indent()->indent( document(), this, oldIndent, newIndent );
+}
+
+void QTextParagraph::paint( QPainter &painter, const QColorGroup &cg, QTextCursor *cursor, bool drawSelections,
+			int clipx, int clipy, int clipw, int cliph )
+{
+    if ( !visible )
+	return;
+    int i, y, h, baseLine, xstart, xend = 0;
+    i = y =h = baseLine = 0;
+    QRect cursorRect;
+    drawSelections &= ( mSelections != 0 );
+    // macintosh full-width selection style
+    bool fullWidthStyle = QApplication::style().styleHint(QStyle::SH_RichText_FullWidthSelection);
+    int fullSelectionWidth = 0;
+    if ( drawSelections && fullWidthStyle )
+	fullSelectionWidth = (hasdoc ? document()->width() : r.width());
+
+    QString qstr = str->toString();
+    // detach string
+    qstr.setLength(qstr.length());
+    // ### workaround so that \n are not drawn, actually this should
+    // be fixed in QFont somewhere (under Windows you get ugly boxes
+    // otherwise)
+    QChar* uc = (QChar*) qstr.unicode();
+    for ( uint ii = 0; ii < qstr.length(); ii++ )
+	if ( uc[(int)ii]== '\n' || uc[(int)ii] == '\t' )
+	    uc[(int)ii] = 0x20;
+
+    int line = -1;
+    int paintStart = 0;
+    QTextStringChar *chr = 0;
+    QTextStringChar *nextchr = at( 0 );
+    for ( i = 0; i < length(); i++ ) {
+	chr = nextchr;
+	if ( i < length()-1 )
+	    nextchr = at( i+1 );
+
+	// we flush at end of document
+	bool flush = (i == length()-1);
+	bool ignoreSoftHyphen = FALSE;
+	if ( !flush ) {
+	    // we flush at end of line
+	    flush |= nextchr->lineStart;
+	    // we flush on format changes
+	    flush |= ( nextchr->format() != chr->format() );
+	    // we flush on link changes
+	    flush |= ( nextchr->isLink() != chr->isLink() );
+	    // we flush on start of run
+	    flush |= ( nextchr->bidiLevel != chr->bidiLevel );
+	    // we flush on bidi changes
+	    flush |= ( nextchr->rightToLeft != chr->rightToLeft );
+	    // we flush before and after tabs
+	    flush |= ( chr->c == '\t' || nextchr->c == '\t' );
+	    // we flush on soft hypens
+	    if (chr->c.unicode() == 0xad) {
+		flush = TRUE;
+		if (!nextchr->lineStart)
+		    ignoreSoftHyphen = TRUE;
+	    }
+	    // we flush on custom items
+	    flush |= chr->isCustom();
+	    // we flush before custom items
+	    flush |= nextchr->isCustom();
+	    // when painting justified, we flush on spaces
+	    if ((alignment() & Qt::AlignJustify) == Qt::AlignJustify )
+		flush |= chr->whiteSpace;
+	}
+
+	// init a new line
+	if ( chr->lineStart ) {
+	    ++line;
+	    paintStart = i;
+	    lineInfo( line, y, h, baseLine );
+	    if ( clipy != -1 && cliph != 0 && y + r.y() - h > clipy + cliph ) { // outside clip area, leave
+		break;
+	    }
+
+	    // if this is the first line and we are a list item, draw the the bullet label
+	    if ( line == 0 && isListItem() ) {
+		int x = chr->x;
+		if (str->isBidi()) {
+		    if (str->isRightToLeft()) {
+			x = chr->x + str->width(0);
+			for (int k = 1; k < length(); ++k) {
+			    if (str->at(k).lineStart)
+				break;
+			    x = QMAX(x, str->at(k).x + str->width(k));
+			}
+		    } else {
+			x = chr->x;
+			for (int k = 1; k < length(); ++k) {
+			    if (str->at(k).lineStart)
+				break;
+			    x = QMIN(x, str->at(k).x);
+			}
+		    }
+		}
+		drawLabel( &painter, x, y, 0, 0, baseLine, cg );
+	    }
+	}
+
+	// check for cursor mark
+	if ( cursor && this == cursor->paragraph() && i == cursor->index() ) {
+	    QTextStringChar *c = i == 0 ? chr : chr - 1;
+	    cursorRect.setRect( cursor->x() , y + baseLine - c->format()->ascent(),
+				1, c->format()->height() );
+	}
+
+	if ( flush ) {  // something changed, draw what we have so far
+	    if ( chr->rightToLeft ) {
+		xstart = chr->x;
+		xend = at( paintStart )->x + str->width( paintStart );
+	    } else {
+		xstart = at( paintStart )->x;
+		xend = chr->x;
+		if ( i < length() - 1 ) {
+		    if ( !str->at( i + 1 ).lineStart &&
+			 str->at( i + 1 ).rightToLeft == chr->rightToLeft )
+			xend = str->at( i + 1 ).x;
+		    else
+			xend += str->width( i );
+		}
+	    }
+
+	    if ( (clipx == -1 || clipw <= 0 || (xend >= clipx && xstart <= clipx + clipw)) &&
+		 ( clipy == -1 || clipy < y+r.y()+h ) ) {
+		if ( !chr->isCustom() )
+		    drawString( painter, qstr, paintStart, i - paintStart + (ignoreSoftHyphen ? 0 : 1), xstart, y,
+				baseLine, xend-xstart, h, drawSelections, fullSelectionWidth,
+				chr, cg, chr->rightToLeft );
+#ifndef QT_NO_TEXTCUSTOMITEM
+		else if ( chr->customItem()->placement() == QTextCustomItem::PlaceInline ) {
+		    bool inSelection = FALSE;
+		    if (drawSelections) {
+			QMap<int, QTextParagraphSelection>::ConstIterator it = mSelections->find( QTextDocument::Standard );
+			inSelection = (it != mSelections->end() && (*it).start <= i && (*it).end > i);
+		    }
+		    chr->customItem()->draw( &painter, chr->x, y,
+					     clipx == -1 ? clipx : (clipx - r.x()),
+					     clipy == -1 ? clipy : (clipy - r.y()),
+					     clipw, cliph, cg, inSelection );
+		}
+#endif
+	    }
+	    paintStart = i+1;
+	}
+
+    }
+
+    // time to draw the cursor
+    const int cursor_extent = 4;
+    if ( !cursorRect.isNull() && cursor &&
+	 ((clipx == -1 || clipw == -1) || (cursorRect.right()+cursor_extent >= clipx && cursorRect.left()-cursor_extent <= clipx + clipw)) ) {
+	painter.fillRect( cursorRect, cg.color( QColorGroup::Text ) );
+	painter.save();
+	if ( string()->isBidi() ) {
+	    if ( at( cursor->index() )->rightToLeft ) {
+		painter.setPen( Qt::black );
+		painter.drawLine( cursorRect.x(), cursorRect.y(), cursorRect.x() - cursor_extent / 2, cursorRect.y() + cursor_extent / 2 );
+		painter.drawLine( cursorRect.x(), cursorRect.y() + cursor_extent, cursorRect.x() - cursor_extent / 2, cursorRect.y() + cursor_extent / 2 );
+	    } else {
+		painter.setPen( Qt::black );
+		painter.drawLine( cursorRect.x(), cursorRect.y(), cursorRect.x() + cursor_extent / 2, cursorRect.y() + cursor_extent / 2 );
+		painter.drawLine( cursorRect.x(), cursorRect.y() + cursor_extent, cursorRect.x() + cursor_extent / 2, cursorRect.y() + cursor_extent / 2 );
+	    }
+	}
+	painter.restore();
+    }
+}
+
+//#define BIDI_DEBUG
+
+void QTextParagraph::setColorForSelection( QColor &color, QPainter &painter,
+					   const QColorGroup& cg, int selection )
+{
+    if (selection < 0)
+	return;
+    color = ( hasdoc && selection != QTextDocument::Standard ) ?
+	    document()->selectionColor( selection ) :
+	    cg.color( QColorGroup::Highlight );
+    if ( selection == QTextDocument::IMCompositionText ) {
+#ifndef Q_WS_MACX
+	int h1, s1, v1, h2, s2, v2;
+	cg.color( QColorGroup::Base ).hsv( &h1, &s1, &v1 );
+	cg.color( QColorGroup::Background ).hsv( &h2, &s2, &v2 );
+	color.setHsv( h1, s1, ( v1 + v2 ) / 2 );
+#else
+        color = Qt::lightGray;
+#endif
+	painter.setPen( cg.color( QColorGroup::Text ) );
+    } else if ( selection == QTextDocument::IMSelectionText ) {
+	color = cg.color( QColorGroup::Dark );
+	painter.setPen( cg.color( QColorGroup::BrightText ) );
+    } else if ( !hasdoc || document()->invertSelectionText( selection ) ) {
+	painter.setPen( cg.color( QColorGroup::HighlightedText ) );
+    }
+}
+
+void QTextParagraph::drawString( QPainter &painter, const QString &str, int start, int len, int xstart,
+			     int y, int baseLine, int w, int h, bool drawSelections, int fullSelectionWidth,
+			     QTextStringChar *formatChar, const QColorGroup& cg,
+			     bool rightToLeft )
+{
+    bool plainText = hasdoc ? document()->textFormat() == Qt::PlainText : FALSE;
+    QTextFormat* format = formatChar->format();
+
+    if ( !plainText || hasdoc && format->color() != document()->formatCollection()->defaultFormat()->color() )
+	painter.setPen( QPen( format->color() ) );
+    else
+	painter.setPen( cg.text() );
+    painter.setFont( format->font() );
+
+    if ( hasdoc && formatChar->isAnchor() && !formatChar->anchorHref().isEmpty() ) {
+	if ( format->useLinkColor() )
+	    painter.setPen(document()->linkColor.isValid() ? document()->linkColor : cg.link());
+	if ( document()->underlineLinks() ) {
+	    QFont fn = format->font();
+	    fn.setUnderline( TRUE );
+	    painter.setFont( fn );
+	}
+    }
+
+    QPainter::TextDirection dir = rightToLeft ? QPainter::RTL : QPainter::LTR;
+
+    int real_length = len;
+    if (len && dir != QPainter::RTL && start + len == length() ) // don't draw the last character (trailing space)
+	len--;
+    if (len && str.unicode()[start+len-1] == QChar_linesep)
+	len--;
+
+
+    QTextFormat::VerticalAlignment vAlign = format->vAlign();
+    if ( vAlign != QTextFormat::AlignNormal ) {
+	// sub or superscript
+	QFont f( painter.font() );
+	if ( format->fontSizesInPixels() )
+	    f.setPixelSize( ( f.pixelSize() * 2 ) / 3 );
+	else
+	    f.setPointSize( ( f.pointSize() * 2 ) / 3 );
+	painter.setFont( f );
+	int h = painter.fontMetrics().height();
+	baseLine += (vAlign == QTextFormat::AlignSubScript) ? h/6 : -h/2;
+    }
+
+    bool allSelected = FALSE;
+    if (drawSelections) {
+	QMap<int, QTextParagraphSelection>::ConstIterator it = mSelections->find( QTextDocument::Standard );
+	allSelected = (it != mSelections->end() && (*it).start <= start && (*it).end >= start+len);
+    }
+    if (!allSelected)
+	painter.drawText(xstart, y + baseLine, str, start, len, dir);
+
+#ifdef BIDI_DEBUG
+    painter.save();
+    painter.setPen ( Qt::red );
+    painter.drawLine( xstart, y, xstart, y + baseLine );
+    painter.drawLine( xstart, y + baseLine/2, xstart + 10, y + baseLine/2 );
+    int w = 0;
+    int i = 0;
+    while( i < len )
+	w += painter.fontMetrics().charWidth( str, start + i++ );
+    painter.setPen ( Qt::blue );
+    painter.drawLine( xstart + w - 1, y, xstart + w - 1, y + baseLine );
+    painter.drawLine( xstart + w - 1, y + baseLine/2, xstart + w - 1 - 10, y + baseLine/2 );
+    painter.restore();
+#endif
+
+    // check if we are in a selection and draw it
+    if (drawSelections) {
+	QMap<int, QTextParagraphSelection>::ConstIterator it = mSelections->end();
+	while ( it != mSelections->begin() ) {
+	    --it;
+	    int selStart = (*it).start;
+	    int selEnd = (*it).end;
+	    int tmpw = w;
+
+	    selStart = QMAX(selStart, start);
+	    int real_selEnd = QMIN(selEnd, start+real_length);
+	    selEnd = QMIN(selEnd, start+len);
+	    bool extendRight = FALSE;
+	    bool extendLeft = FALSE;
+	    bool selWrap = (real_selEnd == length()-1 && n && n->hasSelection(it.key()));
+ 	    if (selWrap || this->str->at(real_selEnd).lineStart) {
+		extendRight = (fullSelectionWidth != 0);
+ 		if (!extendRight && !rightToLeft)
+		    tmpw += painter.fontMetrics().width(' ');
+	    }
+	    if (fullSelectionWidth && (selStart == 0 || this->str->at(selStart).lineStart)) {
+		extendLeft = TRUE;
+	    }
+	    if (this->str->isRightToLeft() != rightToLeft)
+		extendLeft = extendRight = FALSE;
+
+	    if (this->str->isRightToLeft()) {
+		bool tmp = extendLeft;
+		extendLeft = extendRight;
+		extendRight = tmp;
+	    }
+
+	    if (selStart < real_selEnd ||
+		selWrap && fullSelectionWidth && extendRight &&
+		// don't draw the standard selection on a printer=
+		(it.key() != QTextDocument::Standard || !is_printer( &painter))) {
+		int selection = it.key();
+		QColor color;
+		setColorForSelection( color, painter, cg, selection );
+		if (selStart != start || selEnd != start + len || selWrap) {
+		    // have to clip
+		    painter.save();
+		    int cs, ce;
+		    if (rightToLeft) {
+			cs = (selEnd != start + len) ?
+			     this->str->at(this->str->previousCursorPosition(selEnd)).x : xstart;
+			ce = (selStart != start) ?
+			     this->str->at(this->str->previousCursorPosition(selStart)).x : xstart+tmpw;
+		    } else {
+			cs = (selStart != start) ? this->str->at(selStart).x : xstart;
+			ce = (selEnd != start + len) ? this->str->at(selEnd).x : xstart+tmpw;
+		    }
+		    QRect r(cs, y, ce-cs, h);
+		    if (extendLeft)
+			r.setLeft(0);
+		    if (extendRight)
+			r.setRight(fullSelectionWidth);
+		    QRegion reg(r);
+		    if ( painter.hasClipping() )
+			reg &= painter.clipRegion(QPainter::CoordPainter);
+		    painter.setClipRegion(reg, QPainter::CoordPainter);
+		}
+		int xleft = xstart;
+		if ( extendLeft ) {
+		    tmpw += xstart;
+		    xleft = 0;
+		}
+		if ( extendRight )
+		    tmpw = fullSelectionWidth - xleft;
+		painter.fillRect( xleft, y, tmpw, h, color );
+		painter.drawText( xstart, y + baseLine, str, start, len, dir );
+		if (selStart != start || selEnd != start + len || selWrap)
+		    painter.restore();
+	    }
+	}
+    }
+
+    if ( format->isMisspelled() ) {
+	painter.save();
+	painter.setPen( QPen( Qt::red, 1, Qt::DotLine ) );
+	painter.drawLine( xstart, y + baseLine + 1, xstart + w, y + baseLine + 1 );
+	painter.restore();
+    }
+
+    if ( hasdoc && formatChar->isAnchor() && !formatChar->anchorHref().isEmpty() &&
+	 document()->focusIndicator.parag == this &&
+	 ( document()->focusIndicator.start >= start  &&
+	   document()->focusIndicator.start + document()->focusIndicator.len <= start + len ||
+	   document()->focusIndicator.start <= start &&
+	   document()->focusIndicator.start + document()->focusIndicator.len >= start + len ) )
+	painter.drawWinFocusRect( QRect( xstart, y, w, h ) );
+}
+
+void QTextParagraph::drawLabel( QPainter* p, int x, int y, int w, int h, int base, const QColorGroup& cg )
+{
+    QRect r ( x, y, w, h );
+    QStyleSheetItem::ListStyle s = listStyle();
+
+    p->save();
+    QTextFormat *format = at( 0 )->format();
+    if ( format ) {
+	p->setPen( format->color() );
+	p->setFont( format->font() );
+    }
+    QFontMetrics fm( p->fontMetrics() );
+    int size = fm.lineSpacing() / 3;
+
+    bool rtl = str->isRightToLeft();
+
+    switch ( s ) {
+    case QStyleSheetItem::ListDecimal:
+    case QStyleSheetItem::ListLowerAlpha:
+    case QStyleSheetItem::ListUpperAlpha:
+	{
+	    if ( list_val == -1 ) { // uninitialised list value, calcluate the right one
+		int depth = listDepth();
+		list_val--;
+		// ### evil, square and expensive. This needs to be done when formatting, not when painting
+		QTextParagraph* s = prev();
+		int depth_s;
+		while ( s && (depth_s = s->listDepth()) >= depth ) {
+		    if ( depth_s == depth && s->isListItem() )
+			list_val--;
+		    s = s->prev();
+		}
+	    }
+
+	    int n = list_val;
+	    if ( n < -1 )
+		n = -n - 1;
+	    QString l;
+	    switch ( s ) {
+	    case QStyleSheetItem::ListLowerAlpha:
+		if ( n < 27 ) {
+		    l = QChar( ('a' + (char) (n-1)));
+		    break;
+		}
+	    case QStyleSheetItem::ListUpperAlpha:
+		if ( n < 27 ) {
+		    l = QChar( ('A' + (char) (n-1)));
+		    break;
+		}
+		break;
+	    default:  //QStyleSheetItem::ListDecimal:
+		l.setNum( n );
+		break;
+	    }
+	    if (rtl)
+		l.prepend(" .");
+	    else
+		l += QString::fromLatin1(". ");
+	    int x = ( rtl ? r.left() : r.right() - fm.width(l));
+	    p->drawText( x, r.top() + base, l );
+	}
+	break;
+    case QStyleSheetItem::ListSquare:
+	{
+	    int x = rtl ? r.left() + size : r.right() - size*2;
+	    QRect er( x, r.top() + fm.height() / 2 - size / 2, size, size );
+	    p->fillRect( er , cg.brush( QColorGroup::Text ) );
+	}
+	break;
+    case QStyleSheetItem::ListCircle:
+	{
+	    int x = rtl ? r.left() + size : r.right() - size*2;
+	    QRect er( x, r.top() + fm.height() / 2 - size / 2, size, size);
+	    p->drawEllipse( er );
+	}
+	break;
+    case QStyleSheetItem::ListDisc:
+    default:
+	{
+	    p->setBrush( cg.brush( QColorGroup::Text ));
+	    int x = rtl ? r.left() + size : r.right() - size*2;
+	    QRect er( x, r.top() + fm.height() / 2 - size / 2, size, size);
+	    p->drawEllipse( er );
+	    p->setBrush( Qt::NoBrush );
+	}
+	break;
+    }
+
+    p->restore();
+}
+
+#ifndef QT_NO_DATASTREAM
+void QTextParagraph::readStyleInformation( QDataStream& stream )
+{
+    int int_align, int_lstyle;
+    uchar uchar_litem, uchar_rtext, uchar_dir;
+    stream >> int_align >> int_lstyle >> utm >> ubm >> ulm >> urm >> uflm
+	   >> ulinespacing >> ldepth >> uchar_litem >> uchar_rtext >> uchar_dir;
+    align = int_align; lstyle = (QStyleSheetItem::ListStyle) int_lstyle;
+    litem = uchar_litem; rtext = uchar_rtext; str->setDirection( (QChar::Direction)uchar_dir );
+    QTextParagraph* s = prev() ? prev() : this;
+    while ( s ) {
+	s->invalidate( 0 );
+	s = s->next();
+    }
+}
+
+void QTextParagraph::writeStyleInformation( QDataStream& stream ) const
+{
+    stream << (int) align << (int) lstyle << utm << ubm << ulm << urm << uflm << ulinespacing << ldepth << (uchar)litem << (uchar)rtext << (uchar)str->direction();
+}
+#endif
+
+
+void QTextParagraph::setListItem( bool li )
+{
+    if ( (bool)litem == li )
+	return;
+    litem = li;
+    changed = TRUE;
+    QTextParagraph* s = prev() ? prev() : this;
+    while ( s ) {
+	s->invalidate( 0 );
+	s = s->next();
+    }
+}
+
+void QTextParagraph::setListDepth( int depth ) {
+    if ( !hasdoc || depth == ldepth )
+	return;
+    ldepth = depth;
+    QTextParagraph* s = prev() ? prev() : this;
+    while ( s ) {
+	s->invalidate( 0 );
+	s = s->next();
+    }
+}
+
+int *QTextParagraph::tabArray() const
+{
+    int *ta = tArray;
+    if ( !ta && hasdoc )
+	ta = document()->tabArray();
+    return ta;
+}
+
+int QTextParagraph::nextTab( int, int x )
+{
+    int *ta = tArray;
+    if ( hasdoc ) {
+	if ( !ta )
+	    ta = document()->tabArray();
+	tabStopWidth = document()->tabStopWidth();
+    }
+    if ( ta ) {
+	int i = 0;
+	while ( ta[ i ] ) {
+	    if ( ta[ i ] >= x )
+		return tArray[ i ];
+	    ++i;
+	}
+	return tArray[ 0 ];
+    } else {
+	int d;
+	if ( tabStopWidth != 0 )
+	    d = x / tabStopWidth;
+	else
+	    return x;
+	return tabStopWidth * ( d + 1 );
+    }
+}
+
+void QTextParagraph::adjustToPainter( QPainter *p )
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    for ( int i = 0; i < length(); ++i ) {
+	if ( at( i )->isCustom() )
+	    at( i )->customItem()->adjustToPainter( p );
+    }
+#endif
+}
+
+QTextFormatCollection *QTextParagraph::formatCollection() const
+{
+    if ( hasdoc )
+	return document()->formatCollection();
+    QTextFormatCollection* fc = &pseudoDocument()->collection;
+    if ( paintdevice != fc->paintDevice() )
+	fc->setPaintDevice( paintdevice );
+    return fc;
+}
+
+QString QTextParagraph::richText() const
+{
+    QString s;
+    QTextStringChar *formatChar = 0;
+    QString spaces;
+    bool doStart = richTextExportStart && richTextExportStart->paragraph() == this;
+    bool doEnd = richTextExportEnd && richTextExportEnd->paragraph() == this;
+    int i;
+    QString lastAnchorName;
+    for ( i = 0; i < length()-1; ++i ) {
+	if ( doStart && i && richTextExportStart->index() == i )
+	    s += "<!--StartFragment-->";
+	if ( doEnd && richTextExportEnd->index() == i )
+	    s += "<!--EndFragment-->";
+	QTextStringChar *c = &str->at( i );
+	if ( c->isAnchor() && !c->anchorName().isEmpty() && c->anchorName() != lastAnchorName ) {
+            lastAnchorName = c->anchorName();
+            if ( c->anchorName().contains( '#' ) ) {
+		QStringList l = QStringList::split( '#', c->anchorName() );
+		for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it )
+		    s += "<a name=\"" + *it + "\"></a>";
+	    } else {
+		s += "<a name=\"" + c->anchorName() + "\"></a>";
+	    }
+	}
+	if ( !formatChar ) {
+	    s += c->format()->makeFormatChangeTags( formatCollection()->defaultFormat(),
+						    0, QString::null, c->anchorHref() );
+	    formatChar = c;
+	} else if ( ( formatChar->format()->key() != c->format()->key() ) ||
+		  (c->anchorHref() != formatChar->anchorHref() ) )  {
+	    s += c->format()->makeFormatChangeTags( formatCollection()->defaultFormat(),
+						    formatChar->format() , formatChar->anchorHref(), c->anchorHref() );
+	    formatChar = c;
+	}
+	if ( c->c == '<' )
+	    s += "&lt;";
+	else if ( c->c == '>' )
+	    s += "&gt;";
+	else if ( c->c =='&' )
+	    s += "&amp;";
+	else if ( c->c =='\"' )
+	    s += "&quot;";
+#ifndef QT_NO_TEXTCUSTOMITEM
+	else if ( c->isCustom() )
+	    s += c->customItem()->richText();
+#endif
+	else if ( c->c == '\n' || c->c == QChar_linesep )
+	    s += "<br />"; // space on purpose for compatibility with Netscape, Lynx & Co.
+	else
+	    s += c->c;
+    }
+    if ( doEnd && richTextExportEnd->index() == i )
+	s += "<!--EndFragment-->";
+    if ( formatChar )
+	s += formatChar->format()->makeFormatEndTags( formatCollection()->defaultFormat(), formatChar->anchorHref() );
+    return s;
+}
+
+void QTextParagraph::addCommand( QTextCommand *cmd )
+{
+    if ( !hasdoc )
+	pseudoDocument()->commandHistory->addCommand( cmd );
+    else
+	document()->commands()->addCommand( cmd );
+}
+
+QTextCursor *QTextParagraph::undo( QTextCursor *c )
+{
+    if ( !hasdoc )
+	return pseudoDocument()->commandHistory->undo( c );
+    return document()->commands()->undo( c );
+}
+
+QTextCursor *QTextParagraph::redo( QTextCursor *c )
+{
+    if ( !hasdoc )
+	return pseudoDocument()->commandHistory->redo( c );
+    return document()->commands()->redo( c );
+}
+
+int QTextParagraph::topMargin() const
+{
+    int m = 0;
+    if ( rtext ) {
+	m = isListItem() ? (document()->li_tm/QMAX(1,listDepth()*listDepth())) :
+	    ( listDepth() ? 0 : document()->par_tm );
+	if ( listDepth() == 1 &&(  !prev() || prev()->listDepth() < listDepth() ) )
+	    m = QMAX( m, document()->list_tm );
+    }
+    m += utm;
+    return scale( m, QTextFormat::painter() );
+}
+
+int QTextParagraph::bottomMargin() const
+{
+    int m = 0;
+    if ( rtext ) {
+	m = isListItem() ? (document()->li_bm/QMAX(1,listDepth()*listDepth())) :
+	    ( listDepth() ? 0 : document()->par_bm );
+	if ( listDepth() == 1 &&(  !next() || next()->listDepth() < listDepth() ) )
+	    m = QMAX( m, document()->list_bm );
+    }
+    m += ubm;
+    return scale( m, QTextFormat::painter() );
+}
+
+int QTextParagraph::leftMargin() const
+{
+    int m = ulm;
+    if ( listDepth() && !string()->isRightToLeft() )
+	m += listDepth() * document()->list_lm;
+    return scale( m, QTextFormat::painter() );
+}
+
+int QTextParagraph::firstLineMargin() const
+{
+    int m = uflm;
+    return scale( m, QTextFormat::painter() );
+}
+
+int QTextParagraph::rightMargin() const
+{
+    int m = urm;
+    if ( listDepth() && string()->isRightToLeft() )
+	m += listDepth() * document()->list_lm;
+    return scale( m, QTextFormat::painter() );
+}
+
+int QTextParagraph::lineSpacing() const
+{
+    int l = ulinespacing;
+    l = scale( l, QTextFormat::painter() );
+    return l;
+}
+
+void QTextParagraph::copyParagData( QTextParagraph *parag )
+{
+    rtext = parag->rtext;
+    lstyle = parag->lstyle;
+    ldepth = parag->ldepth;
+    litem = parag->litem;
+    align = parag->align;
+    utm = parag->utm;
+    ubm = parag->ubm;
+    urm = parag->urm;
+    ulm = parag->ulm;
+    uflm = parag->uflm;
+    ulinespacing = parag->ulinespacing;
+    QColor *c = parag->backgroundColor();
+    if ( c )
+	setBackgroundColor( *c );
+    str->setDirection( parag->str->direction() );
+}
+
+void QTextParagraph::show()
+{
+    if ( visible || !hasdoc )
+	return;
+    visible = TRUE;
+}
+
+void QTextParagraph::hide()
+{
+    if ( !visible || !hasdoc )
+	return;
+    visible = FALSE;
+}
+
+void QTextParagraph::setDirection( QChar::Direction d )
+{
+    if ( str && str->direction() != d ) {
+	str->setDirection( d );
+	invalidate( 0 );
+    }
+}
+
+QChar::Direction QTextParagraph::direction() const
+{
+    return (str ? str->direction() : QChar::DirON );
+}
+
+void QTextParagraph::setChanged( bool b, bool recursive )
+{
+    changed = b;
+    if ( recursive ) {
+	if ( document() && document()->parentParagraph() )
+	    document()->parentParagraph()->setChanged( b, recursive );
+    }
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+QTextPreProcessor::QTextPreProcessor()
+{
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextFormatter::QTextFormatter()
+    : thisminw(0), thiswused(0), wrapEnabled( TRUE ), wrapColumn( -1 ), biw( FALSE )
+{
+}
+
+QTextLineStart *QTextFormatter::formatLine( QTextParagraph *parag, QTextString *string, QTextLineStart *line,
+						   QTextStringChar *startChar, QTextStringChar *lastChar, int align, int space )
+{
+    if ( lastChar < startChar )
+	return new QTextLineStart;
+#ifndef QT_NO_COMPLEXTEXT
+    if( string->isBidi() )
+	return bidiReorderLine( parag, string, line, startChar, lastChar, align, space );
+#endif
+    int start = (startChar - &string->at(0));
+    int last = (lastChar - &string->at(0) );
+
+    // ignore white space at the end of the line.
+    QTextStringChar *ch = lastChar;
+    while ( ch > startChar && ch->whiteSpace ) {
+	space += ch->format()->width( ' ' );
+	--ch;
+    }
+
+    if (space < 0)
+	space = 0;
+
+    // do alignment Auto == Left in this case
+    if ( align & Qt::AlignHCenter || align & Qt::AlignRight ) {
+	if ( align & Qt::AlignHCenter )
+	    space /= 2;
+	for ( int j = start; j <= last; ++j )
+	    string->at( j ).x += space;
+    } else if ( align & Qt::AlignJustify ) {
+	int numSpaces = 0;
+	// End at "last-1", the last space ends up with a width of 0
+	for ( int j = last-1; j >= start; --j ) {
+	    // Start at last tab, if any.
+	    QTextStringChar &ch = string->at( j );
+	    if ( ch.c == '\t' ) {
+		start = j+1;
+		break;
+	    }
+	    if(ch.whiteSpace)
+		numSpaces++;
+	}
+	int toAdd = 0;
+	for ( int k = start + 1; k <= last; ++k ) {
+	    QTextStringChar &ch = string->at( k );
+	    if( numSpaces && ch.whiteSpace ) {
+		int s = space / numSpaces;
+		toAdd += s;
+		space -= s;
+		numSpaces--;
+	    }
+	    string->at( k ).x += toAdd;
+	}
+    }
+
+    if ( last >= 0 && last < string->length() )
+	line->w = string->at( last ).x + string->width( last );
+    else
+	line->w = 0;
+
+    return new QTextLineStart;
+}
+
+#ifndef QT_NO_COMPLEXTEXT
+
+#ifdef BIDI_DEBUG
+#include <iostream>
+#endif
+
+// collects one line of the paragraph and transforms it to visual order
+QTextLineStart *QTextFormatter::bidiReorderLine( QTextParagraph * /*parag*/, QTextString *text, QTextLineStart *line,
+							QTextStringChar *startChar, QTextStringChar *lastChar, int align, int space )
+{
+    // ignore white space at the end of the line.
+    int endSpaces = 0;
+    while ( lastChar > startChar && lastChar->whiteSpace ) {
+	space += lastChar->format()->width( ' ' );
+	--lastChar;
+	++endSpaces;
+    }
+
+    int start = (startChar - &text->at(0));
+    int last = (lastChar - &text->at(0) );
+
+    int length = lastChar - startChar + 1;
+
+
+    int x = startChar->x;
+
+    unsigned char _levels[256];
+    int _visual[256];
+
+    unsigned char *levels = _levels;
+    int *visual = _visual;
+
+    if ( length > 255 ) {
+	levels = (unsigned char *)malloc( length*sizeof( unsigned char ) );
+	visual = (int *)malloc( length*sizeof( int ) );
+    }
+
+    //qDebug("bidiReorderLine: length=%d (%d-%d)", length, start, last );
+
+    QTextStringChar *ch = startChar;
+    unsigned char *l = levels;
+    while ( ch <= lastChar ) {
+	//qDebug( "  level: %d", ch->bidiLevel );
+	*(l++) = (ch++)->bidiLevel;
+    }
+
+    QTextEngine::bidiReorder( length, levels, visual );
+
+    // now construct the reordered string out of the runs...
+
+    int numSpaces = 0;
+    // set the correct alignment. This is a bit messy....
+    if( align == Qt::AlignAuto ) {
+	// align according to directionality of the paragraph...
+	if ( text->isRightToLeft() )
+	    align = Qt::AlignRight;
+    }
+
+    // This is not really correct, but as we can't make the scrollbar move to the left of the origin,
+    // this ensures all text can be scrolled to and read.
+    if (space < 0)
+	space = 0;
+
+    if ( align & Qt::AlignHCenter )
+	x += space/2;
+    else if ( align & Qt::AlignRight )
+	x += space;
+    else if ( align & Qt::AlignJustify ) {
+	// End at "last-1", the last space ends up with a width of 0
+	for ( int j = last-1; j >= start; --j ) {
+	    // Start at last tab, if any.
+	    QTextStringChar &ch = text->at( j );
+	    if ( ch.c == '\t' ) {
+		start = j+1;
+		break;
+	    }
+	    if(ch.whiteSpace)
+		numSpaces++;
+	}
+    }
+
+    int toAdd = 0;
+    int xorig = x;
+    QTextStringChar *lc = startChar + visual[0];
+    for ( int i = 0; i < length; i++ ) {
+	QTextStringChar *ch = startChar + visual[i];
+	if (numSpaces && ch->whiteSpace) {
+	    int s = space / numSpaces;
+	    toAdd += s;
+	    space -= s;
+	    numSpaces--;
+	}
+
+	if (lc->format() != ch->format() && !ch->c.isSpace()
+	    && lc->format()->font().italic() && !ch->format()->font().italic()) {
+	    int rb = lc->format()->fontMetrics().rightBearing(lc->c);
+	    if (rb < 0)
+		x -= rb;
+	}
+
+ 	ch->x = x + toAdd;
+        ch->rightToLeft = ch->bidiLevel % 2;
+	//qDebug("visual: %d (%x) placed at %d rightToLeft=%d", visual[i], ch->c.unicode(), x +toAdd, ch->rightToLeft  );
+	int ww = 0;
+	if ( ch->c.unicode() >= 32 || ch->c == '\t' || ch->c == '\n' || ch->isCustom() ) {
+	    ww = text->width( start+visual[i] );
+	} else {
+	    ww = ch->format()->width( ' ' );
+	}
+	x += ww;
+	lc = ch;
+    }
+    x += toAdd;
+
+    while ( endSpaces-- ) {
+	++lastChar;
+	int sw = lastChar->format()->width( ' ' );
+	if ( text->isRightToLeft() ) {
+	    xorig -= sw;
+	    lastChar->x = xorig;
+            ch->rightToLeft = TRUE;
+	} else {
+	    lastChar->x = x;
+	    x += sw;
+            ch->rightToLeft = FALSE;
+	}
+    }
+
+    line->w = x;
+
+    if ( length > 255 ) {
+	free( levels );
+	free( visual );
+    }
+
+    return new QTextLineStart;
+}
+#endif
+
+
+void QTextFormatter::insertLineStart( QTextParagraph *parag, int index, QTextLineStart *ls )
+{
+    QMap<int, QTextLineStart*>::Iterator it;
+    if ( ( it = parag->lineStartList().find( index ) ) == parag->lineStartList().end() ) {
+	parag->lineStartList().insert( index, ls );
+    } else {
+	delete *it;
+	parag->lineStartList().remove( it );
+	parag->lineStartList().insert( index, ls );
+    }
+}
+
+
+/* Standard pagebreak algorithm using QTextFlow::adjustFlow. Returns
+ the shift of the paragraphs bottom line.
+ */
+int QTextFormatter::formatVertically( QTextDocument* doc, QTextParagraph* parag )
+{
+    int oldHeight = parag->rect().height();
+    QMap<int, QTextLineStart*>& lineStarts = parag->lineStartList();
+    QMap<int, QTextLineStart*>::Iterator it = lineStarts.begin();
+    int h = parag->prev() ? QMAX(parag->prev()->bottomMargin(),parag->topMargin() ) / 2: 0;
+    for ( ; it != lineStarts.end() ; ++it  ) {
+	QTextLineStart * ls = it.data();
+	ls->y = h;
+	QTextStringChar *c = &parag->string()->at(it.key());
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( c && c->customItem() && c->customItem()->ownLine() ) {
+	    int h = c->customItem()->height;
+	    c->customItem()->pageBreak( parag->rect().y() + ls->y + ls->baseLine - h, doc->flow() );
+	    int delta = c->customItem()->height - h;
+	    ls->h += delta;
+	    if ( delta )
+		parag->setMovedDown( TRUE );
+	} else
+#endif
+	{
+
+	    int shift = doc->flow()->adjustFlow( parag->rect().y() + ls->y, ls->w, ls->h );
+	    ls->y += shift;
+	    if ( shift )
+		parag->setMovedDown( TRUE );
+	}
+	h = ls->y + ls->h;
+    }
+    int m = parag->bottomMargin();
+    if ( !parag->next() )
+	m = 0;
+    else
+	m = QMAX(m, parag->next()->topMargin() ) / 2;
+    h += m;
+    parag->setHeight( h );
+    return h - oldHeight;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextFormatterBreakInWords::QTextFormatterBreakInWords()
+{
+}
+
+#define SPACE(s) s
+
+int QTextFormatterBreakInWords::format( QTextDocument *doc,QTextParagraph *parag,
+					int start, const QMap<int, QTextLineStart*> & )
+{
+    // make sure bidi information is correct.
+    (void )parag->string()->isBidi();
+
+    QTextStringChar *c = 0;
+    QTextStringChar *firstChar = 0;
+    int left = doc ? parag->leftMargin() + doc->leftMargin() : 0;
+    int x = left + ( doc ? parag->firstLineMargin() : 0 );
+    int dw = parag->documentVisibleWidth() - ( doc ? doc->rightMargin() : 0 );
+    int y = parag->prev() ? QMAX(parag->prev()->bottomMargin(),parag->topMargin()) / 2: 0;
+    int h = y;
+    int len = parag->length();
+    if ( doc )
+	x = doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), x, 4 );
+    int rm = parag->rightMargin();
+    int w = dw - ( doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 4 ) : 0 );
+    bool fullWidth = TRUE;
+    int minw = 0;
+    int wused = 0;
+    bool wrapEnabled = isWrapEnabled( parag );
+
+    start = 0;    //######### what is the point with start?! (Matthias)
+    if ( start == 0 )
+	c = &parag->string()->at( 0 );
+
+    int i = start;
+    QTextLineStart *lineStart = new QTextLineStart( y, y, 0 );
+    insertLineStart( parag, 0, lineStart );
+
+    QPainter *painter = QTextFormat::painter();
+
+    int col = 0;
+    int ww = 0;
+    QChar lastChr;
+    for ( ; i < len; ++i, ++col ) {
+	if ( c )
+	    lastChr = c->c;
+	c = &parag->string()->at( i );
+	// ### the lines below should not be needed
+	if ( painter )
+	    c->format()->setPainter( painter );
+	if ( i > 0 ) {
+	    c->lineStart = 0;
+	} else {
+	    c->lineStart = 1;
+	    firstChar = c;
+	}
+	if ( c->c.unicode() >= 32 || c->isCustom() ) {
+	    ww = parag->string()->width( i );
+	} else if ( c->c == '\t' ) {
+	    int nx = parag->nextTab( i, x - left ) + left;
+	    if ( nx < x )
+		ww = w - x;
+	    else
+		ww = nx - x;
+	} else {
+	    ww = c->format()->width( ' ' );
+	}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+	if ( c->isCustom() && c->customItem()->ownLine() ) {
+	    x = doc ? doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), left, 4 ) : left;
+	    w = dw - ( doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 4 ) : 0 );
+	    c->customItem()->resize( w - x );
+	    w = dw;
+	    y += h;
+	    h = c->height();
+	    lineStart = new QTextLineStart( y, h, h );
+	    insertLineStart( parag, i, lineStart );
+	    c->lineStart = 1;
+	    firstChar = c;
+	    x = 0xffffff;
+	    continue;
+	}
+#endif
+
+	if ( wrapEnabled &&
+	     ( wrapAtColumn() == -1 && x + ww > w ||
+	       wrapAtColumn() != -1 && col >= wrapAtColumn() ) ) {
+	    x = doc ? parag->document()->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), left, 4 ) : left;
+	    w = dw;
+	    y += h;
+	    h = c->height();
+	    lineStart = formatLine( parag, parag->string(), lineStart, firstChar, c-1 );
+	    lineStart->y = y;
+	    insertLineStart( parag, i, lineStart );
+	    lineStart->baseLine = c->ascent();
+	    lineStart->h = c->height();
+	    c->lineStart = 1;
+	    firstChar = c;
+	    col = 0;
+	    if ( wrapAtColumn() != -1 )
+		minw = QMAX( minw, w );
+	} else if ( lineStart ) {
+	    lineStart->baseLine = QMAX( lineStart->baseLine, c->ascent() );
+	    h = QMAX( h, c->height() );
+	    lineStart->h = h;
+	}
+
+	c->x = x;
+	x += ww;
+	wused = QMAX( wused, x );
+    }
+
+    int m = parag->bottomMargin();
+    if ( !parag->next() )
+	m = 0;
+    else
+	m = QMAX(m, parag->next()->topMargin() ) / 2;
+    parag->setFullWidth( fullWidth );
+    y += h + m;
+    if ( doc )
+	minw += doc->rightMargin();
+    if ( !wrapEnabled )
+	minw = QMAX(minw, wused);
+
+    thisminw = minw;
+    thiswused = wused;
+    return y;
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextFormatterBreakWords::QTextFormatterBreakWords()
+{
+}
+
+#define DO_FLOW( lineStart ) do{ if ( doc && doc->isPageBreakEnabled() ) { \
+		    int yflow = lineStart->y + parag->rect().y();\
+		    int shift = doc->flow()->adjustFlow( yflow, dw, lineStart->h ); \
+		    lineStart->y += shift;\
+		    y += shift;\
+		}}while(FALSE)
+
+int QTextFormatterBreakWords::format( QTextDocument *doc, QTextParagraph *parag,
+				      int start, const QMap<int, QTextLineStart*> & )
+{
+    // make sure bidi information is correct.
+    (void )parag->string()->isBidi();
+
+    QTextStringChar *c = 0;
+    QTextStringChar *firstChar = 0;
+    QTextString *string = parag->string();
+    int left = doc ? parag->leftMargin() + doc->leftMargin() : 0;
+    int x = left + ( doc ? parag->firstLineMargin() : 0 );
+    int y = parag->prev() ? QMAX(parag->prev()->bottomMargin(),parag->topMargin()) / 2: 0;
+    int h = y;
+    int len = parag->length();
+    if ( doc )
+	x = doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), x, 0 );
+    int dw = parag->documentVisibleWidth() - ( doc ? ( left != x ? 0 : doc->rightMargin() ) : 0 );
+
+    int curLeft = x;
+    int rm = parag->rightMargin();
+    int rdiff = doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 0 ) : 0;
+    int w = dw - rdiff;
+    bool fullWidth = TRUE;
+    int marg = left + rdiff;
+    int minw = 0;
+    int wused = 0;
+    int tminw = marg;
+    int linespacing = doc ? parag->lineSpacing() : 0;
+    bool wrapEnabled = isWrapEnabled( parag );
+
+    start = 0;
+
+    int i = start;
+    QTextLineStart *lineStart = new QTextLineStart( y, y, 0 );
+    insertLineStart( parag, 0, lineStart );
+    int lastBreak = -1;
+    int tmpBaseLine = 0, tmph = 0;
+    bool lastWasNonInlineCustom = FALSE;
+
+    int align = parag->alignment();
+    if ( align == Qt::AlignAuto && doc && doc->alignment() != Qt::AlignAuto )
+	align = doc->alignment();
+
+    align &= Qt::AlignHorizontal_Mask;
+
+    // ### hack. The last char in the paragraph is always invisible,
+    // ### and somehow sometimes has a wrong format. It changes
+    // ### between // layouting and printing. This corrects some
+    // ### layouting errors in BiDi mode due to this.
+    if ( len > 1 ) {
+	c = &parag->string()->at(len - 1);
+	if (!c->isAnchor()) {
+              if (c->format())
+	        c->format()->removeRef();
+	    c->setFormat( string->at( len - 2 ).format() );
+	    if (c->format())
+                  c->format()->addRef();
+	}
+    }
+
+    c = &parag->string()->at( 0 );
+
+    QPainter *painter = QTextFormat::painter();
+    int col = 0;
+    int ww = 0;
+    QChar lastChr = c->c;
+    QTextFormat *lastFormat = c->format();
+    for ( ; i < len; ++i, ++col ) {
+	if ( i ) {
+	    c = &parag->string()->at(i-1);
+	    lastChr = c->c;
+	    lastFormat = c->format();
+	}
+	bool lastWasOwnLineCustomItem = lastBreak == -2;
+	bool hadBreakableChar = lastBreak != -1;
+	bool lastWasHardBreak = lastChr == QChar_linesep;
+
+	// ### next line should not be needed
+	if ( painter )
+	    c->format()->setPainter( painter );
+	c = &string->at( i );
+
+	if (lastFormat != c->format() && !c->c.isSpace()
+	    && lastFormat->font().italic() && !c->format()->font().italic()) {
+	    int rb = lastFormat->fontMetrics().rightBearing(lastChr);
+	    if (rb < 0)
+		x -= rb;
+	}
+
+	if ( i > 0 && (x > curLeft || ww == 0) || lastWasNonInlineCustom ) {
+	    c->lineStart = 0;
+	} else {
+	    c->lineStart = 1;
+	    firstChar = c;
+	}
+
+        // ignore non spacing marks for column count.
+        if (col != 0 && ::category(c->c) == QChar::Mark_NonSpacing)
+            --col;
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+	lastWasNonInlineCustom =  ( c->isCustom() && c->customItem()->placement() != QTextCustomItem::PlaceInline );
+#endif
+
+ 	if ( c->c.unicode() >= 32 || c->isCustom() ) {
+	    ww = string->width( i );
+	} else if ( c->c == '\t' ) {
+	    if ( align == Qt::AlignRight || align == Qt::AlignCenter ) {
+		// we can not  (yet) do tabs
+		ww = c->format()->width(' ' );
+	    } else {
+		int tabx = lastWasHardBreak ? (left + ( doc ? parag->firstLineMargin() : 0 )) : x;
+		int nx = parag->nextTab( i, tabx - left ) + left;
+		if ( nx < tabx ) // strrrange...
+		    ww = 0;
+		else
+		    ww = nx - tabx;
+	    }
+	} else {
+	    ww = c->format()->width( ' ' );
+	}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+	QTextCustomItem* ci = c->customItem();
+	if ( c->isCustom() && ci->ownLine() ) {
+	    QTextLineStart *lineStart2 = formatLine( parag, string, lineStart, firstChar, c-1, align, SPACE(w - x - ww) );
+	    x = doc ? doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), left, 4 ) : left;
+	    w = dw - ( doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 4 ) : 0 );
+	    ci->resize(w - x);
+	    if ( ci->width < w - x ) {
+		if ( align & Qt::AlignHCenter )
+		    x = ( w - ci->width ) / 2;
+		else if ( align & Qt::AlignRight ) {
+		    x = w - ci->width;
+		}
+	    }
+	    c->x = x;
+	    curLeft = x;
+	    if ( i == 0 || !isBreakable(string, i-1) ||
+		 string->at( i - 1 ).lineStart == 0 ) {
+		y += QMAX( h, QMAX( tmph, linespacing ) );
+		tmph = c->height();
+		h = tmph;
+		lineStart = lineStart2;
+		lineStart->y = y;
+		insertLineStart( parag, i, lineStart );
+		c->lineStart = 1;
+		firstChar = c;
+	    } else {
+		tmph = c->height();
+		h = tmph;
+		delete lineStart2;
+	    }
+	    lineStart->h = h;
+	    lineStart->baseLine = h;
+	    tmpBaseLine = lineStart->baseLine;
+	    lastBreak = -2;
+	    x = w;
+	    minw = QMAX( minw, tminw );
+
+	    int tw = ci->minimumWidth() + ( doc ? doc->leftMargin() : 0 );
+	    if ( tw < QWIDGETSIZE_MAX )
+		tminw = tw;
+	    else
+		tminw = marg;
+ 	    wused = QMAX( wused, ci->width );
+	    continue;
+	} else if ( c->isCustom() && ci->placement() != QTextCustomItem::PlaceInline ) {
+	    int tw = ci->minimumWidth();
+	    if ( tw < QWIDGETSIZE_MAX )
+		minw = QMAX( minw, tw );
+	}
+#endif
+	// we break if
+	// 1. the last character was a hard break (QChar_linesep) or
+	// 2. the last charater was a own-line custom item (eg. table or ruler) or
+	// 3. wrapping was enabled, it was not a space and following
+	// condition is true: We either had a breakable character
+	// previously or we ar allowed to break in words and - either
+	// we break at w pixels and the current char would exceed that
+	// or - we break at a column and the current character would
+	// exceed that.
+	if ( lastWasHardBreak || lastWasOwnLineCustomItem ||
+	     ( wrapEnabled &&
+	       ( (!c->c.isSpace() && (hadBreakableChar || allowBreakInWords()) &&
+		  ( (wrapAtColumn() == -1 && x + ww > w) ||
+		    (wrapAtColumn() != -1 && col >= wrapAtColumn()) ) ) )
+	       )
+	     ) {
+	    if ( wrapAtColumn() != -1 )
+		minw = QMAX( minw, x + ww );
+	    // if a break was forced (no breakable char, hard break or own line custom item), break immediately....
+	    if ( !hadBreakableChar || lastWasHardBreak || lastWasOwnLineCustomItem ) {
+		if ( lineStart ) {
+		    lineStart->baseLine = QMAX( lineStart->baseLine, tmpBaseLine );
+		    h = QMAX( h, tmph );
+		    lineStart->h = h;
+  		    DO_FLOW( lineStart );
+		}
+		lineStart = formatLine( parag, string, lineStart, firstChar, c-1, align, SPACE(w - x) );
+		x = doc ? doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), left, 4 ) : left;
+		w = dw - ( doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 4 ) : 0 );
+		if ( !doc && c->c == '\t' ) { // qt_format_text tab handling
+		    int nx = parag->nextTab( i, x - left ) + left;
+		    if ( nx < x )
+			ww = w - x;
+		    else
+			ww = nx - x;
+		}
+		curLeft = x;
+		y += QMAX( h, linespacing );
+		tmph = c->height();
+		h = 0;
+		lineStart->y = y;
+		insertLineStart( parag, i, lineStart );
+		lineStart->baseLine = c->ascent();
+		lineStart->h = c->height();
+		c->lineStart = 1;
+		firstChar = c;
+		tmpBaseLine = lineStart->baseLine;
+		lastBreak = -1;
+		col = 0;
+		if ( allowBreakInWords() || lastWasHardBreak ) {
+		    minw = QMAX(minw, tminw);
+		    tminw = marg + ww;
+		}
+	    } else { // ... otherwise if we had a breakable char, break there
+  		DO_FLOW( lineStart );
+		c->x = x;
+		i = lastBreak;
+		lineStart = formatLine( parag, string, lineStart, firstChar, parag->at( lastBreak ),align, SPACE(w - string->at( i+1 ).x) );
+		x = doc ? doc->flow()->adjustLMargin( y + parag->rect().y(), parag->rect().height(), left, 4 ) : left;
+		w = dw - ( doc ? doc->flow()->adjustRMargin( y + parag->rect().y(), parag->rect().height(), rm, 4 ) : 0 );
+		if ( !doc && c->c == '\t' ) { // qt_format_text tab handling
+		    int nx = parag->nextTab( i, x - left ) + left;
+		    if ( nx < x )
+			ww = w - x;
+		    else
+			ww = nx - x;
+		}
+		curLeft = x;
+		y += QMAX( h, linespacing );
+		tmph = c->height();
+		h = tmph;
+		lineStart->y = y;
+		insertLineStart( parag, i + 1, lineStart );
+		lineStart->baseLine = c->ascent();
+		lineStart->h = c->height();
+		c->lineStart = 1;
+		firstChar = c;
+		tmpBaseLine = lineStart->baseLine;
+		lastBreak = -1;
+		col = 0;
+		minw = QMAX(minw, tminw);
+		tminw = marg;
+		continue;
+	    }
+	} else if (lineStart && isBreakable(string, i)) {
+	    if ( len <= 2 || i < len - 1 ) {
+		tmpBaseLine = QMAX( tmpBaseLine, c->ascent() );
+		tmph = QMAX( tmph, c->height() );
+	    }
+	    minw = QMAX( minw, tminw );
+
+	    tminw = marg + ww;
+	    lineStart->baseLine = QMAX( lineStart->baseLine, tmpBaseLine );
+	    h = QMAX( h, tmph );
+	    lineStart->h = h;
+	    if ( i < len - 2 || c->c != ' ' )
+		lastBreak = i;
+	} else {
+	    tminw += ww;
+	    int cascent = c->ascent();
+	    int cheight = c->height();
+	    int belowBaseLine = QMAX( tmph - tmpBaseLine, cheight-cascent );
+	    tmpBaseLine = QMAX( tmpBaseLine, cascent );
+	    tmph = tmpBaseLine + belowBaseLine;
+	}
+
+	c->x = x;
+	x += ww;
+	wused = QMAX( wused, x );
+    }
+
+    if ( lineStart ) {
+	lineStart->baseLine = QMAX( lineStart->baseLine, tmpBaseLine );
+	h = QMAX( h, tmph );
+	lineStart->h = h;
+	// last line in a paragraph is not justified
+	if ( align == Qt::AlignJustify )
+	    align = Qt::AlignAuto;
+ 	DO_FLOW( lineStart );
+	lineStart = formatLine( parag, string, lineStart, firstChar, c, align, SPACE(w - x) );
+	delete lineStart;
+    }
+
+    minw = QMAX( minw, tminw );
+    if ( doc )
+	minw += doc->rightMargin();
+
+    int m = parag->bottomMargin();
+    if ( !parag->next() )
+	m = 0;
+    else
+	m = QMAX(m, parag->next()->topMargin() ) / 2;
+    parag->setFullWidth( fullWidth );
+    y += QMAX( h, linespacing ) + m;
+
+    wused += rm;
+    if ( !wrapEnabled || wrapAtColumn() != -1 )
+	minw = QMAX(minw, wused);
+
+    // This is the case where we are breaking wherever we darn well please
+    // in cases like that, the minw should not be the length of the entire
+    // word, because we necessarily want to show the word on the whole line.
+    // example: word wrap in iconview
+    if ( allowBreakInWords() && minw > wused )
+	minw = wused;
+
+    thisminw = minw;
+    thiswused = wused;
+    return y;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextIndent::QTextIndent()
+{
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+QTextFormatCollection::QTextFormatCollection()
+    : cKey( 307 ), paintdevice( 0 )
+{
+    defFormat = new QTextFormat( QApplication::font(),
+				 QApplication::palette().color( QPalette::Active, QColorGroup::Text ) );
+    lastFormat = cres = 0;
+    cflags = -1;
+    cKey.setAutoDelete( TRUE );
+    cachedFormat = 0;
+}
+
+QTextFormatCollection::~QTextFormatCollection()
+{
+    delete defFormat;
+}
+
+void QTextFormatCollection::setPaintDevice( QPaintDevice *pd )
+{
+    paintdevice = pd;
+
+#if defined(Q_WS_X11)
+    int scr = ( paintdevice ) ? paintdevice->x11Screen() : QPaintDevice::x11AppScreen();
+
+    defFormat->fn.x11SetScreen( scr );
+    defFormat->update();
+
+    QDictIterator<QTextFormat> it( cKey );
+    QTextFormat *format;
+    while ( ( format = it.current() ) != 0 ) {
+	++it;
+	format->fn.x11SetScreen( scr );
+	format->update();
+    }
+#endif // Q_WS_X11
+}
+
+QTextFormat *QTextFormatCollection::format( QTextFormat *f )
+{
+    if ( f->parent() == this || f == defFormat ) {
+	lastFormat = f;
+	lastFormat->addRef();
+	return lastFormat;
+    }
+
+    if ( f == lastFormat || ( lastFormat && f->key() == lastFormat->key() ) ) {
+	lastFormat->addRef();
+	return lastFormat;
+    }
+
+    QTextFormat *fm = cKey.find( f->key() );
+    if ( fm ) {
+	lastFormat = fm;
+	lastFormat->addRef();
+	return lastFormat;
+    }
+
+    if ( f->key() == defFormat->key() )
+	return defFormat;
+
+    lastFormat = createFormat( *f );
+    lastFormat->collection = this;
+    cKey.insert( lastFormat->key(), lastFormat );
+    return lastFormat;
+}
+
+QTextFormat *QTextFormatCollection::format( QTextFormat *of, QTextFormat *nf, int flags )
+{
+    if ( cres && kof == of->key() && knf == nf->key() && cflags == flags ) {
+	cres->addRef();
+	return cres;
+    }
+
+    cres = createFormat( *of );
+    kof = of->key();
+    knf = nf->key();
+    cflags = flags;
+    if ( flags & QTextFormat::Bold )
+	cres->fn.setBold( nf->fn.bold() );
+    if ( flags & QTextFormat::Italic )
+	cres->fn.setItalic( nf->fn.italic() );
+    if ( flags & QTextFormat::Underline )
+	cres->fn.setUnderline( nf->fn.underline() );
+    if ( flags & QTextFormat::StrikeOut )
+	cres->fn.setStrikeOut( nf->fn.strikeOut() );
+    if ( flags & QTextFormat::Family )
+	cres->fn.setFamily( nf->fn.family() );
+    if ( flags & QTextFormat::Size ) {
+	if ( of->usePixelSizes )
+	    cres->fn.setPixelSize( nf->fn.pixelSize() );
+	else
+	    cres->fn.setPointSize( nf->fn.pointSize() );
+    }
+    if ( flags & QTextFormat::Color )
+	cres->col = nf->col;
+    if ( flags & QTextFormat::Misspelled )
+	cres->missp = nf->missp;
+    if ( flags & QTextFormat::VAlign )
+	cres->ha = nf->ha;
+    cres->update();
+
+    QTextFormat *fm = cKey.find( cres->key() );
+    if ( !fm ) {
+	cres->collection = this;
+	cKey.insert( cres->key(), cres );
+    } else {
+	delete cres;
+	cres = fm;
+	cres->addRef();
+    }
+
+    return cres;
+}
+
+QTextFormat *QTextFormatCollection::format( const QFont &f, const QColor &c )
+{
+    if ( cachedFormat && cfont == f && ccol == c ) {
+	cachedFormat->addRef();
+	return cachedFormat;
+    }
+
+    QString key = QTextFormat::getKey( f, c, FALSE,  QTextFormat::AlignNormal );
+    cachedFormat = cKey.find( key );
+    cfont = f;
+    ccol = c;
+
+    if ( cachedFormat ) {
+	cachedFormat->addRef();
+	return cachedFormat;
+    }
+
+    if ( key == defFormat->key() )
+	return defFormat;
+
+    cachedFormat = createFormat( f, c );
+    cachedFormat->collection = this;
+    cKey.insert( cachedFormat->key(), cachedFormat );
+    if ( cachedFormat->key() != key )
+	qWarning("ASSERT: keys for format not identical: '%s '%s'", cachedFormat->key().latin1(), key.latin1() );
+    return cachedFormat;
+}
+
+void QTextFormatCollection::remove( QTextFormat *f )
+{
+    if ( lastFormat == f )
+	lastFormat = 0;
+    if ( cres == f )
+	cres = 0;
+    if ( cachedFormat == f )
+	cachedFormat = 0;
+    if (cKey.find(f->key()) == f)
+	cKey.remove( f->key() );
+}
+
+#define UPDATE( up, lo, rest ) \
+	if ( font.lo##rest() != defFormat->fn.lo##rest() && fm->fn.lo##rest() == defFormat->fn.lo##rest() ) \
+	    fm->fn.set##up##rest( font.lo##rest() )
+
+void QTextFormatCollection::updateDefaultFormat( const QFont &font, const QColor &color, QStyleSheet *sheet )
+{
+    QDictIterator<QTextFormat> it( cKey );
+    QTextFormat *fm;
+    bool usePixels = font.pointSize() == -1;
+    bool changeSize = usePixels ? font.pixelSize() != defFormat->fn.pixelSize() :
+	font.pointSize() != defFormat->fn.pointSize();
+    int base = usePixels ? font.pixelSize() : font.pointSize();
+    while ( ( fm = it.current() ) ) {
+	++it;
+	UPDATE( F, f, amily );
+	UPDATE( W, w, eight );
+	UPDATE( B, b, old );
+	UPDATE( I, i, talic );
+	UPDATE( U, u, nderline );
+	if ( changeSize ) {
+	    fm->stdSize = base;
+	    fm->usePixelSizes = usePixels;
+	    if ( usePixels )
+		fm->fn.setPixelSize( fm->stdSize );
+	    else
+		fm->fn.setPointSize( fm->stdSize );
+	    sheet->scaleFont( fm->fn, fm->logicalFontSize );
+	}
+	if ( color.isValid() && color != defFormat->col && fm->col == defFormat->col )
+	    fm->col = color;
+	fm->update();
+    }
+
+    defFormat->fn = font;
+    defFormat->col = color;
+    defFormat->update();
+    defFormat->stdSize = base;
+    defFormat->usePixelSizes = usePixels;
+
+    updateKeys();
+}
+
+// the keys in cKey have changed, rebuild the hashtable
+void QTextFormatCollection::updateKeys()
+{
+    if ( cKey.isEmpty() )
+	return;
+    cKey.setAutoDelete( FALSE );
+    QTextFormat** formats = new QTextFormat*[ cKey.count() + 1 ];
+    QTextFormat **f = formats;
+    QDictIterator<QTextFormat> it( cKey );
+    while ( ( *f = it.current() ) ) {
+       ++it;
+       ++f;
+    }
+    cKey.clear();
+    for ( f = formats; *f; f++ )
+       cKey.insert( (*f)->key(), *f );
+    cKey.setAutoDelete( TRUE );
+    delete [] formats;
+}
+
+
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+void QTextFormat::setBold( bool b )
+{
+    if ( b == fn.bold() )
+	return;
+    fn.setBold( b );
+    update();
+}
+
+void QTextFormat::setMisspelled( bool b )
+{
+    if ( b == (bool)missp )
+	return;
+    missp = b;
+    update();
+}
+
+void QTextFormat::setVAlign( VerticalAlignment a )
+{
+    if ( a == ha )
+	return;
+    ha = a;
+    update();
+}
+
+void QTextFormat::setItalic( bool b )
+{
+    if ( b == fn.italic() )
+	return;
+    fn.setItalic( b );
+    update();
+}
+
+void QTextFormat::setUnderline( bool b )
+{
+    if ( b == fn.underline() )
+	return;
+    fn.setUnderline( b );
+    update();
+}
+
+void QTextFormat::setStrikeOut( bool b )
+{
+    if ( b == fn.strikeOut() )
+	return;
+    fn.setStrikeOut( b );
+    update();
+}
+
+void QTextFormat::setFamily( const QString &f )
+{
+    if ( f == fn.family() )
+	return;
+    fn.setFamily( f );
+    update();
+}
+
+void QTextFormat::setPointSize( int s )
+{
+    if ( s == fn.pointSize() )
+	return;
+    fn.setPointSize( s );
+    usePixelSizes = FALSE;
+    update();
+}
+
+void QTextFormat::setFont( const QFont &f )
+{
+    if ( f == fn && !k.isEmpty() )
+	return;
+    fn = f;
+    update();
+}
+
+void QTextFormat::setColor( const QColor &c )
+{
+    if ( c == col )
+	return;
+    col = c;
+    update();
+}
+
+QString QTextFormat::makeFormatChangeTags( QTextFormat* defaultFormat, QTextFormat *f,
+			   const QString& oldAnchorHref, const QString& anchorHref  ) const
+{
+    QString tag;
+    if ( f )
+	tag += f->makeFormatEndTags( defaultFormat, oldAnchorHref );
+
+    if ( !anchorHref.isEmpty() )
+	tag += "<a href=\"" + anchorHref + "\">";
+
+    if ( font() != defaultFormat->font()
+	 || vAlign() != defaultFormat->vAlign()
+	 || color().rgb() != defaultFormat->color().rgb() ) {
+	QString s;
+	if ( font().family() != defaultFormat->font().family() )
+	    s += QString(!!s?";":"") + "font-family:" + fn.family();
+	if ( font().italic() && font().italic() != defaultFormat->font().italic() )
+	    s += QString(!!s?";":"") + "font-style:" + (font().italic() ? "italic" : "normal");
+	if ( font().pointSize() != defaultFormat->font().pointSize() )
+	    s += QString(!!s?";":"") + "font-size:" + QString::number( fn.pointSize() ) + "pt";
+	if ( font().weight() != defaultFormat->font().weight() )
+	    s += QString(!!s?";":"") + "font-weight:" + QString::number( fn.weight() * 8 );
+        QString textDecoration;
+        bool none = FALSE;
+	if ( font().underline() != defaultFormat->font().underline() ) {
+            if (font().underline())
+                textDecoration = "underline";
+            else
+                none = TRUE;
+        }
+	if ( font().overline() != defaultFormat->font().overline() ) {
+            if (font().overline())
+                textDecoration += " overline";
+            else
+                none = TRUE;
+        }
+	if ( font().strikeOut() != defaultFormat->font().strikeOut() ) {
+            if (font().strikeOut())
+                textDecoration += " line-through";
+            else
+                none = TRUE;
+        }
+        if (none && textDecoration.isEmpty())
+            textDecoration = "none";
+        if (!textDecoration.isEmpty())
+	    s += QString(!!s?";":"") + "text-decoration:" + textDecoration;
+	if ( vAlign() != defaultFormat->vAlign() ) {
+	    s += QString(!!s?";":"") + "vertical-align:";
+	    if ( vAlign() == QTextFormat::AlignSuperScript )
+		s += "super";
+	    else if ( vAlign() == QTextFormat::AlignSubScript )
+		s += "sub";
+	    else
+		s += "normal";
+	}
+	if ( color().rgb() != defaultFormat->color().rgb() )
+	    s += QString(!!s?";":"") + "color:" + col.name();
+	if ( !s.isEmpty() )
+	    tag += "<span style=\"" + s + "\">";
+    }
+
+    return tag;
+}
+
+QString QTextFormat::makeFormatEndTags( QTextFormat* defaultFormat, const QString& anchorHref ) const
+{
+    QString tag;
+    if ( font().family() != defaultFormat->font().family()
+	 || font().pointSize() != defaultFormat->font().pointSize()
+	 || font().weight() != defaultFormat->font().weight()
+	 || font().italic() != defaultFormat->font().italic()
+	 || font().underline() != defaultFormat->font().underline()
+	 || font().strikeOut() != defaultFormat->font().strikeOut()
+	 || vAlign() != defaultFormat->vAlign()
+	 || color().rgb() != defaultFormat->color().rgb() )
+	tag += "</span>";
+    if ( !anchorHref.isEmpty() )
+	tag += "</a>";
+    return tag;
+}
+
+QTextFormat QTextFormat::makeTextFormat( const QStyleSheetItem *style, const QMap<QString,QString>& attr, double scaleFontsFactor ) const
+{
+    QTextFormat format(*this);
+    if (!style )
+	return format;
+
+    if ( !style->isAnchor() && style->color().isValid() ) {
+	// the style is not an anchor and defines a color.
+	// It might be used inside an anchor and it should
+	// override the link color.
+	format.linkColor = FALSE;
+    }
+    switch ( style->verticalAlignment() ) {
+    case QStyleSheetItem::VAlignBaseline:
+	format.setVAlign( QTextFormat::AlignNormal );
+	break;
+    case QStyleSheetItem::VAlignSuper:
+	format.setVAlign( QTextFormat::AlignSuperScript );
+	break;
+    case QStyleSheetItem::VAlignSub:
+	format.setVAlign( QTextFormat::AlignSubScript );
+	break;
+    }
+
+    if ( style->fontWeight() != QStyleSheetItem::Undefined )
+	format.fn.setWeight( style->fontWeight() );
+    if ( style->fontSize() != QStyleSheetItem::Undefined ) {
+	format.fn.setPointSize( style->fontSize() );
+    } else if ( style->logicalFontSize() != QStyleSheetItem::Undefined ) {
+	format.logicalFontSize = style->logicalFontSize();
+	if ( format.usePixelSizes )
+	    format.fn.setPixelSize( format.stdSize );
+	else
+	    format.fn.setPointSize( format.stdSize );
+	style->styleSheet()->scaleFont( format.fn, format.logicalFontSize );
+    } else if ( style->logicalFontSizeStep() ) {
+	format.logicalFontSize += style->logicalFontSizeStep();
+	if ( format.usePixelSizes )
+	    format.fn.setPixelSize( format.stdSize );
+	else
+	    format.fn.setPointSize( format.stdSize );
+	style->styleSheet()->scaleFont( format.fn, format.logicalFontSize );
+    }
+    if ( !style->fontFamily().isEmpty() )
+	format.fn.setFamily( style->fontFamily() );
+    if ( style->color().isValid() )
+	format.col = style->color();
+    if ( style->definesFontItalic() )
+	format.fn.setItalic( style->fontItalic() );
+    if ( style->definesFontUnderline() )
+	format.fn.setUnderline( style->fontUnderline() );
+    if ( style->definesFontStrikeOut() )
+	format.fn.setStrikeOut( style->fontStrikeOut() );
+
+
+    if ( style->name() == "font") {
+	if ( attr.contains("color") ) {
+	    QString s = attr["color"];
+	    if ( !s.isEmpty() ) {
+		format.col.setNamedColor( s );
+		format.linkColor = FALSE;
+	    }
+	}
+	if ( attr.contains("face") ) {
+	    QString a = attr["face"];
+	    QString family = a.section( ',', 0, 0 );
+	    if ( !!family )
+		format.fn.setFamily( family );
+	}
+	if ( attr.contains("size") ) {
+	    QString a = attr["size"];
+	    int n = a.toInt();
+	    if ( a[0] == '+' || a[0] == '-' )
+		n += 3;
+	    format.logicalFontSize = n;
+	    if ( format.usePixelSizes )
+		format.fn.setPixelSize( format.stdSize );
+	    else
+		format.fn.setPointSize( format.stdSize );
+	    style->styleSheet()->scaleFont( format.fn, format.logicalFontSize );
+	}
+    }
+    if ( attr.contains("style" ) ) {
+	QString a = attr["style"];
+	for ( int s = 0; s < a.contains(';')+1; s++ ) {
+	    QString style = a.section( ';', s, s );
+	    if ( style.startsWith("font-size:" ) && style.endsWith("pt") ) {
+		format.logicalFontSize = 0;
+		int size = int( scaleFontsFactor * style.mid( 10, style.length() - 12 ).toDouble() );
+		format.setPointSize( size );
+	    } else if ( style.startsWith("font-style:" ) ) {
+		QString s = style.mid( 11 ).stripWhiteSpace();
+		if ( s == "normal" )
+		    format.fn.setItalic( FALSE );
+		else if ( s == "italic" || s == "oblique" )
+		    format.fn.setItalic( TRUE );
+	    } else if ( style.startsWith("font-weight:" ) ) {
+		QString s = style.mid( 12 );
+		bool ok = TRUE;
+		int n = s.toInt( &ok );
+		if ( ok )
+		    format.fn.setWeight( n/8 );
+	    } else if ( style.startsWith("font-family:" ) ) {
+		QString family = style.mid(12).section(',',0,0);
+		family.replace( '\"', ' ' );
+		family.replace( '\'', ' ' );
+		family = family.stripWhiteSpace();
+		format.fn.setFamily( family );
+	    } else if ( style.startsWith("text-decoration:" ) ) {
+		QString s = style.mid( 16 );
+		format.fn.setOverline( s.find("overline") != -1 );
+		format.fn.setStrikeOut( s.find("line-through") != -1 );
+		format.fn.setUnderline( s.find("underline") != -1 );
+	    } else if ( style.startsWith("vertical-align:" ) ) {
+		QString s = style.mid( 15 ).stripWhiteSpace();
+		if ( s == "sub" )
+		    format.setVAlign( QTextFormat::AlignSubScript );
+		else if ( s == "super" )
+		    format.setVAlign( QTextFormat::AlignSuperScript );
+		else
+		    format.setVAlign( QTextFormat::AlignNormal );
+	    } else if ( style.startsWith("color:" ) ) {
+		format.col.setNamedColor( style.mid(6) );
+		format.linkColor = FALSE;
+	    }
+	}
+    }
+
+    format.update();
+    return format;
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+
+struct QPixmapInt
+{
+    QPixmapInt() : ref( 0 ) {}
+    QPixmap pm;
+    int	    ref;
+    Q_DUMMY_COMPARISON_OPERATOR(QPixmapInt)
+};
+
+static QMap<QString, QPixmapInt> *pixmap_map = 0;
+
+QTextImage::QTextImage( QTextDocument *p, const QMap<QString, QString> &attr, const QString& context,
+			QMimeSourceFactory &factory )
+    : QTextCustomItem( p )
+{
+    width = height = 0;
+    if ( attr.contains("width") )
+	width = attr["width"].toInt();
+    if ( attr.contains("height") )
+	height = attr["height"].toInt();
+
+    reg = 0;
+    QString imageName = attr["src"];
+
+    if (!imageName)
+	imageName = attr["source"];
+
+    if ( !imageName.isEmpty() ) {
+	imgId = QString( "%1,%2,%3,%4" ).arg( imageName ).arg( width ).arg( height ).arg( (ulong)&factory );
+	if ( !pixmap_map )
+	    pixmap_map = new QMap<QString, QPixmapInt>;
+	if ( pixmap_map->contains( imgId ) ) {
+	    QPixmapInt& pmi = pixmap_map->operator[](imgId);
+	    pm = pmi.pm;
+	    pmi.ref++;
+	    width = pm.width();
+	    height = pm.height();
+	} else {
+	    QImage img;
+	    const QMimeSource* m =
+		factory.data( imageName, context );
+	    if ( !m ) {
+		qWarning("QTextImage: no mimesource for %s", imageName.latin1() );
+	    }
+	    else {
+		if ( !QImageDrag::decode( m, img ) ) {
+		    qWarning("QTextImage: cannot decode %s", imageName.latin1() );
+		}
+	    }
+
+	    if ( !img.isNull() ) {
+		if ( width == 0 ) {
+		    width = img.width();
+		    if ( height != 0 ) {
+			width = img.width() * height / img.height();
+		    }
+		}
+		if ( height == 0 ) {
+		    height = img.height();
+		    if ( width != img.width() ) {
+			height = img.height() * width / img.width();
+		    }
+		}
+		if ( img.width() != width || img.height() != height ){
+#ifndef QT_NO_IMAGE_SMOOTHSCALE
+		    img = img.smoothScale(width, height);
+#endif
+		    width = img.width();
+		    height = img.height();
+		}
+		pm.convertFromImage( img );
+	    }
+	    if ( !pm.isNull() ) {
+		QPixmapInt& pmi = pixmap_map->operator[](imgId);
+		pmi.pm = pm;
+		pmi.ref++;
+	    }
+	}
+	if ( pm.mask() ) {
+	    QRegion mask( *pm.mask() );
+	    QRegion all( 0, 0, pm.width(), pm.height() );
+	    reg = new QRegion( all.subtract( mask ) );
+	}
+    }
+
+    if ( pm.isNull() && (width*height)==0 )
+	width = height = 50;
+
+    place = PlaceInline;
+    if ( attr["align"] == "left" )
+	place = PlaceLeft;
+    else if ( attr["align"] == "right" )
+	place = PlaceRight;
+
+    tmpwidth = width;
+    tmpheight = height;
+
+    attributes = attr;
+}
+
+QTextImage::~QTextImage()
+{
+    if ( pixmap_map && pixmap_map->contains( imgId ) ) {
+	QPixmapInt& pmi = pixmap_map->operator[](imgId);
+	pmi.ref--;
+	if ( !pmi.ref ) {
+	    pixmap_map->remove( imgId );
+	    if ( pixmap_map->isEmpty() ) {
+		delete pixmap_map;
+		pixmap_map = 0;
+	    }
+	}
+    }
+    delete reg;
+}
+
+QString QTextImage::richText() const
+{
+    QString s;
+    s += "<img ";
+    QMap<QString, QString>::ConstIterator it = attributes.begin();
+    for ( ; it != attributes.end(); ++it ) {
+	s += it.key() + "=";
+	if ( (*it).find( ' ' ) != -1 )
+	    s += "\"" + *it + "\"" + " ";
+	else
+	    s += *it + " ";
+    }
+    s += ">";
+    return s;
+}
+
+void QTextImage::adjustToPainter( QPainter* p )
+{
+    width = scale( tmpwidth, p );
+    height = scale( tmpheight, p );
+}
+
+#if !defined(Q_WS_X11)
+#include <qbitmap.h>
+#include <qcleanuphandler.h>
+static QPixmap *qrt_selection = 0;
+static QSingleCleanupHandler<QPixmap> qrt_cleanup_pixmap;
+static void qrt_createSelectionPixmap( const QColorGroup &cg )
+{
+    qrt_selection = new QPixmap( 2, 2 );
+    qrt_cleanup_pixmap.set( &qrt_selection );
+    qrt_selection->fill( Qt::color0 );
+    QBitmap m( 2, 2 );
+    m.fill( Qt::color1 );
+    QPainter p( &m );
+    p.setPen( Qt::color0 );
+    for ( int j = 0; j < 2; ++j ) {
+	p.drawPoint( j % 2, j );
+    }
+    p.end();
+    qrt_selection->setMask( m );
+    qrt_selection->fill( cg.highlight() );
+}
+#endif
+
+void QTextImage::draw( QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected )
+{
+    if ( placement() != PlaceInline ) {
+	x = xpos;
+	y = ypos;
+    }
+
+    if ( pm.isNull() ) {
+	p->fillRect( x , y, width, height,  cg.dark() );
+	return;
+    }
+
+    if ( is_printer( p ) ) {
+	p->drawPixmap( QRect( x, y, width, height ), pm );
+	return;
+    }
+
+    if ( placement() != PlaceInline && !QRect( xpos, ypos, width, height ).intersects( QRect( cx, cy, cw, ch ) ) )
+	return;
+
+    if ( placement() == PlaceInline )
+	p->drawPixmap( x , y, pm );
+    else
+	p->drawPixmap( cx , cy, pm, cx - x, cy - y, cw, ch );
+
+    if ( selected && placement() == PlaceInline && is_printer( p ) ) {
+#if defined(Q_WS_X11)
+	p->fillRect( QRect( QPoint( x, y ), pm.size() ), QBrush( cg.highlight(), QBrush::Dense4Pattern) );
+#else // in WIN32 Dense4Pattern doesn't work correctly (transparency problem), so work around it
+	if ( !qrt_selection )
+	    qrt_createSelectionPixmap( cg );
+	p->drawTiledPixmap( x, y, pm.width(), pm.height(), *qrt_selection );
+#endif
+    }
+}
+
+void QTextHorizontalLine::adjustToPainter( QPainter* p )
+{
+    height = scale( tmpheight, p );
+}
+
+
+QTextHorizontalLine::QTextHorizontalLine( QTextDocument *p, const QMap<QString, QString> &attr,
+					  const QString &,
+					  QMimeSourceFactory & )
+    : QTextCustomItem( p )
+{
+    height = tmpheight = 8;
+    if ( attr.find( "color" ) != attr.end() )
+	color = QColor( *attr.find( "color" ) );
+    shade = attr.find( "noshade" ) == attr.end();
+}
+
+QTextHorizontalLine::~QTextHorizontalLine()
+{
+}
+
+QString QTextHorizontalLine::richText() const
+{
+    return "<hr>";
+}
+
+void QTextHorizontalLine::draw( QPainter* p, int x, int y, int , int , int , int , const QColorGroup& cg, bool selected )
+{
+    QRect r( x, y, width, height);
+    if ( is_printer( p ) || !shade ) {
+	QPen oldPen = p->pen();
+	if ( !color.isValid() )
+	    p->setPen( QPen( cg.text(), is_printer( p ) ? height/8 : QMAX( 2, height/4 ) ) );
+	else
+	    p->setPen( QPen( color, is_printer( p ) ? height/8 : QMAX( 2, height/4 ) ) );
+	p->drawLine( r.left()-1, y + height / 2, r.right() + 1, y + height / 2 );
+	p->setPen( oldPen );
+    } else {
+	QColorGroup g( cg );
+	if ( color.isValid() )
+	    g.setColor( QColorGroup::Dark, color );
+	if ( selected )
+	    p->fillRect( r, g.highlight() );
+	qDrawShadeLine( p, r.left() - 1, y + height / 2, r.right() + 1, y + height / 2, g, TRUE, height / 8 );
+    }
+}
+#endif //QT_NO_TEXTCUSTOMITEM
+
+/*****************************************************************/
+// Small set of utility functions to make the parser a bit simpler
+//
+
+bool QTextDocument::hasPrefix(const QChar* doc, int length, int pos, QChar c)
+{
+    if ( pos + 1 > length )
+	return FALSE;
+    return doc[ pos ].lower() == c.lower();
+}
+
+bool QTextDocument::hasPrefix( const QChar* doc, int length, int pos, const QString& s )
+{
+    if ( pos + (int) s.length() > length )
+	return FALSE;
+    for ( int i = 0; i < (int)s.length(); i++ ) {
+	if ( doc[ pos + i ].lower() != s[ i ].lower() )
+	    return FALSE;
+    }
+    return TRUE;
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+static bool qt_is_cell_in_use( QPtrList<QTextTableCell>& cells, int row, int col )
+{
+    for ( QTextTableCell* c = cells.first(); c; c = cells.next() ) {
+	if ( row >= c->row() && row < c->row() + c->rowspan()
+	     && col >= c->column() && col < c->column() + c->colspan() )
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+QTextCustomItem* QTextDocument::parseTable( const QMap<QString, QString> &attr, const QTextFormat &fmt,
+					    const QChar* doc, int length, int& pos, QTextParagraph *curpar )
+{
+
+    QTextTable* table = new QTextTable( this, attr );
+    int row = -1;
+    int col = -1;
+
+    QString rowbgcolor;
+    QString rowalign;
+    QString tablebgcolor = attr["bgcolor"];
+
+    QPtrList<QTextTableCell> multicells;
+
+    QString tagname;
+    (void) eatSpace(doc, length, pos);
+    while ( pos < length) {
+	if (hasPrefix(doc, length, pos, QChar('<')) ){
+	    if (hasPrefix(doc, length, pos+1, QChar('/'))) {
+		tagname = parseCloseTag( doc, length, pos );
+		if ( tagname == "table" ) {
+		    return table;
+		}
+	    } else {
+		QMap<QString, QString> attr2;
+		bool emptyTag = FALSE;
+		tagname = parseOpenTag( doc, length, pos, attr2, emptyTag );
+		if ( tagname == "tr" ) {
+		    rowbgcolor = attr2["bgcolor"];
+		    rowalign = attr2["align"];
+		    row++;
+		    col = -1;
+		}
+		else if ( tagname == "td" || tagname == "th" ) {
+		    col++;
+		    while ( qt_is_cell_in_use( multicells, row, col ) ) {
+			col++;
+		    }
+
+		    if ( row >= 0 && col >= 0 ) {
+			const QStyleSheetItem* s = sheet_->item(tagname);
+			if ( !attr2.contains("bgcolor") ) {
+			    if (!rowbgcolor.isEmpty() )
+				attr2["bgcolor"] = rowbgcolor;
+			    else if (!tablebgcolor.isEmpty() )
+				attr2["bgcolor"] = tablebgcolor;
+			}
+			if ( !attr2.contains("align") ) {
+			    if (!rowalign.isEmpty() )
+				attr2["align"] = rowalign;
+			}
+
+			// extract the cell contents
+			int end = pos;
+			while ( end < length
+				&& !hasPrefix( doc, length, end, "</td")
+				&& !hasPrefix( doc, length, end, "<td")
+				&& !hasPrefix( doc, length, end, "</th")
+				&& !hasPrefix( doc, length, end, "<th")
+				&& !hasPrefix( doc, length, end, "<td")
+				&& !hasPrefix( doc, length, end, "</tr")
+				&& !hasPrefix( doc, length, end, "<tr")
+				&& !hasPrefix( doc, length, end, "</table") ) {
+			    if ( hasPrefix( doc, length, end, "<table" ) ) { // nested table
+				int nested = 1;
+				++end;
+				while ( end < length && nested != 0 ) {
+				    if ( hasPrefix( doc, length, end, "</table" ) )
+					nested--;
+				    if ( hasPrefix( doc, length, end, "<table" ) )
+					nested++;
+				    end++;
+				}
+			    }
+			    end++;
+			}
+			QTextTableCell* cell  = new QTextTableCell( table, row, col,
+					    attr2, s, fmt.makeTextFormat( s, attr2, scaleFontsFactor ),
+					    contxt, *factory_, sheet_,
+					    QConstString( doc + pos, end - pos ).string() );
+			cell->richText()->parentPar = curpar;
+			if ( cell->colspan() > 1 || cell->rowspan() > 1 )
+			    multicells.append( cell );
+			col += cell->colspan()-1;
+			pos = end;
+		    }
+		}
+	    }
+
+	} else {
+	    ++pos;
+	}
+    }
+    return table;
+}
+#endif // QT_NO_TEXTCUSTOMITEM
+
+bool QTextDocument::eatSpace(const QChar* doc, int length, int& pos, bool includeNbsp )
+{
+    int old_pos = pos;
+    while (pos < length && doc[pos].isSpace() && ( includeNbsp || (doc[pos] != QChar::nbsp ) ) )
+	pos++;
+    return old_pos < pos;
+}
+
+bool QTextDocument::eat(const QChar* doc, int length, int& pos, QChar c)
+{
+    bool ok = pos < length && doc[pos] == c;
+    if ( ok )
+	pos++;
+    return ok;
+}
+/*****************************************************************/
+
+struct Entity {
+    const char * name;
+    Q_UINT16 code;
+};
+
+static const Entity entitylist [] = {
+    { "AElig", 0x00c6 },
+    { "Aacute", 0x00c1 },
+    { "Acirc", 0x00c2 },
+    { "Agrave", 0x00c0 },
+    { "Alpha", 0x0391 },
+    { "AMP", 38 },
+    { "Aring", 0x00c5 },
+    { "Atilde", 0x00c3 },
+    { "Auml", 0x00c4 },
+    { "Beta", 0x0392 },
+    { "Ccedil", 0x00c7 },
+    { "Chi", 0x03a7 },
+    { "Dagger", 0x2021 },
+    { "Delta", 0x0394 },
+    { "ETH", 0x00d0 },
+    { "Eacute", 0x00c9 },
+    { "Ecirc", 0x00ca },
+    { "Egrave", 0x00c8 },
+    { "Epsilon", 0x0395 },
+    { "Eta", 0x0397 },
+    { "Euml", 0x00cb },
+    { "Gamma", 0x0393 },
+    { "GT", 62 },
+    { "Iacute", 0x00cd },
+    { "Icirc", 0x00ce },
+    { "Igrave", 0x00cc },
+    { "Iota", 0x0399 },
+    { "Iuml", 0x00cf },
+    { "Kappa", 0x039a },
+    { "Lambda", 0x039b },
+    { "LT", 60 },
+    { "Mu", 0x039c },
+    { "Ntilde", 0x00d1 },
+    { "Nu", 0x039d },
+    { "OElig", 0x0152 },
+    { "Oacute", 0x00d3 },
+    { "Ocirc", 0x00d4 },
+    { "Ograve", 0x00d2 },
+    { "Omega", 0x03a9 },
+    { "Omicron", 0x039f },
+    { "Oslash", 0x00d8 },
+    { "Otilde", 0x00d5 },
+    { "Ouml", 0x00d6 },
+    { "Phi", 0x03a6 },
+    { "Pi", 0x03a0 },
+    { "Prime", 0x2033 },
+    { "Psi", 0x03a8 },
+    { "QUOT", 34 },
+    { "Rho", 0x03a1 },
+    { "Scaron", 0x0160 },
+    { "Sigma", 0x03a3 },
+    { "THORN", 0x00de },
+    { "Tau", 0x03a4 },
+    { "Theta", 0x0398 },
+    { "Uacute", 0x00da },
+    { "Ucirc", 0x00db },
+    { "Ugrave", 0x00d9 },
+    { "Upsilon", 0x03a5 },
+    { "Uuml", 0x00dc },
+    { "Xi", 0x039e },
+    { "Yacute", 0x00dd },
+    { "Yuml", 0x0178 },
+    { "Zeta", 0x0396 },
+    { "aacute", 0x00e1 },
+    { "acirc", 0x00e2 },
+    { "acute", 0x00b4 },
+    { "aelig", 0x00e6 },
+    { "agrave", 0x00e0 },
+    { "alefsym", 0x2135 },
+    { "alpha", 0x03b1 },
+    { "amp", 38 },
+    { "and", 0x22a5 },
+    { "ang", 0x2220 },
+    { "apos", 0x0027 },
+    { "aring", 0x00e5 },
+    { "asymp", 0x2248 },
+    { "atilde", 0x00e3 },
+    { "auml", 0x00e4 },
+    { "bdquo", 0x201e },
+    { "beta", 0x03b2 },
+    { "brvbar", 0x00a6 },
+    { "bull", 0x2022 },
+    { "cap", 0x2229 },
+    { "ccedil", 0x00e7 },
+    { "cedil", 0x00b8 },
+    { "cent", 0x00a2 },
+    { "chi", 0x03c7 },
+    { "circ", 0x02c6 },
+    { "clubs", 0x2663 },
+    { "cong", 0x2245 },
+    { "copy", 0x00a9 },
+    { "crarr", 0x21b5 },
+    { "cup", 0x222a },
+    { "curren", 0x00a4 },
+    { "dArr", 0x21d3 },
+    { "dagger", 0x2020 },
+    { "darr", 0x2193 },
+    { "deg", 0x00b0 },
+    { "delta", 0x03b4 },
+    { "diams", 0x2666 },
+    { "divide", 0x00f7 },
+    { "eacute", 0x00e9 },
+    { "ecirc", 0x00ea },
+    { "egrave", 0x00e8 },
+    { "empty", 0x2205 },
+    { "emsp", 0x2003 },
+    { "ensp", 0x2002 },
+    { "epsilon", 0x03b5 },
+    { "equiv", 0x2261 },
+    { "eta", 0x03b7 },
+    { "eth", 0x00f0 },
+    { "euml", 0x00eb },
+    { "euro", 0x20ac },
+    { "exist", 0x2203 },
+    { "fnof", 0x0192 },
+    { "forall", 0x2200 },
+    { "frac12", 0x00bd },
+    { "frac14", 0x00bc },
+    { "frac34", 0x00be },
+    { "frasl", 0x2044 },
+    { "gamma", 0x03b3 },
+    { "ge", 0x2265 },
+    { "gt", 62 },
+    { "hArr", 0x21d4 },
+    { "harr", 0x2194 },
+    { "hearts", 0x2665 },
+    { "hellip", 0x2026 },
+    { "iacute", 0x00ed },
+    { "icirc", 0x00ee },
+    { "iexcl", 0x00a1 },
+    { "igrave", 0x00ec },
+    { "image", 0x2111 },
+    { "infin", 0x221e },
+    { "int", 0x222b },
+    { "iota", 0x03b9 },
+    { "iquest", 0x00bf },
+    { "isin", 0x2208 },
+    { "iuml", 0x00ef },
+    { "kappa", 0x03ba },
+    { "lArr", 0x21d0 },
+    { "lambda", 0x03bb },
+    { "lang", 0x2329 },
+    { "laquo", 0x00ab },
+    { "larr", 0x2190 },
+    { "lceil", 0x2308 },
+    { "ldquo", 0x201c },
+    { "le", 0x2264 },
+    { "lfloor", 0x230a },
+    { "lowast", 0x2217 },
+    { "loz", 0x25ca },
+    { "lrm", 0x200e },
+    { "lsaquo", 0x2039 },
+    { "lsquo", 0x2018 },
+    { "lt", 60 },
+    { "macr", 0x00af },
+    { "mdash", 0x2014 },
+    { "micro", 0x00b5 },
+    { "middot", 0x00b7 },
+    { "minus", 0x2212 },
+    { "mu", 0x03bc },
+    { "nabla", 0x2207 },
+    { "nbsp", 0x00a0 },
+    { "ndash", 0x2013 },
+    { "ne", 0x2260 },
+    { "ni", 0x220b },
+    { "not", 0x00ac },
+    { "notin", 0x2209 },
+    { "nsub", 0x2284 },
+    { "ntilde", 0x00f1 },
+    { "nu", 0x03bd },
+    { "oacute", 0x00f3 },
+    { "ocirc", 0x00f4 },
+    { "oelig", 0x0153 },
+    { "ograve", 0x00f2 },
+    { "oline", 0x203e },
+    { "omega", 0x03c9 },
+    { "omicron", 0x03bf },
+    { "oplus", 0x2295 },
+    { "or", 0x22a6 },
+    { "ordf", 0x00aa },
+    { "ordm", 0x00ba },
+    { "oslash", 0x00f8 },
+    { "otilde", 0x00f5 },
+    { "otimes", 0x2297 },
+    { "ouml", 0x00f6 },
+    { "para", 0x00b6 },
+    { "part", 0x2202 },
+    { "percnt", 0x0025 },
+    { "permil", 0x2030 },
+    { "perp", 0x22a5 },
+    { "phi", 0x03c6 },
+    { "pi", 0x03c0 },
+    { "piv", 0x03d6 },
+    { "plusmn", 0x00b1 },
+    { "pound", 0x00a3 },
+    { "prime", 0x2032 },
+    { "prod", 0x220f },
+    { "prop", 0x221d },
+    { "psi", 0x03c8 },
+    { "quot", 34 },
+    { "rArr", 0x21d2 },
+    { "radic", 0x221a },
+    { "rang", 0x232a },
+    { "raquo", 0x00bb },
+    { "rarr", 0x2192 },
+    { "rceil", 0x2309 },
+    { "rdquo", 0x201d },
+    { "real", 0x211c },
+    { "reg", 0x00ae },
+    { "rfloor", 0x230b },
+    { "rho", 0x03c1 },
+    { "rlm", 0x200f },
+    { "rsaquo", 0x203a },
+    { "rsquo", 0x2019 },
+    { "sbquo", 0x201a },
+    { "scaron", 0x0161 },
+    { "sdot", 0x22c5 },
+    { "sect", 0x00a7 },
+    { "shy", 0x00ad },
+    { "sigma", 0x03c3 },
+    { "sigmaf", 0x03c2 },
+    { "sim", 0x223c },
+    { "spades", 0x2660 },
+    { "sub", 0x2282 },
+    { "sube", 0x2286 },
+    { "sum", 0x2211 },
+    { "sup1", 0x00b9 },
+    { "sup2", 0x00b2 },
+    { "sup3", 0x00b3 },
+    { "sup", 0x2283 },
+    { "supe", 0x2287 },
+    { "szlig", 0x00df },
+    { "tau", 0x03c4 },
+    { "there4", 0x2234 },
+    { "theta", 0x03b8 },
+    { "thetasym", 0x03d1 },
+    { "thinsp", 0x2009 },
+    { "thorn", 0x00fe },
+    { "tilde", 0x02dc },
+    { "times", 0x00d7 },
+    { "trade", 0x2122 },
+    { "uArr", 0x21d1 },
+    { "uacute", 0x00fa },
+    { "uarr", 0x2191 },
+    { "ucirc", 0x00fb },
+    { "ugrave", 0x00f9 },
+    { "uml", 0x00a8 },
+    { "upsih", 0x03d2 },
+    { "upsilon", 0x03c5 },
+    { "uuml", 0x00fc },
+    { "weierp", 0x2118 },
+    { "xi", 0x03be },
+    { "yacute", 0x00fd },
+    { "yen", 0x00a5 },
+    { "yuml", 0x00ff },
+    { "zeta", 0x03b6 },
+    { "zwj", 0x200d },
+    { "zwnj", 0x200c },
+    { "", 0x0000 }
+};
+
+
+
+
+
+static QMap<QString, QChar> *html_map = 0;
+static void qt_cleanup_html_map()
+{
+    delete html_map;
+    html_map = 0;
+}
+
+static QMap<QString, QChar> *htmlMap()
+{
+    if ( !html_map ) {
+	html_map = new QMap<QString, QChar>;
+	qAddPostRoutine( qt_cleanup_html_map );
+
+	const Entity *ent = entitylist;
+	while( ent->code ) {
+	    html_map->insert( ent->name, QChar(ent->code) );
+	    ent++;
+	}
+    }
+    return html_map;
+}
+
+QChar QTextDocument::parseHTMLSpecialChar(const QChar* doc, int length, int& pos)
+{
+    QString s;
+    pos++;
+    int recoverpos = pos;
+    while ( pos < length && doc[pos] != ';' && !doc[pos].isSpace() && pos < recoverpos + 8 ) {
+	s += doc[pos];
+	pos++;
+    }
+    if (doc[pos] != ';' && !doc[pos].isSpace() ) {
+	pos = recoverpos;
+	return '&';
+    }
+    pos++;
+
+    if ( s.length() > 1 && s[0] == '#') {
+        int off = 1;
+        int base = 10;
+        if (s[1] == 'x') {
+            off = 2;
+            base = 16;
+        }
+        bool ok;
+	int num = s.mid(off).toInt(&ok, base);
+	if ( num == 151 ) // ### hack for designer manual
+	    return '-';
+        if (ok)
+            return num;
+    } else {
+        QMap<QString, QChar>::Iterator it = htmlMap()->find(s);
+        if ( it != htmlMap()->end() ) {
+            return *it;
+        }
+    }
+
+    pos = recoverpos;
+    return '&';
+}
+
+QString QTextDocument::parseWord(const QChar* doc, int length, int& pos, bool lower)
+{
+    QString s;
+
+    if (doc[pos] == '"') {
+	pos++;
+	while ( pos < length && doc[pos] != '"' ) {
+	    if ( doc[pos] == '&' ) {
+		s += parseHTMLSpecialChar( doc, length, pos );
+	    } else {
+		s += doc[pos];
+		pos++;
+	    }
+	}
+	eat(doc, length, pos, '"');
+    } else if (doc[pos] == '\'') {
+	pos++;
+	while ( pos < length  && doc[pos] != '\'' ) {
+	    s += doc[pos];
+	    pos++;
+	}
+	eat(doc, length, pos, '\'');
+    } else {
+	static QString term = QString::fromLatin1("/>");
+	while ( pos < length
+		&& doc[pos] != '>'
+		&& !hasPrefix(doc, length, pos, term)
+		&& doc[pos] != '<'
+		&& doc[pos] != '='
+		&& !doc[pos].isSpace() )
+	{
+	    if ( doc[pos] == '&' ) {
+		s += parseHTMLSpecialChar( doc, length, pos );
+	    } else {
+		s += doc[pos];
+		pos++;
+	    }
+	}
+	if (lower)
+	    s = s.lower();
+    }
+    return s;
+}
+
+QChar QTextDocument::parseChar(const QChar* doc, int length, int& pos, QStyleSheetItem::WhiteSpaceMode wsm )
+{
+    if ( pos >=  length )
+	return QChar::null;
+
+    QChar c = doc[pos++];
+
+    if (c == '<' )
+	return QChar::null;
+
+    if ( c.isSpace() && c != QChar::nbsp ) {
+	if ( wsm == QStyleSheetItem::WhiteSpacePre ) {
+	    if ( c == '\n' )
+		return QChar_linesep;
+	    else
+		return c;
+	} else { // non-pre mode: collapse whitespace except nbsp
+	    while ( pos< length &&
+		    doc[pos].isSpace()  && doc[pos] != QChar::nbsp )
+		pos++;
+	    return ' ';
+	}
+    }
+    else if ( c == '&' )
+	return parseHTMLSpecialChar( doc, length, --pos );
+    else
+	return c;
+}
+
+QString QTextDocument::parseOpenTag(const QChar* doc, int length, int& pos,
+				  QMap<QString, QString> &attr, bool& emptyTag)
+{
+    emptyTag = FALSE;
+    pos++;
+    if ( hasPrefix(doc, length, pos, '!') ) {
+	if ( hasPrefix( doc, length, pos+1, "--")) {
+	    pos += 3;
+	    // eat comments
+	    QString pref = QString::fromLatin1("-->");
+	    while ( !hasPrefix(doc, length, pos, pref ) && pos < length )
+		pos++;
+	    if ( hasPrefix(doc, length, pos, pref ) ) {
+		pos += 3;
+		eatSpace(doc, length, pos, TRUE);
+	    }
+	    emptyTag = TRUE;
+	    return QString::null;
+	}
+	else {
+	    // eat strange internal tags
+	    while ( !hasPrefix(doc, length, pos, '>') && pos < length )
+		pos++;
+	    if ( hasPrefix(doc, length, pos, '>') ) {
+		pos++;
+		eatSpace(doc, length, pos, TRUE);
+	    }
+	    return QString::null;
+	}
+    }
+
+    QString tag = parseWord(doc, length, pos );
+    eatSpace(doc, length, pos, TRUE);
+    static QString term = QString::fromLatin1("/>");
+    static QString s_TRUE = QString::fromLatin1("TRUE");
+
+    while (doc[pos] != '>' && ! (emptyTag = hasPrefix(doc, length, pos, term) )) {
+	QString key = parseWord(doc, length, pos );
+	eatSpace(doc, length, pos, TRUE);
+	if ( key.isEmpty()) {
+	    // error recovery
+	    while ( pos < length && doc[pos] != '>' )
+		pos++;
+	    break;
+	}
+	QString value;
+	if (hasPrefix(doc, length, pos, '=') ){
+	    pos++;
+	    eatSpace(doc, length, pos);
+	    value = parseWord(doc, length, pos, FALSE);
+	}
+	else
+	    value = s_TRUE;
+	attr.insert(key.lower(), value );
+	eatSpace(doc, length, pos, TRUE);
+    }
+
+    if (emptyTag) {
+	eat(doc, length, pos, '/');
+	eat(doc, length, pos, '>');
+    }
+    else
+	eat(doc, length, pos, '>');
+
+    return tag;
+}
+
+QString QTextDocument::parseCloseTag( const QChar* doc, int length, int& pos )
+{
+    pos++;
+    pos++;
+    QString tag = parseWord(doc, length, pos );
+    eatSpace(doc, length, pos, TRUE);
+    eat(doc, length, pos, '>');
+    return tag;
+}
+
+QTextFlow::QTextFlow()
+{
+    w = pagesize = 0;
+}
+
+QTextFlow::~QTextFlow()
+{
+    clear();
+}
+
+void QTextFlow::clear()
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    leftItems.setAutoDelete( TRUE );
+    rightItems.setAutoDelete( TRUE );
+    leftItems.clear();
+    rightItems.clear();
+    leftItems.setAutoDelete( FALSE );
+    rightItems.setAutoDelete( FALSE );
+#endif
+}
+
+void QTextFlow::setWidth( int width )
+{
+    w = width;
+}
+
+int QTextFlow::adjustLMargin( int yp, int, int margin, int space )
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    for ( QTextCustomItem* item = leftItems.first(); item; item = leftItems.next() ) {
+	if ( item->ypos == -1 )
+	    continue;
+	if ( yp >= item->ypos && yp < item->ypos + item->height )
+	    margin = QMAX( margin, item->xpos + item->width + space );
+    }
+#endif
+    return margin;
+}
+
+int QTextFlow::adjustRMargin( int yp, int, int margin, int space )
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    for ( QTextCustomItem* item = rightItems.first(); item; item = rightItems.next() ) {
+	if ( item->ypos == -1 )
+	    continue;
+	if ( yp >= item->ypos && yp < item->ypos + item->height )
+	    margin = QMAX( margin, w - item->xpos - space );
+    }
+#endif
+    return margin;
+}
+
+
+int QTextFlow::adjustFlow( int y, int /*w*/, int h )
+{
+    if ( pagesize > 0 ) { // check pages
+	int yinpage = y % pagesize;
+	if ( yinpage <= border_tolerance )
+	    return border_tolerance - yinpage;
+	else
+	    if ( yinpage + h > pagesize - border_tolerance )
+		return ( pagesize - yinpage ) + border_tolerance;
+    }
+    return 0;
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+void QTextFlow::unregisterFloatingItem( QTextCustomItem* item )
+{
+    leftItems.removeRef( item );
+    rightItems.removeRef( item );
+}
+
+void QTextFlow::registerFloatingItem( QTextCustomItem* item )
+{
+    if ( item->placement() == QTextCustomItem::PlaceRight ) {
+	if ( !rightItems.contains( item ) )
+	    rightItems.append( item );
+    } else if ( item->placement() == QTextCustomItem::PlaceLeft &&
+		!leftItems.contains( item ) ) {
+	leftItems.append( item );
+    }
+}
+#endif // QT_NO_TEXTCUSTOMITEM
+
+QRect QTextFlow::boundingRect() const
+{
+    QRect br;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QPtrListIterator<QTextCustomItem> l( leftItems );
+    while( l.current() ) {
+	br = br.unite( l.current()->geometry() );
+	++l;
+    }
+    QPtrListIterator<QTextCustomItem> r( rightItems );
+    while( r.current() ) {
+	br = br.unite( r.current()->geometry() );
+	++r;
+    }
+#endif
+    return br;
+}
+
+
+void QTextFlow::drawFloatingItems( QPainter* p, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected )
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextCustomItem *item;
+    for ( item = leftItems.first(); item; item = leftItems.next() ) {
+	if ( item->xpos == -1 || item->ypos == -1 )
+	    continue;
+	item->draw( p, item->xpos, item->ypos, cx, cy, cw, ch, cg, selected );
+    }
+
+    for ( item = rightItems.first(); item; item = rightItems.next() ) {
+	if ( item->xpos == -1 || item->ypos == -1 )
+	    continue;
+	item->draw( p, item->xpos, item->ypos, cx, cy, cw, ch, cg, selected );
+    }
+#endif
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+void QTextCustomItem::pageBreak( int /*y*/ , QTextFlow* /*flow*/ )
+{
+}
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+QTextTable::QTextTable( QTextDocument *p, const QMap<QString, QString> & attr  )
+    : QTextCustomItem( p )
+{
+    cells.setAutoDelete( FALSE );
+    cellspacing = 2;
+    if ( attr.contains("cellspacing") )
+	cellspacing = attr["cellspacing"].toInt();
+    cellpadding = 1;
+    if ( attr.contains("cellpadding") )
+	cellpadding = attr["cellpadding"].toInt();
+    border = innerborder = 0;
+    if ( attr.contains("border" ) ) {
+	QString s( attr["border"] );
+	if ( s == "TRUE" )
+	    border = 1;
+	else
+	    border = attr["border"].toInt();
+    }
+    us_b = border;
+
+    innerborder = us_ib = border ? 1 : 0;
+
+    if ( border )
+	cellspacing += 2;
+
+    us_ib = innerborder;
+    us_cs = cellspacing;
+    us_cp = cellpadding;
+    outerborder = cellspacing + border;
+    us_ob = outerborder;
+    layout = new QGridLayout( 1, 1, cellspacing );
+
+    fixwidth = 0;
+    stretch = 0;
+    if ( attr.contains("width") ) {
+	bool b;
+	QString s( attr["width"] );
+	int w = s.toInt( &b );
+	if ( b ) {
+	    fixwidth = w;
+	} else {
+	    s = s.stripWhiteSpace();
+	    if ( s.length() > 1 && s[ (int)s.length()-1 ] == '%' )
+		stretch = s.left( s.length()-1).toInt();
+	}
+    }
+    us_fixwidth = fixwidth;
+
+    place = PlaceInline;
+    if ( attr["align"] == "left" )
+	place = PlaceLeft;
+    else if ( attr["align"] == "right" )
+	place = PlaceRight;
+    cachewidth = 0;
+    attributes = attr;
+    pageBreakFor = -1;
+}
+
+QTextTable::~QTextTable()
+{
+    delete layout;
+}
+
+QString QTextTable::richText() const
+{
+    QString s;
+    s = "<table ";
+    QMap<QString, QString>::ConstIterator it = attributes.begin();
+    for ( ; it != attributes.end(); ++it )
+	s += it.key() + "=" + *it + " ";
+    s += ">\n";
+
+    int lastRow = -1;
+    bool needEnd = FALSE;
+    QPtrListIterator<QTextTableCell> it2( cells );
+    while ( it2.current() ) {
+	QTextTableCell *cell = it2.current();
+	++it2;
+	if ( lastRow != cell->row() ) {
+	    if ( lastRow != -1 )
+		s += "</tr>\n";
+	    s += "<tr>";
+	    lastRow = cell->row();
+	    needEnd = TRUE;
+	}
+	s += "<td";
+	it = cell->attributes.begin();
+	for ( ; it != cell->attributes.end(); ++it )
+	    s += " " + it.key() + "=" + *it;
+	s += ">";
+	s += cell->richText()->richText();
+	s += "</td>";
+    }
+    if ( needEnd )
+	s += "</tr>\n";
+    s += "</table>\n";
+    return s;
+}
+
+void QTextTable::setParagraph(QTextParagraph *p)
+{
+    for ( QTextTableCell* cell = cells.first(); cell; cell = cells.next() )
+	cell->richText()->parentPar = p;
+    QTextCustomItem::setParagraph(p);
+}
+
+void QTextTable::adjustToPainter( QPainter* p )
+{
+    cellspacing = scale( us_cs, p );
+    cellpadding = scale( us_cp, p );
+    border = scale( us_b , p );
+    innerborder = scale( us_ib, p );
+    outerborder = scale( us_ob ,p );
+    fixwidth = scale( us_fixwidth, p);
+    width = 0;
+    cachewidth = 0;
+    for ( QTextTableCell* cell = cells.first(); cell; cell = cells.next() )
+	cell->adjustToPainter( p );
+}
+
+void QTextTable::adjustCells( int y , int shift )
+{
+    QPtrListIterator<QTextTableCell> it( cells );
+    QTextTableCell* cell;
+    bool enlarge = FALSE;
+    while ( ( cell = it.current() ) ) {
+	++it;
+	QRect r = cell->geometry();
+	if ( y <= r.top() ) {
+	    r.moveBy(0, shift );
+	    cell->setGeometry( r );
+	    enlarge = TRUE;
+	} else if ( y <= r.bottom() ) {
+	    r.rBottom() += shift;
+	    cell->setGeometry( r );
+	    enlarge = TRUE;
+	}
+    }
+    if ( enlarge )
+	height += shift;
+}
+
+void QTextTable::pageBreak( int  yt, QTextFlow* flow )
+{
+    if ( flow->pageSize() <= 0 )
+        return;
+    if ( layout && pageBreakFor > 0 && pageBreakFor != yt ) {
+	layout->invalidate();
+	int h = layout->heightForWidth( width-2*outerborder );
+	layout->setGeometry( QRect(0, 0, width-2*outerborder, h)  );
+	height = layout->geometry().height()+2*outerborder;
+    }
+    pageBreakFor = yt;
+    QPtrListIterator<QTextTableCell> it( cells );
+    QTextTableCell* cell;
+    while ( ( cell = it.current() ) ) {
+	++it;
+	int y = yt + outerborder + cell->geometry().y();
+	int shift = flow->adjustFlow( y - cellspacing, width, cell->richText()->height() + 2*cellspacing );
+	adjustCells( y - outerborder - yt, shift );
+    }
+}
+
+
+void QTextTable::draw(QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected )
+{
+    if ( placement() != PlaceInline ) {
+	x = xpos;
+	y = ypos;
+    }
+
+    for (QTextTableCell* cell = cells.first(); cell; cell = cells.next() ) {
+	if ( cx < 0 && cy < 0 ||
+	     QRect( cx, cy, cw, ch ).intersects( QRect( x + outerborder + cell->geometry().x(),
+							y + outerborder + cell->geometry().y(),
+							cell->geometry().width(), cell->geometry().height() ) ) ) {
+	    cell->draw( p, x+outerborder, y+outerborder, cx, cy, cw, ch, cg, selected );
+	    if ( border ) {
+		QRect r( x+outerborder+cell->geometry().x() - innerborder,
+			 y+outerborder+cell->geometry().y() - innerborder,
+			 cell->geometry().width() + 2 * innerborder,
+			 cell->geometry().height() + 2 * innerborder );
+		if ( is_printer( p ) ) {
+		    QPen oldPen = p->pen();
+		    QRect r2 = r;
+		    r2.addCoords( innerborder/2, innerborder/2, -innerborder/2, -innerborder/2 );
+		    p->setPen( QPen( cg.text(), innerborder ) );
+		    p->drawRect( r2 );
+		    p->setPen( oldPen );
+		} else {
+		    int s =  QMAX( cellspacing-2*innerborder, 0);
+		    if ( s ) {
+			p->fillRect( r.left()-s, r.top(), s+1, r.height(), cg.button() );
+			p->fillRect( r.right(), r.top(), s+1, r.height(), cg.button() );
+			p->fillRect( r.left()-s, r.top()-s, r.width()+2*s, s, cg.button() );
+			p->fillRect( r.left()-s, r.bottom(), r.width()+2*s, s, cg.button() );
+		    }
+		    qDrawShadePanel( p, r, cg, TRUE, innerborder );
+		}
+	    }
+	}
+    }
+    if ( border ) {
+	QRect r ( x, y, width, height );
+	if ( is_printer( p ) ) {
+ 	    QRect r2 = r;
+ 	    r2.addCoords( border/2, border/2, -border/2, -border/2 );
+	    QPen oldPen = p->pen();
+	    p->setPen( QPen( cg.text(), border ) );
+	    p->drawRect( r2 );
+	    p->setPen( oldPen );
+	} else {
+	    int s = border+QMAX( cellspacing-2*innerborder, 0);
+	    if ( s ) {
+		p->fillRect( r.left(), r.top(), s, r.height(), cg.button() );
+		p->fillRect( r.right()-s, r.top(), s, r.height(), cg.button() );
+		p->fillRect( r.left(), r.top(), r.width(), s, cg.button() );
+		p->fillRect( r.left(), r.bottom()-s, r.width(), s, cg.button() );
+	    }
+	    qDrawShadePanel( p, r, cg, FALSE, border );
+	}
+    }
+
+}
+
+int QTextTable::minimumWidth() const
+{
+    return fixwidth ? fixwidth : ((layout ? layout->minimumSize().width() : 0) + 2 * outerborder);
+}
+
+void QTextTable::resize( int nwidth )
+{
+    if ( fixwidth && cachewidth != 0 )
+	return;
+    if ( nwidth == cachewidth )
+	return;
+
+
+    cachewidth = nwidth;
+    int w = nwidth;
+
+    format( w );
+
+    if ( stretch )
+	nwidth = nwidth * stretch / 100;
+
+    width = nwidth;
+    layout->invalidate();
+    int shw = layout->sizeHint().width() + 2*outerborder;
+    int mw = layout->minimumSize().width() + 2*outerborder;
+    if ( stretch )
+	width = QMAX( mw, nwidth );
+    else
+	width = QMAX( mw, QMIN( nwidth, shw ) );
+
+    if ( fixwidth )
+	width = fixwidth;
+
+    layout->invalidate();
+    mw = layout->minimumSize().width() + 2*outerborder;
+    width = QMAX( width, mw );
+
+    int h = layout->heightForWidth( width-2*outerborder );
+    layout->setGeometry( QRect(0, 0, width-2*outerborder, h)  );
+    height = layout->geometry().height()+2*outerborder;
+}
+
+void QTextTable::format( int w )
+{
+    for ( int i = 0; i < (int)cells.count(); ++i ) {
+	QTextTableCell *cell = cells.at( i );
+	QRect r = cell->geometry();
+	r.setWidth( w - 2*outerborder );
+	cell->setGeometry( r );
+    }
+}
+
+void QTextTable::addCell( QTextTableCell* cell )
+{
+    cells.append( cell );
+    layout->addMultiCell( cell, cell->row(), cell->row() + cell->rowspan()-1,
+			  cell->column(), cell->column() + cell->colspan()-1 );
+}
+
+bool QTextTable::enter( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, bool atEnd )
+{
+    currCell.remove( c );
+    if ( !atEnd )
+	return next( c, doc, parag, idx, ox, oy );
+    currCell.insert( c, cells.count() );
+    return prev( c, doc, parag, idx, ox, oy );
+}
+
+bool QTextTable::enterAt( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, const QPoint &pos )
+{
+    currCell.remove( c );
+    int lastCell = -1;
+    int lastY = -1;
+    int i;
+    for ( i = 0; i < (int)cells.count(); ++i ) {
+	QTextTableCell *cell = cells.at( i );
+	if ( !cell )
+	    continue;
+	QRect r( cell->geometry().x(),
+		 cell->geometry().y(),
+		 cell->geometry().width() + 2 * innerborder + 2 * outerborder,
+		 cell->geometry().height() + 2 * innerborder + 2 * outerborder );
+
+	if ( r.left() <= pos.x() && r.right() >= pos.x() ) {
+	    if ( cell->geometry().y() > lastY ) {
+		lastCell = i;
+		lastY = cell->geometry().y();
+	    }
+	    if ( r.top() <= pos.y() && r.bottom() >= pos.y() ) {
+		currCell.insert( c, i );
+		break;
+	    }
+	}
+    }
+    if ( i == (int) cells.count() )
+ 	return FALSE; // no cell found
+
+    if ( currCell.find( c ) == currCell.end() ) {
+	if ( lastY != -1 )
+	    currCell.insert( c, lastCell );
+	else
+	    return FALSE;
+    }
+
+    QTextTableCell *cell = cells.at( *currCell.find( c ) );
+    if ( !cell )
+	return FALSE;
+    doc = cell->richText();
+    parag = doc->firstParagraph();
+    idx = 0;
+    ox += cell->geometry().x() + cell->horizontalAlignmentOffset() + outerborder + parent->x();
+    oy += cell->geometry().y() + cell->verticalAlignmentOffset() + outerborder;
+    return TRUE;
+}
+
+bool QTextTable::next( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy )
+{
+    int cc = -1;
+    if ( currCell.find( c ) != currCell.end() )
+	cc = *currCell.find( c );
+    if ( cc > (int)cells.count() - 1 || cc < 0 )
+	cc = -1;
+    currCell.remove( c );
+    currCell.insert( c, ++cc );
+    if ( cc >= (int)cells.count() ) {
+	currCell.insert( c, 0 );
+	QTextCustomItem::next( c, doc, parag, idx, ox, oy );
+	QTextTableCell *cell = cells.first();
+	if ( !cell )
+	    return FALSE;
+	doc = cell->richText();
+	idx = -1;
+	return TRUE;
+    }
+
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    QTextTableCell *cell = cells.at( *currCell.find( c ) );
+    if ( !cell )
+	return FALSE;
+    doc = cell->richText();
+    parag = doc->firstParagraph();
+    idx = 0;
+    ox += cell->geometry().x() + cell->horizontalAlignmentOffset() + outerborder + parent->x();
+    oy += cell->geometry().y() + cell->verticalAlignmentOffset() + outerborder;
+    return TRUE;
+}
+
+bool QTextTable::prev( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy )
+{
+    int cc = -1;
+    if ( currCell.find( c ) != currCell.end() )
+	cc = *currCell.find( c );
+    if ( cc > (int)cells.count() - 1 || cc < 0 )
+	cc = cells.count();
+    currCell.remove( c );
+    currCell.insert( c, --cc );
+    if ( cc < 0 ) {
+	currCell.insert( c, 0 );
+	QTextCustomItem::prev( c, doc, parag, idx, ox, oy );
+	QTextTableCell *cell = cells.first();
+	if ( !cell )
+	    return FALSE;
+	doc = cell->richText();
+	idx = -1;
+	return TRUE;
+    }
+
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    QTextTableCell *cell = cells.at( *currCell.find( c ) );
+    if ( !cell )
+	return FALSE;
+    doc = cell->richText();
+    parag = doc->lastParagraph();
+    idx = parag->length() - 1;
+    ox += cell->geometry().x() + cell->horizontalAlignmentOffset() + outerborder + parent->x();
+    oy += cell->geometry().y()  + cell->verticalAlignmentOffset() + outerborder;
+    return TRUE;
+}
+
+bool QTextTable::down( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy )
+{
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    QTextTableCell *cell = cells.at( *currCell.find( c ) );
+    if ( cell->row_ == layout->numRows() - 1 ) {
+	currCell.insert( c, 0 );
+	QTextCustomItem::down( c, doc, parag, idx, ox, oy );
+	QTextTableCell *cell = cells.first();
+	if ( !cell )
+	    return FALSE;
+	doc = cell->richText();
+	idx = -1;
+	return TRUE;
+    }
+
+    int oldRow = cell->row_;
+    int oldCol = cell->col_;
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    int cc = *currCell.find( c );
+    for ( int i = cc; i < (int)cells.count(); ++i ) {
+	cell = cells.at( i );
+	if ( cell->row_ > oldRow && cell->col_ == oldCol ) {
+	    currCell.insert( c, i );
+	    break;
+	}
+    }
+    doc = cell->richText();
+    if ( !cell )
+	return FALSE;
+    parag = doc->firstParagraph();
+    idx = 0;
+    ox += cell->geometry().x() + cell->horizontalAlignmentOffset() + outerborder + parent->x();
+    oy += cell->geometry().y()  + cell->verticalAlignmentOffset() + outerborder;
+    return TRUE;
+}
+
+bool QTextTable::up( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy )
+{
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    QTextTableCell *cell = cells.at( *currCell.find( c ) );
+    if ( cell->row_ == 0 ) {
+	currCell.insert( c, 0 );
+	QTextCustomItem::up( c, doc, parag, idx, ox, oy );
+	QTextTableCell *cell = cells.first();
+	if ( !cell )
+	    return FALSE;
+	doc = cell->richText();
+	idx = -1;
+	return TRUE;
+    }
+
+    int oldRow = cell->row_;
+    int oldCol = cell->col_;
+    if ( currCell.find( c ) == currCell.end() )
+	return FALSE;
+    int cc = *currCell.find( c );
+    for ( int i = cc; i >= 0; --i ) {
+	cell = cells.at( i );
+	if ( cell->row_ < oldRow && cell->col_ == oldCol ) {
+	    currCell.insert( c, i );
+	    break;
+	}
+    }
+    doc = cell->richText();
+    if ( !cell )
+	return FALSE;
+    parag = doc->lastParagraph();
+    idx = parag->length() - 1;
+    ox += cell->geometry().x() + cell->horizontalAlignmentOffset() + outerborder + parent->x();
+    oy += cell->geometry().y()  + cell->verticalAlignmentOffset() + outerborder;
+    return TRUE;
+}
+
+QTextTableCell::QTextTableCell( QTextTable* table,
+				int row, int column,
+				const QMap<QString, QString> &attr,
+				const QStyleSheetItem* /*style*/, // ### use them
+				const QTextFormat& fmt, const QString& context,
+				QMimeSourceFactory &factory, QStyleSheet *sheet,
+				const QString& doc)
+{
+    cached_width = -1;
+    cached_sizehint = -1;
+
+    maxw = QWIDGETSIZE_MAX;
+    minw = 0;
+
+    parent = table;
+    row_ = row;
+    col_ = column;
+    stretch_ = 0;
+    richtext = new QTextDocument( table->parent );
+    richtext->formatCollection()->setPaintDevice( table->parent->formatCollection()->paintDevice() );
+    richtext->bodyText = fmt.color();
+    richtext->setTableCell( this );
+    QString a = *attr.find( "align" );
+    if ( !a.isEmpty() ) {
+	a = a.lower();
+	if ( a == "left" )
+	    richtext->setAlignment( Qt::AlignLeft );
+	else if ( a == "center" )
+	    richtext->setAlignment( Qt::AlignHCenter );
+	else if ( a == "right" )
+	    richtext->setAlignment( Qt::AlignRight );
+    }
+    align = 0;
+    QString va = *attr.find( "valign" );
+    if ( !va.isEmpty() ) {
+	va = va.lower();
+	if ( va == "top" )
+	    align |= Qt::AlignTop;
+	else if ( va == "center" || va == "middle" )
+	    align |= Qt::AlignVCenter;
+	else if ( va == "bottom" )
+	    align |= Qt::AlignBottom;
+    }
+    richtext->setFormatter( table->parent->formatter() );
+    richtext->setUseFormatCollection( table->parent->useFormatCollection() );
+    richtext->setMimeSourceFactory( &factory );
+    richtext->setStyleSheet( sheet );
+    richtext->setRichText( doc, context, &fmt );
+    rowspan_ = 1;
+    colspan_ = 1;
+    if ( attr.contains("colspan") )
+	colspan_ = attr["colspan"].toInt();
+    if ( attr.contains("rowspan") )
+	rowspan_ = attr["rowspan"].toInt();
+
+    background = 0;
+    if ( attr.contains("bgcolor") ) {
+	background = new QBrush(QColor( attr["bgcolor"] ));
+    }
+
+
+    hasFixedWidth = FALSE;
+    if ( attr.contains("width") ) {
+	bool b;
+	QString s( attr["width"] );
+	int w = s.toInt( &b );
+	if ( b ) {
+	    maxw = w;
+	    minw = maxw;
+	    hasFixedWidth = TRUE;
+	} else {
+	    s = s.stripWhiteSpace();
+	    if ( s.length() > 1 && s[ (int)s.length()-1 ] == '%' )
+		stretch_ = s.left( s.length()-1).toInt();
+	}
+    }
+
+    attributes = attr;
+
+    parent->addCell( this );
+}
+
+QTextTableCell::~QTextTableCell()
+{
+    delete background;
+    background = 0;
+    delete richtext;
+    richtext = 0;
+}
+
+QSize QTextTableCell::sizeHint() const
+{
+    int extra = 2 * ( parent->innerborder + parent->cellpadding + border_tolerance);
+    int used = richtext->widthUsed() + extra;
+
+    if  (stretch_ ) {
+	int w = parent->width * stretch_ / 100 - 2*parent->cellspacing - 2*parent->cellpadding;
+	return QSize( QMIN( w, maxw ), 0 ).expandedTo( minimumSize() );
+    }
+
+    return QSize( used, 0 ).expandedTo( minimumSize() );
+}
+
+QSize QTextTableCell::minimumSize() const
+{
+    int extra = 2 * ( parent->innerborder + parent->cellpadding + border_tolerance);
+    return QSize( QMAX( richtext->minimumWidth() + extra, minw), 0 );
+}
+
+QSize QTextTableCell::maximumSize() const
+{
+    return QSize( maxw, QWIDGETSIZE_MAX );
+}
+
+QSizePolicy::ExpandData QTextTableCell::expanding() const
+{
+    return QSizePolicy::BothDirections;
+}
+
+bool QTextTableCell::isEmpty() const
+{
+    return FALSE;
+}
+void QTextTableCell::setGeometry( const QRect& r )
+{
+    int extra = 2 * ( parent->innerborder + parent->cellpadding );
+    if ( r.width() != cached_width )
+	richtext->doLayout( QTextFormat::painter(), r.width() - extra );
+    cached_width = r.width();
+    geom = r;
+}
+
+QRect QTextTableCell::geometry() const
+{
+    return geom;
+}
+
+bool QTextTableCell::hasHeightForWidth() const
+{
+    return TRUE;
+}
+
+int QTextTableCell::heightForWidth( int w ) const
+{
+    int extra = 2 * ( parent->innerborder + parent->cellpadding );
+    w = QMAX( minw, w );
+
+    if ( cached_width != w ) {
+	QTextTableCell* that = (QTextTableCell*) this;
+	that->richtext->doLayout( QTextFormat::painter(), w - extra );
+	that->cached_width = w;
+    }
+    return richtext->height() + extra;
+}
+
+void QTextTableCell::adjustToPainter( QPainter* p )
+{
+    QTextParagraph *parag = richtext->firstParagraph();
+    while ( parag ) {
+	parag->adjustToPainter( p );
+	parag = parag->next();
+    }
+}
+
+int QTextTableCell::horizontalAlignmentOffset() const
+{
+    return parent->cellpadding;
+}
+
+int QTextTableCell::verticalAlignmentOffset() const
+{
+    if ( (align & Qt::AlignVCenter ) == Qt::AlignVCenter )
+	return ( geom.height() - richtext->height() ) / 2;
+    else if ( ( align & Qt::AlignBottom ) == Qt::AlignBottom )
+	return geom.height() - parent->cellpadding - richtext->height()  ;
+    return parent->cellpadding;
+}
+
+void QTextTableCell::draw( QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool )
+{
+    if ( cached_width != geom.width() ) {
+	int extra = 2 * ( parent->innerborder + parent->cellpadding );
+	richtext->doLayout( p, geom.width() - extra );
+	cached_width = geom.width();
+    }
+    QColorGroup g( cg );
+    if ( background )
+	g.setBrush( QColorGroup::Base, *background );
+    else if ( richtext->paper() )
+	g.setBrush( QColorGroup::Base, *richtext->paper() );
+
+    p->save();
+    p->translate( x + geom.x(), y + geom.y() );
+    if ( background )
+	p->fillRect( 0, 0, geom.width(), geom.height(), *background );
+    else if ( richtext->paper() )
+	p->fillRect( 0, 0, geom.width(), geom.height(), *richtext->paper() );
+
+    p->translate( horizontalAlignmentOffset(), verticalAlignmentOffset() );
+
+    QRegion r;
+    if ( cx >= 0 && cy >= 0 )
+	richtext->draw( p, cx - ( x + horizontalAlignmentOffset() + geom.x() ),
+			cy - ( y + geom.y() + verticalAlignmentOffset() ),
+			cw, ch, g, FALSE, FALSE, 0 );
+    else
+	richtext->draw( p, -1, -1, -1, -1, g, FALSE, FALSE, 0 );
+
+    p->restore();
+}
+#endif
+
+#endif //QT_NO_RICHTEXT
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h
--- qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h	2009-10-18 14:38:39.231872222 -0700
@@ -366,5 +366,6 @@
 
     bool place( const QPoint &pos, QTextParagraph *s ) { return place( pos, s, FALSE ); }
-    bool place( const QPoint &pos, QTextParagraph *s, bool link );
+    bool place( const QPoint &pos, QTextParagraph *s, bool link ) { return place( pos, s, link, TRUE, TRUE ); }
+    bool place( const QPoint &pos, QTextParagraph *s, bool link, bool loosePlacing, bool matchBetweenCharacters );
     void restoreState();
 
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h.orig qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h.orig
--- qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qrichtext_p.h.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,2140 @@
+/****************************************************************************
+**
+** Definition of internal rich text classes
+**
+** Created : 990124
+**
+** Copyright (C) 1999-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QRICHTEXT_P_H
+#define QRICHTEXT_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of a number of Qt sources files.  This header file may change from
+// version to version without notice, or even be removed.
+//
+// We mean it.
+//
+//
+
+#ifndef QT_H
+#include "qstring.h"
+#include "qptrlist.h"
+#include "qrect.h"
+#include "qfontmetrics.h"
+#include "qintdict.h"
+#include "qmap.h"
+#include "qstringlist.h"
+#include "qfont.h"
+#include "qcolor.h"
+#include "qsize.h"
+#include "qvaluelist.h"
+#include "qvaluestack.h"
+#include "qobject.h"
+#include "qdict.h"
+#include "qpixmap.h"
+#include "qstylesheet.h"
+#include "qptrvector.h"
+#include "qpainter.h"
+#include "qlayout.h"
+#include "qobject.h"
+#include "qapplication.h"
+#endif // QT_H
+
+#ifndef QT_NO_RICHTEXT
+
+class QTextDocument;
+class QTextString;
+class QTextPreProcessor;
+class QTextFormat;
+class QTextCursor;
+class QTextParagraph;
+class QTextFormatter;
+class QTextIndent;
+class QTextFormatCollection;
+class QStyleSheetItem;
+#ifndef QT_NO_TEXTCUSTOMITEM
+class QTextCustomItem;
+#endif
+class QTextFlow;
+struct QBidiContext;
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextStringChar
+{
+    friend class QTextString;
+
+public:
+    // this is never called, initialize variables in QTextString::insert()!!!
+    QTextStringChar() : nobreak(FALSE), lineStart( 0 ), type( Regular ) {d.format=0;}
+    ~QTextStringChar();
+
+    struct CustomData
+    {
+	QTextFormat *format;
+#ifndef QT_NO_TEXTCUSTOMITEM
+	QTextCustomItem *custom;
+#endif
+	QString anchorName;
+	QString anchorHref;
+    };
+    enum Type { Regular=0, Custom=1, Anchor=2, CustomAnchor=3 };
+
+    QChar c;
+    // this is the same struct as in qtextengine_p.h. Don't change!
+    uchar softBreak      :1;     // Potential linebreak point
+    uchar whiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
+    uchar charStop       :1;     // Valid cursor position (for left/right arrow)
+    uchar wordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
+    uchar nobreak        :1;
+
+    uchar lineStart : 1;
+    uchar /*Type*/ type : 2;
+    uchar bidiLevel       :7;
+    uchar rightToLeft : 1;
+
+    int x;
+    union {
+	QTextFormat* format;
+	CustomData* custom;
+    } d;
+
+
+    int height() const;
+    int ascent() const;
+    int descent() const;
+    bool isCustom() const { return (type & Custom) != 0; }
+    QTextFormat *format() const;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextCustomItem *customItem() const;
+#endif
+    void setFormat( QTextFormat *f );
+#ifndef QT_NO_TEXTCUSTOMITEM
+    void setCustomItem( QTextCustomItem *i );
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    void loseCustomItem();
+#endif
+
+
+    bool isAnchor() const { return ( type & Anchor) != 0; }
+    bool isLink() const { return isAnchor() && !!d.custom->anchorHref; }
+    QString anchorName() const;
+    QString anchorHref() const;
+    void setAnchor( const QString& name, const QString& href );
+
+private:
+    QTextStringChar &operator=( const QTextStringChar & ) {
+	//abort();
+	return *this;
+    }
+    QTextStringChar( const QTextStringChar & ) {
+    }
+    friend class QTextParagraph;
+};
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMemArray<QTextStringChar>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextString
+{
+public:
+
+    QTextString();
+    QTextString( const QTextString &s );
+    virtual ~QTextString();
+
+    static QString toString( const QMemArray<QTextStringChar> &data );
+    QString toString() const;
+
+    inline QTextStringChar &at( int i ) const { return data[ i ]; }
+    inline int length() const { return data.size(); }
+
+    int width( int idx ) const;
+
+    void insert( int index, const QString &s, QTextFormat *f );
+    void insert( int index, const QChar *unicode, int len, QTextFormat *f );
+    void insert( int index, QTextStringChar *c, bool doAddRefFormat = FALSE );
+    void truncate( int index );
+    void remove( int index, int len );
+    void clear();
+
+    void setFormat( int index, QTextFormat *f, bool useCollection );
+
+    void setBidi( bool b ) { bidi = b; }
+    bool isBidi() const;
+    bool isRightToLeft() const;
+    QChar::Direction direction() const;
+    void setDirection( QChar::Direction d ) { dir = d; bidiDirty = TRUE; }
+
+    QMemArray<QTextStringChar> rawData() const { return data.copy(); }
+
+    void operator=( const QString &s ) { clear(); insert( 0, s, 0 ); }
+    void operator+=( const QString &s ) { insert( length(), s, 0 ); }
+    void prepend( const QString &s ) { insert( 0, s, 0 ); }
+    int appendParagraphs( QTextParagraph *start, QTextParagraph *end );
+
+    // return next and previous valid cursor positions.
+    bool validCursorPosition( int idx );
+    int nextCursorPosition( int idx );
+    int previousCursorPosition( int idx );
+
+private:
+    void checkBidi() const;
+
+    QMemArray<QTextStringChar> data;
+    QString stringCache;
+    uint bidiDirty : 1;
+    uint bidi : 1; // true when the paragraph has right to left characters
+    uint rightToLeft : 1;
+    uint dir : 5;
+};
+
+inline bool QTextString::isBidi() const
+{
+    if ( bidiDirty )
+	checkBidi();
+    return bidi;
+}
+
+inline bool QTextString::isRightToLeft() const
+{
+    if ( bidiDirty )
+	checkBidi();
+    return rightToLeft;
+}
+
+inline QString QTextString::toString() const
+{
+    if(bidiDirty)
+        checkBidi();
+    return stringCache;
+}
+
+inline QChar::Direction QTextString::direction() const
+{
+    return (QChar::Direction) dir;
+}
+
+inline int QTextString::nextCursorPosition( int next )
+{
+    if ( bidiDirty )
+	checkBidi();
+
+    const QTextStringChar *c = data.data();
+    int len = length();
+
+    if ( next < len - 1 ) {
+	next++;
+	while ( next < len - 1 && !c[next].charStop )
+	    next++;
+    }
+    return next;
+}
+
+inline int QTextString::previousCursorPosition( int prev )
+{
+    if ( bidiDirty )
+	checkBidi();
+
+    const QTextStringChar *c = data.data();
+
+    if ( prev ) {
+	prev--;
+	while ( prev && !c[prev].charStop )
+	    prev--;
+    }
+    return prev;
+}
+
+inline bool QTextString::validCursorPosition( int idx )
+{
+    if ( bidiDirty )
+	checkBidi();
+
+    return (at( idx ).charStop);
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QValueStack<int>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QValueStack<QTextParagraph*>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QValueStack<bool>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextCursor
+{
+public:
+    QTextCursor( QTextDocument *d = 0 );
+    QTextCursor( const QTextCursor &c );
+    QTextCursor &operator=( const QTextCursor &c );
+    virtual ~QTextCursor() {}
+
+    bool operator==( const QTextCursor &c ) const;
+    bool operator!=( const QTextCursor &c ) const { return !(*this == c); }
+
+    inline QTextParagraph *paragraph() const { return para; }
+
+    QTextDocument *document() const;
+    int index() const;
+
+    void gotoPosition( QTextParagraph* p, int index = 0);
+    void setIndex( int index ) { gotoPosition(paragraph(), index ); }
+    void setParagraph( QTextParagraph*p ) { gotoPosition(p, 0 ); }
+
+    void gotoLeft();
+    void gotoRight();
+    void gotoNextLetter();
+    void gotoPreviousLetter();
+    void gotoUp();
+    void gotoDown();
+    void gotoLineEnd();
+    void gotoLineStart();
+    void gotoHome();
+    void gotoEnd();
+    void gotoPageUp( int visibleHeight );
+    void gotoPageDown( int visibleHeight );
+    void gotoNextWord( bool onlySpace = FALSE );
+    void gotoPreviousWord( bool onlySpace = FALSE );
+    void gotoWordLeft();
+    void gotoWordRight();
+
+    void insert( const QString &s, bool checkNewLine, QMemArray<QTextStringChar> *formatting = 0 );
+    void splitAndInsertEmptyParagraph( bool ind = TRUE, bool updateIds = TRUE );
+    bool remove();
+    bool removePreviousChar();
+    void indent();
+
+    bool atParagStart();
+    bool atParagEnd();
+
+    int x() const; // x in current paragraph
+    int y() const; // y in current paragraph
+
+    int globalX() const;
+    int globalY() const;
+
+    QTextParagraph *topParagraph() const { return paras.isEmpty() ? para : paras.first(); }
+    int offsetX() const { return ox; } // inner document  offset
+    int offsetY() const { return oy; } // inner document offset
+    int totalOffsetX() const; // total document offset
+    int totalOffsetY() const; // total document offset
+
+    bool place( const QPoint &pos, QTextParagraph *s ) { return place( pos, s, FALSE ); }
+    bool place( const QPoint &pos, QTextParagraph *s, bool link );
+    void restoreState();
+
+
+    int nestedDepth() const { return (int)indices.count(); } //### size_t/int cast
+    void oneUp() { if ( !indices.isEmpty() ) pop(); }
+    void setValid( bool b ) { valid = b; }
+    bool isValid() const { return valid; }
+
+    void fixCursorPosition();
+private:
+    enum Operation { EnterBegin, EnterEnd, Next, Prev, Up, Down };
+
+    void push();
+    void pop();
+    bool processNesting( Operation op );
+    void invalidateNested();
+    void gotoIntoNested( const QPoint &globalPos );
+
+    QTextParagraph *para;
+    int idx, tmpX;
+    int ox, oy;
+    QValueStack<int> indices;
+    QValueStack<QTextParagraph*> paras;
+    QValueStack<int> xOffsets;
+    QValueStack<int> yOffsets;
+    uint valid : 1;
+
+};
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextCommand
+{
+public:
+    enum Commands { Invalid, Insert, Delete, Format, Style };
+
+    QTextCommand( QTextDocument *d ) : doc( d ), cursor( d ) {}
+    virtual ~QTextCommand();
+
+    virtual Commands type() const;
+
+    virtual QTextCursor *execute( QTextCursor *c ) = 0;
+    virtual QTextCursor *unexecute( QTextCursor *c ) = 0;
+
+protected:
+    QTextDocument *doc;
+    QTextCursor cursor;
+
+};
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QPtrList<QTextCommand>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextCommandHistory
+{
+public:
+    QTextCommandHistory( int s ) : current( -1 ), steps( s ) { history.setAutoDelete( TRUE ); }
+    virtual ~QTextCommandHistory();
+
+    void clear() { history.clear(); current = -1; }
+
+    void addCommand( QTextCommand *cmd );
+    QTextCursor *undo( QTextCursor *c );
+    QTextCursor *redo( QTextCursor *c );
+
+    bool isUndoAvailable();
+    bool isRedoAvailable();
+
+    void setUndoDepth( int d ) { steps = d; }
+    int undoDepth() const { return steps; }
+
+    int historySize() const { return history.count(); }
+    int currentPosition() const { return current; }
+
+private:
+    QPtrList<QTextCommand> history;
+    int current, steps;
+
+};
+
+inline QTextCommandHistory::~QTextCommandHistory()
+{
+    clear();
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class Q_EXPORT QTextCustomItem
+{
+public:
+    QTextCustomItem( QTextDocument *p )
+	:  xpos(0), ypos(-1), width(-1), height(0), parent( p )
+    {}
+    virtual ~QTextCustomItem();
+    virtual void draw(QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected ) = 0;
+
+    virtual void adjustToPainter( QPainter* );
+
+    enum Placement { PlaceInline = 0, PlaceLeft, PlaceRight };
+    virtual Placement placement() const;
+    bool placeInline() { return placement() == PlaceInline; }
+
+    virtual bool ownLine() const;
+    virtual void resize( int nwidth );
+    virtual void invalidate();
+    virtual int ascent() const { return height; }
+
+    virtual bool isNested() const;
+    virtual int minimumWidth() const;
+
+    virtual QString richText() const;
+
+    int xpos; // used for floating items
+    int ypos; // used for floating items
+    int width;
+    int height;
+
+    QRect geometry() const { return QRect( xpos, ypos, width, height ); }
+
+    virtual bool enter( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, bool atEnd = FALSE );
+    virtual bool enterAt( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, const QPoint & );
+    virtual bool next( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool prev( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool down( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool up( QTextCursor *, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+
+    virtual void setParagraph( QTextParagraph *p ) { parag = p; }
+    QTextParagraph *paragraph() const { return parag; }
+
+    QTextDocument *parent;
+    QTextParagraph *parag;
+
+    virtual void pageBreak( int  y, QTextFlow* flow );
+};
+#endif
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+//Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<QString, QString>;
+// MOC_SKIP_END
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class Q_EXPORT QTextImage : public QTextCustomItem
+{
+public:
+    QTextImage( QTextDocument *p, const QMap<QString, QString> &attr, const QString& context,
+		QMimeSourceFactory &factory );
+    virtual ~QTextImage();
+
+    Placement placement() const { return place; }
+    void adjustToPainter( QPainter* );
+    int minimumWidth() const { return width; }
+
+    QString richText() const;
+
+    void draw( QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected );
+
+private:
+    QRegion* reg;
+    QPixmap pm;
+    Placement place;
+    int tmpwidth, tmpheight;
+    QMap<QString, QString> attributes;
+    QString imgId;
+
+};
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class Q_EXPORT QTextHorizontalLine : public QTextCustomItem
+{
+public:
+    QTextHorizontalLine( QTextDocument *p, const QMap<QString, QString> &attr, const QString& context,
+			 QMimeSourceFactory &factory );
+    virtual ~QTextHorizontalLine();
+
+    void adjustToPainter( QPainter* );
+    void draw(QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected );
+    QString richText() const;
+
+    bool ownLine() const { return TRUE; }
+
+private:
+    int tmpheight;
+    QColor color;
+    bool shade;
+
+};
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QPtrList<QTextCustomItem>;
+// MOC_SKIP_END
+#endif
+#endif
+
+class Q_EXPORT QTextFlow
+{
+    friend class QTextDocument;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    friend class QTextTableCell;
+#endif
+
+public:
+    QTextFlow();
+    virtual ~QTextFlow();
+
+    virtual void setWidth( int width );
+    int width() const;
+
+    virtual void setPageSize( int ps );
+    int pageSize() const { return pagesize; }
+
+    virtual int adjustLMargin( int yp, int h, int margin, int space );
+    virtual int adjustRMargin( int yp, int h, int margin, int space );
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    virtual void registerFloatingItem( QTextCustomItem* item );
+    virtual void unregisterFloatingItem( QTextCustomItem* item );
+#endif
+    virtual QRect boundingRect() const;
+    virtual void drawFloatingItems(QPainter* p, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected );
+
+    virtual int adjustFlow( int  y, int w, int h ); // adjusts y according to the defined pagesize. Returns the shift.
+
+    virtual bool isEmpty();
+
+    void clear();
+
+private:
+    int w;
+    int pagesize;
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QPtrList<QTextCustomItem> leftItems;
+    QPtrList<QTextCustomItem> rightItems;
+#endif
+};
+
+inline int QTextFlow::width() const { return w; }
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class QTextTable;
+
+class Q_EXPORT QTextTableCell : public QLayoutItem
+{
+    friend class QTextTable;
+
+public:
+    QTextTableCell( QTextTable* table,
+		    int row, int column,
+		    const QMap<QString, QString> &attr,
+		    const QStyleSheetItem* style,
+		    const QTextFormat& fmt, const QString& context,
+		    QMimeSourceFactory &factory, QStyleSheet *sheet, const QString& doc );
+    virtual ~QTextTableCell();
+
+    QSize sizeHint() const ;
+    QSize minimumSize() const ;
+    QSize maximumSize() const ;
+    QSizePolicy::ExpandData expanding() const;
+    bool isEmpty() const;
+    void setGeometry( const QRect& ) ;
+    QRect geometry() const;
+
+    bool hasHeightForWidth() const;
+    int heightForWidth( int ) const;
+
+    void adjustToPainter( QPainter* );
+
+    int row() const { return row_; }
+    int column() const { return col_; }
+    int rowspan() const { return rowspan_; }
+    int colspan() const { return colspan_; }
+    int stretch() const { return stretch_; }
+
+    QTextDocument* richText()  const { return richtext; }
+    QTextTable* table() const { return parent; }
+
+    void draw( QPainter* p, int x, int y, int cx, int cy, int cw, int ch, const QColorGroup& cg, bool selected );
+
+    QBrush *backGround() const { return background; }
+    virtual void invalidate();
+
+    int verticalAlignmentOffset() const;
+    int horizontalAlignmentOffset() const;
+
+private:
+    QRect geom;
+    QTextTable* parent;
+    QTextDocument* richtext;
+    int row_;
+    int col_;
+    int rowspan_;
+    int colspan_;
+    int stretch_;
+    int maxw;
+    int minw;
+    bool hasFixedWidth;
+    QBrush *background;
+    int cached_width;
+    int cached_sizehint;
+    QMap<QString, QString> attributes;
+    int align;
+};
+#endif
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QPtrList<QTextTableCell>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<QTextCursor*, int>;
+// MOC_SKIP_END
+#endif
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class Q_EXPORT QTextTable: public QTextCustomItem
+{
+    friend class QTextTableCell;
+
+public:
+    QTextTable( QTextDocument *p, const QMap<QString, QString> &attr );
+    virtual ~QTextTable();
+
+    void adjustToPainter( QPainter *p );
+    void pageBreak( int  y, QTextFlow* flow );
+    void draw( QPainter* p, int x, int y, int cx, int cy, int cw, int ch,
+	       const QColorGroup& cg, bool selected );
+
+    bool noErase() const { return TRUE; }
+    bool ownLine() const { return TRUE; }
+    Placement placement() const { return place; }
+    bool isNested() const { return TRUE; }
+    void resize( int nwidth );
+    virtual void invalidate();
+
+    virtual bool enter( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, bool atEnd = FALSE );
+    virtual bool enterAt( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy, const QPoint &pos );
+    virtual bool next( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool prev( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool down( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+    virtual bool up( QTextCursor *c, QTextDocument *&doc, QTextParagraph *&parag, int &idx, int &ox, int &oy );
+
+    QString richText() const;
+
+    int minimumWidth() const;
+
+    QPtrList<QTextTableCell> tableCells() const { return cells; }
+
+    bool isStretching() const { return stretch; }
+    void setParagraph(QTextParagraph *p);
+
+private:
+    void format( int w );
+    void addCell( QTextTableCell* cell );
+
+private:
+    QGridLayout* layout;
+    QPtrList<QTextTableCell> cells;
+    int cachewidth;
+    int fixwidth;
+    int cellpadding;
+    int cellspacing;
+    int border;
+    int outerborder;
+    int stretch;
+    int innerborder;
+    int us_cp, us_ib, us_b, us_ob, us_cs;
+    int us_fixwidth;
+    QMap<QString, QString> attributes;
+    QMap<QTextCursor*, int> currCell;
+    Placement place;
+    void adjustCells( int y , int shift );
+    int pageBreakFor;
+};
+#endif
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+class QTextTableCell;
+class QTextParagraph;
+#endif
+
+struct Q_EXPORT QTextDocumentSelection
+{
+    QTextCursor startCursor, endCursor;
+    bool swapped;
+    Q_DUMMY_COMPARISON_OPERATOR(QTextDocumentSelection)
+};
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<int, QColor>;
+//Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<int, bool>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<int, QTextDocumentSelection>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QPtrList<QTextDocument>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextDocument : public QObject
+{
+    Q_OBJECT
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    friend class QTextTableCell;
+#endif
+    friend class QTextCursor;
+    friend class QTextEdit;
+    friend class QTextParagraph;
+    friend class QTextTable;
+
+public:
+    enum SelectionIds {
+	Standard = 0,
+	IMSelectionText		= 31998,
+	IMCompositionText	= 31999, // this must be higher!
+	Temp = 32000 // This selection must not be drawn, it's used e.g. by undo/redo to
+	// remove multiple lines with removeSelectedText()
+    };
+
+    QTextDocument( QTextDocument *p );
+    virtual ~QTextDocument();
+
+    QTextDocument *parent() const { return par; }
+    QTextParagraph *parentParagraph() const { return parentPar; }
+
+    void setText( const QString &text, const QString &context );
+    QMap<QString, QString> attributes() const { return attribs; }
+    void setAttributes( const QMap<QString, QString> &attr ) { attribs = attr; }
+
+    QString text() const;
+    QString text( int parag ) const;
+    QString originalText() const;
+
+    int x() const;
+    int y() const;
+    int width() const;
+    int widthUsed() const;
+    int visibleWidth() const;
+    int height() const;
+    void setWidth( int w );
+    int minimumWidth() const;
+    bool setMinimumWidth( int needed, int used = -1, QTextParagraph *parag = 0 );
+
+    void setY( int y );
+    int leftMargin() const;
+    void setLeftMargin( int lm );
+    int rightMargin() const;
+    void setRightMargin( int rm );
+
+    QTextParagraph *firstParagraph() const;
+    QTextParagraph *lastParagraph() const;
+    void setFirstParagraph( QTextParagraph *p );
+    void setLastParagraph( QTextParagraph *p );
+
+    void invalidate();
+
+    void setPreProcessor( QTextPreProcessor *sh );
+    QTextPreProcessor *preProcessor() const;
+
+    void setFormatter( QTextFormatter *f );
+    QTextFormatter *formatter() const;
+
+    void setIndent( QTextIndent *i );
+    QTextIndent *indent() const;
+
+    QColor selectionColor( int id ) const;
+    bool invertSelectionText( int id ) const;
+    void setSelectionColor( int id, const QColor &c );
+    void setInvertSelectionText( int id, bool b );
+    bool hasSelection( int id, bool visible = FALSE ) const;
+    void setSelectionStart( int id, const QTextCursor &cursor );
+    bool setSelectionEnd( int id, const QTextCursor &cursor );
+    void selectAll( int id );
+    bool removeSelection( int id );
+    void selectionStart( int id, int &paragId, int &index );
+    QTextCursor selectionStartCursor( int id );
+    QTextCursor selectionEndCursor( int id );
+    void selectionEnd( int id, int &paragId, int &index );
+    void setFormat( int id, QTextFormat *f, int flags );
+    int numSelections() const { return nSelections; }
+    void addSelection( int id );
+
+    QString selectedText( int id, bool asRichText = FALSE ) const;
+    void removeSelectedText( int id, QTextCursor *cursor );
+    void indentSelection( int id );
+
+    QTextParagraph *paragAt( int i ) const;
+
+    void addCommand( QTextCommand *cmd );
+    QTextCursor *undo( QTextCursor *c = 0 );
+    QTextCursor *redo( QTextCursor *c  = 0 );
+    QTextCommandHistory *commands() const { return commandHistory; }
+
+    QTextFormatCollection *formatCollection() const;
+
+    bool find( QTextCursor &cursor, const QString &expr, bool cs, bool wo, bool forward);
+
+    void setTextFormat( Qt::TextFormat f );
+    Qt::TextFormat textFormat() const;
+
+    bool inSelection( int selId, const QPoint &pos ) const;
+
+    QStyleSheet *styleSheet() const { return sheet_; }
+#ifndef QT_NO_MIME
+    QMimeSourceFactory *mimeSourceFactory() const { return factory_; }
+#endif
+    QString context() const { return contxt; }
+
+    void setStyleSheet( QStyleSheet *s );
+    void setDefaultFormat( const QFont &font, const QColor &color );
+#ifndef QT_NO_MIME
+    void setMimeSourceFactory( QMimeSourceFactory *f ) { if ( f ) factory_ = f; }
+#endif
+    void setContext( const QString &c ) { if ( !c.isEmpty() ) contxt = c; }
+
+    void setUnderlineLinks( bool b );
+    bool underlineLinks() const { return underlLinks; }
+
+    void setPaper( QBrush *brush ) { if ( backBrush ) delete backBrush; backBrush = brush; }
+    QBrush *paper() const { return backBrush; }
+
+    void doLayout( QPainter *p, int w );
+    void draw( QPainter *p, const QRect& rect, const QColorGroup &cg, const QBrush *paper = 0 );
+    bool useDoubleBuffer( QTextParagraph *parag, QPainter *p );
+
+    void drawParagraph( QPainter *p, QTextParagraph *parag, int cx, int cy, int cw, int ch,
+		    QPixmap *&doubleBuffer, const QColorGroup &cg,
+		    bool drawCursor, QTextCursor *cursor, bool resetChanged = TRUE );
+    QTextParagraph *draw( QPainter *p, int cx, int cy, int cw, int ch, const QColorGroup &cg,
+		      bool onlyChanged = FALSE, bool drawCursor = FALSE, QTextCursor *cursor = 0,
+		      bool resetChanged = TRUE );
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    void registerCustomItem( QTextCustomItem *i, QTextParagraph *p );
+    void unregisterCustomItem( QTextCustomItem *i, QTextParagraph *p );
+#endif
+
+    void setFlow( QTextFlow *f );
+    void takeFlow();
+    QTextFlow *flow() const { return flow_; }
+    bool isPageBreakEnabled() const { return pages; }
+    void setPageBreakEnabled( bool b ) { pages = b; }
+
+    void setUseFormatCollection( bool b ) { useFC = b; }
+    bool useFormatCollection() const { return useFC; }
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextTableCell *tableCell() const { return tc; }
+    void setTableCell( QTextTableCell *c ) { tc = c; }
+#endif
+
+    void setPlainText( const QString &text );
+    void setRichText( const QString &text, const QString &context, const QTextFormat *initialFormat = 0 );
+    QString richText() const;
+    QString plainText() const;
+
+    bool focusNextPrevChild( bool next );
+
+    int alignment() const;
+    void setAlignment( int a );
+
+    int *tabArray() const;
+    int tabStopWidth() const;
+    void setTabArray( int *a );
+    void setTabStops( int tw );
+
+    void setUndoDepth( int d ) { commandHistory->setUndoDepth( d ); }
+    int undoDepth() const { return commandHistory->undoDepth(); }
+
+    int length() const;
+    void clear( bool createEmptyParag = FALSE );
+
+    virtual QTextParagraph *createParagraph( QTextDocument *d, QTextParagraph *pr = 0, QTextParagraph *nx = 0, bool updateIds = TRUE );
+    void insertChild( QObject *o ) { QObject::insertChild( o ); }
+    void removeChild( QObject *o ) { QObject::removeChild( o ); }
+    void insertChild( QTextDocument *d ) { childList.append( d ); }
+    void removeChild( QTextDocument *d ) { childList.removeRef( d ); }
+    QPtrList<QTextDocument> children() const { return childList; }
+
+    bool hasFocusParagraph() const;
+    QString focusHref() const;
+    QString focusName() const;
+
+    void invalidateOriginalText() { oTextValid = FALSE; oText = ""; }
+
+signals:
+    void minimumWidthChanged( int );
+
+private:
+    void init();
+    QPixmap *bufferPixmap( const QSize &s );
+    // HTML parser
+    bool hasPrefix(const QChar* doc, int length, int pos, QChar c);
+    bool hasPrefix(const QChar* doc, int length, int pos, const QString& s);
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextCustomItem* parseTable( const QMap<QString, QString> &attr, const QTextFormat &fmt,
+				 const QChar* doc, int length, int& pos, QTextParagraph *curpar );
+#endif
+    bool eatSpace(const QChar* doc, int length, int& pos, bool includeNbsp = FALSE );
+    bool eat(const QChar* doc, int length, int& pos, QChar c);
+    QString parseOpenTag(const QChar* doc, int length, int& pos, QMap<QString, QString> &attr, bool& emptyTag);
+    QString parseCloseTag( const QChar* doc, int length, int& pos );
+    QChar parseHTMLSpecialChar(const QChar* doc, int length, int& pos);
+    QString parseWord(const QChar* doc, int length, int& pos, bool lower = TRUE);
+    QChar parseChar(const QChar* doc, int length, int& pos, QStyleSheetItem::WhiteSpaceMode wsm );
+    void setRichTextInternal( const QString &text, QTextCursor* cursor = 0, const QTextFormat *initialFormat = 0 );
+    void setRichTextMarginsInternal( QPtrList< QPtrVector<QStyleSheetItem> >& styles, QTextParagraph* stylesPar );
+
+private:
+    struct Q_EXPORT Focus {
+	QTextParagraph *parag;
+	int start, len;
+	QString href;
+	QString name;
+    };
+
+    int cx, cy, cw, vw;
+    QTextParagraph *fParag, *lParag;
+    QTextPreProcessor *pProcessor;
+    QMap<int, QColor> selectionColors;
+    QMap<int, QTextDocumentSelection> selections;
+    QMap<int, bool> selectionText;
+    QTextCommandHistory *commandHistory;
+    QTextFormatter *pFormatter;
+    QTextIndent *indenter;
+    QTextFormatCollection *fCollection;
+    Qt::TextFormat txtFormat;
+    uint preferRichText : 1;
+    uint pages : 1;
+    uint useFC : 1;
+    uint withoutDoubleBuffer : 1;
+    uint underlLinks : 1;
+    uint nextDoubleBuffered : 1;
+    uint oTextValid : 1;
+    uint mightHaveCustomItems : 1;
+    int align;
+    int nSelections;
+    QTextFlow *flow_;
+    QTextDocument *par;
+    QTextParagraph *parentPar;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextTableCell *tc;
+#endif
+    QBrush *backBrush;
+    QPixmap *buf_pixmap;
+    Focus focusIndicator;
+    int minw;
+    int wused;
+    int leftmargin;
+    int rightmargin;
+    QTextParagraph *minwParag, *curParag;
+    QStyleSheet* sheet_;
+#ifndef QT_NO_MIME
+    QMimeSourceFactory* factory_;
+#endif
+    QString contxt;
+    QMap<QString, QString> attribs;
+    int *tArray;
+    int tStopWidth;
+    int uDepth;
+    QString oText;
+    QPtrList<QTextDocument> childList;
+    QColor linkColor, bodyText;
+    double scaleFontsFactor;
+
+    short list_tm,list_bm, list_lm, li_tm, li_bm, par_tm, par_bm;
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QTextDocument( const QTextDocument & );
+    QTextDocument &operator=( const QTextDocument & );
+#endif
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+
+class Q_EXPORT QTextDeleteCommand : public QTextCommand
+{
+public:
+    QTextDeleteCommand( QTextDocument *d, int i, int idx, const QMemArray<QTextStringChar> &str,
+			const QByteArray& oldStyle );
+    QTextDeleteCommand( QTextParagraph *p, int idx, const QMemArray<QTextStringChar> &str );
+    virtual ~QTextDeleteCommand();
+
+    Commands type() const { return Delete; }
+    QTextCursor *execute( QTextCursor *c );
+    QTextCursor *unexecute( QTextCursor *c );
+
+protected:
+    int id, index;
+    QTextParagraph *parag;
+    QMemArray<QTextStringChar> text;
+    QByteArray styleInformation;
+
+};
+
+class Q_EXPORT QTextInsertCommand : public QTextDeleteCommand
+{
+public:
+    QTextInsertCommand( QTextDocument *d, int i, int idx, const QMemArray<QTextStringChar> &str,
+			const QByteArray& oldStyleInfo )
+	: QTextDeleteCommand( d, i, idx, str, oldStyleInfo ) {}
+    QTextInsertCommand( QTextParagraph *p, int idx, const QMemArray<QTextStringChar> &str )
+	: QTextDeleteCommand( p, idx, str ) {}
+    virtual ~QTextInsertCommand() {}
+
+    Commands type() const { return Insert; }
+    QTextCursor *execute( QTextCursor *c ) { return QTextDeleteCommand::unexecute( c ); }
+    QTextCursor *unexecute( QTextCursor *c ) { return QTextDeleteCommand::execute( c ); }
+
+};
+
+class Q_EXPORT QTextFormatCommand : public QTextCommand
+{
+public:
+    QTextFormatCommand( QTextDocument *d, int sid, int sidx, int eid, int eidx, const QMemArray<QTextStringChar> &old, QTextFormat *f, int fl );
+    virtual ~QTextFormatCommand();
+
+    Commands type() const { return Format; }
+    QTextCursor *execute( QTextCursor *c );
+    QTextCursor *unexecute( QTextCursor *c );
+
+protected:
+    int startId, startIndex, endId, endIndex;
+    QTextFormat *format;
+    QMemArray<QTextStringChar> oldFormats;
+    int flags;
+
+};
+
+class Q_EXPORT QTextStyleCommand : public QTextCommand
+{
+public:
+    QTextStyleCommand( QTextDocument *d, int fParag, int lParag, const QByteArray& beforeChange  );
+    virtual ~QTextStyleCommand() {}
+
+    Commands type() const { return Style; }
+    QTextCursor *execute( QTextCursor *c );
+    QTextCursor *unexecute( QTextCursor *c );
+
+    static QByteArray readStyleInformation(  QTextDocument* d, int fParag, int lParag );
+    static void writeStyleInformation(  QTextDocument* d, int fParag, const QByteArray& style );
+
+private:
+    int firstParag, lastParag;
+    QByteArray before;
+    QByteArray after;
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+struct Q_EXPORT QTextParagraphSelection
+{
+    QTextParagraphSelection() : start(0), end(0) { }
+    int start, end;
+    Q_DUMMY_COMPARISON_OPERATOR(QTextParagraphSelection)
+};
+
+struct Q_EXPORT QTextLineStart
+{
+    QTextLineStart() : y( 0 ), baseLine( 0 ), h( 0 )
+    {  }
+    QTextLineStart( int y_, int bl, int h_ ) : y( y_ ), baseLine( bl ), h( h_ ),
+	w( 0 )
+    {  }
+
+public:
+    int y, baseLine, h;
+    int w;
+};
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<int, QTextParagraphSelection>;
+Q_TEMPLATE_EXTERN template class Q_EXPORT QMap<int, QTextLineStart*>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextParagraphData
+{
+public:
+    QTextParagraphData() {}
+    virtual ~QTextParagraphData();
+    virtual void join( QTextParagraphData * );
+};
+
+class QTextParagraphPseudoDocument;
+
+class QSyntaxHighlighter;
+
+class Q_EXPORT QTextParagraph
+{
+    friend class QTextDocument;
+    friend class QTextCursor;
+    friend class QSyntaxHighlighter;
+
+public:
+    QTextParagraph( QTextDocument *d, QTextParagraph *pr = 0, QTextParagraph *nx = 0, bool updateIds = TRUE );
+    ~QTextParagraph();
+
+    QTextString *string() const;
+    QTextStringChar *at( int i ) const; // maybe remove later
+    int leftGap() const;
+    int length() const; // maybe remove later
+
+    void setListStyle( QStyleSheetItem::ListStyle ls ) { lstyle = ls; changed = TRUE; }
+    QStyleSheetItem::ListStyle listStyle() const { return (QStyleSheetItem::ListStyle)lstyle; }
+    void setListItem( bool li );
+    bool isListItem() const { return litem; }
+    void setListValue( int v ) { list_val = v; }
+    int listValue() const { return list_val > 0 ? list_val : -1; }
+
+    void setListDepth( int depth );
+    int listDepth() const { return ldepth; }
+
+//     void setFormat( QTextFormat *fm );
+//     QTextFormat *paragFormat() const;
+
+    inline QTextDocument *document() const {
+	if (hasdoc) return (QTextDocument*) docOrPseudo;
+	return 0;
+    }
+    QTextParagraphPseudoDocument *pseudoDocument() const;
+
+    QRect rect() const;
+    void setHeight( int h ) { r.setHeight( h ); }
+    void show();
+    void hide();
+    bool isVisible() const { return visible; }
+
+    QTextParagraph *prev() const;
+    QTextParagraph *next() const;
+    void setPrev( QTextParagraph *s );
+    void setNext( QTextParagraph *s );
+
+    void insert( int index, const QString &s );
+    void insert( int index, const QChar *unicode, int len );
+    void append( const QString &s, bool reallyAtEnd = FALSE );
+    void truncate( int index );
+    void remove( int index, int len );
+    void join( QTextParagraph *s );
+
+    void invalidate( int chr );
+
+    void move( int &dy );
+    void format( int start = -1, bool doMove = TRUE );
+
+    bool isValid() const;
+    bool hasChanged() const;
+    void setChanged( bool b, bool recursive = FALSE );
+
+    int lineHeightOfChar( int i, int *bl = 0, int *y = 0 ) const;
+    QTextStringChar *lineStartOfChar( int i, int *index = 0, int *line = 0 ) const;
+    int lines() const;
+    QTextStringChar *lineStartOfLine( int line, int *index = 0 ) const;
+    int lineY( int l ) const;
+    int lineBaseLine( int l ) const;
+    int lineHeight( int l ) const;
+    void lineInfo( int l, int &y, int &h, int &bl ) const;
+
+    void setSelection( int id, int start, int end );
+    void removeSelection( int id );
+    int selectionStart( int id ) const;
+    int selectionEnd( int id ) const;
+    bool hasSelection( int id ) const;
+    bool hasAnySelection() const;
+    bool fullSelected( int id ) const;
+
+    void setEndState( int s );
+    int endState() const;
+
+    void setParagId( int i );
+    int paragId() const;
+
+    bool firstPreProcess() const;
+    void setFirstPreProcess( bool b );
+
+    void indent( int *oldIndent = 0, int *newIndent = 0 );
+
+    void setExtraData( QTextParagraphData *data );
+    QTextParagraphData *extraData() const;
+
+    QMap<int, QTextLineStart*> &lineStartList();
+
+    void setFormat( int index, int len, QTextFormat *f, bool useCollection = TRUE, int flags = -1 );
+
+    void setAlignment( int a );
+    int alignment() const;
+
+    void paint( QPainter &painter, const QColorGroup &cg, QTextCursor *cursor = 0, bool drawSelections = FALSE,
+			int clipx = -1, int clipy = -1, int clipw = -1, int cliph = -1 );
+
+    int topMargin() const;
+    int bottomMargin() const;
+    int leftMargin() const;
+    int firstLineMargin() const;
+    int rightMargin() const;
+    int lineSpacing() const;
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    void registerFloatingItem( QTextCustomItem *i );
+    void unregisterFloatingItem( QTextCustomItem *i );
+#endif
+
+    void setFullWidth( bool b ) { fullWidth = b; }
+    bool isFullWidth() const { return fullWidth; }
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QTextTableCell *tableCell() const;
+#endif
+
+    QBrush *background() const;
+
+    int documentWidth() const;
+    int documentVisibleWidth() const;
+    int documentX() const;
+    int documentY() const;
+    QTextFormatCollection *formatCollection() const;
+    QTextFormatter *formatter() const;
+
+    int nextTab( int i, int x );
+    int *tabArray() const;
+    void setTabArray( int *a );
+    void setTabStops( int tw );
+
+    void adjustToPainter( QPainter *p );
+
+    void setNewLinesAllowed( bool b );
+    bool isNewLinesAllowed() const;
+
+    QString richText() const;
+
+    void addCommand( QTextCommand *cmd );
+    QTextCursor *undo( QTextCursor *c = 0 );
+    QTextCursor *redo( QTextCursor *c  = 0 );
+    QTextCommandHistory *commands() const;
+    void copyParagData( QTextParagraph *parag );
+
+    void setBreakable( bool b ) { breakable = b; }
+    bool isBreakable() const { return breakable; }
+
+    void setBackgroundColor( const QColor &c );
+    QColor *backgroundColor() const { return bgcol; }
+    void clearBackgroundColor();
+
+    void setMovedDown( bool b ) { movedDown = b; }
+    bool wasMovedDown() const { return movedDown; }
+
+    void setDirection( QChar::Direction d );
+    QChar::Direction direction() const;
+    void setPaintDevice( QPaintDevice *pd ) { paintdevice = pd; }
+
+    void readStyleInformation( QDataStream& stream );
+    void writeStyleInformation( QDataStream& stream ) const;
+
+protected:
+    void setColorForSelection( QColor &c, QPainter &p, const QColorGroup& cg, int selection );
+    void drawLabel( QPainter* p, int x, int y, int w, int h, int base, const QColorGroup& cg );
+    void drawString( QPainter &painter, const QString &str, int start, int len, int xstart,
+			     int y, int baseLine, int w, int h, bool drawSelections, int fullSelectionWidth,
+			     QTextStringChar *formatChar, const QColorGroup& cg,
+			     bool rightToLeft );
+
+private:
+    QMap<int, QTextParagraphSelection> &selections() const;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QPtrList<QTextCustomItem> &floatingItems() const;
+#endif
+    QBrush backgroundBrush( const QColorGroup&cg ) { if ( bgcol ) return *bgcol; return cg.brush( QColorGroup::Base ); }
+    void invalidateStyleCache();
+
+    QMap<int, QTextLineStart*> lineStarts;
+    QRect r;
+    QTextParagraph *p, *n;
+    void *docOrPseudo;
+    uint changed : 1;
+    uint firstFormat : 1;
+    uint firstPProcess : 1;
+    uint needPreProcess : 1;
+    uint fullWidth : 1;
+    uint lastInFrame : 1;
+    uint visible : 1;
+    uint breakable : 1;
+    uint movedDown : 1;
+    uint mightHaveCustomItems : 1;
+    uint hasdoc : 1;
+    uint litem : 1; // whether the paragraph is a list item
+    uint rtext : 1; // whether the paragraph needs rich text margin
+    int align : 4;
+    uint /*QStyleSheetItem::ListStyle*/ lstyle : 4;
+    int invalid;
+    int state, id;
+    QTextString *str;
+    QMap<int, QTextParagraphSelection> *mSelections;
+#ifndef QT_NO_TEXTCUSTOMITEM
+    QPtrList<QTextCustomItem> *mFloatingItems;
+#endif
+    short utm, ubm, ulm, urm, uflm, ulinespacing;
+    short tabStopWidth;
+    int minwidth;
+    int *tArray;
+    QTextParagraphData *eData;
+    short list_val;
+    ushort ldepth;
+    QColor *bgcol;
+    QPaintDevice *paintdevice;
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextFormatter
+{
+public:
+    QTextFormatter();
+    virtual ~QTextFormatter();
+
+    virtual int format( QTextDocument *doc, QTextParagraph *parag, int start, const QMap<int, QTextLineStart*> &oldLineStarts ) = 0;
+    virtual int formatVertically( QTextDocument* doc, QTextParagraph* parag );
+
+    bool isWrapEnabled( QTextParagraph *p ) const { if ( !wrapEnabled ) return FALSE; if ( p && !p->isBreakable() ) return FALSE; return TRUE;}
+    int wrapAtColumn() const { return wrapColumn;}
+    virtual void setWrapEnabled( bool b );
+    virtual void setWrapAtColumn( int c );
+    virtual void setAllowBreakInWords( bool b ) { biw = b; }
+    bool allowBreakInWords() const { return biw; }
+
+    int minimumWidth() const { return thisminw; }
+    int widthUsed() const { return thiswused; }
+
+protected:
+    virtual QTextLineStart *formatLine( QTextParagraph *parag, QTextString *string, QTextLineStart *line, QTextStringChar *start,
+					       QTextStringChar *last, int align = Qt::AlignAuto, int space = 0 );
+#ifndef QT_NO_COMPLEXTEXT
+    virtual QTextLineStart *bidiReorderLine( QTextParagraph *parag, QTextString *string, QTextLineStart *line, QTextStringChar *start,
+						    QTextStringChar *last, int align, int space );
+#endif
+    void insertLineStart( QTextParagraph *parag, int index, QTextLineStart *ls );
+
+    int thisminw;
+    int thiswused;
+
+private:
+    bool wrapEnabled;
+    int wrapColumn;
+    bool biw;
+
+#ifdef HAVE_THAI_BREAKS
+    static QCString *thaiCache;
+    static QTextString *cachedString;
+    static ThBreakIterator *thaiIt;
+#endif
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextFormatterBreakInWords : public QTextFormatter
+{
+public:
+    QTextFormatterBreakInWords();
+    virtual ~QTextFormatterBreakInWords() {}
+
+    int format( QTextDocument *doc, QTextParagraph *parag, int start, const QMap<int, QTextLineStart*> &oldLineStarts );
+
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextFormatterBreakWords : public QTextFormatter
+{
+public:
+    QTextFormatterBreakWords();
+    virtual ~QTextFormatterBreakWords() {}
+
+    int format( QTextDocument *doc, QTextParagraph *parag, int start, const QMap<int, QTextLineStart*> &oldLineStarts );
+
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextIndent
+{
+public:
+    QTextIndent();
+    virtual ~QTextIndent() {}
+
+    virtual void indent( QTextDocument *doc, QTextParagraph *parag, int *oldIndent = 0, int *newIndent = 0 ) = 0;
+
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextPreProcessor
+{
+public:
+    enum Ids {
+	Standard = 0
+    };
+
+    QTextPreProcessor();
+    virtual ~QTextPreProcessor() {}
+
+    virtual void process( QTextDocument *doc, QTextParagraph *, int, bool = TRUE ) = 0;
+    virtual QTextFormat *format( int id ) = 0;
+
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+class Q_EXPORT QTextFormat
+{
+    friend class QTextFormatCollection;
+    friend class QTextDocument;
+
+public:
+    enum Flags {
+	NoFlags,
+	Bold = 1,
+	Italic = 2,
+	Underline = 4,
+	Family = 8,
+	Size = 16,
+	Color = 32,
+	Misspelled = 64,
+	VAlign = 128,
+	StrikeOut= 256,
+	Font = Bold | Italic | Underline | Family | Size | StrikeOut,
+	Format = Font | Color | Misspelled | VAlign
+    };
+
+    enum VerticalAlignment { AlignNormal, AlignSuperScript, AlignSubScript };
+
+    QTextFormat();
+    virtual ~QTextFormat();
+
+    QTextFormat( const QStyleSheetItem *s );
+    QTextFormat( const QFont &f, const QColor &c, QTextFormatCollection *parent = 0 );
+    QTextFormat( const QTextFormat &fm );
+    QTextFormat makeTextFormat( const QStyleSheetItem *style, const QMap<QString,QString>& attr, double scaleFontsFactor ) const;
+    QTextFormat& operator=( const QTextFormat &fm );
+    QColor color() const;
+    QFont font() const;
+    QFontMetrics fontMetrics() const { return fm; }
+    bool isMisspelled() const;
+    VerticalAlignment vAlign() const;
+    int minLeftBearing() const;
+    int minRightBearing() const;
+    int width( const QChar &c ) const;
+    int width( const QString &str, int pos ) const;
+    int height() const;
+    int ascent() const;
+    int descent() const;
+    int leading() const;
+    bool useLinkColor() const;
+
+    void setBold( bool b );
+    void setItalic( bool b );
+    void setUnderline( bool b );
+    void setStrikeOut( bool b );
+    void setFamily( const QString &f );
+    void setPointSize( int s );
+    void setFont( const QFont &f );
+    void setColor( const QColor &c );
+    void setMisspelled( bool b );
+    void setVAlign( VerticalAlignment a );
+
+    bool operator==( const QTextFormat &f ) const;
+    QTextFormatCollection *parent() const;
+    const QString &key() const;
+
+    static QString getKey( const QFont &f, const QColor &c, bool misspelled, VerticalAlignment vAlign );
+
+    void addRef();
+    void removeRef();
+
+    QString makeFormatChangeTags( QTextFormat* defaultFormat, QTextFormat *f, const QString& oldAnchorHref, const QString& anchorHref ) const;
+    QString makeFormatEndTags( QTextFormat* defaultFormat, const QString& anchorHref ) const;
+
+    static void setPainter( QPainter *p );
+    static QPainter* painter();
+
+    bool fontSizesInPixels() { return usePixelSizes; }
+
+protected:
+    virtual void generateKey();
+
+private:
+    void update();
+    static void applyFont( const QFont &f );
+
+private:
+    QFont fn;
+    QColor col;
+    QFontMetrics fm;
+    uint missp : 1;
+    uint linkColor : 1;
+    uint usePixelSizes : 1;
+    int leftBearing, rightBearing;
+    VerticalAlignment ha;
+    uchar widths[ 256 ];
+    int hei, asc, dsc;
+    QTextFormatCollection *collection;
+    int ref;
+    QString k;
+    int logicalFontSize;
+    int stdSize;
+    static QPainter *pntr;
+    static QFontMetrics *pntr_fm;
+    static int pntr_asc;
+    static int pntr_hei;
+    static int pntr_ldg;
+    static int pntr_dsc;
+
+};
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+#if defined(Q_TEMPLATEDLL)
+// MOC_SKIP_BEGIN
+Q_TEMPLATE_EXTERN template class Q_EXPORT QDict<QTextFormat>;
+// MOC_SKIP_END
+#endif
+
+class Q_EXPORT QTextFormatCollection
+{
+    friend class QTextDocument;
+    friend class QTextFormat;
+
+public:
+    QTextFormatCollection();
+    virtual ~QTextFormatCollection();
+
+    void setDefaultFormat( QTextFormat *f );
+    QTextFormat *defaultFormat() const;
+    virtual QTextFormat *format( QTextFormat *f );
+    virtual QTextFormat *format( QTextFormat *of, QTextFormat *nf, int flags );
+    virtual QTextFormat *format( const QFont &f, const QColor &c );
+    virtual void remove( QTextFormat *f );
+    virtual QTextFormat *createFormat( const QTextFormat &f ) { return new QTextFormat( f ); }
+    virtual QTextFormat *createFormat( const QFont &f, const QColor &c ) { return new QTextFormat( f, c, this ); }
+
+    void updateDefaultFormat( const QFont &font, const QColor &c, QStyleSheet *sheet );
+
+    QPaintDevice *paintDevice() const { return paintdevice; }
+    void setPaintDevice( QPaintDevice * );
+
+private:
+    void updateKeys();
+
+private:
+    QTextFormat *defFormat, *lastFormat, *cachedFormat;
+    QDict<QTextFormat> cKey;
+    QTextFormat *cres;
+    QFont cfont;
+    QColor ccol;
+    QString kof, knf;
+    int cflags;
+
+    QPaintDevice *paintdevice;
+};
+
+class Q_EXPORT QTextParagraphPseudoDocument
+{
+public:
+    QTextParagraphPseudoDocument();
+    ~QTextParagraphPseudoDocument();
+    QRect docRect;
+    QTextFormatter *pFormatter;
+    QTextCommandHistory *commandHistory;
+    int minw;
+    int wused;
+    QTextFormatCollection collection;
+};
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+inline int QTextParagraph::length() const
+{
+    return str->length();
+}
+
+inline QRect QTextParagraph::rect() const
+{
+    return r;
+}
+
+inline int QTextCursor::index() const
+{
+    return idx;
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+inline int QTextDocument::x() const
+{
+    return cx;
+}
+
+inline int QTextDocument::y() const
+{
+    return cy;
+}
+
+inline int QTextDocument::width() const
+{
+    return QMAX( cw, flow_->width() );
+}
+
+inline int QTextDocument::visibleWidth() const
+{
+    return vw;
+}
+
+inline QTextParagraph *QTextDocument::firstParagraph() const
+{
+    return fParag;
+}
+
+inline QTextParagraph *QTextDocument::lastParagraph() const
+{
+    return lParag;
+}
+
+inline void QTextDocument::setFirstParagraph( QTextParagraph *p )
+{
+    fParag = p;
+}
+
+inline void QTextDocument::setLastParagraph( QTextParagraph *p )
+{
+    lParag = p;
+}
+
+inline void QTextDocument::setWidth( int w )
+{
+    cw = QMAX( w, minw );
+    flow_->setWidth( cw );
+    vw = w;
+}
+
+inline int QTextDocument::minimumWidth() const
+{
+    return minw;
+}
+
+inline void QTextDocument::setY( int y )
+{
+    cy = y;
+}
+
+inline int QTextDocument::leftMargin() const
+{
+    return leftmargin;
+}
+
+inline void QTextDocument::setLeftMargin( int lm )
+{
+    leftmargin = lm;
+}
+
+inline int QTextDocument::rightMargin() const
+{
+    return rightmargin;
+}
+
+inline void QTextDocument::setRightMargin( int rm )
+{
+    rightmargin = rm;
+}
+
+inline QTextPreProcessor *QTextDocument::preProcessor() const
+{
+    return pProcessor;
+}
+
+inline void QTextDocument::setPreProcessor( QTextPreProcessor * sh )
+{
+    pProcessor = sh;
+}
+
+inline void QTextDocument::setFormatter( QTextFormatter *f )
+{
+    delete pFormatter;
+    pFormatter = f;
+}
+
+inline QTextFormatter *QTextDocument::formatter() const
+{
+    return pFormatter;
+}
+
+inline void QTextDocument::setIndent( QTextIndent *i )
+{
+    indenter = i;
+}
+
+inline QTextIndent *QTextDocument::indent() const
+{
+    return indenter;
+}
+
+inline QColor QTextDocument::selectionColor( int id ) const
+{
+    return selectionColors[ id ];
+}
+
+inline bool QTextDocument::invertSelectionText( int id ) const
+{
+    return selectionText[ id ];
+}
+
+inline void QTextDocument::setSelectionColor( int id, const QColor &c )
+{
+    selectionColors[ id ] = c;
+}
+
+inline void QTextDocument::setInvertSelectionText( int id, bool b )
+{
+    selectionText[ id ] = b;
+}
+
+inline QTextFormatCollection *QTextDocument::formatCollection() const
+{
+    return fCollection;
+}
+
+inline int QTextDocument::alignment() const
+{
+    return align;
+}
+
+inline void QTextDocument::setAlignment( int a )
+{
+    align = a;
+}
+
+inline int *QTextDocument::tabArray() const
+{
+    return tArray;
+}
+
+inline int QTextDocument::tabStopWidth() const
+{
+    return tStopWidth;
+}
+
+inline void QTextDocument::setTabArray( int *a )
+{
+    tArray = a;
+}
+
+inline void QTextDocument::setTabStops( int tw )
+{
+    tStopWidth = tw;
+}
+
+inline QString QTextDocument::originalText() const
+{
+    if ( oTextValid )
+	return oText;
+    return text();
+}
+
+inline void QTextDocument::setFlow( QTextFlow *f )
+{
+    if ( flow_ )
+	delete flow_;
+    flow_ = f;
+}
+
+inline void QTextDocument::takeFlow()
+{
+    flow_ = 0;
+}
+
+inline bool QTextDocument::useDoubleBuffer( QTextParagraph *parag, QPainter *p )
+{
+    return ( !parag->document()->parent() || parag->document()->nextDoubleBuffered ) &&
+	( !p || !p->device() || p->device()->devType() != QInternal::Printer );
+}
+
+// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+inline QColor QTextFormat::color() const
+{
+    return col;
+}
+
+inline QFont QTextFormat::font() const
+{
+    return fn;
+}
+
+inline bool QTextFormat::isMisspelled() const
+{
+    return missp;
+}
+
+inline QTextFormat::VerticalAlignment QTextFormat::vAlign() const
+{
+    return ha;
+}
+
+inline bool QTextFormat::operator==( const QTextFormat &f ) const
+{
+    return k == f.k;
+}
+
+inline QTextFormatCollection *QTextFormat::parent() const
+{
+    return collection;
+}
+
+inline void QTextFormat::addRef()
+{
+    ref++;
+}
+
+inline void QTextFormat::removeRef()
+{
+    ref--;
+    if ( !collection )
+	return;
+    if ( this == collection->defFormat )
+	return;
+    if ( ref == 0 )
+	collection->remove( this );
+}
+
+inline const QString &QTextFormat::key() const
+{
+    return k;
+}
+
+inline bool QTextFormat::useLinkColor() const
+{
+    return linkColor;
+}
+
+inline QTextStringChar *QTextParagraph::at( int i ) const
+{
+    return &str->at( i );
+}
+
+inline bool QTextParagraph::isValid() const
+{
+    return invalid == -1;
+}
+
+inline bool QTextParagraph::hasChanged() const
+{
+    return changed;
+}
+
+inline void QTextParagraph::setBackgroundColor( const QColor & c )
+{
+    delete bgcol;
+    bgcol = new QColor( c );
+    setChanged( TRUE );
+}
+
+inline void QTextParagraph::clearBackgroundColor()
+{
+    delete bgcol; bgcol = 0; setChanged( TRUE );
+}
+
+inline void QTextParagraph::append( const QString &s, bool reallyAtEnd )
+{
+    if ( reallyAtEnd )
+	insert( str->length(), s );
+    else
+	insert( QMAX( str->length() - 1, 0 ), s );
+}
+
+inline QTextParagraph *QTextParagraph::prev() const
+{
+    return p;
+}
+
+inline QTextParagraph *QTextParagraph::next() const
+{
+    return n;
+}
+
+inline bool QTextParagraph::hasAnySelection() const
+{
+    return mSelections ? !selections().isEmpty() : FALSE;
+}
+
+inline void QTextParagraph::setEndState( int s )
+{
+    if ( s == state )
+	return;
+    state = s;
+}
+
+inline int QTextParagraph::endState() const
+{
+    return state;
+}
+
+inline void QTextParagraph::setParagId( int i )
+{
+    id = i;
+}
+
+inline int QTextParagraph::paragId() const
+{
+    if ( id == -1 )
+	qWarning( "invalid parag id!!!!!!!! (%p)", (void*)this );
+    return id;
+}
+
+inline bool QTextParagraph::firstPreProcess() const
+{
+    return firstPProcess;
+}
+
+inline void QTextParagraph::setFirstPreProcess( bool b )
+{
+    firstPProcess = b;
+}
+
+inline QMap<int, QTextLineStart*> &QTextParagraph::lineStartList()
+{
+    return lineStarts;
+}
+
+inline QTextString *QTextParagraph::string() const
+{
+    return str;
+}
+
+inline QTextParagraphPseudoDocument *QTextParagraph::pseudoDocument() const
+{
+    if ( hasdoc )
+	return 0;
+    return (QTextParagraphPseudoDocument*) docOrPseudo;
+}
+
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+inline QTextTableCell *QTextParagraph::tableCell() const
+{
+    return hasdoc ? document()->tableCell () : 0;
+}
+#endif
+
+inline QTextCommandHistory *QTextParagraph::commands() const
+{
+    return hasdoc ? document()->commands() : pseudoDocument()->commandHistory;
+}
+
+
+inline int QTextParagraph::alignment() const
+{
+    return align;
+}
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+inline void QTextParagraph::registerFloatingItem( QTextCustomItem *i )
+{
+    floatingItems().append( i );
+}
+
+inline void QTextParagraph::unregisterFloatingItem( QTextCustomItem *i )
+{
+    floatingItems().removeRef( i );
+}
+#endif
+
+inline QBrush *QTextParagraph::background() const
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    return tableCell() ? tableCell()->backGround() : 0;
+#else
+    return 0;
+#endif
+}
+
+inline int QTextParagraph::documentWidth() const
+{
+    return hasdoc ? document()->width() : pseudoDocument()->docRect.width();
+}
+
+inline int QTextParagraph::documentVisibleWidth() const
+{
+    return hasdoc ? document()->visibleWidth() : pseudoDocument()->docRect.width();
+}
+
+inline int QTextParagraph::documentX() const
+{
+    return hasdoc ? document()->x() : pseudoDocument()->docRect.x();
+}
+
+inline int QTextParagraph::documentY() const
+{
+    return hasdoc ? document()->y() : pseudoDocument()->docRect.y();
+}
+
+inline void QTextParagraph::setExtraData( QTextParagraphData *data )
+{
+    eData = data;
+}
+
+inline QTextParagraphData *QTextParagraph::extraData() const
+{
+    return eData;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+inline void QTextFormatCollection::setDefaultFormat( QTextFormat *f )
+{
+    defFormat = f;
+}
+
+inline QTextFormat *QTextFormatCollection::defaultFormat() const
+{
+    return defFormat;
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+inline QTextFormat *QTextStringChar::format() const
+{
+    return (type == Regular) ? d.format : d.custom->format;
+}
+
+
+#ifndef QT_NO_TEXTCUSTOMITEM
+inline QTextCustomItem *QTextStringChar::customItem() const
+{
+    return isCustom() ? d.custom->custom : 0;
+}
+#endif
+
+inline int QTextStringChar::height() const
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    return !isCustom() ? format()->height() : ( customItem()->placement() == QTextCustomItem::PlaceInline ? customItem()->height : 0 );
+#else
+    return format()->height();
+#endif
+}
+
+inline int QTextStringChar::ascent() const
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    return !isCustom() ? format()->ascent() : ( customItem()->placement() == QTextCustomItem::PlaceInline ? customItem()->ascent() : 0 );
+#else
+    return format()->ascent();
+#endif
+}
+
+inline int QTextStringChar::descent() const
+{
+#ifndef QT_NO_TEXTCUSTOMITEM
+    return !isCustom() ? format()->descent() : 0;
+#else
+    return format()->descent();
+#endif
+}
+
+#endif //QT_NO_RICHTEXT
+
+#endif
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qt_kernel.pri qt-x11-free-3.3.8b/src/kernel/qt_kernel.pri
--- qt-x11-free-3.3.8b/src/kernel/qt_kernel.pri	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qt_kernel.pri	2009-10-18 14:38:39.235204247 -0700
@@ -35,5 +35,4 @@
 		  $$KERNEL_P/qimageformatinterface_p.h \
 		  $$KERNEL_H/qimageformatplugin.h \
-		  $$KERNEL_P/qinputcontext_p.h \
 		  $$KERNEL_H/qkeycode.h \
 		  $$KERNEL_H/qkeysequence.h \
@@ -100,4 +99,10 @@
 		  $$KERNEL_CPP/qtextlayout_p.h
 
+	unix:x11 {
+		HEADERS += $$KERNEL_H/qinputcontext.h
+	} else {
+		HEADERS += $$KERNEL_P/qinputcontext_p.h
+	}
+
 	win32:SOURCES += $$KERNEL_CPP/qapplication_win.cpp \
 		  $$KERNEL_CPP/qclipboard_win.cpp \
@@ -131,4 +136,5 @@
 			  $$KERNEL_CPP/qeventloop_x11.cpp \
 			  $$KERNEL_CPP/qfont_x11.cpp \
+			  $$KERNEL_CPP/qinputcontext.cpp \
 			  $$KERNEL_CPP/qinputcontext_x11.cpp \
 			  $$KERNEL_CPP/qmotifdnd_x11.cpp \
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget.cpp qt-x11-free-3.3.8b/src/kernel/qwidget.cpp
--- qt-x11-free-3.3.8b/src/kernel/qwidget.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget.cpp	2009-10-18 14:38:39.281857664 -0700
@@ -3286,6 +3286,22 @@
 	QWidget * prev = qApp->focus_widget;
 	if ( prev ) {
-	    if ( prev != this )
+	    // This part is never executed when Q_WS_X11? Preceding XFocusOut
+	    // had already reset focus_widget when received XFocusIn
+
+	    // Don't reset input context explicitly here. Whether reset or not
+	    // when focusing out is a responsibility of input methods. For
+	    // example, Japanese input context should not be reset here. The
+	    // context sometimes contains a whole paragraph and has minutes of
+	    // lifetime different to ephemeral one in other languages. The
+	    // input context should be survived until focused again. So we
+	    // delegate the responsibility to input context via
+	    // unfocusInputContext().
+	    if ( prev != this && prev->isInputMethodEnabled() ) {
+#if 0
 		prev->resetInputContext();
+#else
+		prev->unfocusInputContext();
+#endif
+	    }
 	}
 #if defined(Q_WS_WIN)
@@ -3295,7 +3311,6 @@
 #endif
 	qApp->focus_widget = this;
-#if defined(Q_WS_X11)
-	focusInputContext();
-#endif
+	if( isInputMethodEnabled() )
+	    focusInputContext();
 
 #if defined(Q_WS_WIN)
@@ -3345,5 +3360,9 @@
 	return;
     } else if ( hasFocus() ) {
+#if !defined(Q_WS_X11)
         resetInputContext();
+#else
+	unfocusInputContext();
+#endif
 	QWidget* w = qApp->focusWidget();
 	// clear active focus
@@ -4671,5 +4690,11 @@
 
 	case QEvent::MouseButtonPress:
+	    // Don't reset input context here. Whether reset or not is
+	    // a responsibility of input method. reset() will be
+	    // called by mouseHandler() of input method if necessary
+	    // via mousePressEvent() of text widgets.
+#if 0
 	    resetInputContext();
+#endif
 	    mousePressEvent( (QMouseEvent*)e );
 	    if ( ! ((QMouseEvent*)e)->isAccepted() )
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget.cpp.orig qt-x11-free-3.3.8b/src/kernel/qwidget.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qwidget.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,6056 @@
+/****************************************************************************
+**
+** Implementation of QWidget class
+**
+** Created : 931031
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+
+#include "qobjectlist.h"
+#include "qwidget.h"
+#include "qwidgetlist.h"
+#include "qwidgetintdict.h"
+#include "qptrdict.h"
+#include "qfocusdata.h"
+#include "qcursor.h"
+#include "qpixmap.h"
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qbrush.h"
+#include "qlayout.h"
+#include "qstylefactory.h"
+#include "qcleanuphandler.h"
+#include "qstyle.h"
+#include "qmetaobject.h"
+#include "qguardedptr.h"
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+#include "qaccessible.h"
+#endif
+#if defined(Q_WS_WIN)
+#include "qt_windows.h"
+#include "qinputcontext_p.h"
+#endif
+#if defined(Q_WS_QWS)
+#include "qwsmanager_qws.h"
+#endif
+#include "qfontdata_p.h"
+
+
+/*!
+    \class QWidget qwidget.h
+    \brief The QWidget class is the base class of all user interface objects.
+
+    \ingroup abstractwidgets
+    \mainclass
+
+    The widget is the atom of the user interface: it receives mouse,
+    keyboard and other events from the window system, and paints a
+    representation of itself on the screen. Every widget is
+    rectangular, and they are sorted in a Z-order. A widget is
+    clipped by its parent and by the widgets in front of it.
+
+    A widget that isn't embedded in a parent widget is called a
+    top-level widget. Usually, top-level widgets are windows with a
+    frame and a title bar (although it is also possible to create
+    top-level widgets without such decoration if suitable widget flags
+    are used). In Qt, QMainWindow and the various subclasses of
+    QDialog are the most common top-level windows.
+
+    A widget without a parent widget is always a top-level widget.
+
+    Non-top-level widgets are child widgets. These are child windows
+    in their parent widgets. You cannot usually distinguish a child
+    widget from its parent visually. Most other widgets in Qt are
+    useful only as child widgets. (It is possible to make, say, a
+    button into a top-level widget, but most people prefer to put
+    their buttons inside other widgets, e.g. QDialog.)
+
+    If you want to use a QWidget to hold child widgets you will
+    probably want to add a layout to the parent QWidget. (See \link
+    layout.html Layouts\endlink.)
+
+    QWidget has many member functions, but some of them have little
+    direct functionality: for example, QWidget has a font property,
+    but never uses this itself. There are many subclasses which
+    provide real functionality, such as QPushButton, QListBox and
+    QTabDialog, etc.
+
+    \section1 Groups of functions:
+
+    \table
+    \header \i Context \i Functions
+
+    \row \i Window functions \i
+	show(),
+	hide(),
+	raise(),
+	lower(),
+	close().
+
+    \row \i Top level windows \i
+	caption(),
+	setCaption(),
+	icon(),
+	setIcon(),
+	iconText(),
+	setIconText(),
+	isActiveWindow(),
+	setActiveWindow(),
+	showMinimized().
+	showMaximized(),
+	showFullScreen(),
+	showNormal().
+
+    \row \i Window contents \i
+	update(),
+	repaint(),
+	erase(),
+	scroll(),
+	updateMask().
+
+    \row \i Geometry \i
+	pos(),
+	size(),
+	rect(),
+	x(),
+	y(),
+	width(),
+	height(),
+	sizePolicy(),
+	setSizePolicy(),
+	sizeHint(),
+	updateGeometry(),
+	layout(),
+	move(),
+	resize(),
+	setGeometry(),
+	frameGeometry(),
+	geometry(),
+	childrenRect(),
+	adjustSize(),
+	mapFromGlobal(),
+	mapFromParent()
+	mapToGlobal(),
+	mapToParent(),
+	maximumSize(),
+	minimumSize(),
+	sizeIncrement(),
+	setMaximumSize(),
+	setMinimumSize(),
+	setSizeIncrement(),
+	setBaseSize(),
+	setFixedSize()
+
+    \row \i Mode \i
+	isVisible(),
+	isVisibleTo(),
+	isMinimized(),
+	isDesktop(),
+	isEnabled(),
+	isEnabledTo(),
+	isModal(),
+	isPopup(),
+	isTopLevel(),
+	setEnabled(),
+	hasMouseTracking(),
+	setMouseTracking(),
+	isUpdatesEnabled(),
+	setUpdatesEnabled(),
+	clipRegion().
+
+    \row \i Look and feel \i
+	style(),
+	setStyle(),
+	cursor(),
+	setCursor()
+	font(),
+	setFont(),
+	palette(),
+	setPalette(),
+	backgroundMode(),
+	setBackgroundMode(),
+	colorGroup(),
+	fontMetrics(),
+	fontInfo().
+
+    \row \i Keyboard focus<br>functions \i
+	isFocusEnabled(),
+	setFocusPolicy(),
+	focusPolicy(),
+	hasFocus(),
+	setFocus(),
+	clearFocus(),
+	setTabOrder(),
+	setFocusProxy().
+
+    \row \i Mouse and<br>keyboard grabbing \i
+	grabMouse(),
+	releaseMouse(),
+	grabKeyboard(),
+	releaseKeyboard(),
+	mouseGrabber(),
+	keyboardGrabber().
+
+    \row \i Event handlers \i
+	event(),
+	mousePressEvent(),
+	mouseReleaseEvent(),
+	mouseDoubleClickEvent(),
+	mouseMoveEvent(),
+	keyPressEvent(),
+	keyReleaseEvent(),
+	focusInEvent(),
+	focusOutEvent(),
+	wheelEvent(),
+	enterEvent(),
+	leaveEvent(),
+	paintEvent(),
+	moveEvent(),
+	resizeEvent(),
+	closeEvent(),
+	dragEnterEvent(),
+	dragMoveEvent(),
+	dragLeaveEvent(),
+	dropEvent(),
+	childEvent(),
+	showEvent(),
+	hideEvent(),
+	customEvent().
+
+    \row \i Change handlers \i
+	enabledChange(),
+	fontChange(),
+	paletteChange(),
+	styleChange(),
+	windowActivationChange().
+
+    \row \i System functions \i
+	parentWidget(),
+	topLevelWidget(),
+	reparent(),
+	polish(),
+	winId(),
+	find(),
+	metric().
+
+    \row \i What's this help \i
+	customWhatsThis()
+
+    \row \i Internal kernel<br>functions \i
+	focusNextPrevChild(),
+	wmapper(),
+	clearWFlags(),
+	getWFlags(),
+	setWFlags(),
+	testWFlags().
+
+    \endtable
+
+    Every widget's constructor accepts two or three standard arguments:
+    \list 1
+    \i \c{QWidget *parent = 0} is the parent of the new widget.
+    If it is 0 (the default), the new widget will be a top-level window.
+    If not, it will be a child of \e parent, and be constrained by \e
+    parent's geometry (unless you specify \c WType_TopLevel as
+    widget flag).
+    \i \c{const char *name = 0} is the widget name of the new
+    widget. You can access it using name(). The widget name is little
+    used by programmers but is quite useful with GUI builders such as
+    \e{Qt Designer} (you can name a widget in \e{Qt Designer}, and
+    connect() to it using the name in your code). The dumpObjectTree()
+    debugging function also uses it.
+    \i \c{WFlags f = 0} (where available) sets the widget flags; the
+    default is suitable for almost all widgets, but to get, for
+    example, a top-level widget without a window system frame, you
+    must use special flags.
+    \endlist
+
+    The tictac/tictac.cpp example program is good example of a simple
+    widget. It contains a few event handlers (as all widgets must), a
+    few custom routines that are specific to it (as all useful widgets
+    do), and has a few children and connections. Everything it does
+    is done in response to an event: this is by far the most common way
+    to design GUI applications.
+
+    You will need to supply the content for your widgets yourself, but
+    here is a brief run-down of the events, starting with the most common
+    ones:
+
+    \list
+
+    \i paintEvent() - called whenever the widget needs to be
+    repainted. Every widget which displays output must implement it,
+    and it is wise \e not to paint on the screen outside
+    paintEvent().
+
+    \i resizeEvent() - called when the widget has been resized.
+
+    \i mousePressEvent() - called when a mouse button is pressed.
+    There are six mouse-related events, but the mouse press and mouse
+    release events are by far the most important. A widget receives
+    mouse press events when the mouse is inside it, or when it has
+    grabbed the mouse using grabMouse().
+
+    \i mouseReleaseEvent() - called when a mouse button is released.
+    A widget receives mouse release events when it has received the
+    corresponding mouse press event. This means that if the user
+    presses the mouse inside \e your widget, then drags the mouse to
+    somewhere else, then releases, \e your widget receives the release
+    event. There is one exception: if a popup menu appears while the
+    mouse button is held down, this popup immediately steals the mouse
+    events.
+
+    \i mouseDoubleClickEvent() - not quite as obvious as it might seem.
+    If the user double-clicks, the widget receives a mouse press event
+    (perhaps a mouse move event or two if they don't hold the mouse
+    quite steady), a mouse release event and finally this event. It is
+    \e{not possible} to distinguish a click from a double click until you've
+    seen whether the second click arrives. (This is one reason why most GUI
+    books recommend that double clicks be an extension of single clicks,
+    rather than trigger a different action.)
+
+    \endlist
+
+    If your widget only contains child widgets, you probably do not need to
+    implement any event handlers. If you want to detect a mouse click in
+    a child widget call the child's hasMouse() function inside the
+    parent widget's mousePressEvent().
+
+    Widgets that accept keyboard input need to reimplement a few more
+    event handlers:
+
+    \list
+
+    \i keyPressEvent() - called whenever a key is pressed, and again
+    when a key has been held down long enough for it to auto-repeat.
+    Note that the Tab and Shift+Tab keys are only passed to the widget
+    if they are not used by the focus-change mechanisms. To force those
+    keys to be processed by your widget, you must reimplement
+    QWidget::event().
+
+    \i focusInEvent() - called when the widget gains keyboard focus
+    (assuming you have called setFocusPolicy()). Well written widgets
+    indicate that they own the keyboard focus in a clear but discreet
+    way.
+
+    \i focusOutEvent() - called when the widget loses keyboard focus.
+
+    \endlist
+
+    Some widgets will also need to reimplement some of the less common
+    event handlers:
+
+    \list
+
+    \i mouseMoveEvent() - called whenever the mouse moves while a
+    button is held down. This is useful for, for example, dragging. If
+    you call setMouseTracking(TRUE), you get mouse move events even
+    when no buttons are held down. (Note that applications which make
+    use of mouse tracking are often not very useful on low-bandwidth X
+    connections.) (See also the \link dnd.html drag and drop\endlink
+    information.)
+
+    \i keyReleaseEvent() - called whenever a key is released, and also
+    while it is held down if the key is auto-repeating. In that case
+    the widget receives a key release event and immediately a key press
+    event for every repeat. Note that the Tab and Shift+Tab keys are
+    only passed to the widget if they are not used by the focus-change
+    mechanisms. To force those keys to be processed by your widget, you
+    must reimplement QWidget::event().
+
+    \i wheelEvent() -- called whenever the user turns the mouse wheel
+    while the widget has the focus.
+
+    \i enterEvent() - called when the mouse enters the widget's screen
+    space. (This excludes screen space owned by any children of the
+    widget.)
+
+    \i leaveEvent() - called when the mouse leaves the widget's screen
+    space.
+
+    \i moveEvent() - called when the widget has been moved relative to its
+    parent.
+
+    \i closeEvent() - called when the user closes the widget (or when
+    close() is called).
+
+    \endlist
+
+    There are also some rather obscure events. They are listed in
+    \c qevent.h and you need to reimplement event() to handle them.
+    The default implementation of event() handles Tab and Shift+Tab
+    (to move the keyboard focus), and passes on most other events to
+    one of the more specialized handlers above.
+
+    When implementing a widget, there are a few more things to
+    consider.
+
+    \list
+
+    \i In the constructor, be sure to set up your member variables
+    early on, before there's any chance that you might receive an event.
+
+    \i It is almost always useful to reimplement sizeHint() and to set
+    the correct size policy with setSizePolicy(), so users of your class
+    can set up layout management more easily. A size policy lets you
+    supply good defaults for the layout management handling, so that
+    other widgets can contain and manage yours easily. sizeHint()
+    indicates a "good" size for the widget.
+
+    \i If your widget is a top-level window, setCaption() and setIcon() set
+    the title bar and icon respectively.
+
+    \endlist
+
+    \sa QEvent, QPainter, QGridLayout, QBoxLayout
+*/
+
+
+/*****************************************************************************
+  Internal QWidgetMapper class
+
+  The purpose of this class is to map widget identifiers to QWidget objects.
+  All QWidget objects register themselves in the QWidgetMapper when they
+  get an identifier. Widgets unregister themselves when they change ident-
+  ifier or when they are destroyed. A widget identifier is really a window
+  handle.
+
+  The widget mapper is created and destroyed by the main application routines
+  in the file qapp_xxx.cpp.
+ *****************************************************************************/
+
+#if defined(Q_WS_QWS) || defined(Q_OS_TEMP)
+static const int WDictSize = 163; // plenty for small devices
+#else
+static const int WDictSize = 1123; // plenty for 5 big complex windows
+#endif
+
+class QWidgetMapper : public QWidgetIntDict
+{						// maps ids -> widgets
+public:
+    QWidgetMapper();
+   ~QWidgetMapper();
+    QWidget *find( WId id );		// find widget
+    void     insert( const QWidget * );		// insert widget
+    bool     remove( WId id );		// remove widget
+private:
+    WId	     cur_id;
+    QWidget *cur_widget;
+};
+
+QWidgetMapper *QWidget::mapper = 0;		// app global widget mapper
+
+
+QWidgetMapper::QWidgetMapper() : QWidgetIntDict(WDictSize)
+{
+    cur_id = 0;
+    cur_widget = 0;
+}
+
+QWidgetMapper::~QWidgetMapper()
+{
+    clear();
+}
+
+inline QWidget *QWidgetMapper::find( WId id )
+{
+    if ( id != cur_id ) {			// need to lookup
+	cur_widget = QWidgetIntDict::find((long)id);
+	if ( cur_widget )
+	    cur_id = id;
+	else
+	    cur_id = 0;
+    }
+    return cur_widget;
+}
+
+inline void QWidgetMapper::insert( const QWidget *widget )
+{
+    QWidgetIntDict::insert((long)widget->winId(),widget);
+}
+
+inline bool QWidgetMapper::remove( WId id )
+{
+    if ( cur_id == id ) {			// reset current widget
+	cur_id = 0;
+	cur_widget = 0;
+    }
+    return QWidgetIntDict::remove((long)id);
+}
+
+
+/*****************************************************************************
+  QWidget utility functions
+ *****************************************************************************/
+
+static QFont qt_naturalWidgetFont( QWidget* w ) {
+    QFont naturalfont = QApplication::font( w );
+    if ( ! w->isTopLevel() ) {
+	if ( ! naturalfont.isCopyOf( QApplication::font() ) )
+	    naturalfont = naturalfont.resolve( w->parentWidget()->font() );
+	else
+	    naturalfont = w->parentWidget()->font();
+    }
+    return naturalfont;
+}
+
+#ifndef QT_NO_PALETTE
+static QPalette qt_naturalWidgetPalette( QWidget* w ) {
+    QPalette naturalpalette = QApplication::palette( w );
+    if ( !w->isTopLevel() && naturalpalette.isCopyOf( QApplication::palette() ) )
+	naturalpalette = w->parentWidget()->palette();
+    return naturalpalette;
+}
+#endif
+
+QSize qt_naturalWidgetSize( QWidget *w ) {
+    QSize s = w->sizeHint();
+    QSizePolicy::ExpandData exp;
+#ifndef QT_NO_LAYOUT
+    if ( w->layout() ) {
+	if ( w->layout()->hasHeightForWidth() )
+	    s.setHeight( w->layout()->totalHeightForWidth( s.width() ) );
+	exp = w->layout()->expanding();
+    } else
+#endif
+    {
+	if ( w->sizePolicy().hasHeightForWidth() )
+	    s.setHeight( w->heightForWidth( s.width() ) );
+	exp = w->sizePolicy().expanding();
+    }
+    if ( exp & QSizePolicy::Horizontally )
+	s.setWidth( QMAX( s.width(), 200 ) );
+    if ( exp & QSizePolicy::Vertically )
+	s.setHeight( QMAX( s.height(), 150 ) );
+#if defined(Q_WS_X11)
+    QRect screen = QApplication::desktop()->screenGeometry( w->x11Screen() );
+#else // all others
+    QRect screen = QApplication::desktop()->screenGeometry( w->pos() );
+#endif
+    s.setWidth( QMIN( s.width(), screen.width()*2/3 ) );
+    s.setHeight( QMIN( s.height(), screen.height()*2/3 ) );
+    return s;
+}
+
+/*****************************************************************************
+  QWidget member functions
+ *****************************************************************************/
+
+/*
+    Widget state flags:
+  \list
+  \i WState_Created The widget has a valid winId().
+  \i WState_Disabled The widget does not receive any mouse or keyboard
+  events.
+  \i WState_ForceDisabled The widget is explicitly disabled, i.e. it
+  will remain disabled even when all its ancestors are set to the enabled
+  state. This implies WState_Disabled.
+  \i WState_Visible The widget is currently visible.
+  \i WState_ForceHide The widget is explicitly hidden, i.e. it won't
+  become visible unless you call show() on it. WState_ForceHide
+  implies !WState_Visible.
+  \i WState_OwnCursor A cursor has been set for this widget.
+  \i WState_MouseTracking Mouse tracking is enabled.
+  \i WState_CompressKeys Compress keyboard events.
+  \i WState_BlockUpdates Repaints and updates are disabled.
+  \i WState_InPaintEvent Currently processing a paint event.
+  \i WState_Reparented The widget has been reparented.
+  \i WState_ConfigPending A configuration (resize/move) event is pending.
+  \i WState_Resized The widget has been resized.
+  \i WState_AutoMask The widget has an automatic mask, see setAutoMask().
+  \i WState_Polished The widget has been "polished" (i.e. late
+  initialization) by a QStyle.
+  \i WState_DND The widget supports drag and drop, see setAcceptDrops().
+  \i WState_Exposed the widget was finally exposed (X11 only,
+      helps avoid paint event doubling).
+  \i WState_HasMouse The widget is under the mouse cursor.
+  \endlist
+*/
+
+/*! \enum Qt::WFlags
+    \internal */
+/*! \enum Qt::WState
+    \internal */
+
+/*!
+    \enum Qt::WidgetFlags
+
+    \keyword widget flag
+
+    This enum type is used to specify various window-system properties
+    for the widget. They are fairly unusual but necessary in a few
+    cases. Some of these flags depend on whether the underlying window
+    manager supports them. (See the \link toplevel-example.html
+    toplevel example\endlink for an explanation and example of their
+    use.)
+
+    The main types are
+
+    \value WType_TopLevel  indicates that this widget is a top-level
+    widget, usually with a window-system frame and so on.
+
+    \value WType_Dialog  indicates that this widget is a top-level
+    window that should be decorated as a dialog (i.e. typically no
+    maximize or minimize buttons in the title bar). If you want to use
+    it as a modal dialog it should be launched from another window, or
+    have a parent and this flag should be combined with \c WShowModal.
+    If you make it modal, the dialog will prevent other top-level
+    windows in the application from getting any input. \c WType_Dialog
+    implies \c WType_TopLevel. We refer to a top-level window that has
+    a parent as a \e secondary window. (See also \c WGroupLeader.)
+
+    \value WType_Popup  indicates that this widget is a popup
+    top-level window, i.e. that it is modal, but has a window system
+    frame appropriate for popup menus. \c WType_Popup implies
+    WType_TopLevel.
+
+    \value WType_Desktop  indicates that this widget is the desktop.
+    See also \c WPaintDesktop below. \c WType_Desktop implies \c
+    WType_TopLevel.
+
+    There are also a number of flags which you can use to customize
+    the appearance of top-level windows. These have no effect on other
+    windows:
+
+    \value WStyle_Customize  indicates that the \c WStyle_* flags
+    should be used to build the window instead of the default flags.
+
+    \value WStyle_NormalBorder  gives the window a normal border.
+    This cannot be combined with \c WStyle_DialogBorder or \c
+    WStyle_NoBorder.
+
+    \value WStyle_DialogBorder  gives the window a thin dialog border.
+    This cannot be combined with \c WStyle_NormalBorder or \c
+    WStyle_NoBorder.
+
+    \value WStyle_NoBorder  produces a borderless window. Note that
+    the user cannot move or resize a borderless window via the window
+    system. This cannot be combined with \c WStyle_NormalBorder or \c
+    WStyle_DialogBorder. On Windows, the flag works fine. On X11, the
+    result of the flag is dependent on the window manager and its
+    ability to understand MOTIF and/or NETWM hints: most existing
+    modern window managers can handle this. With \c WX11BypassWM, you
+    can bypass the window manager completely. This results in a
+    borderless window that is not managed at all (i.e. no keyboard
+    input unless you call setActiveWindow() manually).
+
+    \value WStyle_NoBorderEx  this value is obsolete. It has the same
+    effect as using \c WStyle_NoBorder.
+
+    \value WStyle_Title  gives the window a title bar.
+
+    \value WStyle_SysMenu  adds a window system menu.
+
+    \value WStyle_Minimize  adds a minimize button. Note that on
+    Windows this has to be combined with \c WStyle_SysMenu for it to
+    work.
+
+    \value WStyle_Maximize  adds a maximize button. Note that on
+    Windows this has to be combined with \c WStyle_SysMenu for it to work.
+
+    \value WStyle_MinMax  is equal to \c
+    WStyle_Minimize|WStyle_Maximize. Note that on Windows this has to
+    be combined with \c WStyle_SysMenu to work.
+
+    \value WStyle_ContextHelp  adds a context help button to dialogs.
+
+    \value WStyle_Tool  makes the window a tool window. A tool window
+    is often a small window with a smaller than usual title bar and
+    decoration, typically used for collections of tool buttons. It
+    there is a parent, the tool window will always be kept on top of
+    it. If there isn't a parent, you may consider passing \c
+    WStyle_StaysOnTop as well. If the window system supports it, a
+    tool window can be decorated with a somewhat lighter frame. It can
+    also be combined with \c WStyle_NoBorder.
+
+    \value WStyle_StaysOnTop  informs the window system that the
+    window should stay on top of all other windows. Note that on some
+    window managers on X11 you also have to pass \c WX11BypassWM for
+    this flag to work correctly.
+
+    \value WStyle_Dialog  indicates that the window is a logical
+    subwindow of its parent (i.e. a dialog). The window will not get
+    its own taskbar entry and will be kept on top of its parent by the
+    window system. Usually it will also be minimized when the parent
+    is minimized. If not customized, the window is decorated with a
+    slightly simpler title bar. This is the flag QDialog uses.
+
+    \value WStyle_Splash  indicates that the window is a splash screen.
+    On X11, we try to follow NETWM standard for a splash screen window if the
+    window manager supports is otherwise it is equivalent to \c WX11BypassWM. On
+    other platforms, it is equivalent to \c WStyle_NoBorder \c | \c WMacNoSheet \c |
+    \c WStyle_Tool \c | \c WWinOwnDC
+
+    Modifier flags:
+
+    \value WDestructiveClose  makes Qt delete this widget when the
+    widget has accepted closeEvent(), or when the widget tried to
+    ignore closeEvent() but could not.
+
+    \value WPaintDesktop  gives this widget paint events for the
+    desktop.
+
+    \value WPaintUnclipped  makes all painters operating on this
+    widget unclipped. Children of this widget or other widgets in
+    front of it do not clip the area the painter can paint on.
+
+    \value WPaintClever  indicates that Qt should \e not try to
+    optimize repainting for the widget, but instead pass on window
+    system repaint events directly. (This tends to produce more events
+    and smaller repaint regions.)
+
+    \value WMouseNoMask  indicates that even if the widget has a mask,
+    it wants mouse events for its entire rectangle.
+
+    \value WStaticContents  indicates that the widget contents are
+    north-west aligned and static. On resize, such a widget will
+    receive paint events only for the newly visible part of itself.
+
+    \value WNoAutoErase indicates that the widget paints all its
+    pixels. Updating, resizing, scrolling and focus changes should
+    therefore not erase the widget. This allows smart-repainting to
+    avoid flicker.
+
+    \value WResizeNoErase  this value is obsolete; use WNoAutoErase instead.
+    \value WRepaintNoErase  this value is obsolete; use WNoAutoErase instead.
+    \value WGroupLeader  makes this window a group leader. A group
+    leader should \e not have a parent (i.e. it should be a top-level
+    window). Any decendant windows (direct or indirect) of a group
+    leader are in its group; other windows are not. If you show a
+    secondary window from the group (i.e. show a window whose top-most
+    parent is a group leader), that window will be modal with respect
+    to the other windows in the group, but modeless with respect to
+    windows in other groups.
+
+    Miscellaneous flags
+
+    \value WShowModal see WType_Dialog
+
+    Internal flags.
+
+    \value WNoMousePropagation
+    \value WStaticContents
+    \value WStyle_Reserved
+    \value WSubWindow
+    \value WType_Modal
+    \value WWinOwnDC
+    \value WX11BypassWM
+    \value WMacNoSheet
+    \value WMacDrawer
+    \value WStyle_Mask
+    \value WType_Mask
+
+*/
+
+/*!
+    \enum Qt::WidgetState
+
+    Internal flags.
+
+    \value WState_Created
+    \value WState_Disabled
+    \value WState_Visible
+    \value WState_ForceHide
+    \value WState_OwnCursor
+    \value WState_MouseTracking
+    \value WState_CompressKeys
+    \value WState_BlockUpdates
+    \value WState_InPaintEvent
+    \value WState_Reparented
+    \value WState_ConfigPending
+    \value WState_Resized
+    \value WState_AutoMask
+    \value WState_Polished
+    \value WState_DND
+    \value WState_Reserved0 \e internal
+    \value WState_CreatedHidden
+    \value WState_Maximized
+    \value WState_Minimized
+    \value WState_ForceDisabled
+    \value WState_Exposed
+    \value WState_HasMouse
+    \value WState_CreatedHidden
+    \value WState_OwnSizePolicy
+    \value WState_FullScreen
+*/
+
+
+/*!
+    \enum Qt::WindowState
+
+    \keyword window state
+
+    This enum type is used to specify the current state of a top-level
+    window.
+
+    The states are
+
+    \value WindowNoState   The window has no state set (in normal state).
+    \value WindowMinimized The window is minimized (i.e. iconified).
+    \value WindowMaximized The window is maximized with a frame around it.
+    \value WindowFullScreen The window fills the entire screen without any frame around it.
+    \value WindowActive The window is the active window, i.e. it has keyboard focus.
+
+*/
+
+/*!
+    Constructs a widget which is a child of \a parent, with the name
+    \a name and widget flags set to \a f.
+
+    If \a parent is 0, the new widget becomes a top-level window. If
+    \a parent is another widget, this widget becomes a child window
+    inside \a parent. The new widget is deleted when its \a parent is
+    deleted.
+
+    The \a name is sent to the QObject constructor.
+
+    The widget flags argument, \a f, is normally 0, but it can be set
+    to customize the window frame of a top-level widget (i.e. \a
+    parent must be 0). To customize the frame, set the \c
+    WStyle_Customize flag OR'ed with any of the \l Qt::WidgetFlags.
+
+    If you add a child widget to an already visible widget you must
+    explicitly show the child to make it visible.
+
+    Note that the X11 version of Qt may not be able to deliver all
+    combinations of style flags on all systems. This is because on
+    X11, Qt can only ask the window manager, and the window manager
+    can override the application's settings. On Windows, Qt can set
+    whatever flags you want.
+
+    Example:
+    \code
+    QLabel *splashScreen = new QLabel( 0, "mySplashScreen",
+				WStyle_Customize | WStyle_Splash );
+    \endcode
+*/
+
+QWidget::QWidget( QWidget *parent, const char *name, WFlags f )
+    : QObject( parent, name ), QPaintDevice( QInternal::Widget )
+{
+#if defined(QT_CHECK_STATE) && !defined(Q_WS_WIN)
+    if ( qApp->type() == QApplication::Tty ) {
+	qWarning( "QWidget: Cannot create a QWidget when no GUI "
+		  "is being used" );
+    }
+#endif
+
+    fstrut_dirty = 1;
+
+    isWidget = TRUE;				// is a widget
+    winid = 0;					// default attributes
+    widget_state = 0;
+    widget_flags = f;
+    focus_policy = 0;
+    own_font = 0;
+    own_palette = 0;
+    sizehint_forced = 0;
+    is_closing = 0;
+    in_show = 0;
+    in_show_maximized = 0;
+    im_enabled = FALSE;
+#ifndef QT_NO_LAYOUT
+    lay_out = 0;
+#endif
+    extra = 0;					// no extra widget info
+#ifndef QT_NO_PALETTE
+    bg_col = pal.active().background();		// default background color
+#endif
+    create();					// platform-dependent init
+#ifndef QT_NO_PALETTE
+    pal = isTopLevel() ? QApplication::palette() : parentWidget()->palette();
+#endif
+    if ( ! isTopLevel() )
+	fnt = parentWidget()->font();
+#if defined(Q_WS_X11)
+    fnt.x11SetScreen( x11Screen() );
+#endif // Q_WS_X11
+
+    if ( !isDesktop() )
+	setBackgroundFromMode(); //### parts of this are done in create but not all (see reparent(...) )
+    // make sure move/resize events are sent to all widgets
+    QApplication::postEvent( this, new QMoveEvent( crect.topLeft(),
+						   crect.topLeft() ) );
+    QApplication::postEvent( this, new QResizeEvent(crect.size(),
+						    crect.size()) );
+    if ( isTopLevel() ) {
+	setWState( WState_ForceHide | WState_CreatedHidden );
+	QFocusData *fd = focusData( TRUE );
+	if ( fd->focusWidgets.findRef(this) < 0 )
+	    fd->focusWidgets.append( this );
+    } else {
+	// propagate enabled state
+	if ( !parentWidget()->isEnabled() )
+	    setWState( WState_Disabled );
+	// new widgets do not show up in already visible parents
+	if ( parentWidget()->isVisible() )
+	    setWState( WState_ForceHide | WState_CreatedHidden );
+    }
+    if ( ++instanceCounter > maxInstances )
+    	maxInstances = instanceCounter;
+}
+
+/*!
+    Destroys the widget.
+
+    All this widget's children are deleted first. The application
+    exits if this widget is the main widget.
+*/
+
+QWidget::~QWidget()
+{
+#if defined (QT_CHECK_STATE)
+    if ( paintingActive() )
+	qWarning( "%s (%s): deleted while being painted", className(), name() );
+#endif
+
+    // Remove myself and all children from the can-take-focus list
+    QFocusData *f = focusData( FALSE );
+    if ( f ) {
+	QPtrListIterator<QWidget> it(f->focusWidgets);
+	QWidget *w;
+	while ( (w = it.current()) ) {
+	    ++it;
+	    QWidget * p = w;
+	    while( p && p != this )
+		p = p->parentWidget();
+	    if ( p ) // my descendant
+		f->focusWidgets.removeRef( w );
+	}
+    }
+    --instanceCounter;
+
+    if ( QApplication::main_widget == this ) {	// reset main widget
+	QApplication::main_widget = 0;
+	if (qApp)
+	    qApp->quit();
+    }
+
+    if ( hasFocus() )
+	clearFocus();
+
+    if ( isTopLevel() && isShown() && winId() )
+	hide();
+
+    // A parent widget must destroy all its children before destroying itself
+    if ( childObjects ) {			// delete children objects
+	QObjectListIt it(*childObjects);
+	QObject *obj;
+	while ( (obj=it.current()) ) {
+	    ++it;
+	    obj->parentObj = 0;
+	    childObjects->removeRef( obj );
+	    delete obj;
+	}
+	delete childObjects;
+	childObjects = 0;
+    }
+
+    QApplication::removePostedEvents( this );
+
+    destroy();					// platform-dependent cleanup
+    if ( extra )
+	deleteExtra();
+}
+
+int QWidget::instanceCounter = 0;  // Current number of widget instances
+int QWidget::maxInstances = 0;     // Maximum number of widget instances
+
+/*!
+  \internal
+  Creates the global widget mapper.
+  The widget mapper converts window handles to widget pointers.
+  \sa destroyMapper()
+*/
+
+void QWidget::createMapper()
+{
+    mapper = new QWidgetMapper;
+    Q_CHECK_PTR( mapper );
+}
+
+/*!
+  \internal
+  Destroys the global widget mapper.
+  \sa createMapper()
+*/
+
+void QWidget::destroyMapper()
+{
+    if ( !mapper )				// already gone
+	return;
+    QWidgetIntDictIt it( *((QWidgetIntDict*)mapper) );
+    QWidgetMapper * myMapper = mapper;
+    mapper = 0;
+    register QWidget *w;
+    while ( (w=it.current()) ) {		// remove parents widgets
+	++it;
+	if ( !w->parentObj )			// widget is a parent
+	    w->destroy( TRUE, TRUE );
+    }
+    delete myMapper;
+}
+
+
+static QWidgetList *wListInternal( QWidgetMapper *mapper, bool onlyTopLevel )
+{
+    QWidgetList *list = new QWidgetList;
+    Q_CHECK_PTR( list );
+    if ( mapper ) {
+	QWidget *w;
+	QWidgetIntDictIt it( *((QWidgetIntDict*)mapper) );
+	while ( (w=it.current()) ) {
+	    ++it;
+	    if ( !onlyTopLevel || w->isTopLevel() )
+		list->append( w );
+	}
+    }
+    return list;
+}
+
+/*!
+  \internal
+  Returns a list of all widgets.
+  \sa tlwList(), QApplication::allWidgets()
+*/
+
+QWidgetList *QWidget::wList()
+{
+    return wListInternal( mapper, FALSE );
+}
+
+/*!
+  \internal
+  Returns a list of all top level widgets.
+  \sa wList(), QApplication::topLevelWidgets()
+*/
+
+QWidgetList *QWidget::tlwList()
+{
+    return wListInternal( mapper, TRUE );
+}
+
+
+void QWidget::setWinId( WId id )		// set widget identifier
+{
+    if ( !mapper )				// mapper destroyed
+	return;
+    if ( winid )
+	mapper->remove( winid );
+    winid = id;
+#if defined(Q_WS_X11)
+    hd = id;					// X11: hd == ident
+#endif
+    if ( id )
+	mapper->insert( this );
+}
+
+
+/*!
+  \internal
+  Returns a pointer to the block of extra widget data.
+*/
+
+QWExtra *QWidget::extraData()
+{
+    return extra;
+}
+
+
+/*!
+  \internal
+  Returns a pointer to the block of extra top level widget data.
+
+  This data is guaranteed to exist for top level widgets.
+*/
+
+QTLWExtra *QWidget::topData()
+{
+    createTLExtra();
+    return extra->topextra;
+}
+
+
+void QWidget::createTLExtra()
+{
+    if ( !extra )
+	createExtra();
+    if ( !extra->topextra ) {
+	QTLWExtra* x = extra->topextra = new QTLWExtra;
+#if defined( Q_WS_WIN ) || defined( Q_WS_MAC )
+	x->opacity = 255;
+#endif
+#ifndef QT_NO_WIDGET_TOPEXTRA
+	x->icon = 0;
+#endif
+	x->focusData = 0;
+	x->fleft = x->fright = x->ftop = x->fbottom = 0;
+	x->incw = x->inch = 0;
+	x->basew = x->baseh = 0;
+	x->normalGeometry = QRect(0,0,-1,-1);
+#if defined(Q_WS_X11)
+	x->embedded = 0;
+	x->parentWinId = 0;
+	x->spont_unmapped = 0;
+	x->dnd = 0;
+	x->uspos = 0;
+	x->ussize = 0;
+#endif
+	x->savedFlags = 0;
+#if defined(Q_WS_QWS) && !defined(QT_NO_QWS_MANAGER)
+	x->decor_allocated_region = QRegion();
+	x->qwsManager = 0;
+#endif
+	createTLSysExtra();
+    }
+}
+
+/*!
+  \internal
+  Creates the widget extra data.
+*/
+
+void QWidget::createExtra()
+{
+    if ( !extra ) {				// if not exists
+	extra = new QWExtra;
+	Q_CHECK_PTR( extra );
+	extra->minw = extra->minh = 0;
+	extra->maxw = extra->maxh = QWIDGETSIZE_MAX;
+	extra->bg_pix = 0;
+	extra->focus_proxy = 0;
+#ifndef QT_NO_CURSOR
+	extra->curs = 0;
+#endif
+	extra->topextra = 0;
+	extra->bg_mode = PaletteBackground;
+	extra->bg_mode_visual = PaletteBackground;
+	extra->bg_origin = WidgetOrigin;
+#ifndef QT_NO_STYLE
+	extra->style = 0;
+#endif
+	extra->size_policy = QSizePolicy( QSizePolicy::Preferred,
+					  QSizePolicy::Preferred );
+	createSysExtra();
+    }
+}
+
+
+/*!
+  \internal
+  Deletes the widget extra data.
+*/
+
+void QWidget::deleteExtra()
+{
+    if ( extra ) {				// if exists
+	delete extra->bg_pix;
+#ifndef QT_NO_CURSOR
+	delete extra->curs;
+#endif
+	deleteSysExtra();
+	if ( extra->topextra ) {
+	    deleteTLSysExtra();
+#ifndef QT_NO_WIDGET_TOPEXTRA
+	    delete extra->topextra->icon;
+#endif
+	    delete extra->topextra->focusData;
+#if defined(Q_WS_QWS) && !defined(QT_NO_QWS_MANAGER)
+	    delete extra->topextra->qwsManager;
+#endif
+	    delete extra->topextra;
+	}
+	delete extra;
+	// extra->xic destroyed in QWidget::destroy()
+	extra = 0;
+    }
+}
+
+
+/*!
+  \internal
+  This function is called when a widget is hidden or destroyed.
+  It resets some application global pointers that should only refer active,
+  visible widgets.
+*/
+
+void QWidget::deactivateWidgetCleanup()
+{
+    // If this was the active application window, reset it
+    if ( this == QApplication::active_window )
+	qApp->setActiveWindow( 0 );
+    // If the is the active mouse press widget, reset it
+#ifdef Q_WS_MAC
+    extern QGuardedPtr<QWidget> qt_button_down;
+#else
+    extern QWidget *qt_button_down;
+#endif
+    if ( this == (QWidget *)qt_button_down )
+	qt_button_down = 0;
+}
+
+
+/*!
+    Returns a pointer to the widget with window identifer/handle \a
+    id.
+
+    The window identifier type depends on the underlying window
+    system, see \c qwindowdefs.h for the actual definition. If there
+    is no widget with this identifier, 0 is returned.
+*/
+
+QWidget *QWidget::find( WId id )
+{
+    return mapper ? mapper->find( id ) : 0;
+}
+
+/*!
+  \fn QWidgetMapper *QWidget::wmapper()
+  \internal
+  Returns a pointer to the widget mapper.
+
+  The widget mapper is an internal dictionary that is used to map from
+  window identifiers/handles to widget pointers.
+  \sa find(), id()
+*/
+
+/*!
+    \fn WFlags QWidget::getWFlags() const
+
+    Returns the widget flags for this this widget.
+
+    Widget flags are a combination of \l{Qt::WidgetFlags}.
+
+    \sa testWFlags(), setWFlags(), clearWFlags()
+*/
+
+/*!
+    \fn void QWidget::setWFlags( WFlags f )
+
+    Sets the widget flags \a f.
+
+    Widget flags are a combination of \l{Qt::WidgetFlags}.
+
+    \sa testWFlags(), getWFlags(), clearWFlags()
+*/
+
+/*!
+    \fn void QWidget::clearWFlags( WFlags f )
+
+    Clears the widget flags \a f.
+
+    Widget flags are a combination of \l{Qt::WidgetFlags}.
+
+    \sa testWFlags(), getWFlags(), setWFlags()
+*/
+
+
+
+/*!
+    \fn WId QWidget::winId() const
+
+    Returns the window system identifier of the widget.
+
+    Portable in principle, but if you use it you are probably about to
+    do something non-portable. Be careful.
+
+    \sa find()
+*/
+
+#ifndef QT_NO_STYLE
+/*!
+    Returns the GUI style for this widget
+
+    \sa QWidget::setStyle(), QApplication::setStyle(), QApplication::style()
+*/
+
+QStyle& QWidget::style() const
+{
+    if ( extra && extra->style )
+	return *extra->style;
+    QStyle &ret = qApp->style();
+    return ret;
+}
+
+/*!
+    Sets the widget's GUI style to \a style. Ownership of the style
+    object is not transferred.
+
+    If no style is set, the widget uses the application's style,
+    QApplication::style() instead.
+
+    Setting a widget's style has no effect on existing or future child
+    widgets.
+
+    \warning This function is particularly useful for demonstration
+    purposes, where you want to show Qt's styling capabilities. Real
+    applications should avoid it and use one consistent GUI style
+    instead.
+
+    \sa style(), QStyle, QApplication::style(), QApplication::setStyle()
+*/
+
+void QWidget::setStyle( QStyle *style )
+{
+    QStyle& old  = QWidget::style();
+    createExtra();
+    extra->style = style;
+    if ( !testWFlags(WType_Desktop) // (except desktop)
+	 && testWState(WState_Polished)) { // (and have been polished)
+	old.unPolish( this );
+	QWidget::style().polish( this );
+    }
+    styleChange( old );
+}
+
+/*!
+    \overload
+
+    Sets the widget's GUI style to \a style using the QStyleFactory.
+*/
+QStyle* QWidget::setStyle( const QString &style )
+{
+    QStyle *s = QStyleFactory::create( style );
+    setStyle( s );
+    return s;
+}
+
+/*!
+    This virtual function is called when the style of the widgets
+    changes. \a oldStyle is the previous GUI style; you can get the
+    new style from style().
+
+    Reimplement this function if your widget needs to know when its
+    GUI style changes. You will almost certainly need to update the
+    widget using update().
+
+    The default implementation updates the widget including its
+    geometry.
+
+    \sa QApplication::setStyle(), style(), update(), updateGeometry()
+*/
+
+void QWidget::styleChange( QStyle& /* oldStyle */ )
+{
+    update();
+    updateGeometry();
+}
+
+#endif
+
+/*!
+    \property QWidget::isTopLevel
+    \brief whether the widget is a top-level widget
+
+    A top-level widget is a widget which usually has a frame and a
+    \link QWidget::caption caption (title)\endlink. \link
+    QWidget::isPopup() Popup\endlink and \link QWidget::isDesktop()
+    desktop\endlink widgets are also top-level widgets.
+
+    A top-level widget can have a \link QWidget::parentWidget() parent
+    widget\endlink. It will then be grouped with its parent and deleted
+    when the parent is deleted, minimized when the parent is minimized
+    etc. If supported by the window manager, it will also have a
+    common taskbar entry with its parent.
+
+    QDialog and QMainWindow widgets are by default top-level, even if
+    a parent widget is specified in the constructor. This behavior is
+    specified by the \c WType_TopLevel widget flag.
+
+    \sa topLevelWidget(), isDialog(), isModal(), isPopup(), isDesktop(), parentWidget()
+*/
+
+/*!
+    \property QWidget::isDialog
+    \brief whether the widget is a dialog widget
+
+    A dialog widget is a secondary top-level widget, i.e. a top-level
+    widget with a parent.
+
+    \sa isTopLevel(), QDialog
+*/
+
+/*!
+    \property QWidget::isPopup
+    \brief whether the widget is a popup widget
+
+    A popup widget is created by specifying the widget flag \c
+    WType_Popup to the widget constructor. A popup widget is also a
+    top-level widget.
+
+    \sa isTopLevel()
+*/
+
+/*!
+    \property QWidget::isDesktop
+    \brief whether the widget is a desktop widget, i.e. represents the desktop
+
+    A desktop widget is also a top-level widget.
+
+    \sa isTopLevel(), QApplication::desktop()
+*/
+
+/*!
+    \property QWidget::isModal
+    \brief whether the widget is a modal widget
+
+    This property only makes sense for top-level widgets. A modal
+    widget prevents widgets in all other top-level widgets from
+    getting any input.
+
+    \sa isTopLevel(), isDialog(), QDialog
+*/
+
+/*!
+    \property QWidget::underMouse
+    \brief whether the widget is under the mouse cursor
+
+    This value is not updated properly during drag and drop
+    operations.
+
+    \sa QEvent::Enter, QEvent::Leave
+*/
+
+/*!
+    \property QWidget::minimized
+    \brief whether this widget is minimized (iconified)
+
+    This property is only relevant for top-level widgets.
+
+    \sa showMinimized(), visible, show(), hide(), showNormal(), maximized
+*/
+bool QWidget::isMinimized() const
+{ return testWState(WState_Minimized); }
+
+/*!
+    Shows the widget minimized, as an icon.
+
+    Calling this function only affects \link isTopLevel() top-level
+    widgets\endlink.
+
+    \sa showNormal(), showMaximized(), show(), hide(), isVisible(),
+    isMinimized()
+*/
+void QWidget::showMinimized()
+{
+    bool isMin = isMinimized();
+    if (isMin && isVisible()) return;
+
+    if (!isMin)
+        setWindowState((windowState() & ~WindowActive) | WindowMinimized);
+    show();
+    if (!isTopLevel())
+	QApplication::sendPostedEvents(this, QEvent::ShowMinimized);
+}
+
+/*!
+    \property QWidget::maximized
+    \brief whether this widget is maximized
+
+    This property is only relevant for top-level widgets.
+
+    Note that due to limitations in some window-systems, this does not
+    always report the expected results (e.g. if the user on X11
+    maximizes the window via the window manager, Qt has no way of
+    distinguishing this from any other resize). This is expected to
+    improve as window manager protocols evolve.
+
+    \sa windowState(), showMaximized(), visible, show(), hide(), showNormal(), minimized
+*/
+bool QWidget::isMaximized() const
+{ return testWState(WState_Maximized); }
+
+
+
+/*!  Returns the current window state. The window state is a OR'ed
+  combination of Qt::WindowState: \c WindowMinimized, \c
+  WindowMaximized, \c WindowFullScreen and \c WindowActive.
+
+  \sa Qt::WindowState setWindowState()
+ */
+uint QWidget::windowState() const
+{
+    uint state = 0;
+    if (testWState(WState_Minimized))
+	state |= WindowMinimized;
+    if (testWState(WState_Maximized))
+	state |= WindowMaximized;
+    if (testWState(WState_FullScreen))
+	state |= WindowFullScreen;
+    if (isActiveWindow())
+	state |= WindowActive;
+    return state;
+}
+
+/*!
+  \fn void QWidget::setWindowState(uint windowState)
+
+  Sets the window state to \a windowState. The window state is a OR'ed
+  combination of Qt::WindowState: \c WindowMinimized, \c
+  WindowMaximized, \c WindowFullScreen and \c WindowActive.
+
+  If the window is not visible (i.e. isVisible() returns FALSE), the
+  window state will take effect when show() is called. For visible
+  windows, the change is immediate. For example, to toggle between
+  full-screen and mormal mode, use the following code:
+
+  \code
+	w->setWindowState(w->windowState() ^ WindowFullScreen);
+  \endcode
+
+  In order to restore and activate a minimized window (while
+  preserving its maximized and/or full-screen state), use the following:
+
+  \code
+	w->setWindowState(w->windowState() & ~WindowMinimized | WindowActive);
+  \endcode
+
+  Note: On some window systems \c WindowActive is not immediate, and may be
+  ignored in certain cases.
+
+  \sa Qt::WindowState windowState()
+*/
+
+/*!
+    \property QWidget::fullScreen
+    \brief whether the widget is full screen
+
+    \sa windowState(), minimized, maximized
+*/
+bool QWidget::isFullScreen() const
+{ return testWState(WState_FullScreen); }
+
+/*!
+    Shows the widget in full-screen mode.
+
+    Calling this function only affects top-level widgets.
+
+    To return from full-screen mode, call showNormal().
+
+    Full-screen mode works fine under Windows, but has certain
+    problems under X. These problems are due to limitations of the
+    ICCCM protocol that specifies the communication between X11
+    clients and the window manager. ICCCM simply does not understand
+    the concept of non-decorated full-screen windows. Therefore, the
+    best we can do is to request a borderless window and place and
+    resize it to fill the entire screen. Depending on the window
+    manager, this may or may not work. The borderless window is
+    requested using MOTIF hints, which are at least partially
+    supported by virtually all modern window managers.
+
+    An alternative would be to bypass the window manager entirely and
+    create a window with the WX11BypassWM flag. This has other severe
+    problems though, like totally broken keyboard focus and very
+    strange effects on desktop changes or when the user raises other
+    windows.
+
+    X11 window managers that follow modern post-ICCCM specifications
+    support full-screen mode properly.
+
+    \sa showNormal(), showMaximized(), show(), hide(), isVisible()
+*/
+void QWidget::showFullScreen()
+{
+    bool isFull = isFullScreen();
+    if (isFull && isVisible())
+	return;
+
+    if (!isFull)
+	setWindowState(windowState() | WindowFullScreen);
+    show();
+    if (!isTopLevel())
+	QApplication::sendPostedEvents(this, QEvent::ShowFullScreen);
+    setActiveWindow();
+}
+
+/*!
+    Shows the widget maximized.
+
+    Calling this function only affects \link isTopLevel() top-level
+    widgets\endlink.
+
+    On X11, this function may not work properly with certain window
+    managers. See the \link geometry.html Window Geometry
+    documentation\endlink for an explanation.
+
+    \sa setWindowState(), showNormal(), showMinimized(), show(), hide(), isVisible()
+*/
+void QWidget::showMaximized()
+{
+    if (isMaximized() && isVisible() && !isMinimized())
+	return;
+
+    setWindowState((windowState() & ~WindowMinimized) | WindowMaximized);
+    show();
+    if (!isTopLevel())
+	QApplication::sendPostedEvents(this, QEvent::ShowMaximized);
+}
+
+/*!
+    Restores the widget after it has been maximized or minimized.
+
+    Calling this function only affects \link isTopLevel() top-level
+    widgets\endlink.
+
+    \sa setWindowState(), showMinimized(), showMaximized(), show(), hide(), isVisible()
+*/
+void QWidget::showNormal()
+{
+    setWindowState(WindowNoState);
+    show();
+    if (!isTopLevel())
+	QApplication::sendPostedEvents(this, QEvent::ShowNormal);
+}
+
+/*!
+    Returns TRUE if this widget would become enabled if \a ancestor is
+    enabled; otherwise returns FALSE.
+
+    This is the case if neither the widget itself nor every parent up
+    to but excluding \a ancestor has been explicitly disabled.
+
+    isEnabledTo(0) is equivalent to isEnabled().
+
+    \sa setEnabled() enabled
+*/
+
+bool QWidget::isEnabledTo( QWidget* ancestor ) const
+{
+    const QWidget * w = this;
+    while ( w && !w->testWState(WState_ForceDisabled)
+	    && !w->isTopLevel()
+	    && w->parentWidget()
+	    && w->parentWidget() != ancestor )
+	w = w->parentWidget();
+    return !w->testWState( WState_ForceDisabled );
+}
+
+
+/*!
+  \fn bool QWidget::isEnabledToTLW() const
+  \obsolete
+
+  This function is deprecated. It is equivalent to isEnabled()
+*/
+
+/*!
+    \property QWidget::enabled
+    \brief whether the widget is enabled
+
+    An enabled widget receives keyboard and mouse events; a disabled
+    widget does not. In fact, an enabled widget only receives keyboard
+    events when it is in focus.
+
+    Some widgets display themselves differently when they are
+    disabled. For example a button might draw its label grayed out. If
+    your widget needs to know when it becomes enabled or disabled, you
+    can reimplement the enabledChange() function.
+
+    Disabling a widget implicitly disables all its children. Enabling
+    respectively enables all child widgets unless they have been
+    explicitly disabled.
+
+    \sa isEnabled(), isEnabledTo(), QKeyEvent, QMouseEvent, enabledChange()
+*/
+void QWidget::setEnabled( bool enable )
+{
+    if ( enable )
+	clearWState( WState_ForceDisabled );
+    else
+	setWState( WState_ForceDisabled );
+
+    if ( !isTopLevel() && parentWidget() &&
+	 !parentWidget()->isEnabled() && enable )
+	return; // nothing we can do
+
+    if ( enable ) {
+	if ( testWState(WState_Disabled) ) {
+	    clearWState( WState_Disabled );
+	    setBackgroundFromMode();
+	    enabledChange( !enable );
+	    if ( children() ) {
+		QObjectListIt it( *children() );
+		QWidget *w;
+		while( (w = (QWidget *)it.current()) != 0 ) {
+		    ++it;
+		    if ( w->isWidgetType() &&
+			 !w->testWState( WState_ForceDisabled ) )
+			w->setEnabled( TRUE );
+		}
+	    }
+	}
+    } else {
+	if ( !testWState(WState_Disabled) ) {
+            if (focusWidget() == this) {
+                bool parentIsEnabled = (!parentWidget() || parentWidget()->isEnabled());
+                if (!parentIsEnabled || !focusNextPrevChild(TRUE))
+		    clearFocus();
+            }
+	    setWState( WState_Disabled );
+	    setBackgroundFromMode();
+	    enabledChange( !enable );
+	    if ( children() ) {
+		QObjectListIt it( *children() );
+		QWidget *w;
+		while( (w = (QWidget *)it.current()) != 0 ) {
+		    ++it;
+		    if ( w->isWidgetType() && w->isEnabled() ) {
+			w->setEnabled( FALSE );
+			w->clearWState( WState_ForceDisabled );
+		    }
+		}
+	    }
+	}
+    }
+#if defined(Q_WS_X11)
+    if ( testWState( WState_OwnCursor ) ) {
+	// enforce the windows behavior of clearing the cursor on
+	// disabled widgets
+
+	extern void qt_x11_enforce_cursor( QWidget * w ); // defined in qwidget_x11.cpp
+	qt_x11_enforce_cursor( this );
+    }
+#endif
+#ifdef Q_WS_WIN
+    QInputContext::enable( this, im_enabled & !((bool)testWState(WState_Disabled)) );
+#endif
+}
+
+/*!
+    Disables widget input events if \a disable is TRUE; otherwise
+    enables input events.
+
+    See the \l enabled documentation for more information.
+
+    \sa isEnabledTo(), QKeyEvent, QMouseEvent, enabledChange()
+*/
+void QWidget::setDisabled( bool disable )
+{
+    setEnabled( !disable );
+}
+
+/*!
+    \fn void QWidget::enabledChange( bool oldEnabled )
+
+    This virtual function is called from setEnabled(). \a oldEnabled
+    is the previous setting; you can get the new setting from
+    isEnabled().
+
+    Reimplement this function if your widget needs to know when it
+    becomes enabled or disabled. You will almost certainly need to
+    update the widget using update().
+
+    The default implementation repaints the visible part of the
+    widget.
+
+    \sa setEnabled(), isEnabled(), repaint(), update(), clipRegion()
+*/
+
+void QWidget::enabledChange( bool )
+{
+    update();
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+    QAccessible::updateAccessibility( this, 0, QAccessible::StateChanged );
+#endif
+}
+
+/*!
+    \fn void QWidget::windowActivationChange( bool oldActive )
+
+    This virtual function is called for a widget when its window is
+    activated or deactivated by the window system. \a oldActive is the
+    previous state; you can get the new setting from isActiveWindow().
+
+    Reimplement this function if your widget needs to know when its
+    window becomes activated or deactivated.
+
+    The default implementation updates the visible part of the widget
+    if the inactive and the active colorgroup are different for colors
+    other than the highlight and link colors.
+
+    \sa setActiveWindow(), isActiveWindow(), update(), palette()
+*/
+
+void QWidget::windowActivationChange( bool )
+{
+#ifndef QT_NO_PALETTE
+    if ( !isVisible() )
+	return;
+
+    const QColorGroup &acg = palette().active();
+    const QColorGroup &icg = palette().inactive();
+
+    if ( acg != icg ) {
+	BackgroundMode bm = backgroundMode();
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode(bm);
+	if ( bm > NoBackground  && acg.brush(role) != icg.brush(role) )
+	    setBackgroundFromMode();
+	else if ( acg.background() == icg.background() &&
+		  acg.base() == icg.base() &&
+		  acg.text() == icg.text() &&
+		  acg.foreground() == icg.foreground() &&
+		  acg.button() == icg.button() &&
+		  acg.buttonText() == icg.buttonText() &&
+		  acg.brightText() == icg.brightText() &&
+		  acg.dark() == icg.dark() &&
+		  acg.light() == icg.light() &&
+		  acg.mid() == icg.mid() &&
+		  acg.midlight() == icg.midlight() &&
+		  acg.shadow() == icg.shadow() )
+	    return;
+	update();
+    }
+#endif
+}
+
+/*!
+    \property QWidget::frameGeometry
+    \brief geometry of the widget relative to its parent including any
+    window frame
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of geometry issues with top-level widgets.
+
+    \sa geometry() x() y() pos()
+*/
+QRect QWidget::frameGeometry() const
+{
+    if (isTopLevel() && ! isPopup()) {
+	if (fstrut_dirty)
+	    updateFrameStrut();
+	QWidget *that = (QWidget *) this;
+	QTLWExtra *top = that->topData();
+	return QRect(crect.x() - top->fleft,
+		     crect.y() - top->ftop,
+		     crect.width() + top->fleft + top->fright,
+		     crect.height() + top->ftop + top->fbottom);
+    }
+    return crect;
+}
+
+/*! \property QWidget::x
+    \brief the x coordinate of the widget relative to its parent including
+    any window frame
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa frameGeometry, y, pos
+*/
+int QWidget::x() const
+{
+    if (isTopLevel() && ! isPopup()) {
+	if (fstrut_dirty)
+	    updateFrameStrut();
+	QWidget *that = (QWidget *) this;
+	return crect.x() - that->topData()->fleft;
+    }
+    return crect.x();
+}
+
+/*!
+    \property QWidget::y
+    \brief the y coordinate of the widget relative to its parent and
+    including any window frame
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa frameGeometry, x, pos
+*/
+int QWidget::y() const
+{
+    if (isTopLevel() && ! isPopup()) {
+	if (fstrut_dirty)
+	    updateFrameStrut();
+	QWidget *that = (QWidget *) this;
+	return crect.y() - that->topData()->ftop;
+    }
+    return crect.y();
+}
+
+/*!
+    \property QWidget::pos
+    \brief the position of the widget within its parent widget
+
+    If the widget is a top-level widget, the position is that of the
+    widget on the desktop, including its frame.
+
+    When changing the position, the widget, if visible, receives a
+    move event (moveEvent()) immediately. If the widget is not
+    currently visible, it is guaranteed to receive an event before it
+    is shown.
+
+    move() is virtual, and all other overloaded move() implementations
+    in Qt call it.
+
+    \warning Calling move() or setGeometry() inside moveEvent() can
+    lead to infinite recursion.
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa frameGeometry, size x(), y()
+*/
+QPoint QWidget::pos() const
+{
+    if (isTopLevel() && ! isPopup()) {
+	if (fstrut_dirty)
+	    updateFrameStrut();
+	QWidget *that = (QWidget *) this;
+	QTLWExtra *top = that->topData();
+	return QPoint(crect.x() - top->fleft, crect.y() - top->ftop);
+    }
+    return crect.topLeft();
+}
+
+/*!
+    \property QWidget::geometry
+    \brief the geometry of the widget relative to its parent and
+    excluding the window frame
+
+    When changing the geometry, the widget, if visible, receives a
+    move event (moveEvent()) and/or a resize event (resizeEvent())
+    immediately. If the widget is not currently visible, it is
+    guaranteed to receive appropriate events before it is shown.
+
+    The size component is adjusted if it lies outside the range
+    defined by minimumSize() and maximumSize().
+
+    setGeometry() is virtual, and all other overloaded setGeometry()
+    implementations in Qt call it.
+
+    \warning Calling setGeometry() inside resizeEvent() or moveEvent()
+    can lead to infinite recursion.
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa frameGeometry(), rect(), move(), resize(), moveEvent(),
+	resizeEvent(), minimumSize(), maximumSize()
+*/
+
+/*!
+    \property QWidget::size
+    \brief the size of the widget excluding any window frame
+
+    When resizing, the widget, if visible, receives a resize event
+    (resizeEvent()) immediately. If the widget is not currently
+    visible, it is guaranteed to receive an event before it is shown.
+
+    The size is adjusted if it lies outside the range defined by
+    minimumSize() and maximumSize(). Furthermore, the size is always
+    at least QSize(1, 1). For toplevel widgets, the minimum size
+    might be larger, depending on the window manager.
+
+    If you want a top-level window to have a fixed size, call
+    setResizeMode( QLayout::FreeResize ) on its layout.
+
+    resize() is virtual, and all other overloaded resize()
+    implementations in Qt call it.
+
+    \warning Calling resize() or setGeometry() inside resizeEvent() can
+    lead to infinite recursion.
+
+    \sa pos, geometry, minimumSize, maximumSize, resizeEvent()
+*/
+
+/*!
+    \property QWidget::width
+    \brief the width of the widget excluding any window frame
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa geometry, height, size
+*/
+
+/*!
+    \property QWidget::height
+    \brief the height of the widget excluding any window frame
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa geometry, width, size
+*/
+
+/*!
+    \property QWidget::rect
+    \brief the internal geometry of the widget excluding any window
+    frame
+
+    The rect property equals QRect(0, 0, width(), height()).
+
+    See the \link geometry.html Window Geometry documentation\endlink
+    for an overview of top-level widget geometry.
+
+    \sa size
+*/
+
+/*!
+    \property QWidget::childrenRect
+    \brief the bounding rectangle of the widget's children
+
+    Hidden children are excluded.
+
+    \sa childrenRegion() geometry()
+*/
+
+QRect QWidget::childrenRect() const
+{
+    QRect r( 0, 0, 0, 0 );
+    if ( !children() )
+	return r;
+    QObjectListIt it( *children() );
+    QObject *obj;
+    while ( (obj = it.current()) ) {
+	++it;
+	if ( obj->isWidgetType() && !((QWidget*)obj)->isHidden() && !((QWidget*)obj)->isTopLevel())
+	    r = r.unite( ((QWidget*)obj)->geometry() );
+    }
+    return r;
+}
+
+/*!
+    \property QWidget::childrenRegion
+    \brief the combined region occupied by the widget's children
+
+    Hidden children are excluded.
+
+    \sa childrenRect() geometry()
+*/
+
+QRegion QWidget::childrenRegion() const
+{
+    QRegion r;
+    if ( !children() )
+	return r;
+    QObjectListIt it( *children() );		// iterate over all children
+    QObject *obj;
+    while ( (obj=it.current()) ) {
+	++it;
+	if ( obj->isWidgetType() && !((QWidget*)obj)->isHidden() && !((QWidget*)obj)->isTopLevel())
+	    r = r.unite( ((QWidget*)obj)->geometry() );
+    }
+    return r;
+}
+
+
+/*!
+    \property QWidget::minimumSize
+    \brief the widget's minimum size
+
+    The widget cannot be resized to a smaller size than the minimum
+    widget size. The widget's size is forced to the minimum size if
+    the current size is smaller.
+
+    If you use a layout inside the widget, the minimum size will be
+    set by the layout and not by setMinimumSize(), unless you set the
+    layout's resize mode to QLayout::FreeResize.
+
+    \sa minimumWidth, minimumHeight, maximumSize, sizeIncrement
+	QLayout::setResizeMode()
+*/
+
+QSize QWidget::minimumSize() const
+{
+    return extra ? QSize( extra->minw, extra->minh ) : QSize( 0, 0 );
+}
+
+/*!
+    \property QWidget::maximumSize
+    \brief the widget's maximum size
+
+    The widget cannot be resized to a larger size than the maximum
+    widget size.
+
+    \sa maximumWidth(), maximumHeight(), setMaximumSize(),
+    minimumSize(), sizeIncrement()
+*/
+
+QSize QWidget::maximumSize() const
+{
+    return extra ? QSize( extra->maxw, extra->maxh )
+		 : QSize( QWIDGETSIZE_MAX, QWIDGETSIZE_MAX );
+}
+
+
+/*!
+    \property QWidget::minimumWidth
+    \brief the widget's minimum width
+
+    This property corresponds to minimumSize().width().
+
+    \sa minimumSize, minimumHeight
+*/
+
+/*!
+    \property QWidget::minimumHeight
+    \brief the widget's minimum height
+
+    This property corresponds to minimumSize().height().
+
+    \sa minimumSize, minimumWidth
+*/
+
+/*!
+    \property QWidget::maximumWidth
+    \brief the widget's maximum width
+
+    This property corresponds to maximumSize().width().
+
+    \sa maximumSize, maximumHeight
+*/
+
+/*!
+    \property QWidget::maximumHeight
+    \brief the widget's maximum height
+
+    This property corresponds to maximumSize().height().
+
+    \sa maximumSize, maximumWidth
+*/
+
+/*!
+    \property QWidget::sizeIncrement
+    \brief the size increment of the widget
+
+    When the user resizes the window, the size will move in steps of
+    sizeIncrement().width() pixels horizontally and
+    sizeIncrement.height() pixels vertically, with baseSize() as the
+    basis. Preferred widget sizes are for non-negative integers \e i
+    and \e j:
+    \code
+	width = baseSize().width() + i * sizeIncrement().width();
+	height = baseSize().height() + j * sizeIncrement().height();
+    \endcode
+
+    Note that while you can set the size increment for all widgets, it
+    only affects top-level widgets.
+
+    \warning The size increment has no effect under Windows, and may
+    be disregarded by the window manager on X.
+
+    \sa size, minimumSize, maximumSize
+*/
+QSize QWidget::sizeIncrement() const
+{
+    return ( extra && extra->topextra )
+	? QSize( extra->topextra->incw, extra->topextra->inch )
+	: QSize( 0, 0 );
+}
+
+/*!
+    \property QWidget::baseSize
+    \brief the base size of the widget
+
+    The base size is used to calculate a proper widget size if the
+    widget defines sizeIncrement().
+
+    \sa setSizeIncrement()
+*/
+
+QSize QWidget::baseSize() const
+{
+    return ( extra != 0 && extra->topextra != 0 )
+	? QSize( extra->topextra->basew, extra->topextra->baseh )
+	: QSize( 0, 0 );
+}
+
+/*!
+    Sets both the minimum and maximum sizes of the widget to \a s,
+    thereby preventing it from ever growing or shrinking.
+
+    \sa setMaximumSize() setMinimumSize()
+*/
+
+void QWidget::setFixedSize( const QSize & s)
+{
+    setMinimumSize( s );
+    setMaximumSize( s );
+    resize( s );
+}
+
+
+/*!
+    \overload void QWidget::setFixedSize( int w, int h )
+
+    Sets the width of the widget to \a w and the height to \a h.
+*/
+
+void QWidget::setFixedSize( int w, int h )
+{
+    setMinimumSize( w, h );
+    setMaximumSize( w, h );
+    resize( w, h );
+}
+
+void QWidget::setMinimumWidth( int w )
+{
+    setMinimumSize( w, minimumSize().height() );
+}
+
+void QWidget::setMinimumHeight( int h )
+{
+    setMinimumSize( minimumSize().width(), h );
+}
+
+void QWidget::setMaximumWidth( int w )
+{
+    setMaximumSize( w, maximumSize().height() );
+}
+
+void QWidget::setMaximumHeight( int h )
+{
+    setMaximumSize( maximumSize().width(), h );
+}
+
+/*!
+    Sets both the minimum and maximum width of the widget to \a w
+    without changing the heights. Provided for convenience.
+
+    \sa sizeHint() minimumSize() maximumSize() setFixedSize()
+*/
+
+void QWidget::setFixedWidth( int w )
+{
+    setMinimumSize( w, minimumSize().height() );
+    setMaximumSize( w, maximumSize().height() );
+}
+
+
+/*!
+    Sets both the minimum and maximum heights of the widget to \a h
+    without changing the widths. Provided for convenience.
+
+    \sa sizeHint() minimumSize() maximumSize() setFixedSize()
+*/
+
+void QWidget::setFixedHeight( int h )
+{
+    setMinimumSize( minimumSize().width(), h );
+    setMaximumSize( maximumSize().width(), h );
+}
+
+
+/*!
+    Translates the widget coordinate \a pos to the coordinate system
+    of \a parent. The \a parent must not be 0 and must be a parent
+    of the calling widget.
+
+    \sa mapFrom() mapToParent() mapToGlobal() hasMouse()
+*/
+
+QPoint QWidget::mapTo( QWidget * parent, const QPoint & pos ) const
+{
+    QPoint p = pos;
+    if ( parent ) {
+	const QWidget * w = this;
+	while ( w != parent ) {
+	    p = w->mapToParent( p );
+	    w = w->parentWidget();
+	}
+    }
+    return p;
+}
+
+
+/*!
+    Translates the widget coordinate \a pos from the coordinate system
+    of \a parent to this widget's coordinate system. The \a parent
+    must not be 0 and must be a parent of the calling widget.
+
+    \sa mapTo() mapFromParent() mapFromGlobal() hasMouse()
+*/
+
+QPoint QWidget::mapFrom( QWidget * parent, const QPoint & pos ) const
+{
+    QPoint p( pos );
+    if ( parent ) {
+	const QWidget * w = this;
+	while ( w != parent ) {
+	    p = w->mapFromParent( p );
+	    w = w->parentWidget();
+	}
+    }
+    return p;
+}
+
+
+/*!
+    Translates the widget coordinate \a pos to a coordinate in the
+    parent widget.
+
+    Same as mapToGlobal() if the widget has no parent.
+
+    \sa mapFromParent() mapTo() mapToGlobal() hasMouse()
+*/
+
+QPoint QWidget::mapToParent( const QPoint &pos ) const
+{
+    return pos + crect.topLeft();
+}
+
+/*!
+    Translates the parent widget coordinate \a pos to widget
+    coordinates.
+
+    Same as mapFromGlobal() if the widget has no parent.
+
+    \sa mapToParent() mapFrom() mapFromGlobal() hasMouse()
+*/
+
+QPoint QWidget::mapFromParent( const QPoint &pos ) const
+{
+    return pos - crect.topLeft();
+}
+
+
+/*!
+    Returns the top-level widget for this widget, i.e. the next
+    ancestor widget that has (or could have) a window-system frame.
+
+    If the widget is a top-level, the widget itself is returned.
+
+    Typical usage is changing the window caption:
+
+    \code
+	aWidget->topLevelWidget()->setCaption( "New Caption" );
+    \endcode
+
+    \sa isTopLevel()
+*/
+
+QWidget *QWidget::topLevelWidget() const
+{
+    QWidget *w = (QWidget *)this;
+    QWidget *p = w->parentWidget();
+    while ( !w->testWFlags(WType_TopLevel) && p ) {
+	w = p;
+	p = p->parentWidget();
+    }
+    return w;
+}
+
+
+/*!
+    \property QWidget::paletteForegroundColor
+    \brief the foreground color of the widget
+
+    setPaletteForegroundColor() is a convenience function that creates
+    and sets a modified QPalette with setPalette(). The palette is
+    modified according to the widget's \e {background mode}. For
+    example, if the background mode is \c PaletteButton the palette entry
+    \c QColorGroup::ButtonText is set to color.
+
+    \sa setPalette() QApplication::setPalette() backgroundMode()
+      foregroundColor() setBackgroundMode() setEraseColor()
+*/
+const QColor &QWidget::paletteForegroundColor() const
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    return colorGroup().color( QPalette::foregroundRoleFromMode(mode) );
+#else
+    return Qt::black;
+#endif
+}
+
+void QWidget::setPaletteForegroundColor( const QColor & color )
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    QPalette pal = palette();
+    QColorGroup::ColorRole role = QPalette::foregroundRoleFromMode( mode );
+    pal.setColor( QPalette::Active, role, color );
+    pal.setColor( QPalette::Inactive, role, color );
+    pal.setColor( QPalette::Disabled, role, color );
+    setPalette( pal );
+#endif
+}
+
+
+/*!
+    Same as paletteForegroundColor()
+ */
+const QColor &QWidget::foregroundColor() const
+{
+    return paletteForegroundColor();
+}
+
+
+/*!
+    \fn const QColor& QWidget::eraseColor() const
+
+    Returns the erase color of the widget.
+
+    \sa setEraseColor() setErasePixmap() backgroundColor()
+*/
+
+/*!
+    Sets the erase color of the widget to \a color.
+
+    The erase color is the color the widget is to be cleared to before
+    paintEvent() is called. If there is an erase pixmap (set using
+    setErasePixmap()), then this property has an indeterminate value.
+
+    \sa erasePixmap(), backgroundColor(), backgroundMode(), palette()
+*/
+void QWidget::setEraseColor( const QColor & color )
+{
+    setBackgroundModeDirect( FixedColor );
+    setBackgroundColorDirect( color );
+    update();
+}
+
+/*!
+    Returns the widget's erase pixmap.
+
+    \sa setErasePixmap() eraseColor()
+*/
+const QPixmap *QWidget::erasePixmap() const
+{
+    return ( extra && extra->bg_pix ) ? extra->bg_pix : 0;
+}
+
+/*!
+    Sets the widget's erase pixmap to \a pixmap.
+
+    This pixmap is used to clear the widget before paintEvent() is
+    called.
+*/
+void QWidget::setErasePixmap( const QPixmap &pixmap )
+{
+    // This function is called with a null pixmap by setBackgroundEmpty().
+    setBackgroundPixmapDirect( pixmap );
+    setBackgroundModeDirect( FixedPixmap );
+    update();
+}
+
+void QWidget::setBackgroundFromMode()
+{
+#ifndef QT_NO_PALETTE
+    QColorGroup::ColorRole r = QColorGroup::Background;
+    if ( extra ) {
+	int i = (BackgroundMode)extra->bg_mode;
+	if ( i == FixedColor || i == FixedPixmap || i == NoBackground ) {
+	    // Mode is for fixed color, not one based on palette,
+	    // so nothing to do.
+	    return;
+	}
+	switch( i ) {
+	case PaletteForeground:
+	    r = QColorGroup::Foreground;
+	    break;
+	case PaletteButton:
+	    r = QColorGroup::Button;
+	    break;
+	case PaletteLight:
+	    r = QColorGroup::Light;
+	    break;
+	case PaletteMidlight:
+	    r = QColorGroup::Midlight;
+	    break;
+	case PaletteDark:
+	    r = QColorGroup::Dark;
+	    break;
+	case PaletteMid:
+	    r = QColorGroup::Mid;
+	    break;
+	case PaletteText:
+	    r = QColorGroup::Text;
+	    break;
+	case PaletteBrightText:
+	    r = QColorGroup::BrightText;
+	    break;
+	case PaletteBase:
+	    r = QColorGroup::Base;
+	    break;
+	case PaletteBackground:
+	    r = QColorGroup::Background;
+	    break;
+	case PaletteShadow:
+	    r = QColorGroup::Shadow;
+	    break;
+	case PaletteHighlight:
+	    r = QColorGroup::Highlight;
+	    break;
+	case PaletteHighlightedText:
+	    r = QColorGroup::HighlightedText;
+	    break;
+	case PaletteButtonText:
+	    r = QColorGroup::ButtonText;
+	    break;
+	case X11ParentRelative:
+#if defined(Q_WS_X11)
+	    setBackgroundX11Relative();
+#endif
+	    return;
+	}
+    }
+    const QColorGroup &cg = colorGroup();
+    QPixmap * p = cg.brush( r ).pixmap();
+    if ( p )
+	setBackgroundPixmapDirect( *p );
+    else
+	setBackgroundColorDirect( cg.color( r ) );
+#endif
+}
+
+/*!
+    \enum Qt::BackgroundMode
+
+    This enum describes how the background of a widget changes, as the
+    widget's palette changes.
+
+    The background is what the widget contains when \link
+    QWidget::paintEvent() paintEvent()\endlink is called. To minimize
+    flicker, this should be the most common color or pixmap in the
+    widget. For \c PaletteBackground, use colorGroup().brush( \c
+    QColorGroup::Background ), and so on.
+
+    \value PaletteForeground
+    \value PaletteBackground
+    \value PaletteButton
+    \value PaletteLight
+    \value PaletteMidlight
+    \value PaletteDark
+    \value PaletteMid
+    \value PaletteText
+    \value PaletteBrightText
+    \value PaletteButtonText
+    \value PaletteBase
+    \value PaletteShadow
+    \value PaletteHighlight
+    \value PaletteHighlightedText
+    \value PaletteLink
+    \value PaletteLinkVisited
+    \value X11ParentRelative (internal use only)
+
+    The final three values have special meaning:
+
+    \value NoBackground the widget is not cleared before paintEvent().
+    If the widget's paint event always draws on all the pixels, using
+    this mode can be both fast and flicker-free.
+    \value FixedColor the widget is cleared to a fixed color, normally
+    different from all the ones in the palette(). Set using \link
+    QWidget::setPaletteBackgroundColor()
+    setPaletteBackgroundColor()\endlink.
+    \value FixedPixmap the widget is cleared to a fixed pixmap,
+    normally different from all the ones in the palette(). Set using
+    \link QWidget::setPaletteBackgroundPixmap()
+    setPaletteBackgroundPixmap()\endlink.
+
+    Although \c FixedColor and \c FixedPixmap are sometimes just
+    right, if you use them, make sure that you test your application
+    when the desktop color scheme has been changed. (On X11, a quick
+    way to test this is e.g. "./myapp -bg paleblue". On Windows, you
+    must use the control panel.)
+
+    \sa QWidget::setBackgroundMode() QWidget::backgroundMode()
+    QWidget::setBackgroundPixmap() QWidget::setPaletteBackgroundColor()
+*/
+
+/*!
+    \property QWidget::backgroundMode
+    \brief the color role used for painting the background of the widget
+
+    setPaletteBackgroundColor() reads this property to determine which
+    entry of the \link QWidget::palette palette\endlink to set.
+
+    For most widgets the default suffices (\c PaletteBackground,
+    typically gray), but some need to use \c PaletteBase (the
+    background color for text output, typically white) or another
+    role.
+
+    QListBox, which is "sunken" and uses the base color to contrast
+    with its environment, does this in its constructor:
+
+    \code
+    setBackgroundMode( PaletteBase );
+    \endcode
+
+    You will never need to set the background mode of a built-in
+    widget in Qt, but you might consider setting it in your custom
+    widgets, so that setPaletteBackgroundColor() works as expected.
+
+    Note that two of the BackgroundMode values make no sense for
+    setBackgroundMode(), namely \c FixedPixmap and \c FixedColor. You
+    must call setBackgroundPixmap() and setPaletteBackgroundColor()
+    instead.
+*/
+Qt::BackgroundMode QWidget::backgroundMode() const
+{
+    return extra ? (BackgroundMode) extra->bg_mode : PaletteBackground;
+}
+
+void QWidget::setBackgroundMode( BackgroundMode m )
+{
+    setBackgroundMode( m, m );
+    if ( (widget_state & (WState_Visible|WState_BlockUpdates)) ==
+	 WState_Visible )
+	update();
+}
+
+
+/*!
+    \overload
+
+    Sets the widget's own background mode to \a m and the visual
+    background mode to \a visual. The visual background mode is used
+    with the designable properties \c backgroundColor, \c
+    foregroundColor and \c backgroundPixmap.
+
+    For complex controls, the logical background mode sometimes
+    differs from a widget's own background mode. A spinbox for example
+    has \c PaletteBackground as background mode (typically dark gray),
+    while it's embedded lineedit control uses \c PaletteBase
+    (typically white). Since the lineedit covers most of the visual
+    area of a spinbox, it defines \c PaletteBase to be its \a visual
+    background mode. Changing the \c backgroundColor property thus
+    changes the lineedit control's background, which is exactly what
+    the user expects in \e{Qt Designer}.
+*/
+void QWidget::setBackgroundMode( BackgroundMode m, BackgroundMode visual )
+{
+    if ( m == NoBackground ) {
+	setBackgroundEmpty();
+    } else if ( m == FixedColor || m == FixedPixmap ) {
+#if defined(QT_DEBUG)
+	qWarning( "QWidget::setBackgroundMode: FixedColor or FixedPixmap makes"
+		  " no sense" );
+#endif
+	return;
+    }
+    setBackgroundModeDirect(m);
+    if ( m != visual && !extra )
+	createExtra();
+    if ( extra )
+	extra->bg_mode_visual = visual;
+}
+
+
+/*!
+  \internal
+*/
+void QWidget::setBackgroundModeDirect( BackgroundMode m )
+{
+    if ( m == PaletteBackground && !extra )
+	return;
+
+    createExtra();
+    if ( (BackgroundMode)extra->bg_mode != m ) {
+	extra->bg_mode = m;
+	extra->bg_mode_visual = m;
+	setBackgroundFromMode();
+    }
+}
+
+/*!
+    \property QWidget::paletteBackgroundColor
+    \brief the background color of the widget
+
+    The palette background color is usually set implicitly by
+    setBackgroundMode(), although it can also be set explicitly by
+    setPaletteBackgroundColor(). setPaletteBackgroundColor() is a
+    convenience function that creates and sets a modified QPalette
+    with setPalette(). The palette is modified according to the
+    widget's background mode. For example, if the background mode is
+    \c PaletteButton the color used for the palette's \c
+    QColorGroup::Button color entry is set.
+
+    If there is a background pixmap (set using
+    setPaletteBackgroundPixmap()), then the return value of this
+    function is indeterminate.
+
+    \sa paletteBackgroundPixmap, paletteForegroundColor, palette, colorGroup()
+*/
+const QColor & QWidget::paletteBackgroundColor() const
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    switch( mode ) {
+    case FixedColor:
+    case FixedPixmap :
+    case NoBackground:
+    case X11ParentRelative:
+	return eraseColor();
+    default:
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode( mode );
+	return colorGroup().color( role );
+    }
+#else
+    return eraseColor();
+#endif
+}
+
+void QWidget::setPaletteBackgroundColor( const QColor &color )
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    switch( mode ) {
+    case FixedColor:
+    case FixedPixmap :
+    case NoBackground:
+    case X11ParentRelative:
+	setEraseColor( color );
+	break;
+    default:
+	QPalette pal = palette();
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode( mode );
+	pal.setColor( QPalette::Active, role, color );
+	pal.setColor( QPalette::Inactive, role, color );
+	pal.setColor( QPalette::Disabled, role, color );
+	setPalette( pal );
+	break;
+    }
+#else
+    setEraseColor( color );
+#endif
+}
+
+
+/*!
+    \property QWidget::paletteBackgroundPixmap
+    \brief the background pixmap of the widget
+
+    The palette background pixmap is usually set implicitly by
+    setBackgroundMode(), although it can also be set explicitly by
+    setPaletteBackgroundPixmap(). setPaletteBackgroundPixmap() is a
+    convenience function that creates and sets a modified QPalette
+    with setPalette(). The palette is modified according to the
+    widget's background mode. For example, if the background mode is
+    \c PaletteButton the pixmap used for the palette's
+    \c QColorGroup::Button color entry is set.
+
+    If there is a plain background color (set using
+    setPaletteBackgroundColor()), then this function returns 0.
+
+    \sa paletteBackgroundColor, paletteForegroundColor, palette, colorGroup()
+*/
+const QPixmap *QWidget::paletteBackgroundPixmap() const
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    switch( mode ) {
+    case FixedColor:
+    case FixedPixmap :
+    case NoBackground:
+    case X11ParentRelative:
+	return erasePixmap();
+    default:
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode( mode );
+	return palette().brush( QPalette::Active, role ).pixmap();
+    }
+#else
+    return erasePixmap();
+#endif
+}
+
+void QWidget::setPaletteBackgroundPixmap( const QPixmap &pixmap )
+{
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    switch( mode ) {
+    case FixedColor:
+    case FixedPixmap :
+    case NoBackground:
+    case X11ParentRelative:
+	setErasePixmap( pixmap );
+	break;
+    default:
+	QPalette pal = palette();
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode( mode );
+	pal.setBrush( QPalette::Active, role, QBrush( pal.color( QPalette::Active, role ), pixmap ) );
+	pal.setBrush( QPalette::Inactive, role, QBrush( pal.color( QPalette::Inactive, role ), pixmap ) );
+	pal.setBrush( QPalette::Disabled, role, QBrush( pal.color( QPalette::Disabled, role ), pixmap ) );
+	setPalette( pal );
+	break;
+    }
+#else
+    setErasePixmap( pixmap );
+#endif
+}
+
+
+/*!
+    \property QWidget::backgroundBrush
+    \brief the widget's background brush
+
+    The background brush depends on a widget's palette and its
+    background mode.
+
+    \sa backgroundColor(), backgroundPixmap(), eraseColor(),  palette,
+    QApplication::setPalette()
+*/
+const QBrush& QWidget::backgroundBrush() const
+{
+    static QBrush noBrush;
+#ifndef QT_NO_PALETTE
+    BackgroundMode mode = extra ? (BackgroundMode) extra->bg_mode_visual : PaletteBackground;
+    switch( mode ) {
+    case FixedColor:
+    case FixedPixmap :
+    case NoBackground:
+    case X11ParentRelative:
+	return noBrush;
+    default:
+	QColorGroup::ColorRole role = QPalette::backgroundRoleFromMode( mode );
+	return colorGroup().brush( role );
+    }
+#else
+    return noBrush;
+#endif
+}
+
+
+/*!
+    \property QWidget::colorGroup
+    \brief the current color group of the widget palette
+
+    The color group is determined by the state of the widget. A
+    disabled widget has the QPalette::disabled() color group, a widget
+    with keyboard focus has the QPalette::active() color group, and an
+    inactive widget has the QPalette::inactive() color group.
+
+    \sa palette
+*/
+#ifndef QT_NO_PALETTE
+const QColorGroup &QWidget::colorGroup() const
+{
+    if ( !isEnabled() )
+	return palette().disabled();
+    else if ( !isVisible() || isActiveWindow() )
+	return palette().active();
+    else
+	return palette().inactive();
+}
+#endif
+
+/*!
+    \property QWidget::palette
+    \brief the widget's palette
+
+    As long as no special palette has been set, or after unsetPalette()
+    has been called, this is either a special palette for the widget
+    class, the parent's palette or (if this widget is a top level
+    widget), the default application palette.
+
+    Instead of defining an entirely new palette, you can also use the
+    \link QWidget::paletteBackgroundColor paletteBackgroundColor\endlink,
+    \link QWidget::paletteBackgroundPixmap paletteBackgroundPixmap\endlink and
+    \link QWidget::paletteForegroundColor paletteForegroundColor\endlink
+    convenience properties to change a widget's
+    background and foreground appearance only.
+
+    \sa ownPalette, colorGroup(), QApplication::palette()
+*/
+
+#ifndef QT_NO_PALETTE
+void QWidget::setPalette( const QPalette &palette )
+{
+    own_palette = TRUE;
+    if ( pal == palette )
+	return;
+    QPalette old = pal;
+    pal = palette;
+    setBackgroundFromMode();
+    QEvent ev( QEvent::PaletteChange );
+    QApplication::sendEvent( this, &ev );
+    if ( children() ) {
+	QEvent e( QEvent::ParentPaletteChange );
+	QObjectListIt it( *children() );
+	QWidget *w;
+	while( (w=(QWidget *)it.current()) != 0 ) {
+	    ++it;
+	    if ( w->isWidgetType() )
+		QApplication::sendEvent( w, &e );
+	}
+    }
+    paletteChange( old );
+    update();
+}
+
+void QWidget::unsetPalette()
+{
+    // reset the palette
+    setPalette( qt_naturalWidgetPalette( this ) );
+    own_palette = FALSE;
+}
+
+/*!
+  \fn void QWidget::setPalette( const QPalette&, bool )
+  \obsolete
+
+  Use setPalette( const QPalette& p ) instead.
+*/
+
+/*!
+    \fn void QWidget::paletteChange( const QPalette &oldPalette )
+
+    This virtual function is called from setPalette(). \a oldPalette
+    is the previous palette; you can get the new palette from
+    palette().
+
+    Reimplement this function if your widget needs to know when its
+    palette changes.
+
+    \sa setPalette(), palette()
+*/
+
+void QWidget::paletteChange( const QPalette & )
+{
+}
+#endif // QT_NO_PALETTE
+
+/*!
+    \property QWidget::font
+    \brief the font currently set for the widget
+
+    The fontInfo() function reports the actual font that is being used
+    by the widget.
+
+    As long as no special font has been set, or after unsetFont() is
+    called, this is either a special font for the widget class, the
+    parent's font or (if this widget is a top level widget), the
+    default application font.
+
+    This code fragment sets a 12 point helvetica bold font:
+    \code
+    QFont f( "Helvetica", 12, QFont::Bold );
+    setFont( f );
+    \endcode
+
+    In addition to setting the font, setFont() informs all children
+    about the change.
+
+    \sa fontChange() fontInfo() fontMetrics() ownFont()
+*/
+void QWidget::setFont( const QFont &font )
+{
+    own_font = TRUE;
+    if ( fnt == font && fnt.d->mask == font.d->mask )
+	return;
+    QFont old = fnt;
+    fnt = font.resolve( qt_naturalWidgetFont( this ) );
+#if defined(Q_WS_X11)
+    // make sure the font set on this widget is associated with the correct screen
+    fnt.x11SetScreen( x11Screen() );
+#endif
+    if ( children() ) {
+	QEvent e( QEvent::ParentFontChange );
+	QObjectListIt it( *children() );
+	QWidget *w;
+	while( (w=(QWidget *)it.current()) != 0 ) {
+	    ++it;
+	    if ( w->isWidgetType() )
+		QApplication::sendEvent( w, &e );
+	}
+    }
+    if ( hasFocus() )
+	setFontSys();
+    fontChange( old );
+}
+
+void QWidget::unsetFont()
+{
+    // reset the font
+    setFont( qt_naturalWidgetFont( this ) );
+    own_font = FALSE;
+}
+
+/*!
+  \fn void QWidget::setFont( const QFont&, bool )
+  \obsolete
+
+  Use setFont(const QFont& font) instead.
+*/
+
+/*!
+    \fn void QWidget::fontChange( const QFont &oldFont )
+
+    This virtual function is called from setFont(). \a oldFont is the
+    previous font; you can get the new font from font().
+
+    Reimplement this function if your widget needs to know when its
+    font changes. You will almost certainly need to update the widget
+    using update().
+
+    The default implementation updates the widget including its
+    geometry.
+
+    \sa setFont(), font(), update(), updateGeometry()
+*/
+
+void QWidget::fontChange( const QFont & )
+{
+    update();
+    updateGeometry();
+}
+
+
+/*!
+    \fn QFontMetrics QWidget::fontMetrics() const
+
+    Returns the font metrics for the widget's current font.
+    Equivalent to QFontMetrics(widget->font()).
+
+    \sa font(), fontInfo(), setFont()
+*/
+
+/*!
+    \fn QFontInfo QWidget::fontInfo() const
+
+    Returns the font info for the widget's current font.
+    Equivalent to QFontInto(widget->font()).
+
+    \sa font(), fontMetrics(), setFont()
+*/
+
+
+/*!
+    \property QWidget::cursor
+    \brief the cursor shape for this widget
+
+    The mouse cursor will assume this shape when it's over this
+    widget. See the \link Qt::CursorShape list of predefined cursor
+    objects\endlink for a range of useful shapes.
+
+    An editor widget might use an I-beam cursor:
+    \code
+	setCursor( IbeamCursor );
+    \endcode
+
+    If no cursor has been set, or after a call to unsetCursor(), the
+    parent's cursor is used. The function unsetCursor() has no effect
+    on top-level widgets.
+
+    \sa QApplication::setOverrideCursor()
+*/
+
+#ifndef QT_NO_CURSOR
+const QCursor &QWidget::cursor() const
+{
+    if ( testWState(WState_OwnCursor) )
+	return (extra && extra->curs)
+	    ? *extra->curs
+	    : arrowCursor;
+    else
+	return (isTopLevel() || !parentWidget()) ? arrowCursor : parentWidget()->cursor();
+}
+#endif
+#ifndef QT_NO_WIDGET_TOPEXTRA
+/*!
+    \property QWidget::caption
+    \brief the window caption (title)
+
+    This property only makes sense for top-level widgets. If no
+    caption has been set, the caption is QString::null.
+
+    \sa icon() iconText()
+*/
+QString QWidget::caption() const
+{
+    return extra && extra->topextra
+	? extra->topextra->caption
+	: QString::null;
+}
+
+/*!
+    \property QWidget::icon
+    \brief the widget's icon
+
+    This property only makes sense for top-level widgets. If no icon
+    has been set, icon() returns 0.
+
+    \sa iconText, caption,
+      \link appicon.html Setting the Application Icon\endlink
+*/
+const QPixmap *QWidget::icon() const
+{
+    return ( extra && extra->topextra ) ? extra->topextra->icon : 0;
+}
+
+/*!
+    \property QWidget::iconText
+    \brief the widget's icon text
+
+    This property only makes sense for top-level widgets. If no icon
+    text has been set, this functions returns QString::null.
+
+    \sa icon, caption
+*/
+
+QString QWidget::iconText() const
+{
+    return ( extra && extra->topextra ) ? extra->topextra->iconText
+	: QString::null;
+}
+#endif //QT_NO_WIDGET_TOPEXTRA
+
+/*!
+    \property QWidget::mouseTracking
+    \brief whether mouse tracking is enabled for the widget
+
+    If mouse tracking is disabled (the default), the widget only
+    receives mouse move events when at least one mouse button is
+    pressed while the mouse is being moved.
+
+    If mouse tracking is enabled, the widget receives mouse move
+    events even if no buttons are pressed.
+
+    \sa mouseMoveEvent(), QApplication::setGlobalMouseTracking()
+*/
+
+
+/*!
+    Sets the widget's focus proxy to widget \a w. If \a w is 0, the
+    function resets this widget to have no focus proxy.
+
+    Some widgets, such as QComboBox, can "have focus", but create a
+    child widget to actually handle the focus. QComboBox, for example,
+    creates a QLineEdit which handles the focus.
+
+    setFocusProxy() sets the widget which will actually get focus when
+    "this widget" gets it. If there is a focus proxy, focusPolicy(),
+    setFocusPolicy(), setFocus() and hasFocus() all operate on the
+    focus proxy.
+
+    \sa focusProxy()
+*/
+
+void QWidget::setFocusProxy( QWidget * w )
+{
+    if ( !w && !extra )
+	return;
+
+    for ( QWidget* fp  = w; fp; fp = fp->focusProxy() ) {
+	if ( fp == this ) {
+#if defined (QT_CHECK_STATE)
+	    qWarning( "%s (%s): already in focus proxy chain", className(), name() );
+#endif
+	    return;
+	}
+    }
+
+    createExtra();
+
+    if ( extra->focus_proxy ) {
+	disconnect( extra->focus_proxy, SIGNAL(destroyed()),
+		    this, SLOT(focusProxyDestroyed()) );
+	extra->focus_proxy = 0;
+    }
+
+    if ( w ) {
+	setFocusPolicy( w->focusPolicy() );
+	connect( w, SIGNAL(destroyed()),
+		 this, SLOT(focusProxyDestroyed()) );
+    }
+    extra->focus_proxy = w;
+}
+
+
+/*!
+    Returns the focus proxy, or 0 if there is no focus proxy.
+
+    \sa setFocusProxy()
+*/
+
+QWidget * QWidget::focusProxy() const
+{
+    return extra ? extra->focus_proxy : 0;
+}
+
+
+/*!
+    \internal
+
+    Internal slot used to clean up if the focus proxy is destroyed.
+
+    \sa setFocusProxy()
+*/
+
+void QWidget::focusProxyDestroyed()
+{
+    if ( extra )
+	extra->focus_proxy = 0;
+    setFocusPolicy( NoFocus );
+}
+
+/*!
+    \property QWidget::focus
+    \brief whether this widget (or its focus proxy) has the keyboard
+    input focus
+
+    Effectively equivalent to \c {qApp->focusWidget() == this}.
+
+    \sa setFocus(), clearFocus(), setFocusPolicy(), QApplication::focusWidget()
+*/
+bool QWidget::hasFocus() const
+{
+    const QWidget* w = this;
+    while ( w->focusProxy() )
+	w = w->focusProxy();
+    return qApp->focusWidget() == w;
+}
+
+/*!
+    Gives the keyboard input focus to this widget (or its focus
+    proxy) if this widget or one of its parents is the \link
+    isActiveWindow() active window\endlink.
+
+    First, a focus out event is sent to the focus widget (if any) to
+    tell it that it is about to lose the focus. Then a focus in event
+    is sent to this widget to tell it that it just received the focus.
+    (Nothing happens if the focus in and focus out widgets are the
+    same.)
+
+    setFocus() gives focus to a widget regardless of its focus policy,
+    but does not clear any keyboard grab (see grabKeyboard()).
+
+    Be aware that if the widget is hidden, it will not accept focus.
+
+    \warning If you call setFocus() in a function which may itself be
+    called from focusOutEvent() or focusInEvent(), you may get an
+    infinite recursion.
+
+    \sa hasFocus() clearFocus() focusInEvent() focusOutEvent()
+    setFocusPolicy() QApplication::focusWidget() grabKeyboard()
+    grabMouse()
+*/
+
+void QWidget::setFocus()
+{
+    if ( !isEnabled() )
+	return;
+
+    if ( focusProxy() ) {
+	focusProxy()->setFocus();
+	return;
+    }
+
+    QFocusData * f = focusData( TRUE );
+    if ( f->it.current() == this && qApp->focusWidget() == this
+#if defined(Q_WS_WIN)
+	&& GetFocus() == winId()
+#endif
+	)
+	return;
+
+    f->it.toFirst();
+    while ( f->it.current() != this && !f->it.atLast() )
+	++f->it;
+    // at this point, the iterator should point to 'this'.  if it
+    // does not, 'this' must not be in the list - an error, but
+    // perhaps possible.  fix it.
+    if ( f->it.current() != this ) {
+	f->focusWidgets.append( this );
+	f->it.toLast();
+    }
+
+    if ( isActiveWindow() ) {
+	QWidget * prev = qApp->focus_widget;
+	if ( prev ) {
+	    if ( prev != this )
+		prev->resetInputContext();
+	}
+#if defined(Q_WS_WIN)
+	else {
+	    QInputContext::endComposition();
+	}
+#endif
+	qApp->focus_widget = this;
+#if defined(Q_WS_X11)
+	focusInputContext();
+#endif
+
+#if defined(Q_WS_WIN)
+	if ( !topLevelWidget()->isPopup() )
+	    SetFocus( winId() );
+	else {
+#endif
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+	    QAccessible::updateAccessibility( this, 0, QAccessible::Focus );
+#endif
+#if defined(Q_WS_WIN)
+	}
+#endif
+
+	if ( prev != this ) {
+	    if ( prev ) {
+		QFocusEvent out( QEvent::FocusOut );
+		QApplication::sendEvent( prev, &out );
+	    }
+
+	    if ( qApp->focus_widget == this ) {
+		QFocusEvent in( QEvent::FocusIn );
+		QApplication::sendEvent( this, &in );
+	    }
+	}
+    }
+}
+
+/*!
+    Takes keyboard input focus from the widget.
+
+    If the widget has active focus, a \link focusOutEvent() focus out
+    event\endlink is sent to this widget to tell it that it is about
+    to lose the focus.
+
+    This widget must enable focus setting in order to get the keyboard
+    input focus, i.e. it must call setFocusPolicy().
+
+    \sa hasFocus(), setFocus(), focusInEvent(), focusOutEvent(),
+    setFocusPolicy(), QApplication::focusWidget()
+*/
+
+void QWidget::clearFocus()
+{
+    if ( focusProxy() ) {
+	focusProxy()->clearFocus();
+	return;
+    } else if ( hasFocus() ) {
+        resetInputContext();
+	QWidget* w = qApp->focusWidget();
+	// clear active focus
+	qApp->focus_widget = 0;
+	QFocusEvent out( QEvent::FocusOut );
+	QApplication::sendEvent( w, &out );
+#if defined(Q_WS_WIN)
+	if ( !isPopup() && GetFocus() == winId() )
+	    SetFocus( 0 );
+	else {
+#endif
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+	    QAccessible::updateAccessibility( this, 0, QAccessible::Focus );
+#endif
+#if defined(Q_WS_WIN)
+	}
+#endif
+    }
+}
+
+
+/*!
+    Finds a new widget to give the keyboard focus to, as appropriate
+    for Tab and Shift+Tab, and returns TRUE if is can find a new
+    widget and FALSE if it can't,
+
+    If \a next is TRUE, this function searches "forwards", if \a next
+    is FALSE, it searches "backwards".
+
+    Sometimes, you will want to reimplement this function. For
+    example, a web browser might reimplement it to move its "current
+    active link" forwards or backwards, and call
+    QWidget::focusNextPrevChild() only when it reaches the last or
+    first link on the "page".
+
+    Child widgets call focusNextPrevChild() on their parent widgets,
+    but only the top-level widget decides where to redirect focus. By
+    overriding this method for an object, you thus gain control of
+    focus traversal for all child widgets.
+
+    \warning QScrollView uses it own logic for this function, which
+    does the right thing in most cases. But if you are using a
+    QScrollView and want complete control of the focus chain you'll
+    need to override QScrollView::focusNextPrevChild() and your
+    top-level widgets' focusNextPrevChild() functions.
+
+    \sa focusData()
+*/
+
+bool QWidget::focusNextPrevChild( bool next )
+{
+    QWidget* p = parentWidget();
+    if ( !isTopLevel() && p )
+	return p->focusNextPrevChild(next);
+
+    QFocusData *f = focusData( TRUE );
+
+    QWidget *startingPoint = f->it.current();
+    QWidget *candidate = 0;
+    QWidget *w = next ? f->focusWidgets.last() : f->focusWidgets.first();
+    extern bool qt_tab_all_widgets;
+    uint focus_flag = qt_tab_all_widgets ? TabFocus : StrongFocus;
+    do {
+	if ( w && w != startingPoint &&
+	     ( ( w->focusPolicy() & focus_flag ) == focus_flag )
+	     && !w->focusProxy() && w->isVisibleTo(this) && w->isEnabled())
+	    candidate = w;
+	w = next ? f->focusWidgets.prev() : f->focusWidgets.next();
+    } while( w && !(candidate && w==startingPoint) );
+
+    if ( !candidate )
+	return FALSE;
+
+    candidate->setFocus();
+    return TRUE;
+}
+
+/*!
+    Returns the focus widget in this widget's window. This is not the
+    same as QApplication::focusWidget(), which returns the focus
+    widget in the currently active window.
+*/
+
+QWidget *QWidget::focusWidget() const
+{
+    QWidget *that = (QWidget *)this;		// mutable
+    QFocusData *f = that->focusData( FALSE );
+    if ( f && f->focusWidgets.count() && f->it.current() == 0 )
+	f->it.toFirst();
+    return ( f && f->it.current() ) ? f->it.current() : 0;
+}
+
+
+/*!
+    Returns the focus data for this widget's top-level widget.
+
+    Focus data always belongs to the top-level widget. The focus data
+    list contains all the widgets in this top-level widget that can
+    accept focus, in tab order. An iterator points to the current
+    focus widget (focusWidget() returns a pointer to this widget).
+
+    This information is useful for implementing advanced versions of
+    focusNextPrevChild().
+*/
+QFocusData * QWidget::focusData()
+{
+    return focusData( TRUE );
+}
+
+/*!
+    \internal
+
+    Internal function which lets us ask for the focus data, creating
+    it if it doesn't exist and \a create is TRUE.
+*/
+QFocusData * QWidget::focusData( bool create )
+{
+    QWidget * tlw = topLevelWidget();
+    QWExtra * ed = tlw->extraData();
+    if ( !ed || !ed->topextra ) {
+	if ( !create )
+	    return 0;
+	tlw->createTLExtra();
+	ed = tlw->extraData();
+    }
+    if ( create && !ed->topextra->focusData )
+	ed->topextra->focusData = new QFocusData;
+
+    return ed->topextra->focusData;
+}
+
+/*!
+    \property QWidget::inputMethodEnabled
+    \brief enables or disables the use of input methods for this widget.
+
+    Most Widgets (as eg. buttons) that do not handle text input should have
+    the input method disabled if they have focus. This is the default.
+
+    If a widget handles text input it should set this property to TRUE.
+*/
+
+void QWidget::setInputMethodEnabled( bool b )
+{
+    im_enabled = b;
+#ifdef Q_WS_WIN
+    QInputContext::enable( this, im_enabled & !((bool)testWState(WState_Disabled)) );
+#endif
+}
+
+
+/*!
+    Enables key event compression, if \a compress is TRUE, and
+    disables it if \a compress is FALSE.
+
+    Key compression is off by default (except for QLineEdit and
+    QTextEdit), so widgets receive one key press event for each key
+    press (or more, since autorepeat is usually on). If you turn it on
+    and your program doesn't keep up with key input, Qt may try to
+    compress key events so that more than one character can be
+    processed in each event.
+
+    For example, a word processor widget might receive 2, 3 or more
+    characters in each QKeyEvent::text(), if the layout recalculation
+    takes too long for the CPU.
+
+    If a widget supports multiple character unicode input, it is
+    always safe to turn the compression on.
+
+    Qt performs key event compression only for printable characters.
+    Modifier keys, cursor movement keys, function keys and
+    miscellaneous action keys (e.g. Escape, Enter, Backspace,
+    PrintScreen) will stop key event compression, even if there are
+    more compressible key events available.
+
+    Not all platforms support this compression, in which case turning
+    it on will have no effect.
+
+    \sa QKeyEvent::text();
+*/
+
+void QWidget::setKeyCompression(bool compress)
+{
+    if ( compress )
+	setWState( WState_CompressKeys );
+    else
+	clearWState( WState_CompressKeys );
+}
+
+/*!
+    \property QWidget::isActiveWindow
+    \brief whether this widget is the active window
+
+    The active window is the window that contains the widget
+    that has keyboard focus.
+
+    When popup windows are visible, this property is TRUE for both the
+    active window \e and for the popup.
+
+    \sa setActiveWindow(), QApplication::activeWindow()
+*/
+bool QWidget::isActiveWindow() const
+{
+    QWidget *tlw = topLevelWidget();
+    if(testWFlags(WSubWindow) && parentWidget())
+	tlw = parentWidget()->topLevelWidget();
+    if(tlw == qApp->activeWindow() || ( isVisible() && tlw->isPopup() ))
+	return TRUE;
+#ifndef QT_NO_STYLE
+    if(style().styleHint(QStyle::SH_Widget_ShareActivation, this )) {
+        if((tlw->isDialog() || (tlw->testWFlags(Qt::WStyle_Tool) && !tlw->isPopup())) &&
+           !tlw->testWFlags(Qt::WShowModal) &&
+           (!tlw->parentWidget() || tlw->parentWidget()->isActiveWindow()))
+	   return TRUE;
+	QWidget *w = qApp->activeWindow();
+	if( !testWFlags(WSubWindow) && w && w->testWFlags(WSubWindow) &&
+	    w->parentWidget()->topLevelWidget() == tlw)
+	    return TRUE;
+        while(w && (tlw->isDialog() || tlw->testWFlags(Qt::WStyle_Tool)) &&
+              !w->testWFlags(Qt::WShowModal) && w->parentWidget()) {
+	    w = w->parentWidget()->topLevelWidget();
+	    if( w == tlw )
+		return TRUE;
+	}
+    }
+#endif
+#if defined(Q_WS_WIN32)
+    HWND parent = tlw->winId();
+    HWND topparent = GetActiveWindow();
+    while ( parent ) {
+	parent = ::GetParent( parent );
+	if ( parent && parent == topparent )
+	    return TRUE;
+    }
+#endif
+
+    return FALSE;
+}
+
+/*!
+    Moves the \a second widget around the ring of focus widgets so
+    that keyboard focus moves from the \a first widget to the \a
+    second widget when the Tab key is pressed.
+
+    Note that since the tab order of the \a second widget is changed,
+    you should order a chain like this:
+
+    \code
+	setTabOrder( a, b ); // a to b
+	setTabOrder( b, c ); // a to b to c
+	setTabOrder( c, d ); // a to b to c to d
+    \endcode
+
+    \e not like this:
+
+    \code
+	setTabOrder( c, d ); // c to d   WRONG
+	setTabOrder( a, b ); // a to b AND c to d
+	setTabOrder( b, c ); // a to b to c, but not c to d
+    \endcode
+
+    If \a first or \a second has a focus proxy, setTabOrder()
+    correctly substitutes the proxy.
+
+    \sa setFocusPolicy(), setFocusProxy()
+*/
+void QWidget::setTabOrder( QWidget* first, QWidget *second )
+{
+    if ( !first || !second ||
+	first->focusPolicy() == NoFocus || second->focusPolicy() == NoFocus )
+	return;
+
+    // If first is redirected, set first to the last child of first
+    // that can take keyboard focus so that second is inserted after
+    // that last child, and the focus order within first is (more
+    // likely to be) preserved.
+    if ( first->focusProxy() ) {
+	QObjectList *l = first->queryList( "QWidget" );
+	if ( l && l->count() ) {
+	    QObjectListIt it(*l);
+	    it.toLast();
+	    while (it.current()) {
+		if (((QWidget*)it.current())->topLevelWidget() == first->topLevelWidget()) {
+		    first = (QWidget*)it.current();
+		    if (first->focusPolicy() != NoFocus)
+			break;
+		}
+		--it;
+	    }
+	}
+	delete l;
+    }
+    while ( first->focusProxy() )
+	first = first->focusProxy();
+    while ( second->focusProxy() )
+	second = second->focusProxy();
+
+    QFocusData *f = first->focusData( TRUE );
+    bool focusThere = (f->it.current() == second );
+    f->focusWidgets.removeRef( second );
+    if ( f->focusWidgets.findRef( first ) >= 0 )
+	f->focusWidgets.insert( f->focusWidgets.at() + 1, second );
+    else
+	f->focusWidgets.append( second );
+    if ( focusThere ) { // reset iterator so tab will work appropriately
+	f->it.toFirst();
+	while( f->it.current() && f->it.current() != second )
+	    ++f->it;
+    }
+}
+
+/*!\internal
+
+  Moves the relevant subwidgets of this widget from the \a oldtlw's
+  tab chain to that of the new parent, if there's anything to move and
+  we're really moving
+
+  This function is called from QWidget::reparent() *after* the widget
+  has been reparented.
+
+  \sa reparent()
+*/
+
+void QWidget::reparentFocusWidgets( QWidget * oldtlw )
+{
+    if ( oldtlw == topLevelWidget() )
+	return; // nothing to do
+
+    QFocusData * from = oldtlw ? oldtlw->topData()->focusData : 0;
+    QFocusData * to;
+    to = focusData();
+
+    if ( from ) {
+	from->focusWidgets.first();
+	do {
+	    QWidget * pw = from->focusWidgets.current();
+	    while( pw && pw != this )
+		pw = pw->parentWidget();
+	    if ( pw == this ) {
+		QWidget * w = from->focusWidgets.take();
+		if ( w == from->it.current() )
+		    // probably best to clear keyboard focus, or
+		    // the user might become rather confused
+		    w->clearFocus();
+		if ( !isTopLevel() )
+		    to->focusWidgets.append( w );
+	    } else {
+		from->focusWidgets.next();
+	    }
+	} while( from->focusWidgets.current() );
+    }
+
+    if ( to->focusWidgets.findRef(this) < 0 )
+	to->focusWidgets.append( this );
+
+    if ( !isTopLevel() && extra && extra->topextra && extra->topextra->focusData ) {
+	// this widget is no longer a top-level widget, so get rid
+	// of old focus data
+	delete extra->topextra->focusData;
+	extra->topextra->focusData = 0;
+    }
+}
+
+/*!
+  \fn void QWidget::recreate( QWidget *parent, WFlags f, const QPoint & p, bool showIt )
+
+  \obsolete
+
+  This method is provided to aid porting from Qt 1.0 to 2.0. It has
+  been renamed reparent() in Qt 2.0.
+*/
+
+/*!
+    \property QWidget::frameSize
+    \brief the size of the widget including any window frame
+*/
+QSize QWidget::frameSize() const
+{
+    if ( isTopLevel() && !isPopup() ) {
+	if ( fstrut_dirty )
+	    updateFrameStrut();
+	QWidget *that = (QWidget *) this;
+	QTLWExtra *top = that->topData();
+	return QSize( crect.width() + top->fleft + top->fright,
+		      crect.height() + top->ftop + top->fbottom );
+    }
+    return crect.size();
+}
+
+/*!
+    \internal
+
+    Recursive function that updates \a widget and all its children,
+    if they have some parent background origin.
+*/
+static void qt_update_bg_recursive( QWidget *widget )
+{
+    if ( !widget || widget->isHidden() || widget->backgroundOrigin() == QWidget::WidgetOrigin || !widget->backgroundPixmap() )
+	return;
+
+    const QObjectList *lst = widget->children();
+
+    if ( lst ) {
+	QObjectListIterator it( *lst );
+	QWidget *widget;
+	while ( (widget = (QWidget*)it.current()) ) {
+	    ++it;
+	    if ( widget->isWidgetType() && !widget->isHidden() && !widget->isTopLevel() && !widget->testWFlags(Qt::WSubWindow) )
+		    qt_update_bg_recursive( widget );
+	}
+    }
+    QApplication::postEvent( widget, new QPaintEvent( widget->clipRegion(), !widget->testWFlags(Qt::WRepaintNoErase) ) );
+}
+
+/*!
+    \overload
+
+    This corresponds to move( QPoint(\a x, \a y) ).
+*/
+
+void QWidget::move( int x, int y )
+{
+    QPoint oldp(pos());
+    internalSetGeometry( x + geometry().x() - QWidget::x(),
+			 y + geometry().y() - QWidget::y(),
+			 width(), height(), TRUE );
+    if ( isVisible() && oldp != pos() )
+	qt_update_bg_recursive( this );
+}
+
+/*!
+    \overload
+
+    This corresponds to resize( QSize(\a w, \a h) ).
+*/
+void QWidget::resize( int w, int h )
+{
+    internalSetGeometry( geometry().x(), geometry().y(), w, h, FALSE );
+    setWState( WState_Resized );
+}
+
+/*!
+    \overload
+
+    This corresponds to setGeometry( QRect(\a x, \a y, \a w, \a h) ).
+*/
+void QWidget::setGeometry( int x, int y, int w, int h )
+{
+    QPoint oldp( pos( ));
+    internalSetGeometry( x, y, w, h, TRUE );
+    setWState( WState_Resized );
+    if ( isVisible() && oldp != pos() )
+	qt_update_bg_recursive( this );
+}
+
+/*!
+    \property QWidget::focusEnabled
+    \brief whether the widget accepts keyboard focus
+
+    Keyboard focus is initially disabled (i.e. focusPolicy() ==
+    \c QWidget::NoFocus).
+
+    You must enable keyboard focus for a widget if it processes
+    keyboard events. This is normally done from the widget's
+    constructor. For instance, the QLineEdit constructor calls
+    setFocusPolicy(QWidget::StrongFocus).
+
+    \sa setFocusPolicy(), focusInEvent(), focusOutEvent(), keyPressEvent(),
+      keyReleaseEvent(), isEnabled()
+*/
+
+/*!
+    \enum QWidget::FocusPolicy
+
+    This enum type defines the various policies a widget can have with
+    respect to acquiring keyboard focus.
+
+    \value TabFocus  the widget accepts focus by tabbing.
+    \value ClickFocus  the widget accepts focus by clicking.
+    \value StrongFocus  the widget accepts focus by both tabbing
+			and clicking. On Mac OS X this will also
+			be indicate that the widget accepts tab focus
+			when in 'Text/List focus mode'.
+    \value WheelFocus  like StrongFocus plus the widget accepts
+			focus by using the mouse wheel.
+    \value NoFocus  the widget does not accept focus.
+
+*/
+
+/*!
+    \property QWidget::focusPolicy
+    \brief the way the widget accepts keyboard focus
+
+    The policy is \c QWidget::TabFocus if the widget accepts keyboard
+    focus by tabbing, \c QWidget::ClickFocus if the widget accepts
+    focus by clicking, \c QWidget::StrongFocus if it accepts both, and
+    \c QWidget::NoFocus (the default) if it does not accept focus at
+    all.
+
+    You must enable keyboard focus for a widget if it processes
+    keyboard events. This is normally done from the widget's
+    constructor. For instance, the QLineEdit constructor calls
+    setFocusPolicy(QWidget::StrongFocus).
+
+    \sa focusEnabled, focusInEvent(), focusOutEvent(), keyPressEvent(),
+      keyReleaseEvent(), enabled
+*/
+
+void QWidget::setFocusPolicy( FocusPolicy policy )
+{
+    if ( focusProxy() )
+	focusProxy()->setFocusPolicy( policy );
+    if ( policy != NoFocus ) {
+	QFocusData * f = focusData( TRUE );
+	if ( f->focusWidgets.findRef( this ) < 0 )
+	    f->focusWidgets.append( this );
+    }
+    focus_policy = (uint) policy;
+}
+
+/*!
+    \property QWidget::updatesEnabled
+    \brief whether updates are enabled
+
+    Calling update() and repaint() has no effect if updates are
+    disabled. Paint events from the window system are processed
+    normally even if updates are disabled.
+
+    setUpdatesEnabled() is normally used to disable updates for a
+    short period of time, for instance to avoid screen flicker during
+    large changes.
+
+    Example:
+    \code
+	setUpdatesEnabled( FALSE );
+	bigVisualChanges();
+	setUpdatesEnabled( TRUE );
+	repaint();
+    \endcode
+
+    \sa update(), repaint(), paintEvent()
+*/
+void QWidget::setUpdatesEnabled( bool enable )
+{
+    if ( enable )
+	clearWState( WState_BlockUpdates );
+    else
+	setWState( WState_BlockUpdates );
+}
+
+/*!
+    Shows the widget and its child widgets.
+
+    If its size or position has changed, Qt guarantees that a widget
+    gets move and resize events just before it is shown.
+
+    You almost never have to reimplement this function. If you need to
+    change some settings before a widget is shown, use showEvent()
+    instead. If you need to do some delayed initialization use
+    polish().
+
+    \sa showEvent(), hide(), showMinimized(), showMaximized(),
+    showNormal(), isVisible(), polish()
+*/
+
+void QWidget::show()
+{
+    if ( testWState(WState_Visible) )
+	return;
+
+    bool wasHidden = isHidden();
+    bool postLayoutHint = !isTopLevel() && wasHidden;
+    clearWState( WState_ForceHide | WState_CreatedHidden );
+
+    if ( !isTopLevel() && !parentWidget()->isVisible() ) {
+	// we should become visible, but one of our ancestors is
+	// explicitly hidden. Since we cleared the ForceHide flag, our
+	// immediate parent will call show() on us again during its
+	// own processing of show().
+	if ( wasHidden ) {
+	    QEvent showToParentEvent( QEvent::ShowToParent );
+	    QApplication::sendEvent( this, &showToParentEvent );
+	}
+	if ( postLayoutHint )
+	    QApplication::postEvent( parentWidget(),
+				     new QEvent(QEvent::LayoutHint) );
+	return;
+    }
+
+    in_show = TRUE; // set qws recursion watch
+
+    QApplication::sendPostedEvents( this, QEvent::ChildInserted );
+
+    uint state = isTopLevel() ? windowState() : 0;
+#ifndef Q_OS_TEMP
+    if ( isTopLevel() && !testWState( WState_Resized ) ) {
+	// do this before sending the posted resize events. Otherwise
+	// the layout would catch the resize event and may expand the
+	// minimum size.
+	QSize s = qt_naturalWidgetSize( this );
+	if ( !s.isEmpty() )
+	    resize( s );
+    }
+#endif // Q_OS_TEMP
+
+    QApplication::sendPostedEvents( this, QEvent::Move );
+    QApplication::sendPostedEvents( this, QEvent::Resize );
+
+    // the resizing and layouting might have changed the window state
+    if (isTopLevel() && windowState() != state)
+	setWindowState(state);
+
+    setWState( WState_Visible );
+
+    if ( parentWidget() )
+	QApplication::sendPostedEvents( parentWidget(),
+					QEvent::ChildInserted );
+
+    if ( extra ) {
+	int w = crect.width();
+	int h = crect.height();
+	if ( w < extra->minw || h < extra->minh ||
+	     w > extra->maxw || h > extra->maxh ) {
+	    w = QMAX( extra->minw, QMIN( w, extra->maxw ));
+	    h = QMAX( extra->minh, QMIN( h, extra->maxh ));
+	    resize( w, h );			// deferred resize
+	}
+    }
+
+    if ( testWFlags(WStyle_Tool) || isPopup() ) {
+	raise();
+    } else if ( testWFlags(WType_TopLevel) ) {
+	while ( QApplication::activePopupWidget() ) {
+	    if ( !QApplication::activePopupWidget()->close() )
+		break;
+	}
+    }
+
+    if ( !testWState(WState_Polished) )
+	polish();
+
+    showChildren( FALSE );
+
+    if ( postLayoutHint )
+	QApplication::postEvent( parentWidget(),
+				 new QEvent(QEvent::LayoutHint) );
+
+    // Required for Mac, not sure whether we should always do that
+    if( isTopLevel() )
+	QApplication::sendPostedEvents(0, QEvent::LayoutHint);
+
+    // On Windows, show the popup now so that our own focus handling
+    // stores the correct old focus widget even if it's stolen in the showevent
+#if defined(Q_WS_WIN)
+    if ( testWFlags(WType_Popup) )
+	qApp->openPopup( this );
+#endif
+
+    QShowEvent showEvent;
+    QApplication::sendEvent( this, &showEvent );
+
+    if ( testWFlags(WShowModal) ) {
+	// qt_enter_modal *before* show, otherwise the initial
+	// stacking might be wrong
+	qt_enter_modal( this );
+    }
+
+    // do not show the window directly, but post a show-window request
+    // to reduce flicker with widgets in layouts
+    if ( postLayoutHint )
+	QApplication::postEvent( this, new QEvent( QEvent::ShowWindowRequest ) );
+    else
+	showWindow();
+
+#if !defined(Q_WS_WIN)
+    if ( testWFlags(WType_Popup) )
+	qApp->openPopup( this );
+#endif
+
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+    QAccessible::updateAccessibility( this, 0, QAccessible::ObjectShow );
+#endif
+
+    in_show = FALSE;  // reset qws recursion watch
+}
+
+/*! \fn void QWidget::iconify()
+    \obsolete
+*/
+
+/*!
+    Hides the widget.
+
+    You almost never have to reimplement this function. If you need to
+    do something after a widget is hidden, use hideEvent() instead.
+
+    \sa hideEvent(), isHidden(), show(), showMinimized(), isVisible(), close()
+*/
+
+void QWidget::hide()
+{
+    clearWState( WState_CreatedHidden );
+    if ( testWState(WState_ForceHide) )
+	return;
+
+    setWState( WState_ForceHide );
+
+    if ( testWFlags(WType_Popup) )
+	qApp->closePopup( this );
+
+    // Move test modal here.  Otherwise, a modal dialog could get
+    // destroyed and we lose all access to its parent because we haven't
+    // left modality.  (Eg. modal Progress Dialog)
+    if ( testWFlags(WShowModal) )
+	qt_leave_modal( this );
+
+#if defined(Q_WS_WIN)
+    if ( isTopLevel() && !isPopup() && parentWidget() && isActiveWindow() )
+	parentWidget()->setActiveWindow();	// Activate parent
+#endif
+
+    hideWindow();
+
+    if ( testWState(WState_Visible) ) {
+	clearWState( WState_Visible );
+
+	// next bit tries to move the focus if the focus widget is now
+	// hidden.
+	if ( qApp && qApp->focusWidget() == this )
+  	    focusNextPrevChild( TRUE );
+	QHideEvent hideEvent;
+	QApplication::sendEvent( this, &hideEvent );
+	hideChildren( FALSE );
+
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+	QAccessible::updateAccessibility( this, 0, QAccessible::ObjectHide );
+#endif
+    } else {
+	QEvent hideToParentEvent( QEvent::HideToParent );
+	QApplication::sendEvent( this, &hideToParentEvent );
+    }
+
+    // post layout hint for non toplevels. The parent widget check is
+    // necessary since the function is called in the destructor
+    if ( !isTopLevel() && parentWidget() )
+	QApplication::postEvent( parentWidget(),
+				 new QEvent( QEvent::LayoutHint) );
+}
+
+void QWidget::setShown( bool show )
+{
+    if ( show )
+	this->show();
+    else
+	hide();
+}
+
+void QWidget::setHidden( bool hide )
+{
+    if ( hide )
+	this->hide();
+    else
+	show();
+}
+
+void QWidget::showChildren( bool spontaneous )
+{
+     if ( children() ) {
+	QObjectListIt it(*children());
+	register QObject *object;
+	QWidget *widget;
+	while ( it ) {
+	    object = it.current();
+	    ++it;
+	    if ( object->isWidgetType() ) {
+		widget = (QWidget*)object;
+		if ( !widget->isTopLevel() && widget->isShown() ) {
+		    if ( spontaneous ) {
+			widget->showChildren( spontaneous );
+			QShowEvent e;
+			QApplication::sendSpontaneousEvent( widget, &e );
+		    } else {
+			widget->show();
+		    }
+		}
+	    }
+	}
+    }
+}
+
+void QWidget::hideChildren( bool spontaneous )
+{
+     if ( children() ) {
+	QObjectListIt it(*children());
+	register QObject *object;
+	QWidget *widget;
+	while ( it ) {
+	    object = it.current();
+	    ++it;
+	    if ( object->isWidgetType() ) {
+		widget = (QWidget*)object;
+		if ( !widget->isTopLevel() && widget->isShown() ) {
+		    if ( !spontaneous )
+			widget->clearWState( WState_Visible );
+		    widget->hideChildren( spontaneous );
+		    QHideEvent e;
+		    if ( spontaneous )
+			QApplication::sendSpontaneousEvent( widget, &e );
+		    else
+			QApplication::sendEvent( widget, &e );
+		}
+	    }
+	}
+    }
+}
+
+
+/*!
+    Delayed initialization of a widget.
+
+    This function will be called \e after a widget has been fully
+    created and \e before it is shown the very first time.
+
+    Polishing is useful for final initialization which depends on
+    having an instantiated widget. This is something a constructor
+    cannot guarantee since the initialization of the subclasses might
+    not be finished.
+
+    After this function, the widget has a proper font and palette and
+    QApplication::polish() has been called.
+
+    Remember to call QWidget's implementation first when reimplementing this
+    function to ensure that your program does not end up in infinite recursion.
+
+    \sa constPolish(), QApplication::polish()
+*/
+
+void QWidget::polish()
+{
+#ifndef QT_NO_WIDGET_TOPEXTRA
+    if ( isTopLevel() ) {
+	const QPixmap *pm = icon();
+	if ( !pm || pm->isNull() ) {
+	    QWidget *mw = (QWidget *)parent();
+	    pm = mw ? mw->icon() : 0;
+	    if ( pm && !pm->isNull() )
+		setIcon( *pm );
+	    else {
+		mw = mw ? mw->topLevelWidget() : 0;
+		pm = mw ? mw->icon() : 0;
+		if ( pm && !pm->isNull() )
+		    setIcon( *pm );
+		else {
+		    mw = qApp ? qApp->mainWidget() : 0;
+		    pm = mw ? mw->icon() : 0;
+		    if ( pm && !pm->isNull() )
+			setIcon( *pm );
+		}
+	    }
+	}
+    }
+#endif
+    if ( !testWState(WState_Polished) ) {
+	if ( ! own_font &&
+	     ! QApplication::font( this ).isCopyOf( QApplication::font() ) )
+	    unsetFont();
+#ifndef QT_NO_PALETTE
+	if ( ! own_palette &&
+	     ! QApplication::palette( this ).isCopyOf( QApplication::palette() ) )
+	    unsetPalette();
+#endif
+	setWState(WState_Polished);
+	qApp->polish( this );
+	QApplication::sendPostedEvents( this, QEvent::ChildInserted );
+    }
+}
+
+
+/*!
+    \fn void QWidget::constPolish() const
+
+    Ensures that the widget is properly initialized by calling
+    polish().
+
+    Call constPolish() from functions like sizeHint() that depends on
+    the widget being initialized, and that may be called before
+    show().
+
+    \warning Do not call constPolish() on a widget from inside that
+    widget's constructor.
+
+    \sa polish()
+*/
+
+/*!
+    \overload
+
+    Closes this widget. Returns TRUE if the widget was closed;
+    otherwise returns FALSE.
+
+    If \a alsoDelete is TRUE or the widget has the \c
+    WDestructiveClose widget flag, the widget is also deleted. The
+    widget can prevent itself from being closed by rejecting the
+    \l QCloseEvent it gets. A close events is delivered to the widget
+    no matter if the widget is visible or not.
+
+    The QApplication::lastWindowClosed() signal is emitted when the
+    last visible top level widget is closed.
+
+    Note that closing the \l QApplication::mainWidget() terminates the
+    application.
+
+    \sa closeEvent(), QCloseEvent, hide(), QApplication::quit(),
+    QApplication::setMainWidget(), QApplication::lastWindowClosed()
+*/
+
+bool QWidget::close( bool alsoDelete )
+{
+    if ( is_closing )
+	return TRUE;
+    is_closing = 1;
+    WId id	= winId();
+    bool isMain = qApp->mainWidget() == this;
+    bool checkLastWindowClosed = isTopLevel() && !isPopup();
+    bool deleted = FALSE;
+    QCloseEvent e;
+    QApplication::sendEvent( this, &e );
+    deleted = !QWidget::find(id);
+    if ( !deleted && !e.isAccepted() ) {
+	is_closing = 0;
+	return FALSE;
+    }
+    if ( !deleted && !isHidden() )
+	hide();
+    if ( checkLastWindowClosed
+	 && qApp->receivers(SIGNAL(lastWindowClosed())) ) {
+	/* if there is no non-withdrawn top level window left (except
+	   the desktop, popups, or dialogs with parents), we emit the
+	   lastWindowClosed signal */
+	QWidgetList *list   = qApp->topLevelWidgets();
+	QWidget     *widget = list->first();
+	while ( widget ) {
+	    if ( !widget->isHidden()
+		 && !widget->isDesktop()
+		 && !widget->isPopup()
+		 && (!widget->isDialog() || !widget->parentWidget()))
+		break;
+	    widget = list->next();
+	}
+	delete list;
+	if ( widget == 0 )
+	    emit qApp->lastWindowClosed();
+    }
+    if ( isMain )
+	qApp->quit();
+    if ( deleted )
+	return TRUE;
+    is_closing = 0;
+    if ( alsoDelete )
+	delete this;
+    else if ( testWFlags(WDestructiveClose) ) {
+	clearWFlags(WDestructiveClose);
+	deleteLater();
+    }
+    return TRUE;
+}
+
+
+/*!
+    \fn bool QWidget::close()
+
+    Closes this widget. Returns TRUE if the widget was closed;
+    otherwise returns FALSE.
+
+    First it sends the widget a QCloseEvent. The widget is \link
+    hide() hidden\endlink if it \link QCloseEvent::accept()
+    accepts\endlink the close event. The default implementation of
+    QWidget::closeEvent() accepts the close event.
+
+    The \l QApplication::lastWindowClosed() signal is emitted when the
+    last visible top level widget is closed.
+
+*/
+
+/*!
+    \property QWidget::visible
+    \brief whether the widget is visible
+
+    Calling show() sets the widget to visible status if all its parent
+    widgets up to the top-level widget are visible. If an ancestor is
+    not visible, the widget won't become visible until all its
+    ancestors are shown.
+
+    Calling hide() hides a widget explicitly. An explicitly hidden
+    widget will never become visible, even if all its ancestors become
+    visible, unless you show it.
+
+    A widget receives show and hide events when its visibility status
+    changes. Between a hide and a show event, there is no need to
+    waste CPU cycles preparing or displaying information to the user.
+    A video application, for example, might simply stop generating new
+    frames.
+
+    A widget that happens to be obscured by other windows on the
+    screen is considered to be visible. The same applies to iconified
+    top-level widgets and windows that exist on another virtual
+    desktop (on platforms that support this concept). A widget
+    receives spontaneous show and hide events when its mapping status
+    is changed by the window system, e.g. a spontaneous hide event
+    when the user minimizes the window, and a spontaneous show event
+    when the window is restored again.
+
+    \sa show(), hide(), isHidden(), isVisibleTo(), isMinimized(),
+    showEvent(), hideEvent()
+*/
+
+
+/*!
+    Returns TRUE if this widget would become visible if \a ancestor is
+    shown; otherwise returns FALSE.
+
+    The TRUE case occurs if neither the widget itself nor any parent
+    up to but excluding \a ancestor has been explicitly hidden.
+
+    This function will still return TRUE if the widget is obscured by
+    other windows on the screen, but could be physically visible if it
+    or they were to be moved.
+
+    isVisibleTo(0) is identical to isVisible().
+
+    \sa show() hide() isVisible()
+*/
+
+bool QWidget::isVisibleTo(QWidget* ancestor) const
+{
+    if ( !ancestor )
+	return isVisible();
+    const QWidget * w = this;
+    while ( w
+	    && w->isShown()
+	    && !w->isTopLevel()
+	    && w->parentWidget()
+	    && w->parentWidget() != ancestor )
+	w = w->parentWidget();
+    return w->isShown();
+}
+
+
+/*!
+  \fn bool QWidget::isVisibleToTLW() const
+  \obsolete
+
+  This function is deprecated. It is equivalent to isVisible()
+*/
+
+/*!
+    \property QWidget::hidden
+    \brief whether the widget is explicitly hidden
+
+    If FALSE, the widget is visible or would become visible if all its
+    ancestors became visible.
+
+    \sa hide(), show(), isVisible(), isVisibleTo(), shown
+*/
+
+/*!
+    \property QWidget::shown
+    \brief whether the widget is shown
+
+    If TRUE, the widget is visible or would become visible if all its
+    ancestors became visible.
+
+    \sa hide(), show(), isVisible(), isVisibleTo(), hidden
+*/
+
+/*!
+    \property QWidget::visibleRect
+    \brief the visible rectangle
+
+    \obsolete
+
+    No longer necessary, you can simply call repaint(). If you do not
+    need the rectangle for repaint(), use clipRegion() instead.
+*/
+QRect QWidget::visibleRect() const
+{
+    QRect r = rect();
+    const QWidget * w = this;
+    int ox = 0;
+    int oy = 0;
+    while ( w
+	    && w->isVisible()
+	    && !w->isTopLevel()
+	    && w->parentWidget() ) {
+	ox -= w->x();
+	oy -= w->y();
+	w = w->parentWidget();
+	r = r.intersect( QRect( ox, oy, w->width(), w->height() ) );
+    }
+    if ( !w->isVisible() )
+	return QRect();
+    return r;
+}
+
+/*!
+    Returns the unobscured region where paint events can occur.
+
+    For visible widgets, this is an approximation of the area not
+    covered by other widgets; otherwise, this is an empty region.
+
+    The repaint() function calls this function if necessary, so in
+    general you do not need to call it.
+
+*/
+QRegion QWidget::clipRegion() const
+{
+    return visibleRect();
+}
+
+
+/*!
+    Adjusts the size of the widget to fit the contents.
+
+    Uses sizeHint() if valid (i.e if the size hint's width and height
+    are \>= 0), otherwise sets the size to the children rectangle (the
+    union of all child widget geometries).
+
+    \sa sizeHint(), childrenRect()
+*/
+
+void QWidget::adjustSize()
+{
+    QApplication::sendPostedEvents( 0, QEvent::ChildInserted );
+    QApplication::sendPostedEvents( 0, QEvent::LayoutHint );
+    if ( !testWState(WState_Polished) )
+	polish();
+    QSize s = sizeHint();
+
+    if ( isTopLevel() ) {
+
+#if defined(Q_WS_X11)
+	QRect screen = QApplication::desktop()->screenGeometry( x11Screen() );
+#else // all others
+	QRect screen = QApplication::desktop()->screenGeometry( pos() );
+#endif
+
+#ifndef QT_NO_LAYOUT
+	if ( layout() ) {
+	    if ( layout()->hasHeightForWidth() ) {
+		s = s.boundedTo( screen.size() );
+		s.setHeight( layout()->totalHeightForWidth( s.width() ) );
+	    }
+	} else
+#endif
+	{
+	    if ( sizePolicy().hasHeightForWidth() ) {
+		s = s.boundedTo( screen.size() );
+		s.setHeight( heightForWidth( s.width() ) );
+	    }
+	}
+    }
+    if ( s.isValid() ) {
+	resize( s );
+	return;
+    }
+    QRect r = childrenRect();			// get children rectangle
+    if ( r.isNull() )				// probably no widgets
+	return;
+    resize( r.width() + 2 * r.x(), r.height() + 2 * r.y() );
+}
+
+
+/*!
+    \property QWidget::sizeHint
+    \brief the recommended size for the widget
+
+    If the value of this property is an invalid size, no size is
+    recommended.
+
+    The default implementation of sizeHint() returns an invalid size
+    if there is no layout for this widget, and returns the layout's
+    preferred size otherwise.
+
+    \sa QSize::isValid(), minimumSizeHint(), sizePolicy(),
+    setMinimumSize(), updateGeometry()
+*/
+
+QSize QWidget::sizeHint() const
+{
+#ifndef QT_NO_LAYOUT
+    if ( layout() )
+	return layout()->totalSizeHint();
+#endif
+    return QSize( -1, -1 );
+}
+
+/*!
+    \property QWidget::minimumSizeHint
+    \brief the recommended minimum size for the widget
+
+    If the value of this property is an invalid size, no minimum size
+    is recommended.
+
+    The default implementation of minimumSizeHint() returns an invalid
+    size if there is no layout for this widget, and returns the
+    layout's minimum size otherwise. Most built-in widgets reimplement
+    minimumSizeHint().
+
+    \l QLayout will never resize a widget to a size smaller than
+    minimumSizeHint.
+
+    \sa QSize::isValid(), resize(), setMinimumSize(), sizePolicy()
+*/
+QSize QWidget::minimumSizeHint() const
+{
+#ifndef QT_NO_LAYOUT
+    if ( layout() )
+	return layout()->totalMinimumSize();
+#endif
+    return QSize( -1, -1 );
+}
+
+
+/*!
+    \fn QWidget *QWidget::parentWidget( bool sameWindow ) const
+
+    Returns the parent of this widget, or 0 if it does not have any
+    parent widget. If \a sameWindow is TRUE and the widget is top
+    level returns 0; otherwise returns the widget's parent.
+*/
+
+/*!
+    \fn WFlags QWidget::testWFlags( WFlags f ) const
+
+    Returns the bitwise AND of the widget flags and \a f.
+
+    Widget flags are a combination of \l{Qt::WidgetFlags}.
+
+    If you want to test for the presence of multiple flags (or
+    composite flags such as \c WStyle_Splash), test the
+    return value for equality against the argument. For example:
+
+    \code
+    int flags = WStyle_Tool | WStyle_NoBorder;
+    if ( testWFlags(flags) )
+	... // WStyle_Tool or WStyle_NoBorder or both are set
+    if ( testWFlags(flags) == flags )
+        ... // both WStyle_Tool and WStyle_NoBorder are set
+    \endcode
+
+    \sa getWFlags(), setWFlags(), clearWFlags()
+*/
+
+/*!
+  \fn WState QWidget::testWState( WState s ) const
+  \internal
+
+  Returns the bitwise AND of the widget states and \a s.
+*/
+
+/*!
+  \fn uint QWidget::getWState() const
+
+  \internal
+
+  Returns the current widget state.
+*/
+/*!
+  \fn void QWidget::clearWState( uint n )
+
+  \internal
+
+  Clears the widgets states \a n.
+*/
+/*!
+  \fn void QWidget::setWState( uint n )
+
+  \internal
+
+  Sets the widgets states \a n.
+*/
+
+
+
+/*****************************************************************************
+  QWidget event handling
+ *****************************************************************************/
+
+/*!
+    This is the main event handler; it handles event \a e. You can
+    reimplement this function in a subclass, but we recommend using
+    one of the specialized event handlers instead.
+
+    The main event handler first passes an event through all \link
+    QObject::installEventFilter() event filters\endlink that have been
+    installed. If none of the filters intercept the event, it calls
+    one of the specialized event handlers.
+
+    Key press and release events are treated differently from other
+    events. event() checks for Tab and Shift+Tab and tries to move the
+    focus appropriately. If there is no widget to move the focus to
+    (or the key press is not Tab or Shift+Tab), event() calls
+    keyPressEvent().
+
+    This function returns TRUE if it is able to pass the event over to
+    someone (i.e. someone wanted the event); otherwise returns FALSE.
+
+    \sa closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(),
+    keyPressEvent(), keyReleaseEvent(), leaveEvent(),
+    mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(),
+    mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(),
+    QObject::event(), QObject::timerEvent()
+*/
+
+bool QWidget::event( QEvent *e )
+{
+    if ( QObject::event( e ) )
+	return TRUE;
+
+    switch ( e->type() ) {
+	case QEvent::MouseMove:
+	    mouseMoveEvent( (QMouseEvent*)e );
+	    if ( ! ((QMouseEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+
+	case QEvent::MouseButtonPress:
+	    resetInputContext();
+	    mousePressEvent( (QMouseEvent*)e );
+	    if ( ! ((QMouseEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+
+	case QEvent::MouseButtonRelease:
+	    mouseReleaseEvent( (QMouseEvent*)e );
+	    if ( ! ((QMouseEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+
+	case QEvent::MouseButtonDblClick:
+	    mouseDoubleClickEvent( (QMouseEvent*)e );
+	    if ( ! ((QMouseEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+#ifndef QT_NO_WHEELEVENT
+	case QEvent::Wheel:
+	    wheelEvent( (QWheelEvent*)e );
+	    if ( ! ((QWheelEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+#endif
+	case QEvent::TabletMove:
+	case QEvent::TabletPress:
+	case QEvent::TabletRelease:
+	    tabletEvent( (QTabletEvent*)e );
+	    if ( ! ((QTabletEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+	case QEvent::Accel:
+	    ((QKeyEvent*)e)->ignore();
+	    return FALSE;
+	case QEvent::KeyPress: {
+	    QKeyEvent *k = (QKeyEvent *)e;
+	    bool res = FALSE;
+	    if ( !(k->state() & ControlButton || k->state() & AltButton) ) {
+		if ( k->key() == Key_Backtab ||
+		     (k->key() == Key_Tab &&
+		      (k->state() & ShiftButton)) ) {
+		    QFocusEvent::setReason( QFocusEvent::Backtab );
+		    res = focusNextPrevChild( FALSE );
+		    QFocusEvent::resetReason();
+
+		} else if ( k->key() == Key_Tab ) {
+		    QFocusEvent::setReason( QFocusEvent::Tab );
+		    res = focusNextPrevChild( TRUE );
+		    QFocusEvent::resetReason();
+		}
+		if ( res )
+		    break;
+	    }
+	    keyPressEvent( k );
+	    if ( !k->isAccepted() )
+		return FALSE;
+	    }
+	    break;
+
+	case QEvent::KeyRelease:
+	    keyReleaseEvent( (QKeyEvent*)e );
+	    if ( ! ((QKeyEvent*)e)->isAccepted() )
+		return FALSE;
+	    break;
+
+	case QEvent::IMStart: {
+	    QIMEvent *i = (QIMEvent *) e;
+	    imStartEvent(i);
+	    if (! i->isAccepted())
+		return FALSE;
+	    }
+	    break;
+
+	case QEvent::IMCompose: {
+	    QIMEvent *i = (QIMEvent *) e;
+	    imComposeEvent(i);
+	    if (! i->isAccepted())
+		return FALSE;
+	    }
+	    break;
+
+	case QEvent::IMEnd: {
+	    QIMEvent *i = (QIMEvent *) e;
+	    imEndEvent(i);
+	    if (! i->isAccepted())
+		return FALSE;
+	    }
+	    break;
+
+	case QEvent::FocusIn:
+	    focusInEvent( (QFocusEvent*)e );
+	    setFontSys();
+	    break;
+
+	case QEvent::FocusOut:
+	    focusOutEvent( (QFocusEvent*)e );
+	    break;
+
+	case QEvent::Enter:
+	    enterEvent( e );
+	    break;
+
+	case QEvent::Leave:
+	     leaveEvent( e );
+	    break;
+
+	case QEvent::Paint:
+	    // At this point the event has to be delivered, regardless
+	    // whether the widget isVisible() or not because it
+	    // already went through the filters
+	    paintEvent( (QPaintEvent*)e );
+	    break;
+
+	case QEvent::Move:
+	    moveEvent( (QMoveEvent*)e );
+	    break;
+
+	case QEvent::Resize:
+	    resizeEvent( (QResizeEvent*)e );
+	    break;
+
+	case QEvent::Close: {
+	    QCloseEvent *c = (QCloseEvent *)e;
+	    closeEvent( c );
+	    if ( !c->isAccepted() )
+		return FALSE;
+	    }
+	    break;
+
+	case QEvent::ContextMenu: {
+	    QContextMenuEvent *c = (QContextMenuEvent *)e;
+	    contextMenuEvent( c );
+	    if ( !c->isAccepted() )
+		return FALSE;
+	    }
+	    break;
+
+#ifndef QT_NO_DRAGANDDROP
+	case QEvent::Drop:
+	    dropEvent( (QDropEvent*) e);
+	    break;
+
+	case QEvent::DragEnter:
+	    dragEnterEvent( (QDragEnterEvent*) e);
+	    break;
+
+	case QEvent::DragMove:
+	    dragMoveEvent( (QDragMoveEvent*) e);
+	    break;
+
+	case QEvent::DragLeave:
+	    dragLeaveEvent( (QDragLeaveEvent*) e);
+	    break;
+#endif
+
+	case QEvent::Show:
+	    showEvent( (QShowEvent*) e);
+	    break;
+
+	case QEvent::Hide:
+	    hideEvent( (QHideEvent*) e);
+	    break;
+
+	case QEvent::ShowWindowRequest:
+	    if ( isShown() )
+		showWindow();
+	    break;
+
+	case QEvent::ParentFontChange:
+	    if ( isTopLevel() )
+		break;
+	    // fall through
+	case QEvent::ApplicationFontChange:
+	    if ( own_font )
+		setFont( fnt.resolve( qt_naturalWidgetFont( this ) ) );
+	    else
+		unsetFont();
+	    break;
+
+#ifndef QT_NO_PALETTE
+	case QEvent::ParentPaletteChange:
+	    if ( isTopLevel() )
+		break;
+	    // fall through
+	case QEvent::ApplicationPaletteChange:
+	    if ( !own_palette && !isDesktop() )
+		unsetPalette();
+# if defined(Q_WS_QWS) && !defined (QT_NO_QWS_MANAGER)
+	    if ( isTopLevel() && topData()->qwsManager ) {
+		QRegion r( topData()->qwsManager->region() );
+		QApplication::postEvent(topData()->qwsManager, new QPaintEvent(r, FALSE) );
+	    }
+# endif
+	    break;
+#endif
+
+	case QEvent::WindowActivate:
+	case QEvent::WindowDeactivate:
+	    windowActivationChange( e->type() != QEvent::WindowActivate );
+	    if ( children() ) {
+		QObjectListIt it( *children() );
+		QObject *o;
+		while( ( o = it.current() ) != 0 ) {
+		    ++it;
+		    if ( o->isWidgetType() &&
+			 ((QWidget*)o)->isVisible() &&
+			 !((QWidget*)o)->isTopLevel() )
+			QApplication::sendEvent( o, e );
+		}
+	    }
+	    break;
+
+	case QEvent::LanguageChange:
+	case QEvent::LocaleChange:
+	    if ( children() ) {
+		QObjectListIt it( *children() );
+		QObject *o;
+		while( ( o = it.current() ) != 0 ) {
+		    ++it;
+		    QApplication::sendEvent( o, e );
+		}
+	    }
+	    if ( e->type() == QEvent::LanguageChange ) {
+		int index = metaObject()->findSlot( "languageChange()", TRUE );
+		if ( index >= 0 )
+		    qt_invoke( index, 0 );
+	    }
+	    update();
+	    break;
+#ifndef QT_NO_LAYOUT
+	case QEvent::LayoutDirectionChange:
+	    if ( layout() ) {
+		layout()->activate();
+	    } else {
+		QObjectList* llist = queryList( "QLayout", 0, TRUE, TRUE );
+		QObjectListIt lit( *llist );
+		QLayout *lay;
+		while ( ( lay = (QLayout*)lit.current() ) != 0 ) {
+		    ++lit;
+		    lay->activate();
+		}
+		delete llist;
+	    }
+	    update();
+	    break;
+#endif
+
+    case QEvent::WindowStateChange:
+	{
+	    QEvent::Type type;
+	    if (isMinimized())
+		type = QEvent::ShowMinimized;
+	    else if (isFullScreen())
+		type = QEvent::ShowFullScreen;
+	    else if (isMaximized())
+		type = QEvent::ShowMaximized;
+	    else
+		type = QEvent::ShowNormal;
+
+	    QApplication::postEvent(this, new QEvent(type));
+	    break;
+	}
+
+    case QEvent::WindowBlocked:
+    case QEvent::WindowUnblocked:
+	if ( children() ) {
+	    QObjectListIt it( *children() );
+	    QObject *o;
+	    while( ( o = it.current() ) != 0 ) {
+		++it;
+                QWidget *w = ::qt_cast<QWidget*>(o);
+                if (w && !w->testWFlags(Qt::WShowModal))
+	            QApplication::sendEvent( o, e );
+	    }
+	}
+	break;
+
+    default:
+	return FALSE;
+    }
+    return TRUE;
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive mouse move events for the widget.
+
+    If mouse tracking is switched off, mouse move events only occur if
+    a mouse button is pressed while the mouse is being moved. If mouse
+    tracking is switched on, mouse move events occur even if no mouse
+    button is pressed.
+
+    QMouseEvent::pos() reports the position of the mouse cursor,
+    relative to this widget. For press and release events, the
+    position is usually the same as the position of the last mouse
+    move event, but it might be different if the user's hand shakes.
+    This is a feature of the underlying window system, not Qt.
+
+    \sa setMouseTracking(), mousePressEvent(), mouseReleaseEvent(),
+    mouseDoubleClickEvent(), event(), QMouseEvent
+*/
+
+void QWidget::mouseMoveEvent( QMouseEvent * e)
+{
+    e->ignore();
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive mouse press events for the widget.
+
+    If you create new widgets in the mousePressEvent() the
+    mouseReleaseEvent() may not end up where you expect, depending on
+    the underlying window system (or X11 window manager), the widgets'
+    location and maybe more.
+
+    The default implementation implements the closing of popup widgets
+    when you click outside the window. For other widget types it does
+    nothing.
+
+    \sa mouseReleaseEvent(), mouseDoubleClickEvent(),
+    mouseMoveEvent(), event(), QMouseEvent
+*/
+
+void QWidget::mousePressEvent( QMouseEvent *e )
+{
+    e->ignore();
+    if ( isPopup() ) {
+	e->accept();
+	QWidget* w;
+	while ( (w = qApp->activePopupWidget() ) && w != this ){
+	    w->close();
+	    if (qApp->activePopupWidget() == w) // widget does not want to dissappear
+		w->hide(); // hide at least
+	}
+	if (!rect().contains(e->pos()) ){
+	    close();
+	}
+    }
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive mouse release events for the widget.
+
+    \sa mouseReleaseEvent(), mouseDoubleClickEvent(),
+    mouseMoveEvent(), event(),  QMouseEvent
+*/
+
+void QWidget::mouseReleaseEvent( QMouseEvent * e )
+{
+    e->ignore();
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive mouse double click events for the widget.
+
+    The default implementation generates a normal mouse press event.
+
+    Note that the widgets gets a mousePressEvent() and a
+    mouseReleaseEvent() before the mouseDoubleClickEvent().
+
+    \sa mousePressEvent(), mouseReleaseEvent() mouseMoveEvent(),
+    event(), QMouseEvent
+*/
+
+void QWidget::mouseDoubleClickEvent( QMouseEvent *e )
+{
+    mousePressEvent( e );			// try mouse press event
+}
+
+#ifndef QT_NO_WHEELEVENT
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive wheel events for the widget.
+
+    If you reimplement this handler, it is very important that you
+    \link QWheelEvent ignore()\endlink the event if you do not handle
+    it, so that the widget's parent can interpret it.
+
+    The default implementation ignores the event.
+
+    \sa QWheelEvent::ignore(), QWheelEvent::accept(), event(),
+    QWheelEvent
+*/
+
+void QWidget::wheelEvent( QWheelEvent *e )
+{
+    e->ignore();
+}
+#endif
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive tablet events for the widget.
+
+    If you reimplement this handler, it is very important that you
+    \link QTabletEvent ignore()\endlink the event if you do not handle
+    it, so that the widget's parent can interpret it.
+
+    The default implementation ignores the event.
+
+    \sa QTabletEvent::ignore(), QTabletEvent::accept(), event(),
+    QTabletEvent
+*/
+
+void QWidget::tabletEvent( QTabletEvent *e )
+{
+    e->ignore();
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive key press events for the widget.
+
+    A widget must call setFocusPolicy() to accept focus initially and
+    have focus in order to receive a key press event.
+
+    If you reimplement this handler, it is very important that you
+    explicitly \link QKeyEvent::ignore() ignore\endlink the event
+    if you do not understand it, so that the widget's parent can
+    interpret it; otherwise, the event will be implicitly accepted.
+    Although top-level widgets are able to choose whether to accept
+    or ignore unknown events because they have no parent widgets that
+    could otherwise handle them, it is good practice to explicitly
+    ignore events to make widgets as reusable as possible.
+
+    The default implementation closes popup widgets if the user
+    presses <b>Esc</b>. Otherwise the event is ignored.
+
+    \sa keyReleaseEvent(), QKeyEvent::ignore(), setFocusPolicy(),
+    focusInEvent(), focusOutEvent(), event(), QKeyEvent
+*/
+
+void QWidget::keyPressEvent( QKeyEvent *e )
+{
+    if ( isPopup() && e->key() == Key_Escape ) {
+	e->accept();
+	close();
+    } else {
+	e->ignore();
+    }
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive key release events for the widget.
+
+    A widget must \link setFocusPolicy() accept focus\endlink
+    initially and \link hasFocus() have focus\endlink in order to
+    receive a key release event.
+
+    If you reimplement this handler, it is very important that you
+    \link QKeyEvent ignore()\endlink the release if you do not
+    understand it, so that the widget's parent can interpret it.
+
+    The default implementation ignores the event.
+
+    \sa keyPressEvent(), QKeyEvent::ignore(), setFocusPolicy(),
+    focusInEvent(), focusOutEvent(), event(), QKeyEvent
+*/
+
+void QWidget::keyReleaseEvent( QKeyEvent *e )
+{
+    e->ignore();
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    keyboard focus events (focus received) for the widget.
+
+    A widget normally must setFocusPolicy() to something other than
+    \c NoFocus in order to receive focus events. (Note that the
+    application programmer can call setFocus() on any widget, even
+    those that do not normally accept focus.)
+
+    The default implementation updates the widget (except for toplevel
+    widgets that do not specify a focusPolicy() ). It also calls
+    setMicroFocusHint(), hinting any system-specific input tools about
+    the focus of the user's attention.
+
+    \sa focusOutEvent(), setFocusPolicy(), keyPressEvent(),
+    keyReleaseEvent(), event(), QFocusEvent
+*/
+
+void QWidget::focusInEvent( QFocusEvent * )
+{
+    if ( focusPolicy() != NoFocus || !isTopLevel() ) {
+	update();
+	if ( testWState(WState_AutoMask) )
+	    updateMask();
+	setMicroFocusHint(width()/2, 0, 1, height(), FALSE);
+    }
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    keyboard focus events (focus lost) for the widget.
+
+    A widget normally must setFocusPolicy() to something other than
+    \c NoFocus in order to receive focus events. (Note that the
+    application programmer can call setFocus() on any widget, even
+    those that do not normally accept focus.)
+
+    The default implementation updates the widget (except for toplevel
+    widgets that do not specify a focusPolicy() ). It also calls
+    setMicroFocusHint(), hinting any system-specific input tools about
+    the focus of the user's attention.
+
+    \sa focusInEvent(), setFocusPolicy(), keyPressEvent(),
+    keyReleaseEvent(), event(), QFocusEvent
+*/
+
+void QWidget::focusOutEvent( QFocusEvent * )
+{
+    if ( focusPolicy() != NoFocus || !isTopLevel() ){
+	update();
+	if ( testWState(WState_AutoMask) )
+	    updateMask();
+    }
+}
+
+/*!
+    \property QWidget::microFocusHint
+    \brief the currently set micro focus hint for this widget.
+
+    See the documentation of setMicroFocusHint() for more information.
+*/
+QRect QWidget::microFocusHint() const
+{
+    if ( !extra || extra->micro_focus_hint.isEmpty() )
+	return QRect(width()/2, 0, 1, height() );
+    else
+	return extra->micro_focus_hint;
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget enter events.
+
+    An event is sent to the widget when the mouse cursor enters the
+    widget.
+
+    \sa leaveEvent(), mouseMoveEvent(), event()
+*/
+
+void QWidget::enterEvent( QEvent * )
+{
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget leave events.
+
+    A leave event is sent to the widget when the mouse cursor leaves
+    the widget.
+
+    \sa enterEvent(), mouseMoveEvent(), event()
+*/
+
+void QWidget::leaveEvent( QEvent * )
+{
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    paint events.
+
+    A paint event is a request to repaint all or part of the widget.
+    It can happen as a result of repaint() or update(), or because the
+    widget was obscured and has now been uncovered, or for many other
+    reasons.
+
+    Many widgets can simply repaint their entire surface when asked
+    to, but some slow widgets need to optimize by painting only the
+    requested region: QPaintEvent::region(). This speed optimization
+    does not change the result, as painting is clipped to that region
+    during event processing. QListView and QCanvas do this, for
+    example.
+
+    Qt also tries to speed up painting by merging multiple paint
+    events into one. When update() is called several times or the
+    window system sends several paint events, Qt merges these events
+    into one event with a larger region (see QRegion::unite()).
+    repaint() does not permit this optimization, so we suggest using
+    update() when possible.
+
+    When the paint event occurs, the update region has normally been
+    erased, so that you're painting on the widget's background. There
+    are a couple of exceptions and QPaintEvent::erased() tells you
+    whether the widget has been erased or not.
+
+    The background can be set using setBackgroundMode(),
+    setPaletteBackgroundColor() or setBackgroundPixmap(). The
+    documentation for setBackgroundMode() elaborates on the
+    background; we recommend reading it.
+
+    \sa event(), repaint(), update(), QPainter, QPixmap, QPaintEvent
+*/
+
+void QWidget::paintEvent( QPaintEvent * )
+{
+}
+
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget move events. When the widget receives this event, it is
+    already at the new position.
+
+    The old position is accessible through QMoveEvent::oldPos().
+
+    \sa resizeEvent(), event(), move(), QMoveEvent
+*/
+
+void QWidget::moveEvent( QMoveEvent * )
+{
+}
+
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget resize events. When resizeEvent() is called, the widget
+    already has its new geometry. The old size is accessible through
+    QResizeEvent::oldSize().
+
+    The widget will be erased and receive a paint event immediately
+    after processing the resize event. No drawing need be (or should
+    be) done inside this handler.
+
+    Widgets that have been created with the \c WNoAutoErase flag
+    will not be erased. Nevertheless, they will receive a paint event
+    for their entire area afterwards. Again, no drawing needs to be
+    done inside this handler.
+
+    The default implementation calls updateMask() if the widget has
+    \link QWidget::setAutoMask() automatic masking\endlink enabled.
+
+    \sa moveEvent(), event(), resize(), QResizeEvent, paintEvent()
+*/
+
+void QWidget::resizeEvent( QResizeEvent * )
+{
+    if ( testWState(WState_AutoMask) )
+	updateMask();
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive widget close events.
+
+    The default implementation calls e->accept(), which hides this
+    widget. See the \l QCloseEvent documentation for more details.
+
+    \sa event(), hide(), close(), QCloseEvent
+*/
+
+void QWidget::closeEvent( QCloseEvent *e )
+{
+    e->accept();
+}
+
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive widget context menu events.
+
+    The default implementation calls e->ignore(), which rejects the
+    context event. See the \l QContextMenuEvent documentation for
+    more details.
+
+    \sa event(), QContextMenuEvent
+*/
+
+void QWidget::contextMenuEvent( QContextMenuEvent *e )
+{
+    e->ignore();
+}
+
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive Input Method composition events. This handler
+    is called when the user begins entering text using an Input Method.
+
+    The default implementation calls e->ignore(), which rejects the
+    Input Method event. See the \l QIMEvent documentation for more
+    details.
+
+    \sa event(), QIMEvent
+*/
+void QWidget::imStartEvent( QIMEvent *e )
+{
+    e->ignore();
+}
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive Input Method composition events. This handler
+    is called when the user has entered some text using an Input Method.
+
+    The default implementation calls e->ignore(), which rejects the
+    Input Method event. See the \l QIMEvent documentation for more
+    details.
+
+    \sa event(), QIMEvent
+*/
+void QWidget::imComposeEvent( QIMEvent *e )
+{
+    e->ignore();
+}
+
+
+/*!
+    This event handler, for event \a e, can be reimplemented in a
+    subclass to receive Input Method composition events. This handler
+    is called when the user has finished inputting text via an Input
+    Method.
+
+    The default implementation calls e->ignore(), which rejects the
+    Input Method event. See the \l QIMEvent documentation for more
+    details.
+
+    \sa event(), QIMEvent
+*/
+void QWidget::imEndEvent( QIMEvent *e )
+{
+    e->ignore();
+}
+
+
+#ifndef QT_NO_DRAGANDDROP
+
+/*!
+    This event handler is called when a drag is in progress and the
+    mouse enters this widget.
+
+    See the \link dnd.html Drag-and-drop documentation\endlink for an
+    overview of how to provide drag-and-drop in your application.
+
+    \sa QTextDrag, QImageDrag, QDragEnterEvent
+*/
+void QWidget::dragEnterEvent( QDragEnterEvent * )
+{
+}
+
+/*!
+    This event handler is called when a drag is in progress and the
+    mouse enters this widget, and whenever it moves within the widget.
+
+    See the \link dnd.html Drag-and-drop documentation\endlink for an
+    overview of how to provide drag-and-drop in your application.
+
+    \sa QTextDrag, QImageDrag, QDragMoveEvent
+*/
+void QWidget::dragMoveEvent( QDragMoveEvent * )
+{
+}
+
+/*!
+    This event handler is called when a drag is in progress and the
+    mouse leaves this widget.
+
+    See the \link dnd.html Drag-and-drop documentation\endlink for an
+    overview of how to provide drag-and-drop in your application.
+
+    \sa QTextDrag, QImageDrag, QDragLeaveEvent
+*/
+void QWidget::dragLeaveEvent( QDragLeaveEvent * )
+{
+}
+
+/*!
+    This event handler is called when the drag is dropped on this
+    widget.
+
+    See the \link dnd.html Drag-and-drop documentation\endlink for an
+    overview of how to provide drag-and-drop in your application.
+
+    \sa QTextDrag, QImageDrag, QDropEvent
+*/
+void QWidget::dropEvent( QDropEvent * )
+{
+}
+
+#endif // QT_NO_DRAGANDDROP
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget show events.
+
+    Non-spontaneous show events are sent to widgets immediately before
+    they are shown. The spontaneous show events of top-level widgets
+    are delivered afterwards.
+
+    \sa event(), QShowEvent
+*/
+void QWidget::showEvent( QShowEvent * )
+{
+}
+
+/*!
+    This event handler can be reimplemented in a subclass to receive
+    widget hide events.
+
+    Hide events are sent to widgets immediately after they have been
+    hidden.
+
+    \sa event(), QHideEvent
+*/
+void QWidget::hideEvent( QHideEvent * )
+{
+}
+
+/*
+    \fn QWidget::x11Event( MSG * )
+
+    This special event handler can be reimplemented in a subclass to
+    receive native X11 events.
+
+    In your reimplementation of this function, if you want to stop the
+    event being handled by Qt, return TRUE. If you return FALSE, this
+    native event is passed back to Qt, which translates the event into
+    a Qt event and sends it to the widget.
+
+    \warning This function is not portable.
+
+    \sa QApplication::x11EventFilter()
+*/
+
+
+#if defined(Q_WS_MAC)
+
+/*!
+    This special event handler can be reimplemented in a subclass to
+    receive native Macintosh events.
+
+    In your reimplementation of this function, if you want to stop the
+    event being handled by Qt, return TRUE. If you return FALSE, this
+    native event is passed back to Qt, which translates the event into
+    a Qt event and sends it to the widget.
+
+    \warning This function is not portable.
+
+    \sa QApplication::macEventFilter()
+*/
+
+bool QWidget::macEvent( MSG * )
+{
+    return FALSE;
+}
+
+#endif
+#if defined(Q_WS_WIN)
+
+/*!
+    This special event handler can be reimplemented in a subclass to
+    receive native Windows events.
+
+    In your reimplementation of this function, if you want to stop the
+    event being handled by Qt, return TRUE. If you return FALSE, this
+    native event is passed back to Qt, which translates the event into
+    a Qt event and sends it to the widget.
+
+    \warning This function is not portable.
+
+    \sa QApplication::winEventFilter()
+*/
+bool QWidget::winEvent( MSG * )
+{
+    return FALSE;
+}
+
+#endif
+#if defined(Q_WS_X11)
+
+/*!
+    This special event handler can be reimplemented in a subclass to
+    receive native X11 events.
+
+    In your reimplementation of this function, if you want to stop the
+    event being handled by Qt, return TRUE. If you return FALSE, this
+    native event is passed back to Qt, which translates the event into
+    a Qt event and sends it to the widget.
+
+    \warning This function is not portable.
+
+    \sa QApplication::x11EventFilter()
+*/
+bool QWidget::x11Event( XEvent * )
+{
+    return FALSE;
+}
+
+#endif
+#if defined(Q_WS_QWS)
+
+/*!
+    This special event handler can be reimplemented in a subclass to
+    receive native Qt/Embedded events.
+
+    In your reimplementation of this function, if you want to stop the
+    event being handled by Qt, return TRUE. If you return FALSE, this
+    native event is passed back to Qt, which translates the event into
+    a Qt event and sends it to the widget.
+
+    \warning This function is not portable.
+
+    \sa QApplication::qwsEventFilter()
+*/
+bool QWidget::qwsEvent( QWSEvent * )
+{
+    return FALSE;
+}
+
+#endif
+
+/*!
+    \property QWidget::autoMask
+    \brief whether the auto mask feature is enabled for the widget
+
+    Transparent widgets use a mask to define their visible region.
+    QWidget has some built-in support to make the task of
+    recalculating the mask easier. When setting auto mask to TRUE,
+    updateMask() will be called whenever the widget is resized or
+    changes its focus state. Note that you must reimplement
+    updateMask() (which should include a call to setMask()) or nothing
+    will happen.
+
+    Note: when you re-implement resizeEvent(), focusInEvent() or
+    focusOutEvent() in your custom widgets and still want to ensure
+    that the auto mask calculation works, you should add:
+
+    \code
+	if ( autoMask() )
+	    updateMask();
+    \endcode
+
+    at the end of your event handlers. This is true for all member
+    functions that change the appearance of the widget in a way that
+    requires a recalculation of the mask.
+
+    While being a technically appealing concept, masks have a big
+    drawback: when using complex masks that cannot be expressed easily
+    with relatively simple regions, they can be very slow on some
+    window systems. The classic example is a transparent label. The
+    complex shape of its contents makes it necessary to represent its
+    mask by a bitmap, which consumes both memory and time. If all you
+    want is to blend the background of several neighboring widgets
+    together seamlessly, you will probably want to use
+    setBackgroundOrigin() rather than a mask.
+
+    \sa autoMask() updateMask() setMask() clearMask() setBackgroundOrigin()
+*/
+
+bool QWidget::autoMask() const
+{
+    return testWState(WState_AutoMask);
+}
+
+void QWidget::setAutoMask( bool enable )
+{
+    if ( enable == autoMask() )
+	return;
+
+    if ( enable ) {
+	setWState(WState_AutoMask);
+	updateMask();
+    } else {
+	clearWState(WState_AutoMask);
+	clearMask();
+    }
+}
+
+/*!
+    \enum QWidget::BackgroundOrigin
+
+    This enum defines the origin used to draw a widget's background
+    pixmap.
+
+    The pixmap is drawn using the:
+    \value WidgetOrigin  widget's coordinate system.
+    \value ParentOrigin  parent's coordinate system.
+    \value WindowOrigin  top-level window's coordinate system.
+    \value AncestorOrigin  same origin as the parent uses.
+*/
+
+/*!
+    \property QWidget::backgroundOrigin
+    \brief the origin of the widget's background
+
+    The origin is either WidgetOrigin (the default), ParentOrigin,
+    WindowOrigin or AncestorOrigin.
+
+    This only makes a difference if the widget has a background
+    pixmap, in which case positioning matters. Using \c WindowOrigin
+    for several neighboring widgets makes the background blend
+    together seamlessly. \c AncestorOrigin allows blending backgrounds
+    seamlessly when an ancestor of the widget has an origin other than
+    \c WindowOrigin.
+
+    \sa backgroundPixmap(), setBackgroundMode()
+*/
+QWidget::BackgroundOrigin QWidget::backgroundOrigin() const
+{
+    return extra ? (BackgroundOrigin)extra->bg_origin : WidgetOrigin;
+}
+
+void QWidget::setBackgroundOrigin( BackgroundOrigin origin )
+{
+    if ( origin == backgroundOrigin() )
+	return;
+    createExtra();
+    extra->bg_origin = origin;
+    update();
+}
+
+/*!
+    This function can be reimplemented in a subclass to support
+    transparent widgets. It should be called whenever a widget changes
+    state in a way that means that the shape mask must be recalculated.
+
+    \sa setAutoMask(), updateMask(), setMask(), clearMask()
+*/
+void QWidget::updateMask()
+{
+}
+
+/*!
+  \internal
+  Returns the offset of the widget from the backgroundOrigin.
+
+  \sa setBackgroundMode(), backgroundMode(),
+*/
+QPoint QWidget::backgroundOffset() const
+{
+    if (!isTopLevel()) {
+	switch(backgroundOrigin()) {
+	    case WidgetOrigin:
+		break;
+	    case ParentOrigin:
+		return pos();
+	    case WindowOrigin:
+		{
+		    const QWidget *topl = this;
+		    while(topl && !topl->isTopLevel() && !topl->testWFlags(Qt::WSubWindow))
+			topl = topl->parentWidget(TRUE);
+		    return mapTo((QWidget *)topl, QPoint(0, 0) );
+		}
+	    case AncestorOrigin:
+		{
+		    const QWidget *topl = this;
+		    bool ancestorIsWindowOrigin = FALSE;
+		    while(topl && !topl->isTopLevel() && !topl->testWFlags(Qt::WSubWindow))
+		    {
+			if (!ancestorIsWindowOrigin) {
+			    if (topl->backgroundOrigin() == QWidget::WidgetOrigin)
+				break;
+			    if (topl->backgroundOrigin() == QWidget::ParentOrigin)
+			    {
+				topl = topl->parentWidget(TRUE);
+				break;
+			    }
+			    if (topl->backgroundOrigin() == QWidget::WindowOrigin)
+				ancestorIsWindowOrigin = TRUE;
+			}
+			topl = topl->parentWidget(TRUE);
+		    }
+
+		    return mapTo((QWidget *) topl, QPoint(0,0) );
+		}
+	}
+    }
+    // fall back
+    return QPoint(0,0);
+}
+
+/*!
+    \fn QLayout* QWidget::layout () const
+
+    Returns the layout engine that manages the geometry of this
+    widget's children.
+
+    If the widget does not have a layout, layout() returns 0.
+
+    \sa  sizePolicy()
+*/
+
+
+/*  Sets this widget to use layout \a l to manage the geometry of its
+  children.
+
+  If the widget already had a layout, the old layout is
+  forgotten. (Note that it is not deleted.)
+
+  \sa layout() QLayout sizePolicy()
+*/
+#ifndef QT_NO_LAYOUT
+void QWidget::setLayout( QLayout *l )
+{
+    lay_out = l;
+}
+#endif
+
+/*!
+    \property QWidget::sizePolicy
+    \brief the default layout behavior of the widget
+
+    If there is a QLayout that manages this widget's children, the
+    size policy specified by that layout is used. If there is no such
+    QLayout, the result of this function is used.
+
+    The default policy is Preferred/Preferred, which means that the
+    widget can be freely resized, but prefers to be the size
+    sizeHint() returns. Button-like widgets set the size policy to
+    specify that they may stretch horizontally, but are fixed
+    vertically. The same applies to lineedit controls (such as
+    QLineEdit, QSpinBox or an editable QComboBox) and other
+    horizontally orientated widgets (such as QProgressBar).
+    QToolButton's are normally square, so they allow growth in both
+    directions. Widgets that support different directions (such as
+    QSlider, QScrollBar or QHeader) specify stretching in the
+    respective direction only. Widgets that can provide scrollbars
+    (usually subclasses of QScrollView) tend to specify that they can
+    use additional space, and that they can make do with less than
+    sizeHint().
+
+    \sa sizeHint() QLayout QSizePolicy updateGeometry()
+*/
+QSizePolicy QWidget::sizePolicy() const
+{
+    return extra ? extra->size_policy
+	: QSizePolicy( QSizePolicy::Preferred, QSizePolicy::Preferred );
+}
+
+void QWidget::setSizePolicy( QSizePolicy policy )
+{
+    setWState( WState_OwnSizePolicy );
+    if ( policy == sizePolicy() )
+	return;
+    createExtra();
+    extra->size_policy = policy;
+    updateGeometry();
+}
+
+/*!
+    \overload void QWidget::setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw )
+
+    Sets the size policy of the widget to \a hor, \a ver and \a hfw
+    (height for width).
+
+    \sa QSizePolicy::QSizePolicy()
+*/
+
+/*!
+    Returns the preferred height for this widget, given the width \a
+    w. The default implementation returns 0, indicating that the
+    preferred height does not depend on the width.
+
+    \warning Does not look at the widget's layout.
+*/
+
+int QWidget::heightForWidth( int w ) const
+{
+    (void)w;
+    return 0;
+}
+
+/*!
+    \property QWidget::customWhatsThis
+    \brief whether the widget wants to handle What's This help manually
+
+    The default implementation of customWhatsThis() returns FALSE,
+    which means the widget will not receive any events in Whats This
+    mode.
+
+    The widget may leave What's This mode by calling
+    QWhatsThis::leaveWhatsThisMode(), with or without actually
+    displaying any help text.
+
+    You can also reimplement customWhatsThis() if your widget is a
+    "passive interactor" supposed to work under all circumstances.
+    Simply don't call QWhatsThis::leaveWhatsThisMode() in that case.
+
+    \sa QWhatsThis::inWhatsThisMode() QWhatsThis::leaveWhatsThisMode()
+*/
+bool QWidget::customWhatsThis() const
+{
+    return FALSE;
+}
+
+/*!
+    Returns the visible child widget at pixel position \a (x, y) in
+    the widget's own coordinate system.
+
+    If \a includeThis is TRUE, and there is no child visible at \a (x,
+    y), the widget itself is returned.
+*/
+QWidget  *QWidget::childAt( int x, int y, bool includeThis ) const
+{
+    if ( !rect().contains( x, y ) )
+	return 0;
+    if ( children() ) {
+	QObjectListIt it( *children() );
+	it.toLast();
+	QWidget *w, *t;
+	while( (w=(QWidget *)it.current()) != 0 ) {
+	    --it;
+	    if ( w->isWidgetType() && !w->isTopLevel() && !w->isHidden() ) {
+		if ( ( t = w->childAt( x - w->x(), y - w->y(), TRUE ) ) )
+		    return t;
+	    }
+	}
+    }
+    if ( includeThis )
+	return (QWidget*)this;
+    return 0;
+}
+
+/*!
+    \overload
+
+    Returns the visible child widget at point \a p in the widget's own
+    coordinate system.
+
+    If \a includeThis is TRUE, and there is no child visible at \a p,
+    the widget itself is returned.
+
+*/
+QWidget  *QWidget::childAt( const QPoint & p, bool includeThis ) const
+{
+    return childAt( p.x(), p.y(), includeThis );
+}
+
+
+/*!
+    Notifies the layout system that this widget has changed and may
+    need to change geometry.
+
+    Call this function if the sizeHint() or sizePolicy() have changed.
+
+    For explicitly hidden widgets, updateGeometry() is a no-op. The
+    layout system will be notified as soon as the widget is shown.
+*/
+
+void QWidget::updateGeometry()
+{
+    if ( !isTopLevel() && isShown() )
+	QApplication::postEvent( parentWidget(),
+				 new QEvent( QEvent::LayoutHint ) );
+}
+
+
+/*!
+    Reparents the widget. The widget gets a new \a parent, new widget
+    flags (\a f, but as usual, use 0) at a new position in its new
+    parent (\a p).
+
+    If \a showIt is TRUE, show() is called once the widget has been
+    reparented.
+
+    If the new parent widget is in a different top-level widget, the
+    reparented widget and its children are appended to the end of the
+    \link setFocusPolicy() tab chain \endlink of the new parent
+    widget, in the same internal order as before. If one of the moved
+    widgets had keyboard focus, reparent() calls clearFocus() for that
+    widget.
+
+    If the new parent widget is in the same top-level widget as the
+    old parent, reparent doesn't change the tab order or keyboard
+    focus.
+
+    \warning It is extremely unlikely that you will ever need this
+    function. If you have a widget that changes its content
+    dynamically, it is far easier to use \l QWidgetStack or \l
+    QWizard.
+
+    \sa getWFlags()
+*/
+
+void QWidget::reparent( QWidget *parent, WFlags f, const QPoint &p,
+			bool showIt )
+{
+    reparentSys( parent, f, p, showIt );
+    QEvent e( QEvent::Reparent );
+    QApplication::sendEvent( this, &e );
+    if (!own_font)
+	unsetFont();
+    else
+	setFont( fnt.resolve( qt_naturalWidgetFont( this ) ) );
+#ifndef QT_NO_PALETTE
+    if (!own_palette)
+	unsetPalette();
+#endif
+}
+
+/*!
+    \overload
+
+    A convenience version of reparent that does not take widget flags
+    as argument.
+
+    Calls reparent(\a parent, getWFlags() \& ~\l WType_Mask, \a p, \a
+    showIt).
+*/
+void  QWidget::reparent( QWidget *parent, const QPoint & p,
+			 bool showIt )
+{
+    reparent( parent, getWFlags() & ~WType_Mask, p, showIt );
+}
+
+/*!
+    \property QWidget::ownCursor
+    \brief whether the widget uses its own cursor
+
+    If FALSE, the widget uses its parent widget's cursor.
+
+    \sa cursor
+*/
+
+/*!
+    \property QWidget::ownFont
+    \brief whether the widget uses its own font
+
+    If FALSE, the widget uses its parent widget's font.
+
+    \sa font
+*/
+
+/*!
+    \property QWidget::ownPalette
+    \brief whether the widget uses its own palette
+
+    If FALSE, the widget uses its parent widget's palette.
+
+    \sa palette
+*/
+
+
+void QWidget::repaint( bool erase )
+{
+    repaint( visibleRect(), erase );
+}
+
+
+
+
+/*!\obsolete  Use paletteBackgroundColor() or eraseColor() instead. */
+const QColor & QWidget::backgroundColor() const { return eraseColor(); }
+/*!\obsolete  Use setPaletteBackgroundColor() or setEraseColor() instead. */
+void QWidget::setBackgroundColor( const QColor &c ) { setEraseColor( c ); }
+/*!\obsolete  Use paletteBackgroundPixmap()  or erasePixmap() instead. */
+const QPixmap *QWidget::backgroundPixmap() const { return erasePixmap(); }
+/*!\obsolete  Use setPaletteBackgroundPixmap() or setErasePixmap() instead. */
+void QWidget::setBackgroundPixmap( const QPixmap &pm ) { setErasePixmap( pm ); }
+
+
+// documentation in qdesktopwidget_win.cpp
+void QDesktopWidget::insertChild( QObject *obj )
+{
+    if ( obj->isWidgetType() )
+	return;
+    QWidget::insertChild( obj );
+}
+
+/*!
+  \property QWidget::windowOpacity
+
+  \brief The level of opacity for the window.
+
+  The valid range of opacity is from 1.0 (completely opaque) to
+  0.0 (completely transparent).
+
+  By default the value of this property is 1.0.
+
+  This feature is only present on Mac OS X and Windows 2000 and up.
+
+  \warning Changing this property from opaque to transparent might issue a
+  paint event that needs to be processed before the window is displayed
+  correctly. This affects mainly the use of QPixmap::grabWindow(). Also note
+  that semi-transparent windows update and resize significantely slower than
+  opaque windows.
+*/
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget.h qt-x11-free-3.3.8b/src/kernel/qwidget.h
--- qt-x11-free-3.3.8b/src/kernel/qwidget.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget.h	2009-10-18 14:38:39.285199339 -0700
@@ -53,4 +53,8 @@
 #endif // QT_H
 
+#if defined(Q_WS_X11) && !defined(QT_NO_IM)
+class QInputContext;
+#endif
+
 class QLayout;
 struct QWExtra;
@@ -539,4 +543,16 @@
     int		 metric( int )	const;
 
+#if defined(Q_WS_X11)
+#if !defined(QT_NO_IM_EXTENSIONS)
+    virtual QWidget *icHolderWidget();
+#else
+    QWidget *icHolderWidget();
+#endif
+    QInputContext *getInputContext();
+    void	 changeInputContext( const QString & );
+    void	 sendMouseEventToInputContext( int x, QEvent::Type type,
+					       Qt::ButtonState button,
+					       Qt::ButtonState state );
+#endif
     void	 resetInputContext();
 
@@ -570,4 +586,7 @@
 private slots:
     void	 focusProxyDestroyed();
+#if defined(Q_WS_X11)
+    void	 destroyInputContext();
+#endif
 
 private:
@@ -575,6 +594,6 @@
 #if defined(Q_WS_X11)
     void	 createInputContext();
-    void	 destroyInputContext();
     void	 focusInputContext();
+    void	 unfocusInputContext();
     void	 checkChildrenDnd();
 #elif defined(Q_WS_MAC)
@@ -648,4 +667,7 @@
     QLayout 	*lay_out;
 #endif
+#if defined(Q_WS_X11) && !defined(QT_NO_IM) && !defined(QT_NO_IM_EXTENSIONS)
+    QInputContext *ic;				// Input Context
+#endif
     QWExtra	*extra;
 #if defined(Q_WS_QWS)
@@ -953,5 +975,7 @@
     uint     uspos : 1;				// User defined position
     uint     ussize : 1;			// User defined size
-    void    *xic;				// XIM Input Context
+#if defined(QT_NO_IM_EXTENSIONS)
+    void    *xic;				// Input Context
+#endif
 #endif
 #if defined(Q_WS_MAC)
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget.h.orig qt-x11-free-3.3.8b/src/kernel/qwidget.h.orig
--- qt-x11-free-3.3.8b/src/kernel/qwidget.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget.h.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,1026 @@
+/****************************************************************************
+**
+** Definition of QWidget class
+**
+** Created : 931029
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QWIDGET_H
+#define QWIDGET_H
+
+#ifndef QT_H
+#include "qwindowdefs.h"
+#include "qobject.h"
+#include "qpaintdevice.h"
+#include "qpalette.h"
+#include "qfont.h"
+#include "qfontmetrics.h"
+#include "qfontinfo.h"
+#include "qsizepolicy.h"
+#endif // QT_H
+
+class QLayout;
+struct QWExtra;
+struct QTLWExtra;
+class QFocusData;
+class QCursor;
+class QWSRegionManager;
+class QStyle;
+
+class Q_EXPORT QWidget : public QObject, public QPaintDevice
+{
+    Q_OBJECT
+    Q_ENUMS( BackgroundMode FocusPolicy BackgroundOrigin )
+    Q_PROPERTY( bool isTopLevel READ isTopLevel )
+    Q_PROPERTY( bool isDialog READ isDialog )
+    Q_PROPERTY( bool isModal READ isModal )
+    Q_PROPERTY( bool isPopup READ isPopup )
+    Q_PROPERTY( bool isDesktop READ isDesktop )
+    Q_PROPERTY( bool enabled READ isEnabled WRITE setEnabled )
+    Q_PROPERTY( QRect geometry READ geometry WRITE setGeometry )
+    Q_PROPERTY( QRect frameGeometry READ frameGeometry )
+    Q_PROPERTY( int x READ x )
+    Q_PROPERTY( int y READ y )
+    Q_PROPERTY( QPoint pos READ pos WRITE move DESIGNABLE false STORED false )
+    Q_PROPERTY( QSize frameSize READ frameSize )
+    Q_PROPERTY( QSize size READ size WRITE resize DESIGNABLE false STORED false )
+    Q_PROPERTY( int width READ width )
+    Q_PROPERTY( int height READ height )
+    Q_PROPERTY( QRect rect READ rect )
+    Q_PROPERTY( QRect childrenRect READ childrenRect )
+    Q_PROPERTY( QRegion childrenRegion READ childrenRegion )
+    Q_PROPERTY( QSizePolicy sizePolicy READ sizePolicy WRITE setSizePolicy )
+    Q_PROPERTY( QSize minimumSize READ minimumSize WRITE setMinimumSize )
+    Q_PROPERTY( QSize maximumSize READ maximumSize WRITE setMaximumSize )
+    Q_PROPERTY( int minimumWidth READ minimumWidth WRITE setMinimumWidth STORED false DESIGNABLE false )
+    Q_PROPERTY( int minimumHeight READ minimumHeight WRITE setMinimumHeight STORED false DESIGNABLE false )
+    Q_PROPERTY( int maximumWidth READ maximumWidth WRITE setMaximumWidth STORED false DESIGNABLE false )
+    Q_PROPERTY( int maximumHeight READ maximumHeight WRITE setMaximumHeight STORED false DESIGNABLE false )
+    Q_PROPERTY( QSize sizeIncrement READ sizeIncrement WRITE setSizeIncrement )
+    Q_PROPERTY( QSize baseSize READ baseSize WRITE setBaseSize )
+    Q_PROPERTY( BackgroundMode backgroundMode READ backgroundMode WRITE setBackgroundMode DESIGNABLE false )
+    Q_PROPERTY( QColor paletteForegroundColor READ paletteForegroundColor WRITE setPaletteForegroundColor RESET unsetPalette )
+    Q_PROPERTY( QColor paletteBackgroundColor READ paletteBackgroundColor WRITE setPaletteBackgroundColor RESET unsetPalette )
+    Q_PROPERTY( QPixmap paletteBackgroundPixmap READ paletteBackgroundPixmap WRITE setPaletteBackgroundPixmap RESET unsetPalette )
+    Q_PROPERTY( QBrush backgroundBrush READ backgroundBrush )
+    Q_PROPERTY( QColorGroup colorGroup READ colorGroup )
+    Q_PROPERTY( QPalette palette READ palette WRITE setPalette RESET unsetPalette  STORED ownPalette )
+    Q_PROPERTY( BackgroundOrigin backgroundOrigin READ backgroundOrigin WRITE setBackgroundOrigin )
+    Q_PROPERTY( bool ownPalette READ ownPalette )
+    Q_PROPERTY( QFont font READ font WRITE setFont RESET unsetFont STORED ownFont )
+    Q_PROPERTY( bool ownFont READ ownFont )
+#ifndef QT_NO_CURSOR
+    Q_PROPERTY( QCursor cursor READ cursor WRITE setCursor RESET unsetCursor STORED ownCursor )
+    Q_PROPERTY( bool ownCursor READ ownCursor )
+#endif
+#ifndef QT_NO_WIDGET_TOPEXTRA
+    Q_PROPERTY( QString caption READ caption WRITE setCaption )
+    Q_PROPERTY( QPixmap icon READ icon WRITE setIcon )
+    Q_PROPERTY( QString iconText READ iconText WRITE setIconText )
+#endif
+    Q_PROPERTY( bool mouseTracking READ hasMouseTracking WRITE setMouseTracking )
+    Q_PROPERTY( bool underMouse READ hasMouse )
+    Q_PROPERTY( bool isActiveWindow READ isActiveWindow )
+    Q_PROPERTY( bool focusEnabled READ isFocusEnabled )
+    Q_PROPERTY( FocusPolicy focusPolicy READ focusPolicy WRITE setFocusPolicy )
+    Q_PROPERTY( bool focus READ hasFocus )
+    Q_PROPERTY( bool updatesEnabled READ isUpdatesEnabled WRITE setUpdatesEnabled DESIGNABLE false )
+    Q_PROPERTY( bool visible READ isVisible )
+    Q_PROPERTY( QRect visibleRect READ visibleRect ) // obsolete
+    Q_PROPERTY( bool hidden READ isHidden WRITE setHidden DESIGNABLE false SCRIPTABLE false )
+    Q_PROPERTY( bool shown READ isShown WRITE setShown DESIGNABLE false SCRIPTABLE false )
+    Q_PROPERTY( bool minimized READ isMinimized )
+    Q_PROPERTY( bool maximized READ isMaximized )
+    Q_PROPERTY( bool fullScreen READ isFullScreen )
+    Q_PROPERTY( QSize sizeHint READ sizeHint )
+    Q_PROPERTY( QSize minimumSizeHint READ minimumSizeHint )
+    Q_PROPERTY( QRect microFocusHint READ microFocusHint )
+    Q_PROPERTY( bool acceptDrops READ acceptDrops WRITE setAcceptDrops )
+    Q_PROPERTY( bool autoMask READ autoMask WRITE setAutoMask DESIGNABLE false SCRIPTABLE false )
+    Q_PROPERTY( bool customWhatsThis READ customWhatsThis )
+    Q_PROPERTY( bool inputMethodEnabled READ isInputMethodEnabled WRITE setInputMethodEnabled DESIGNABLE false SCRIPTABLE false )
+    Q_PROPERTY( double windowOpacity READ windowOpacity WRITE setWindowOpacity DESIGNABLE false )
+
+public:
+    Q_EXPLICIT QWidget( QWidget* parent=0, const char* name=0, WFlags f=0 );
+    ~QWidget();
+
+    WId		 winId() const;
+    void	 setName( const char *name );
+#ifndef QT_NO_STYLE
+    // GUI style setting
+
+    QStyle     &style() const;
+    void        setStyle( QStyle * );
+    QStyle*	setStyle( const QString& );
+#endif
+    // Widget types and states
+
+    bool	 isTopLevel()	const;
+    bool	 isDialog()	const;
+    bool	 isPopup()	const;
+    bool	 isDesktop()	const;
+    bool	 isModal()	const;
+
+    bool	 isEnabled()	const;
+    bool	 isEnabledTo(QWidget*) const;
+    bool	 isEnabledToTLW() const;
+
+public slots:
+    virtual void setEnabled( bool );
+    void setDisabled( bool );
+
+    // Widget coordinates
+
+public:
+    QRect	 frameGeometry() const;
+    const QRect &geometry()	const;
+    int		 x()		const;
+    int		 y()		const;
+    QPoint	 pos()		const;
+    QSize	 frameSize()    const;
+    QSize	 size()		const;
+    int		 width()	const;
+    int		 height()	const;
+    QRect	 rect()		const;
+    QRect	 childrenRect() const;
+    QRegion	 childrenRegion() const;
+
+    QSize	 minimumSize()	 const;
+    QSize	 maximumSize()	 const;
+    int		 minimumWidth()	 const;
+    int		 minimumHeight() const;
+    int		 maximumWidth()	 const;
+    int		 maximumHeight() const;
+    void	 setMinimumSize( const QSize & );
+    virtual void setMinimumSize( int minw, int minh );
+    void	 setMaximumSize( const QSize & );
+    virtual void setMaximumSize( int maxw, int maxh );
+    void	 setMinimumWidth( int minw );
+    void	 setMinimumHeight( int minh );
+    void	 setMaximumWidth( int maxw );
+    void	 setMaximumHeight( int maxh );
+
+    QSize	 sizeIncrement() const;
+    void	 setSizeIncrement( const QSize & );
+    virtual void setSizeIncrement( int w, int h );
+    QSize	 baseSize() const;
+    void	 setBaseSize( const QSize & );
+    void	 setBaseSize( int basew, int baseh );
+
+    void	setFixedSize( const QSize & );
+    void	setFixedSize( int w, int h );
+    void	setFixedWidth( int w );
+    void	setFixedHeight( int h );
+
+    // Widget coordinate mapping
+
+    QPoint	 mapToGlobal( const QPoint & )	 const;
+    QPoint	 mapFromGlobal( const QPoint & ) const;
+    QPoint	 mapToParent( const QPoint & )	 const;
+    QPoint	 mapFromParent( const QPoint & ) const;
+    QPoint	 mapTo( QWidget *, const QPoint & ) const;
+    QPoint	 mapFrom( QWidget *, const QPoint & ) const;
+
+    QWidget	*topLevelWidget()   const;
+
+    // Widget attribute functions
+
+    BackgroundMode	backgroundMode() const;
+    virtual void	setBackgroundMode( BackgroundMode );
+    void 		setBackgroundMode( BackgroundMode, BackgroundMode );
+
+    const QColor &	foregroundColor() const;
+
+    const QColor &	eraseColor() const;
+    virtual void	setEraseColor( const QColor & );
+
+    const QPixmap *	erasePixmap() const;
+    virtual void	setErasePixmap( const QPixmap & );
+
+#ifndef QT_NO_PALETTE
+    const QColorGroup & colorGroup() const;
+    const QPalette &	palette()    const;
+    bool		ownPalette() const;
+    virtual void	setPalette( const QPalette & );
+    void		unsetPalette();
+#endif
+
+    const QColor &	paletteForegroundColor() const;
+    void		setPaletteForegroundColor( const QColor & );
+
+    const QColor &	paletteBackgroundColor() const;
+    virtual void	setPaletteBackgroundColor( const QColor & );
+
+    const QPixmap *	paletteBackgroundPixmap() const;
+    virtual void 	setPaletteBackgroundPixmap( const QPixmap & );
+
+    const QBrush&	backgroundBrush() const;
+
+    QFont		font() const;
+    bool		ownFont() const;
+    virtual void	setFont( const QFont & );
+    void		unsetFont();
+    QFontMetrics	fontMetrics() const;
+    QFontInfo	 	fontInfo() const;
+
+#ifndef QT_NO_CURSOR
+    const QCursor      &cursor() const;
+    bool		ownCursor() const;
+    virtual void	setCursor( const QCursor & );
+    virtual void	unsetCursor();
+#endif
+#ifndef QT_NO_WIDGET_TOPEXTRA
+    QString		caption() const;
+    const QPixmap      *icon() const;
+    QString		iconText() const;
+#endif
+    bool		hasMouseTracking() const;
+    bool		hasMouse() const;
+
+    virtual void	setMask( const QBitmap & );
+    virtual void	setMask( const QRegion & );
+    void		clearMask();
+
+    const QColor &	backgroundColor() const; // obsolete, use eraseColor()
+    virtual void	setBackgroundColor( const QColor & ); // obsolete, use setEraseColor()
+    const QPixmap *	backgroundPixmap() const; // obsolete, use erasePixmap()
+    virtual void	setBackgroundPixmap( const QPixmap & ); // obsolete, use setErasePixmap()
+
+public slots:
+#ifndef QT_NO_WIDGET_TOPEXTRA
+    virtual void	setCaption( const QString &);
+    virtual void	setIcon( const QPixmap & );
+    virtual void	setIconText( const QString &);
+#endif
+    virtual void	setMouseTracking( bool enable );
+
+    // Keyboard input focus functions
+
+    virtual void	setFocus();
+    void		clearFocus();
+
+public:
+    enum FocusPolicy {
+	NoFocus = 0,
+	TabFocus = 0x1,
+	ClickFocus = 0x2,
+	StrongFocus = TabFocus | ClickFocus | 0x8,
+	WheelFocus = StrongFocus | 0x4
+    };
+
+    bool		isActiveWindow() const;
+    virtual void	setActiveWindow();
+    bool		isFocusEnabled() const;
+
+    FocusPolicy		focusPolicy() const;
+    virtual void	setFocusPolicy( FocusPolicy );
+    bool		hasFocus() const;
+    static void		setTabOrder( QWidget *, QWidget * );
+    virtual void	setFocusProxy( QWidget * );
+    QWidget *		focusProxy() const;
+
+    void setInputMethodEnabled( bool b );
+    bool isInputMethodEnabled() const;
+    // Grab functions
+
+    void		grabMouse();
+#ifndef QT_NO_CURSOR
+    void		grabMouse( const QCursor & );
+#endif
+    void		releaseMouse();
+    void		grabKeyboard();
+    void		releaseKeyboard();
+    static QWidget *	mouseGrabber();
+    static QWidget *	keyboardGrabber();
+
+    // Update/refresh functions
+
+    bool	 	isUpdatesEnabled() const;
+
+#if 0 //def Q_WS_QWS
+    void		repaintUnclipped( const QRegion &, bool erase = TRUE );
+#endif
+public slots:
+    virtual void	setUpdatesEnabled( bool enable );
+    void		update();
+    void		update( int x, int y, int w, int h );
+    void		update( const QRect& );
+    void		repaint();
+    void		repaint( bool erase );
+    void		repaint( int x, int y, int w, int h, bool erase=TRUE );
+    void		repaint( const QRect &, bool erase = TRUE );
+    void		repaint( const QRegion &, bool erase = TRUE );
+
+    // Widget management functions
+
+    virtual void	show();
+    virtual void	hide();
+    void		setShown( bool show );
+    void		setHidden( bool hide );
+#ifndef QT_NO_COMPAT
+    void		iconify() { showMinimized(); }
+#endif
+    virtual void	showMinimized();
+    virtual void	showMaximized();
+    void		showFullScreen();
+    virtual void	showNormal();
+    virtual void	polish();
+    void 		constPolish() const;
+    bool		close();
+
+    void		raise();
+    void		lower();
+    void		stackUnder( QWidget* );
+    virtual void	move( int x, int y );
+    void		move( const QPoint & );
+    virtual void	resize( int w, int h );
+    void		resize( const QSize & );
+    virtual void	setGeometry( int x, int y, int w, int h );
+    virtual void	setGeometry( const QRect & ); // ### make non virtual in Qt 4?
+
+public:
+    virtual bool	close( bool alsoDelete );
+    bool		isVisible()	const;
+    bool		isVisibleTo(QWidget*) const;
+    bool		isVisibleToTLW() const; // obsolete
+    QRect		visibleRect() const; // obsolete
+    bool 		isHidden() const;
+    bool 		isShown() const;
+    bool		isMinimized() const;
+    bool		isMaximized() const;
+    bool		isFullScreen() const;
+
+    uint windowState() const;
+    void setWindowState(uint windowState);
+
+    virtual QSize	sizeHint() const;
+    virtual QSize	minimumSizeHint() const;
+    virtual QSizePolicy	sizePolicy() const;
+    virtual void	setSizePolicy( QSizePolicy );
+    void 		setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE );
+    virtual int heightForWidth(int) const;
+
+    QRegion	clipRegion() const;
+
+// ### move together with other slots in Qt 4.0
+public slots:
+    virtual void  	adjustSize();
+
+public:
+#ifndef QT_NO_LAYOUT
+    QLayout *		layout() const { return lay_out; }
+#endif
+    void		updateGeometry();
+    virtual void 	reparent( QWidget *parent, WFlags, const QPoint &,
+				  bool showIt=FALSE );
+    void		reparent( QWidget *parent, const QPoint &,
+				  bool showIt=FALSE );
+#ifndef QT_NO_COMPAT
+    void		recreate( QWidget *parent, WFlags f, const QPoint & p,
+				  bool showIt=FALSE ) { reparent(parent,f,p,showIt); }
+#endif
+
+    void		erase();
+    void		erase( int x, int y, int w, int h );
+    void		erase( const QRect & );
+    void		erase( const QRegion & );
+    void		scroll( int dx, int dy );
+    void		scroll( int dx, int dy, const QRect& );
+
+    void		drawText( int x, int y, const QString &);
+    void		drawText( const QPoint &, const QString &);
+
+    // Misc. functions
+
+    QWidget *		focusWidget() const;
+    QRect               microFocusHint() const;
+
+    // drag and drop
+
+    bool		acceptDrops() const;
+    virtual void	setAcceptDrops( bool on );
+
+    // transparency and pseudo transparency
+
+    virtual void	setAutoMask(bool);
+    bool		autoMask() const;
+
+    enum BackgroundOrigin { WidgetOrigin, ParentOrigin, WindowOrigin, AncestorOrigin };
+
+    virtual void setBackgroundOrigin( BackgroundOrigin );
+    BackgroundOrigin backgroundOrigin() const;
+    QPoint backgroundOffset() const;
+
+    // whats this help
+    virtual bool customWhatsThis() const;
+
+    QWidget *		parentWidget( bool sameWindow = FALSE ) const;
+    WState		testWState( WState s ) const;
+    WFlags		testWFlags( WFlags f ) const;
+    static QWidget *	find( WId );
+    static QWidgetMapper *wmapper();
+
+    QWidget  *childAt( int x, int y, bool includeThis = FALSE ) const;
+    QWidget  *childAt( const QPoint &, bool includeThis = FALSE ) const;
+
+#if defined(Q_WS_QWS)
+    virtual QGfx * graphicsContext(bool clip_children=TRUE) const;
+#endif
+#if defined(Q_WS_MAC)
+    QRegion clippedRegion(bool do_children=TRUE);
+    uint clippedSerial(bool do_children=TRUE);
+#ifndef QMAC_NO_QUARTZ
+    CGContextRef macCGContext(bool clipped=TRUE) const;
+#endif
+#endif
+
+    void setWindowOpacity(double level);
+    double windowOpacity() const;
+
+protected:
+    // Event handlers
+    bool	 event( QEvent * );
+    virtual void mousePressEvent( QMouseEvent * );
+    virtual void mouseReleaseEvent( QMouseEvent * );
+    virtual void mouseDoubleClickEvent( QMouseEvent * );
+    virtual void mouseMoveEvent( QMouseEvent * );
+#ifndef QT_NO_WHEELEVENT
+    virtual void wheelEvent( QWheelEvent * );
+#endif
+    virtual void keyPressEvent( QKeyEvent * );
+    virtual void keyReleaseEvent( QKeyEvent * );
+    virtual void focusInEvent( QFocusEvent * );
+    virtual void focusOutEvent( QFocusEvent * );
+    virtual void enterEvent( QEvent * );
+    virtual void leaveEvent( QEvent * );
+    virtual void paintEvent( QPaintEvent * );
+    virtual void moveEvent( QMoveEvent * );
+    virtual void resizeEvent( QResizeEvent * );
+    virtual void closeEvent( QCloseEvent * );
+    virtual void contextMenuEvent( QContextMenuEvent * );
+    virtual void imStartEvent( QIMEvent * );
+    virtual void imComposeEvent( QIMEvent * );
+    virtual void imEndEvent( QIMEvent * );
+    virtual void tabletEvent( QTabletEvent * );
+
+#ifndef QT_NO_DRAGANDDROP
+    virtual void dragEnterEvent( QDragEnterEvent * );
+    virtual void dragMoveEvent( QDragMoveEvent * );
+    virtual void dragLeaveEvent( QDragLeaveEvent * );
+    virtual void dropEvent( QDropEvent * );
+#endif
+
+    virtual void showEvent( QShowEvent * );
+    virtual void hideEvent( QHideEvent * );
+
+#if defined(Q_WS_MAC)
+    virtual bool macEvent( MSG * );
+#endif
+#if defined(Q_WS_WIN)
+    virtual bool winEvent( MSG * );
+#endif
+#if defined(Q_WS_X11)
+    virtual bool x11Event( XEvent * );
+#endif
+#if defined(Q_WS_QWS)
+    virtual bool qwsEvent( QWSEvent * );
+    virtual unsigned char *scanLine( int ) const;
+    virtual int bytesPerLine() const;
+#endif
+
+    virtual void updateMask();
+
+    // Misc. protected functions
+
+#ifndef QT_NO_STYLE
+    virtual void styleChange( QStyle& );
+#endif
+    virtual void enabledChange( bool oldEnabled );
+#ifndef QT_NO_PALETTE
+    virtual void paletteChange( const QPalette & );
+#endif
+    virtual void fontChange( const QFont & );
+    virtual void windowActivationChange( bool oldActive );
+
+    int		 metric( int )	const;
+
+    void	 resetInputContext();
+
+    virtual void create( WId = 0, bool initializeWindow = TRUE,
+			 bool destroyOldWindow = TRUE );
+    virtual void destroy( bool destroyWindow = TRUE,
+			  bool destroySubWindows = TRUE );
+    uint	 getWState() const;
+    virtual void setWState( uint );
+    void	 clearWState( uint n );
+    WFlags	 getWFlags() const;
+    virtual void setWFlags( WFlags );
+    void	 clearWFlags( WFlags n );
+
+    virtual bool focusNextPrevChild( bool next );
+
+    QWExtra	*extraData();
+    QTLWExtra	*topData();
+    QFocusData	*focusData();
+
+    virtual void setKeyCompression(bool);
+    virtual void setMicroFocusHint(int x, int y, int w, int h, bool text=TRUE, QFont *f = 0);
+
+#if defined(Q_WS_MAC)
+    void dirtyClippedRegion(bool);
+    bool isClippedRegionDirty();
+    virtual void setRegionDirty(bool);
+    virtual void macWidgetChangedWindow();
+#endif
+
+private slots:
+    void	 focusProxyDestroyed();
+
+private:
+    void	 setFontSys( QFont *f = 0 );
+#if defined(Q_WS_X11)
+    void	 createInputContext();
+    void	 destroyInputContext();
+    void	 focusInputContext();
+    void	 checkChildrenDnd();
+#elif defined(Q_WS_MAC)
+    uint    own_id : 1, macDropEnabled : 1;
+    EventHandlerRef window_event;
+    //mac event functions
+    void    propagateUpdates(bool update_rgn=TRUE);
+    void    update( const QRegion& );
+    //friends, way too many - fix this immediately!
+    friend void qt_clean_root_win();
+    friend bool qt_recreate_root_win();
+    friend QPoint posInWindow(QWidget *);
+    friend bool qt_mac_update_sizer(QWidget *, int);
+    friend QWidget *qt_recursive_match(QWidget *widg, int x, int y);
+    friend bool qt_paint_children(QWidget *,QRegion &, uchar ops);
+    friend QMAC_PASCAL OSStatus qt_window_event(EventHandlerCallRef er, EventRef event, void *);
+    friend void qt_event_request_updates(QWidget *, const QRegion &, bool subtract);
+    friend bool qt_window_rgn(WId, short, RgnHandle, bool);
+    friend class QDragManager;
+#endif
+
+#ifndef QT_NO_LAYOUT
+    void 	 setLayout( QLayout *l );
+#endif
+    void	 setWinId( WId );
+    void	 showWindow();
+    void	 hideWindow();
+    void	 showChildren( bool spontaneous );
+    void	 hideChildren( bool spontaneous );
+    void	 reparentSys( QWidget *parent, WFlags, const QPoint &,  bool showIt);
+    void	 createTLExtra();
+    void	 createExtra();
+    void	 deleteExtra();
+    void	 createSysExtra();
+    void	 deleteSysExtra();
+    void	 createTLSysExtra();
+    void	 deleteTLSysExtra();
+    void	 deactivateWidgetCleanup();
+    void	 internalSetGeometry( int, int, int, int, bool );
+    void	 reparentFocusWidgets( QWidget * );
+    QFocusData	*focusData( bool create );
+    void         setBackgroundFromMode();
+    void         setBackgroundColorDirect( const QColor & );
+    void   	 setBackgroundPixmapDirect( const QPixmap & );
+    void         setBackgroundModeDirect( BackgroundMode );
+    void         setBackgroundEmpty();
+    void	 updateFrameStrut() const;
+#if defined(Q_WS_X11)
+    void         setBackgroundX11Relative();
+#endif
+
+    WId		 winid;
+    uint	 widget_state;
+    uint	 widget_flags;
+    uint	 focus_policy : 4;
+    uint 	 own_font :1;
+    uint 	 own_palette :1;
+    uint 	 sizehint_forced :1;
+    uint 	 is_closing :1;
+    uint 	 in_show : 1;
+    uint 	 in_show_maximized : 1;
+    uint	 fstrut_dirty : 1;
+    uint	 im_enabled : 1;
+    QRect	 crect;
+    QColor	 bg_col;
+#ifndef QT_NO_PALETTE
+    QPalette	 pal;
+#endif
+    QFont	 fnt;
+#ifndef QT_NO_LAYOUT
+    QLayout 	*lay_out;
+#endif
+    QWExtra	*extra;
+#if defined(Q_WS_QWS)
+    QRegion	 req_region;			// Requested region
+    mutable QRegion	 paintable_region;	// Paintable region
+    mutable bool         paintable_region_dirty;// needs to be recalculated
+    mutable QRegion      alloc_region;          // Allocated region
+    mutable bool         alloc_region_dirty;    // needs to be recalculated
+    mutable int          overlapping_children;  // Handle overlapping children
+
+    int		 alloc_region_index;
+    int		 alloc_region_revision;
+
+    void updateOverlappingChildren() const;
+    void setChildrenAllocatedDirty();
+    void setChildrenAllocatedDirty( const QRegion &r, const QWidget *dirty=0 );
+    bool isAllocatedRegionDirty() const;
+    void updateRequestedRegion( const QPoint &gpos );
+    QRegion requestedRegion() const;
+    QRegion allocatedRegion() const;
+    QRegion paintableRegion() const;
+
+    void updateGraphicsContext( QGfx *qgfx_qws, bool clip_children ) const;
+#ifndef QT_NO_CURSOR
+    void updateCursor( const QRegion &r ) const;
+#endif
+
+    // used to accumulate dirty region when children moved/resized.
+    QRegion dirtyChildren;
+    bool isSettingGeometry;
+    friend class QWSManager;
+#endif
+    static int instanceCounter;  // Current number of widget instances
+    static int maxInstances;     // Maximum number of widget instances
+
+    static void	 createMapper();
+    static void	 destroyMapper();
+    static QWidgetList	 *wList();
+    static QWidgetList	 *tlwList();
+    static QWidgetMapper *mapper;
+    friend class QApplication;
+    friend class QBaseApplication;
+    friend class QPainter;
+    friend class QFontMetrics;
+    friend class QFontInfo;
+    friend class QETWidget;
+    friend class QLayout;
+
+private:	// Disabled copy constructor and operator=
+#if defined(Q_DISABLE_COPY)
+    QWidget( const QWidget & );
+    QWidget &operator=( const QWidget & );
+#endif
+
+public: // obsolete functions to dissappear or to become inline in 3.0
+#ifndef QT_NO_PALETTE
+    void setPalette( const QPalette &p, bool ) { setPalette( p ); }
+#endif
+    void setFont( const QFont &f, bool ) { setFont( f ); }
+};
+
+
+inline Qt::WState QWidget::testWState( WState s ) const
+{ return (widget_state & s); }
+
+inline Qt::WFlags QWidget::testWFlags( WFlags f ) const
+{ return (widget_flags & f); }
+
+
+inline WId QWidget::winId() const
+{ return winid; }
+
+inline bool QWidget::isTopLevel() const
+{ return testWFlags(WType_TopLevel); }
+
+inline bool QWidget::isDialog() const
+{ return testWFlags(WType_Dialog); }
+
+inline bool QWidget::isPopup() const
+{ return testWFlags(WType_Popup); }
+
+inline bool QWidget::isDesktop() const
+{ return testWFlags(WType_Desktop); }
+
+inline bool QWidget::isEnabled() const
+{ return !testWState(WState_Disabled); }
+
+inline bool QWidget::isModal() const
+{ return testWFlags(WShowModal); }
+
+inline bool QWidget::isEnabledToTLW() const
+{ return isEnabled(); }
+
+inline const QRect &QWidget::geometry() const
+{ return crect; }
+
+inline QSize QWidget::size() const
+{ return crect.size(); }
+
+inline int QWidget::width() const
+{ return crect.width(); }
+
+inline int QWidget::height() const
+{ return crect.height(); }
+
+inline QRect QWidget::rect() const
+{ return QRect(0,0,crect.width(),crect.height()); }
+
+inline int QWidget::minimumWidth() const
+{ return minimumSize().width(); }
+
+inline int QWidget::minimumHeight() const
+{ return minimumSize().height(); }
+
+inline int QWidget::maximumWidth() const
+{ return maximumSize().width(); }
+
+inline int QWidget::maximumHeight() const
+{ return maximumSize().height(); }
+
+inline void QWidget::setMinimumSize( const QSize &s )
+{ setMinimumSize(s.width(),s.height()); }
+
+inline void QWidget::setMaximumSize( const QSize &s )
+{ setMaximumSize(s.width(),s.height()); }
+
+inline void QWidget::setSizeIncrement( const QSize &s )
+{ setSizeIncrement(s.width(),s.height()); }
+
+inline void QWidget::setBaseSize( const QSize &s )
+{ setBaseSize(s.width(),s.height()); }
+
+inline const QColor &QWidget::eraseColor() const
+{ return bg_col; }
+
+#ifndef QT_NO_PALETTE
+inline const QPalette &QWidget::palette() const
+{ return pal; }
+#endif
+
+inline QFont QWidget::font() const
+{ return fnt; }
+
+inline QFontMetrics QWidget::fontMetrics() const
+{ return QFontMetrics(font()); }
+
+inline QFontInfo QWidget::fontInfo() const
+{ return QFontInfo(font()); }
+
+inline bool QWidget::hasMouseTracking() const
+{ return testWState(WState_MouseTracking); }
+
+inline bool QWidget::hasMouse() const
+{ return testWState(WState_HasMouse); }
+
+inline bool  QWidget::isFocusEnabled() const
+{ return (FocusPolicy)focus_policy != NoFocus; }
+
+inline QWidget::FocusPolicy QWidget::focusPolicy() const
+{ return (FocusPolicy)focus_policy; }
+
+inline bool QWidget::isUpdatesEnabled() const
+{ return !testWState(WState_BlockUpdates); }
+
+inline void QWidget::update( const QRect &r )
+{ update( r.x(), r.y(), r.width(), r.height() ); }
+
+inline void QWidget::repaint()
+{ repaint( TRUE ); }
+
+inline void QWidget::repaint( const QRect &r, bool erase )
+{ repaint( r.x(), r.y(), r.width(), r.height(), erase ); }
+
+inline void QWidget::erase()
+{ erase( 0, 0, crect.width(), crect.height() ); }
+
+inline void QWidget::erase( const QRect &r )
+{ erase( r.x(), r.y(), r.width(), r.height() ); }
+
+inline bool QWidget::close()
+{ return close( FALSE ); }
+
+inline bool QWidget::isVisible() const
+{ return testWState(WState_Visible); }
+
+inline bool QWidget::isVisibleToTLW() const // obsolete
+{ return isVisible(); }
+
+inline bool QWidget::isHidden() const
+{ return testWState(WState_ForceHide); }
+
+inline bool QWidget::isShown() const
+{ return !testWState(WState_ForceHide); }
+
+inline void QWidget::move( const QPoint &p )
+{ move( p.x(), p.y() ); }
+
+inline void QWidget::resize( const QSize &s )
+{ resize( s.width(), s.height()); }
+
+inline void QWidget::setGeometry( const QRect &r )
+{ setGeometry( r.left(), r.top(), r.width(), r.height() ); }
+
+inline void QWidget::drawText( const QPoint &p, const QString &s )
+{ drawText( p.x(), p.y(), s ); }
+
+inline QWidget *QWidget::parentWidget( bool sameWindow ) const
+{
+    if ( sameWindow )
+	return isTopLevel() ? 0 : (QWidget *)QObject::parent();
+    return (QWidget *)QObject::parent();
+}
+
+inline QWidgetMapper *QWidget::wmapper()
+{ return mapper; }
+
+inline uint QWidget::getWState() const
+{ return widget_state; }
+
+inline void QWidget::setWState( uint f )
+{ widget_state |= f; }
+
+inline void QWidget::clearWState( uint f )
+{ widget_state &= ~f; }
+
+inline Qt::WFlags QWidget::getWFlags() const
+{ return widget_flags; }
+
+inline void QWidget::setWFlags( WFlags f )
+{ widget_flags |= f; }
+
+inline void QWidget::clearWFlags( WFlags f )
+{ widget_flags &= ~f; }
+
+inline void QWidget::constPolish() const
+{
+    if ( !testWState(WState_Polished) ) {
+	QWidget* that = (QWidget*) this;
+	that->polish();
+        that->setWState(WState_Polished); // be on the safe side...
+    }
+}
+#ifndef QT_NO_CURSOR
+inline bool QWidget::ownCursor() const
+{
+    return testWState( WState_OwnCursor );
+}
+#endif
+inline bool QWidget::ownFont() const
+{
+    return own_font;
+}
+#ifndef QT_NO_PALETTE
+inline bool QWidget::ownPalette() const
+{
+    return own_palette;
+}
+#endif
+
+inline void QWidget::setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw )
+{
+    setSizePolicy( QSizePolicy( hor, ver, hfw) );
+}
+
+inline bool QWidget::isInputMethodEnabled() const
+{
+    return (bool)im_enabled;
+}
+
+// Extra QWidget data
+//  - to minimize memory usage for members that are seldom used.
+//  - top-level widgets have extra extra data to reduce cost further
+
+class QFocusData;
+class QWSManager;
+#if defined(Q_WS_WIN)
+class QOleDropTarget;
+#endif
+#if defined(Q_WS_MAC)
+class QMacDndExtra;
+#endif
+
+struct Q_EXPORT QTLWExtra {
+#ifndef QT_NO_WIDGET_TOPEXTRA
+    QString  caption;				// widget caption
+    QString  iconText;				// widget icon text
+    QPixmap *icon;				// widget icon
+#endif
+    QFocusData *focusData;			// focus data (for TLW)
+    short    incw, inch;			// size increments
+    // frame strut
+    ulong    fleft, fright, ftop, fbottom;
+    uint     unused : 8;                       // not used at this point...
+#if defined( Q_WS_WIN ) || defined( Q_WS_MAC )
+    uint     opacity : 8;		       // Stores opacity level on Windows/Mac OS X.
+#endif
+    uint     savedFlags;			// Save widgetflags while showing fullscreen
+    short    basew, baseh;			// base sizes
+#if defined(Q_WS_X11)
+    WId  parentWinId;				// parent window Id (valid after reparenting)
+    uint     embedded : 1;			// window is embedded in another Qt application
+    uint     spont_unmapped: 1;			// window was spontaneously unmapped
+    uint     reserved: 1;			// reserved
+    uint     dnd : 1;				// DND properties installed
+    uint     uspos : 1;				// User defined position
+    uint     ussize : 1;			// User defined size
+    void    *xic;				// XIM Input Context
+#endif
+#if defined(Q_WS_MAC)
+    WindowGroupRef group;
+    uint     is_moved: 1;
+    uint     resizer : 4;
+#endif
+#if defined(Q_WS_QWS) && !defined ( QT_NO_QWS_MANAGER )
+    QRegion decor_allocated_region;		// decoration allocated region
+    QWSManager *qwsManager;
+#endif
+#if defined(Q_WS_WIN)
+    HICON    winIcon;				// internal Windows icon
+#endif
+    QRect    normalGeometry;			// used by showMin/maximized/FullScreen
+#ifdef Q_WS_WIN
+    uint style, exstyle;
+#endif
+};
+
+
+#define QWIDGETSIZE_MAX 32767
+
+// dear user: you can see this struct, but it is internal. do not touch.
+
+struct Q_EXPORT QWExtra {
+    Q_INT16  minw, minh;			// minimum size
+    Q_INT16  maxw, maxh;			// maximum size
+    QPixmap *bg_pix;				// background pixmap
+    QWidget *focus_proxy;
+#ifndef QT_NO_CURSOR
+    QCursor *curs;
+#endif
+    QTLWExtra *topextra;			// only useful for TLWs
+#if defined(Q_WS_WIN)
+    QOleDropTarget *dropTarget;			// drop target
+#endif
+#if defined(Q_WS_X11)
+    WId xDndProxy;				// XDND forwarding to embedded windows
+#endif
+#if defined(Q_WS_MAC)
+    QRegion clip_saved, clip_sibs, clip_children;
+    QMacDndExtra *macDndExtra;
+    QRegion dirty_area;
+    uint clip_dirty : 1, clip_serial : 15;
+    uint child_dirty : 1, child_serial : 15;
+#ifndef QMAC_NO_QUARTZ
+    uint ctx_children_clipped:1;
+#endif // QMAC_NO_QUARTZ
+    uint has_dirty_area:1;
+#endif // Q_WS_MAC
+    uint bg_origin : 2;
+#if defined(Q_WS_X11)
+    uint children_use_dnd : 1;
+    uint compress_events : 1;
+#endif
+#if defined(Q_WS_QWS) || defined(Q_WS_MAC)
+    QRegion mask;				// widget mask
+#endif
+    char     bg_mode;				// background mode
+    char     bg_mode_visual;			// visual background mode
+#ifndef QT_NO_STYLE
+    QStyle* style;
+#endif
+    QRect micro_focus_hint;			// micro focus hint
+    QSizePolicy size_policy;
+};
+
+#define Q_DEFINED_QWIDGET
+#include "qwinexport.h"
+
+#endif // QWIDGET_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp
--- qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp	2009-10-18 14:38:39.295203767 -0700
@@ -65,9 +65,7 @@
 void qt_updated_rootinfo();
 
-#ifndef QT_NO_XIM
-#include "qinputcontext_p.h"
-
-extern XIM qt_xim;
-extern XIMStyle qt_xim_style;
+#ifndef QT_NO_IM
+#include "qinputcontext.h"
+#include "qinputcontextfactory.h"
 #endif
 
@@ -692,4 +690,8 @@
     if ( destroyw )
 	qt_XDestroyWindow( this, dpy, destroyw );
+
+#if !defined(QT_NO_IM_EXTENSIONS)
+    ic = 0;
+#endif
 }
 
@@ -755,4 +757,14 @@
 	if ( testWState(WState_Reparented) )
 	    qPRCleanup(this);
+
+	if( this == icHolderWidget() ) {
+	    destroyInputContext();
+	} else {
+	    // release previous focus information participating with
+	    // preedit preservation of qic
+	    QInputContext *qic = getInputContext();
+	    if ( qic )
+		qic->releaseComposingWidget( this );
+	}
     }
 }
@@ -791,9 +803,9 @@
 		     RootWindow( x11Display(), x11Screen() ), 0, 0 );
 
-    if ( isTopLevel() ) {
-        // input contexts are associated with toplevel widgets, so we need
-        // destroy the context here.  if we are reparenting back to toplevel,
-        // then we will have another context created, otherwise we will
-        // use our new toplevel's context
+    if ( this == icHolderWidget() ) {
+	// input contexts are sometimes associated with toplevel widgets, so
+	// we need destroy the context here.  if we are reparenting back to
+	// toplevel, then we may have another context created, otherwise we
+	// will use our new ic holder's context
         destroyInputContext();
     }
@@ -951,5 +963,6 @@
 
     In the X11 version of Qt, if \a text is TRUE, this method sets the
-    XIM "spot" point for complex language input handling.
+    input method focus point in the preedit (XIM "spot" point) for
+    complex language input handling.
 
     The font \a f is a rendering hint to the currently active input method.
@@ -961,20 +974,13 @@
 				bool text, QFont *f )
 {
-#ifndef QT_NO_XIM
+#ifndef QT_NO_IM
     if ( text ) {
-	QWidget* tlw = topLevelWidget();
-	QTLWExtra *topdata = tlw->topData();
-
 	// trigger input context creation if it hasn't happened already
 	createInputContext();
-	QInputContext *qic = (QInputContext *) topdata->xic;
 
-	if ( qt_xim && qic ) {
-	    QPoint p( x, y );
-	    QPoint p2 = mapTo( topLevelWidget(), QPoint( 0, 0 ) );
-	    p = mapTo( topLevelWidget(), p);
-	    qic->setXFontSet( f ? *f : fnt );
-	    qic->setComposePosition(p.x(), p.y() + height);
-	    qic->setComposeArea(p2.x(), p2.y(), this->width(), this->height());
+	QInputContext *qic = getInputContext();
+	if(qic) {
+	    QPoint gp = mapToGlobal( QPoint( x, y ) );
+	    qic->setMicroFocus(gp.x(), gp.y(), width, height, f);
 	}
     }
@@ -2426,11 +2432,14 @@
 void QWidget::createTLSysExtra()
 {
+#if defined(QT_NO_IM_EXTENSIONS)
     // created lazily
     extra->topextra->xic = 0;
+#endif
 }
 
 void QWidget::deleteTLSysExtra()
 {
-    destroyInputContext();
+    // don't destroy input context here. it will be destroyed in
+    // QWidget::destroy() destroyInputContext();
 }
 
@@ -2663,76 +2672,249 @@
 }
 
+/*!
+    This function returns the widget holding the QInputContext
+    instance for this widget. The instance is used for text input to
+    this widget, switching input method, etc.
+
+    By default, this function delegates the role of returning input
+    context holder widget to QApplication::locateICHolderWidget().
+
+    This definition enables application developer to change the
+    mapping of widgets to QInputContext instance simply by overriding
+    QApplication::locateICHolderWidget().
+
+    \sa QApplication::locateICHolderWidget()
+*/
+QWidget *QWidget::icHolderWidget()
+{
+    return qApp->locateICHolderWidget(this);
+}
+
 
+/*!
+    This function returns the QInputContext instance for this widget.
+    This instance is used for text input to this widget, etc.
+    It is simply the accessor function.
+*/
+QInputContext *QWidget::getInputContext()
+{
+    QInputContext *qic = 0;
+
+#if !defined(QT_NO_IM_EXTENSIONS)
+    if ( isInputMethodEnabled() ) {
+      qic = icHolderWidget()->ic;
+#else
+    {
+      // icHolderWidget is always topLevelWidget
+      QTLWExtra *topdata = icHolderWidget()->topData();
+      qic = (QInputContext *)topdata->xic;
+#endif
+    }
+
+    return qic;
+}
+
+
+/*!
+    This function replaces the QInputContext instance used for text
+    input to this widget. The \a identifierName is the identifier name
+    of newly choosed input method.
+*/
+void QWidget::changeInputContext( const QString& identifierName )
+{
+    QWidget *icWidget = icHolderWidget();
+#if !defined(QT_NO_IM_EXTENSIONS)
+    QInputContext **qicp = &icWidget->ic;
+#else
+    QInputContext **qicp = (QInputContext **)&icWidget->topData()->xic;
+#endif
+
+    if( *qicp )
+      delete *qicp;
+    // an input context that has the identifierName is generated.
+    QInputContext *qic = QInputContextFactory::create( identifierName, icWidget );
+    *qicp = qic;
+    if ( qic ) {
+      QObject::connect( qic, SIGNAL(imEventGenerated(QObject *,QIMEvent *)),
+                        qApp, SLOT(postIMEvent(QObject *,QIMEvent *)) );
+      QObject::connect( qic, SIGNAL(deletionRequested()),
+                        icWidget, SLOT(destroyInputContext()) );
+    }
+}
+
+
+/*!
+  \internal
+    This is an internal function, you should never call this.
+
+    This function is called to generate an input context
+    according to a configuration for default input method
+
+    When QT_NO_IM_EXTENSIONS is not set, input context is
+    generated only when isInputMethodEnabled() returns TRUE.
+*/
 void QWidget::createInputContext()
 {
-    QWidget *tlw = topLevelWidget();
-    QTLWExtra *topdata = tlw->topData();
+#if !defined(QT_NO_IM_EXTENSIONS)
+    if( !isInputMethodEnabled() || QApplication::closingDown() )
+      return;
+#endif
 
-#ifndef QT_NO_XIM
-    if (qt_xim) {
-	if (! topdata->xic) {
-	    QInputContext *qic = new QInputContext(tlw);
-	    topdata->xic = (void *) qic;
-	}
-    } else
-#endif // QT_NO_XIM
-	{
-	    // qDebug("QWidget::createInputContext: no xim");
-	    topdata->xic = 0;
-	}
+    QWidget *icWidget = icHolderWidget();
+#ifndef QT_NO_IM
+#if !defined(QT_NO_IM_EXTENSIONS)
+    QInputContext **qicp = &icWidget->ic;
+#else
+    QInputContext **qicp = (QInputContext **)&icWidget->topData()->xic;
+#endif
+    if ( ! *qicp ) {
+      // an input context of the default input method is generated.
+      QInputContext *qic = QInputContextFactory::create( QApplication::defaultInputMethod(), icWidget );
+
+      *qicp = qic;
+      if ( qic ) {
+          QObject::connect( qic, SIGNAL(imEventGenerated(QObject *,QIMEvent *)),
+                            qApp, SLOT(postIMEvent(QObject *,QIMEvent *)) );
+          QObject::connect( qic, SIGNAL(deletionRequested()),
+                            icWidget, SLOT(destroyInputContext()) );
+      }
+    }
+#endif // QT_NO_IM
 }
 
 
+/*!
+    \internal
+
+    This slot is used to destroy the input context that belonging
+    to the widget itself, so icHolderWidget()->ic is not fetched.
+
+    \sa QInputContext::deletionRequested()
+*/
 void QWidget::destroyInputContext()
 {
-#ifndef QT_NO_XIM
-    QInputContext *qic = (QInputContext *) extra->topextra->xic;
-    delete qic;
-#endif // QT_NO_XIM
-    extra->topextra->xic = 0;
+#ifndef QT_NO_IM
+#if !defined(QT_NO_IM_EXTENSIONS)
+    QInputContext **qicp = &ic;
+#else
+    if ( ! extra || ! extra->topextra )
+      return;
+
+    QInputContext **qicp = (QInputContext **)&extra->topextra->xic;
+#endif
+
+    if( *qicp )
+      delete *qicp;
+
+    *qicp = 0;
+#endif // QT_NO_IM
 }
 
 
 /*!
-    This function is called when the user finishes input composition,
-    e.g. changes focus to another widget, moves the cursor, etc.
+    This function is called when text widgets need to be neutral state to
+    execute text operations properly. See qlineedit.cpp and qtextedit.cpp as
+    example.
+
+    Ordinary reset that along with changing focus to another widget,
+    moving the cursor, etc, is implicitly handled via
+    unfocusInputContext() because whether reset or not when such
+    situation is a responsibility of input methods. So we delegate the
+    responsibility to the input context via unfocusInputContext(). See
+    'Preedit preservation' section of the class description of
+    QInputContext for further information.
+
+    \sa QInputContext, unfocusInputContext(), QInputContext::unsetFocus()
 */
 void QWidget::resetInputContext()
 {
-#ifndef QT_NO_XIM
-    if ((qt_xim_style & XIMPreeditCallbacks) && hasFocus()) {
-	QWidget *tlw = topLevelWidget();
-	QTLWExtra *topdata = tlw->topData();
+#ifndef QT_NO_IM
+    // trigger input context creation if it hasn't happened already
+    createInputContext();
 
-	// trigger input context creation if it hasn't happened already
-	createInputContext();
+    QInputContext *qic = getInputContext();
+    if( qic )
+      qic->reset();
+#endif // QT_NO_IM
+}
 
-	if (topdata->xic) {
-	    QInputContext *qic = (QInputContext *) topdata->xic;
-	    qic->reset();
-	}
+
+/*!
+    \internal
+    This is an internal function, you should never call this.
+
+    This function is called to focus associated input context. The
+    code intends to eliminate duplicate focus for the context even if
+    the context is shared between widgets
+
+    \sa QInputContext::setFocus()
+*/
+void QWidget::focusInputContext()
+{
+#ifndef QT_NO_IM
+    // trigger input context creation if it hasn't happened already
+    createInputContext();
+
+    QInputContext *qic = getInputContext();
+    if ( qic ) {
+      if( qic->focusWidget() != this ) {
+	  qic->setFocusWidget( this );
+	  qic->setFocus();
+      }
     }
-#endif // QT_NO_XIM
+#endif // QT_NO_IM
 }
 
 
-void QWidget::focusInputContext()
+/*!
+    \internal
+    This is an internal function, you should never call this.
+
+    This function is called to remove focus from associated input
+    context.
+
+    \sa QInputContext::unsetFocus()
+*/
+void QWidget::unfocusInputContext()
 {
-#ifndef QT_NO_XIM
-    QWidget *tlw = topLevelWidget();
-    if (!tlw->isPopup() || isInputMethodEnabled()) {
-        QTLWExtra *topdata = tlw->topData();
+#ifndef QT_NO_IM
+    // trigger input context creation if it hasn't happened already
+    createInputContext();
 
-        // trigger input context creation if it hasn't happened already
-        createInputContext();
+    QInputContext *qic = getInputContext();
+    if ( qic ) {
+      // may be caused reset() in some input methods
+      qic->unsetFocus();
+      qic->setFocusWidget( 0 );
+    }
+#endif // QT_NO_IM
+}
 
-        if (topdata->xic) {
-            QInputContext *qic = (QInputContext *) topdata->xic;
-            qic->setFocus();
-        }
+
+/*!
+    This function is called to send mouse event to associated input
+    context by derived text widgets. A derived text widget must be
+    calculate \a x as character offset at the mouse cursor in the
+    preedit.
+
+    \sa QInputContext::mouseHandler()
+*/
+void QWidget::sendMouseEventToInputContext( int x, QEvent::Type type,
+                                          Qt::ButtonState button,
+                                          Qt::ButtonState state )
+{
+#ifndef QT_NO_IM
+    // trigger input context creation if it hasn't happened already
+    createInputContext();
+
+    QInputContext *qic = getInputContext();
+    if ( qic ) {
+      // may be causing reset() in some input methods
+      qic->mouseHandler( x, type, button, state );
     }
-#endif // QT_NO_XIM
+#endif // QT_NO_IM
 }
 
+
 void QWidget::setWindowOpacity(double)
 {
diff -r -U2 -N qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp.orig qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp.orig
--- qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/kernel/qwidget_x11.cpp.orig	2008-01-15 12:09:13.000000000 -0700
@@ -0,0 +1,2744 @@
+/****************************************************************************
+**
+** Implementation of QWidget and QWindow classes for X11
+**
+** Created : 931031
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qnamespace.h"
+#include "qpaintdevicemetrics.h"
+#include "qpainter.h"
+#include "qbitmap.h"
+#include "qobjectlist.h"
+#include "qlayout.h"
+#include "qtextcodec.h"
+#include "qdatetime.h"
+#include "qcursor.h"
+#include "qt_x11_p.h"
+#include <stdlib.h>
+
+// NOT REVISED
+
+// defined in qapplication_x11.cpp
+extern Window qt_x11_wm_client_leader;
+extern void qt_x11_create_wm_client_leader();
+
+// defined in qapplication_x11.cpp
+void qt_insert_sip( QWidget*, int, int );
+int  qt_sip_count( QWidget* );
+bool qt_wstate_iconified( WId );
+void qt_updated_rootinfo();
+
+#ifndef QT_NO_XIM
+#include "qinputcontext_p.h"
+
+extern XIM qt_xim;
+extern XIMStyle qt_xim_style;
+#endif
+
+// Paint event clipping magic
+extern void qt_set_paintevent_clipping( QPaintDevice* dev, const QRegion& region);
+extern void qt_clear_paintevent_clipping();
+
+extern bool qt_dnd_enable( QWidget* w, bool on );
+extern bool qt_nograb();
+
+// defined in qapplication_x11.cpp
+extern void qt_deferred_map_add( QWidget* );
+extern void qt_deferred_map_take( QWidget* );
+extern bool qt_deferred_map_contains(QWidget *);
+
+static QWidget *mouseGrb    = 0;
+static QWidget *keyboardGrb = 0;
+
+// defined in qapplication_x11.cpp
+extern Time qt_x_time;
+extern Time qt_x_user_time;
+
+// defined in qfont_x11.cpp
+extern bool qt_has_xft;
+
+int qt_x11_create_desktop_on_screen = -1;
+
+/*****************************************************************************
+  QWidget member functions
+ *****************************************************************************/
+
+// defined in qapplication_x11.cpp
+extern Atom qt_wm_state;
+extern Atom qt_wm_change_state;
+extern Atom qt_wm_delete_window;
+extern Atom qt_wm_take_focus;
+extern Atom qt_wm_client_leader;
+extern Atom qt_window_role;
+extern Atom qt_sm_client_id;
+extern Atom qt_utf8_string;
+extern Atom qt_net_wm_context_help;
+extern Atom qt_net_wm_ping;
+extern Atom qt_xa_motif_wm_hints;
+extern Atom qt_net_wm_name;
+extern Atom qt_net_wm_icon_name;
+extern Atom qt_net_wm_state;
+extern Atom qt_net_wm_state_modal;
+extern Atom qt_net_wm_state_max_v;
+extern Atom qt_net_wm_state_max_h;
+extern Atom qt_net_wm_state_fullscreen;
+extern Atom qt_net_wm_state_above;
+extern Atom qt_net_wm_state_stays_on_top;
+extern Atom qt_net_wm_window_type;
+extern Atom qt_net_wm_window_type_normal;
+extern Atom qt_net_wm_window_type_dialog;
+extern Atom qt_net_wm_window_type_toolbar;
+extern Atom qt_net_wm_window_type_menu;
+extern Atom qt_net_wm_window_type_utility;
+extern Atom qt_net_wm_window_type_splash;
+extern Atom qt_net_wm_window_type_override;
+extern Atom qt_net_wm_pid;
+extern Atom qt_net_wm_user_time;
+extern Atom qt_enlightenment_desktop;
+extern Atom qt_net_virtual_roots;
+extern bool qt_broken_wm;
+
+// defined in qapplication_x11.cpp
+extern bool qt_net_supports(Atom);
+extern unsigned long *qt_net_virtual_root_list;
+
+#if defined (QT_TABLET_SUPPORT)
+extern XDevice *devStylus;
+extern XDevice *devEraser;
+extern XEventClass event_list_stylus[7];
+extern XEventClass event_list_eraser[7];
+extern int qt_curr_events_stylus;
+extern int qt_curr_events_eraser;
+#endif
+
+const uint stdWidgetEventMask =			// X event mask
+	(uint)(
+	    KeyPressMask | KeyReleaseMask |
+	    ButtonPressMask | ButtonReleaseMask |
+	    KeymapStateMask |
+	    ButtonMotionMask |
+	    EnterWindowMask | LeaveWindowMask |
+	    FocusChangeMask |
+	    ExposureMask |
+	    PropertyChangeMask |
+	    StructureNotifyMask
+	);
+
+const uint stdDesktopEventMask =			// X event mask
+       (uint)(
+           KeymapStateMask |
+	   EnterWindowMask | LeaveWindowMask |
+	   PropertyChangeMask
+       );
+
+
+/*
+  The qt_ functions below are implemented in qwidgetcreate_x11.cpp.
+*/
+
+Window qt_XCreateWindow( const QWidget *creator,
+			 Display *display, Window parent,
+			 int x, int y, uint w, uint h,
+			 int borderwidth, int depth,
+			 uint windowclass, Visual *visual,
+			 ulong valuemask, XSetWindowAttributes *attributes );
+Window qt_XCreateSimpleWindow( const QWidget *creator,
+			       Display *display, Window parent,
+			       int x, int y, uint w, uint h, int borderwidth,
+			       ulong border, ulong background );
+void qt_XDestroyWindow( const QWidget *destroyer,
+			Display *display, Window window );
+
+Q_EXPORT void qt_x11_enforce_cursor( QWidget * w )
+{
+    if ( w->testWState( Qt::WState_OwnCursor ) ) {
+	QCursor * oc = QApplication::overrideCursor();
+	if ( oc ) {
+	    XDefineCursor( w->x11Display(), w->winId(), oc->handle() );
+	} else if ( w->isEnabled() ) {
+	    XDefineCursor( w->x11Display(), w->winId(), w->cursor().handle() );
+	} else {
+	    // enforce the windows behavior of clearing the cursor on
+	    // disabled widgets
+	    XDefineCursor( w->x11Display(), w->winId(), None );
+	}
+    } else {
+	XDefineCursor( w->x11Display(), w->winId(), None );
+    }
+}
+
+Q_EXPORT void qt_wait_for_window_manager( QWidget* w )
+{
+    QApplication::flushX();
+    XEvent ev;
+    QTime t;
+    t.start();
+    while ( !XCheckTypedWindowEvent( w->x11Display(), w->winId(), ReparentNotify, &ev ) ) {
+	if ( XCheckTypedWindowEvent( w->x11Display(), w->winId(), MapNotify, &ev ) )
+	    break;
+	if ( t.elapsed() > 500 )
+	    return; // give up, no event available
+	qApp->syncX(); // non-busy wait
+    }
+    qApp->x11ProcessEvent( &ev );
+    if ( XCheckTypedWindowEvent( w->x11Display(), w->winId(), ConfigureNotify, &ev ) )
+	qApp->x11ProcessEvent( &ev );
+}
+
+static void qt_net_change_wm_state(const QWidget* w, bool set, Atom one, Atom two = 0)
+{
+    if (w->isShown()) {
+	// managed by WM
+        XEvent e;
+        e.xclient.type = ClientMessage;
+        e.xclient.message_type = qt_net_wm_state;
+        e.xclient.display = w->x11Display();
+        e.xclient.window = w->winId();
+        e.xclient.format = 32;
+        e.xclient.data.l[ 0 ] = set ? 1 : 0;
+        e.xclient.data.l[ 1 ] = one;
+        e.xclient.data.l[ 2 ] = two;
+        e.xclient.data.l[ 3 ] = 0;
+        e.xclient.data.l[ 4 ] = 0;
+        XSendEvent(w->x11Display(), RootWindow(w->x11Display(), w->x11Screen()),
+		   False, (SubstructureNotifyMask|SubstructureRedirectMask), &e);
+    } else {
+        Atom ret;
+	int format = 0, status;
+	unsigned char *data = 0;
+	unsigned long nitems = 0, after = 0;
+	Atom *old_states = 0;
+	status = XGetWindowProperty(w->x11Display(), w->winId(),
+				    qt_net_wm_state, 0, 1024, False,
+				    XA_ATOM, &ret, &format, &nitems,
+				    &after, &data);
+	if (status == Success && ret == XA_ATOM && format == 32 && nitems > 0)
+	    old_states = (Atom *) data;
+	else
+	    nitems = 0;
+
+	Atom *new_states = new Atom[nitems + 2];
+	int i, j = 0;
+	for (i = 0; i < (int)nitems; ++i) {
+	    if (old_states[i] && old_states[i] != one && old_states[i] != two)
+		new_states[j++] = old_states[i];
+	}
+
+	if (set) {
+	    if (one) new_states[j++] = one;
+	    if (two) new_states[j++] = two;
+	}
+
+	if (j)
+	    XChangeProperty(w->x11Display(), w->winId(), qt_net_wm_state, XA_ATOM, 32,
+			    PropModeReplace, (uchar *) new_states, j);
+	else
+	    XDeleteProperty(w->x11Display(), w->winId(), qt_net_wm_state);
+
+	delete [] new_states;
+	if (data) XFree(data);
+    }
+}
+
+/*!
+    Creates a new widget window if \a window is 0, otherwise sets the
+    widget's window to \a window.
+
+    Initializes the window (sets the geometry etc.) if \a
+    initializeWindow is TRUE. If \a initializeWindow is FALSE, no
+    initialization is performed. This parameter only makes sense if \a
+    window is a valid window.
+
+    Destroys the old window if \a destroyOldWindow is TRUE. If \a
+    destroyOldWindow is FALSE, you are responsible for destroying the
+    window yourself (using platform native code).
+
+    The QWidget constructor calls create(0,TRUE,TRUE) to create a
+    window for this widget.
+*/
+
+void QWidget::create( WId window, bool initializeWindow, bool destroyOldWindow)
+{
+    if ( testWState(WState_Created) && window == 0 )
+	return;
+
+    // set created flag
+    setWState( WState_Created );
+
+    bool popup = testWFlags(WType_Popup);
+    bool dialog = testWFlags(WType_Dialog);
+    bool desktop = testWFlags(WType_Desktop);
+
+    // top-level widget
+    if ( !parentWidget() || parentWidget()->isDesktop() )
+	setWFlags( WType_TopLevel );
+
+    // these are top-level, too
+    if ( dialog || popup || desktop || testWFlags(WStyle_Splash))
+	setWFlags( WType_TopLevel );
+
+    // a popup stays on top
+    if ( popup )
+	setWFlags(WStyle_StaysOnTop);
+
+    bool topLevel = testWFlags(WType_TopLevel);
+    Window parentw, destroyw = 0;
+    WId	   id;
+
+    // always initialize
+    if ( !window )
+	initializeWindow = TRUE;
+
+    if ( desktop &&
+	 qt_x11_create_desktop_on_screen >= 0 &&
+	 qt_x11_create_desktop_on_screen != x11Screen() ) {
+	// desktop on a certain screen other than the default requested
+	QPaintDeviceX11Data* xd = getX11Data( TRUE );
+	xd->x_screen = qt_x11_create_desktop_on_screen;
+	xd->x_depth = QPaintDevice::x11AppDepth( xd->x_screen );
+	xd->x_cells = QPaintDevice::x11AppCells( xd->x_screen );
+	xd->x_colormap = QPaintDevice::x11AppColormap( xd->x_screen );
+	xd->x_defcolormap = QPaintDevice::x11AppDefaultColormap( xd->x_screen );
+	xd->x_visual = QPaintDevice::x11AppVisual( xd->x_screen );
+	xd->x_defvisual = QPaintDevice::x11AppDefaultVisual( xd->x_screen );
+	setX11Data( xd );
+    } else if ( parentWidget() &&  parentWidget()->x11Screen() != x11Screen() ) {
+	// if we have a parent widget, move to its screen if necessary
+	QPaintDeviceX11Data* xd = getX11Data( TRUE );
+	xd->x_screen = parentWidget()->x11Screen();
+	xd->x_depth = QPaintDevice::x11AppDepth( xd->x_screen );
+	xd->x_cells = QPaintDevice::x11AppCells( xd->x_screen );
+	xd->x_colormap = QPaintDevice::x11AppColormap( xd->x_screen );
+	xd->x_defcolormap = QPaintDevice::x11AppDefaultColormap( xd->x_screen );
+	xd->x_visual = QPaintDevice::x11AppVisual( xd->x_screen );
+	xd->x_defvisual = QPaintDevice::x11AppDefaultVisual( xd->x_screen );
+	setX11Data( xd );
+    }
+
+    //get display, screen number, root window and desktop geometry for
+    //the current screen
+    Display *dpy = x11Display();
+    int scr = x11Screen();
+    Window root_win = RootWindow( dpy, scr );
+    int sw = DisplayWidth(dpy,scr);
+    int sh = DisplayHeight(dpy,scr);
+
+    if ( desktop ) {				// desktop widget
+	dialog = popup = FALSE;			// force these flags off
+	crect.setRect( 0, 0, sw, sh );
+    } else if ( topLevel ) {			// calc pos/size from screen
+	crect.setRect( sw/4, 3*sh/10, sw/2, 4*sh/10 );
+    } else {					// child widget
+	crect.setRect( 0, 0, 100, 30 );
+    }
+
+    parentw = topLevel ? root_win : parentWidget()->winId();
+
+    XSetWindowAttributes wsa;
+
+    if ( window ) {				// override the old window
+	if ( destroyOldWindow )
+	    destroyw = winid;
+	id = window;
+	setWinId( window );
+	XWindowAttributes a;
+	XGetWindowAttributes( dpy, window, &a );
+	crect.setRect( a.x, a.y, a.width, a.height );
+
+	if ( a.map_state == IsUnmapped )
+	    clearWState( WState_Visible );
+	else
+	    setWState( WState_Visible );
+
+	QPaintDeviceX11Data* xd = getX11Data( TRUE );
+
+	// find which screen the window is on...
+	xd->x_screen = QPaintDevice::x11AppScreen(); // by default, use the default :)
+	int i;
+	for ( i = 0; i < ScreenCount( dpy ); i++ ) {
+	    if ( RootWindow( dpy, i ) == a.root ) {
+		xd->x_screen = i;
+		break;
+	    }
+	}
+
+	xd->x_depth = a.depth;
+	xd->x_cells = DisplayCells( dpy, xd->x_screen );
+	xd->x_visual = a.visual;
+	xd->x_defvisual = ( XVisualIDFromVisual( a.visual ) ==
+			    XVisualIDFromVisual( (Visual*)x11AppVisual(x11Screen()) ) );
+	xd->x_colormap = a.colormap;
+	xd->x_defcolormap = ( a.colormap == x11AppColormap( x11Screen() ) );
+	setX11Data( xd );
+    } else if ( desktop ) {			// desktop widget
+	id = (WId)parentw;			// id = root window
+	QWidget *otherDesktop = find( id );	// is there another desktop?
+	if ( otherDesktop && otherDesktop->testWFlags(WPaintDesktop) ) {
+	    otherDesktop->setWinId( 0 );	// remove id from widget mapper
+	    setWinId( id );			// make sure otherDesktop is
+	    otherDesktop->setWinId( id );	//   found first
+	} else {
+	    setWinId( id );
+	}
+    } else {
+	if ( x11DefaultVisual() && x11DefaultColormap() ) {
+	    id = (WId)qt_XCreateSimpleWindow( this, dpy, parentw,
+					      crect.left(), crect.top(),
+					      crect.width(), crect.height(),
+					      0,
+					      black.pixel(x11Screen()),
+					      bg_col.pixel(x11Screen()) );
+	} else {
+	    wsa.background_pixel = bg_col.pixel(x11Screen());
+	    wsa.border_pixel = black.pixel(x11Screen());
+	    wsa.colormap = (Colormap)x11Colormap();
+	    id = (WId)qt_XCreateWindow( this, dpy, parentw,
+					crect.left(), crect.top(),
+					crect.width(), crect.height(),
+					0, x11Depth(), InputOutput,
+					(Visual*)x11Visual(),
+					CWBackPixel|CWBorderPixel|CWColormap,
+					&wsa );
+	}
+
+	setWinId( id );				// set widget id/handle + hd
+    }
+
+#ifndef QT_NO_XFTFREETYPE
+    if (rendhd) {
+	XftDrawDestroy( (XftDraw *) rendhd );
+	rendhd = 0;
+    }
+
+    if ( qt_has_xft )
+	rendhd = (HANDLE) XftDrawCreate( dpy, id, (Visual *) x11Visual(),
+					 x11Colormap() );
+#endif // QT_NO_XFTFREETYPE
+
+    // NET window types
+    long net_wintypes[7] = { 0, 0, 0, 0, 0, 0, 0 };
+    int curr_wintype = 0;
+
+    // NET window states
+    long net_winstates[6] = { 0, 0, 0, 0, 0, 0 };
+    int curr_winstate = 0;
+
+    struct {
+        ulong flags, functions, decorations;
+        long input_mode;
+        ulong status;
+    } mwmhints;
+
+    mwmhints.flags = mwmhints.functions = 0L;
+    mwmhints.decorations = (1L << 0); // MWM_DECOR_ALL
+    mwmhints.input_mode = 0L;
+    mwmhints.status = 0L;
+
+    if (topLevel && ! (desktop || popup)) {
+	ulong wsa_mask = 0;
+
+	if ( testWFlags(WStyle_Splash) ) {
+            if (qt_net_supports(qt_net_wm_window_type_splash)) {
+                clearWFlags( WX11BypassWM );
+                net_wintypes[curr_wintype++] = qt_net_wm_window_type_splash;
+	    } else {
+		setWFlags( WX11BypassWM | WStyle_Tool | WStyle_NoBorder );
+	    }
+        }
+	if (testWFlags(WStyle_Customize)) {
+	    mwmhints.decorations = 0L;
+	    mwmhints.flags |= (1L << 1); // MWM_HINTS_DECORATIONS
+
+	    if ( testWFlags( WStyle_NoBorder ) ) {
+		// override netwm type - quick and easy for KDE noborder
+		net_wintypes[curr_wintype++] = qt_net_wm_window_type_override;
+	    } else {
+		if ( testWFlags( WStyle_NormalBorder | WStyle_DialogBorder ) ) {
+		    mwmhints.decorations |= (1L << 1); // MWM_DECOR_BORDER
+		    mwmhints.decorations |= (1L << 2); //  MWM_DECOR_RESIZEH
+		}
+
+		if ( testWFlags( WStyle_Title ) )
+		    mwmhints.decorations |= (1L << 3); // MWM_DECOR_TITLE
+
+		if ( testWFlags( WStyle_SysMenu ) )
+		    mwmhints.decorations |= (1L << 4); // MWM_DECOR_MENU
+
+		if ( testWFlags( WStyle_Minimize ) )
+		    mwmhints.decorations |= (1L << 5); // MWM_DECOR_MINIMIZE
+
+		if ( testWFlags( WStyle_Maximize ) )
+		    mwmhints.decorations |= (1L << 6); // MWM_DECOR_MAXIMIZE
+	    }
+
+	    if (testWFlags(WStyle_Tool)) {
+		wsa.save_under = True;
+		wsa_mask |= CWSaveUnder;
+	    }
+	} else if (testWFlags(WType_Dialog)) {
+	    setWFlags(WStyle_NormalBorder | WStyle_Title |
+		      WStyle_SysMenu | WStyle_ContextHelp);
+	} else {
+	    setWFlags(WStyle_NormalBorder | WStyle_Title |
+		      WStyle_MinMax | WStyle_SysMenu);
+
+	    // maximized netwm state
+	    if (testWFlags(WState_Maximized)) {
+		net_winstates[curr_winstate++] = qt_net_wm_state_max_v;
+		net_winstates[curr_winstate++] = qt_net_wm_state_max_h;
+	    }
+	}
+
+	// ### need a better way to do this
+	if (inherits("QPopupMenu")) {
+	    // menu netwm type
+	    net_wintypes[curr_wintype++] = qt_net_wm_window_type_menu;
+	} else if (inherits("QToolBar")) {
+	    // toolbar netwm type
+	    net_wintypes[curr_wintype++] = qt_net_wm_window_type_toolbar;
+	} else if (testWFlags(WStyle_Customize) && testWFlags(WStyle_Tool)) {
+	    // utility netwm type
+	    net_wintypes[curr_wintype++] = qt_net_wm_window_type_utility;
+	}
+
+	if (dialog) // dialog netwm type
+            net_wintypes[curr_wintype++] = qt_net_wm_window_type_dialog;
+	// normal netwm type - default
+	net_wintypes[curr_wintype++] = qt_net_wm_window_type_normal;
+
+	// stays on top
+	if (testWFlags(WStyle_StaysOnTop)) {
+	    net_winstates[curr_winstate++] = qt_net_wm_state_above;
+	    net_winstates[curr_winstate++] = qt_net_wm_state_stays_on_top;
+	}
+
+        if (testWFlags(WShowModal)) {
+            mwmhints.input_mode = 3L; // MWM_INPUT_FULL_APPLICATION_MODAL
+            mwmhints.flags |= (1L << 2); // MWM_HINTS_INPUT_MODE
+
+            net_winstates[curr_winstate++] = qt_net_wm_state_modal;
+        }
+
+        if ( testWFlags( WX11BypassWM ) ) {
+	    wsa.override_redirect = True;
+	    wsa_mask |= CWOverrideRedirect;
+	}
+
+	if ( wsa_mask && initializeWindow )
+	    XChangeWindowAttributes( dpy, id, wsa_mask, &wsa );
+    } else {
+	if (! testWFlags(WStyle_Customize))
+	    setWFlags(WStyle_NormalBorder | WStyle_Title |
+		      WStyle_MinMax | WStyle_SysMenu);
+    }
+
+
+    if ( !initializeWindow ) {
+	// do no initialization
+    } else if ( popup ) {			// popup widget
+	wsa.override_redirect = True;
+	wsa.save_under = True;
+	XChangeWindowAttributes( dpy, id, CWOverrideRedirect | CWSaveUnder,
+				 &wsa );
+    } else if ( topLevel && !desktop ) {	// top-level widget
+	QWidget *p = parentWidget();	// real parent
+	if (p)
+	    p = p->topLevelWidget();
+
+	if (dialog || testWFlags(WStyle_DialogBorder) || testWFlags(WStyle_Tool)) {
+	    if ( p )
+		XSetTransientForHint( dpy, id, p->winId() );
+	    else				// application-modal
+		XSetTransientForHint( dpy, id, root_win );
+	}
+
+	// find the real client leader, i.e. a toplevel without parent
+	while ( p && p->parentWidget())
+	    p = p->parentWidget()->topLevelWidget();
+
+	XSizeHints size_hints;
+	size_hints.flags = USSize | PSize | PWinGravity;
+	size_hints.x = crect.left();
+	size_hints.y = crect.top();
+	size_hints.width = crect.width();
+	size_hints.height = crect.height();
+	size_hints.win_gravity =
+	    QApplication::reverseLayout() ? NorthEastGravity : NorthWestGravity;
+
+	XWMHints wm_hints;			// window manager hints
+	wm_hints.input = True;
+	wm_hints.initial_state = NormalState;
+	wm_hints.flags = InputHint | StateHint;
+	if ( !qt_x11_wm_client_leader )
+	    qt_x11_create_wm_client_leader();
+
+	wm_hints.window_group = qt_x11_wm_client_leader;
+	wm_hints.flags |= WindowGroupHint;
+
+	XClassHint class_hint;
+	class_hint.res_name = (char *) qAppName(); // application name
+	class_hint.res_class = (char *) qAppClass();	// application class
+
+       	XSetWMProperties( dpy, id, 0, 0, 0, 0, &size_hints, &wm_hints, &class_hint );
+
+	XResizeWindow( dpy, id, crect.width(), crect.height() );
+	XStoreName( dpy, id, qAppName() );
+	Atom protocols[4];
+	int n = 0;
+	protocols[n++] = qt_wm_delete_window;	// support del window protocol
+	protocols[n++] = qt_wm_take_focus;	// support take focus window protocol
+	protocols[n++] = qt_net_wm_ping;	// support _NET_WM_PING protocol
+	if ( testWFlags( WStyle_ContextHelp ) )
+	    protocols[n++] = qt_net_wm_context_help;
+	XSetWMProtocols( dpy, id, protocols, n );
+
+        // set mwm hints
+        if ( mwmhints.flags != 0l )
+            XChangeProperty(dpy, id, qt_xa_motif_wm_hints, qt_xa_motif_wm_hints, 32,
+                            PropModeReplace, (unsigned char *) &mwmhints, 5);
+        else
+            XDeleteProperty(dpy, id, qt_xa_motif_wm_hints);
+
+	// set _NET_WM_WINDOW_TYPE
+	if (curr_wintype > 0)
+	    XChangeProperty(dpy, id, qt_net_wm_window_type, XA_ATOM, 32, PropModeReplace,
+			    (unsigned char *) net_wintypes, curr_wintype);
+        else
+            XDeleteProperty(dpy, id, qt_net_wm_window_type);
+
+	// set _NET_WM_WINDOW_STATE
+	if (curr_winstate > 0)
+	    XChangeProperty(dpy, id, qt_net_wm_state, XA_ATOM, 32, PropModeReplace,
+			    (unsigned char *) net_winstates, curr_winstate);
+        else
+            XDeleteProperty(dpy, id, qt_net_wm_state);
+
+	// set _NET_WM_PID
+	long curr_pid = getpid();
+	XChangeProperty(dpy, id, qt_net_wm_pid, XA_CARDINAL, 32, PropModeReplace,
+			(unsigned char *) &curr_pid, 1);
+
+	// when we create a toplevel widget, the frame strut should be dirty
+	fstrut_dirty = 1;
+
+	// declare the widget's object name as window role
+	XChangeProperty( dpy, id,
+			 qt_window_role, XA_STRING, 8, PropModeReplace,
+			 (unsigned char *)name(), qstrlen( name() ) );
+
+	// set client leader property
+	XChangeProperty( dpy, id, qt_wm_client_leader,
+			 XA_WINDOW, 32, PropModeReplace,
+			 (unsigned char *)&qt_x11_wm_client_leader, 1 );
+    } else {
+	// non-toplevel widgets don't have a frame, so no need to
+	// update the strut
+	fstrut_dirty = 0;
+    }
+
+    if ( initializeWindow ) {
+	// don't erase when resizing
+	wsa.bit_gravity =
+	    QApplication::reverseLayout() ? NorthEastGravity : NorthWestGravity;
+	XChangeWindowAttributes( dpy, id, CWBitGravity, &wsa );
+    }
+
+    setWState( WState_MouseTracking );
+    setMouseTracking( FALSE );			// also sets event mask
+    if ( desktop ) {
+	setWState( WState_Visible );
+    } else if ( topLevel ) {			// set X cursor
+	setWState( WState_OwnCursor );
+	if ( initializeWindow )
+	    qt_x11_enforce_cursor( this );
+    }
+
+    if ( destroyw )
+	qt_XDestroyWindow( this, dpy, destroyw );
+}
+
+
+/*!
+    Frees up window system resources. Destroys the widget window if \a
+    destroyWindow is TRUE.
+
+    destroy() calls itself recursively for all the child widgets,
+    passing \a destroySubWindows for the \a destroyWindow parameter.
+    To have more control over destruction of subwidgets, destroy
+    subwidgets selectively first.
+
+    This function is usually called from the QWidget destructor.
+*/
+
+void QWidget::destroy( bool destroyWindow, bool destroySubWindows )
+{
+    deactivateWidgetCleanup();
+    if ( testWState(WState_Created) ) {
+	clearWState( WState_Created );
+	if ( children() ) {
+	    QObjectListIt it(*children());
+	    register QObject *obj;
+	    while ( (obj=it.current()) ) {	// destroy all widget children
+		++it;
+		if ( obj->isWidgetType() )
+		    ((QWidget*)obj)->destroy(destroySubWindows,
+					     destroySubWindows);
+	    }
+	}
+	if ( mouseGrb == this )
+	    releaseMouse();
+	if ( keyboardGrb == this )
+	    releaseKeyboard();
+	if ( isTopLevel() )
+	    qt_deferred_map_take( this );
+	if ( testWFlags(WShowModal) )		// just be sure we leave modal
+	    qt_leave_modal( this );
+	else if ( testWFlags(WType_Popup) )
+	    qApp->closePopup( this );
+
+#ifndef QT_NO_XFTFREETYPE
+	if ( rendhd) {
+	    if ( destroyWindow )
+		XftDrawDestroy( (XftDraw *) rendhd );
+	    else
+		free( (void*) rendhd );
+	    rendhd = 0;
+	}
+#endif // QT_NO_XFTFREETYPE
+
+	if ( testWFlags(WType_Desktop) ) {
+	    if ( acceptDrops() )
+		qt_dnd_enable( this, FALSE );
+	} else {
+	    if ( destroyWindow )
+		qt_XDestroyWindow( this, x11Display(), winid );
+	}
+	setWinId( 0 );
+
+	extern void qPRCleanup( QWidget *widget ); // from qapplication_x11.cpp
+	if ( testWState(WState_Reparented) )
+	    qPRCleanup(this);
+    }
+}
+
+void QWidget::reparentSys( QWidget *parent, WFlags f, const QPoint &p, bool showIt )
+{
+    extern void qPRCreate( const QWidget *, Window );
+
+    Display *dpy = x11Display();
+    QCursor oldcurs;
+    bool setcurs = testWState(WState_OwnCursor);
+    if ( setcurs ) {
+	oldcurs = cursor();
+	unsetCursor();
+    }
+
+    // dnd unregister (we will register again below)
+    bool accept_drops = acceptDrops();
+    setAcceptDrops( FALSE );
+
+    // clear mouse tracking, re-enabled below
+    bool mouse_tracking = hasMouseTracking();
+    clearWState(WState_MouseTracking);
+
+    QWidget* oldtlw = topLevelWidget();
+    QWidget *oldparent = parentWidget();
+    WId old_winid = winid;
+    if ( testWFlags(WType_Desktop) )
+	old_winid = 0;
+    setWinId( 0 );
+
+    // hide and reparent our own window away. Otherwise we might get
+    // destroyed when emitting the child remove event below. See QWorkspace.
+    XUnmapWindow( x11Display(), old_winid );
+    XReparentWindow( x11Display(), old_winid,
+		     RootWindow( x11Display(), x11Screen() ), 0, 0 );
+
+    if ( isTopLevel() ) {
+        // input contexts are associated with toplevel widgets, so we need
+        // destroy the context here.  if we are reparenting back to toplevel,
+        // then we will have another context created, otherwise we will
+        // use our new toplevel's context
+        destroyInputContext();
+    }
+
+    if ( isTopLevel() || !parent ) // we are toplevel, or reparenting to toplevel
+        topData()->parentWinId = 0;
+
+    if ( parent != parentObj ) {
+	if ( parentObj )				// remove from parent
+	    parentObj->removeChild( this );
+	if ( parent )				// insert into new parent
+	    parent->insertChild( this );
+    }
+    bool     enable = isEnabled();		// remember status
+    FocusPolicy fp = focusPolicy();
+    QSize    s	    = size();
+    QPixmap *bgp    = (QPixmap *)backgroundPixmap();
+    QColor   bgc    = bg_col;			// save colors
+    QString capt= caption();
+    widget_flags = f;
+    clearWState( WState_Created | WState_Visible | WState_ForceHide );
+    create();
+    if ( isTopLevel() || (!parent || parent->isVisible() ) )
+	setWState( WState_ForceHide );	// new widgets do not show up in already visible parents
+
+    const QObjectList *chlist = children();
+    if ( chlist ) {				// reparent children
+        QObjectList childList(*chlist);
+	QObjectListIt it(childList); // iterate over copy
+	QObject *obj;
+	while ( (obj=it.current()) ) {
+	    if ( obj->isWidgetType() ) {
+		QWidget *w = (QWidget *)obj;
+		if ( !w->isTopLevel() ) {
+		    XReparentWindow( x11Display(), w->winId(), winId(),
+				     w->geometry().x(), w->geometry().y() );
+		} else if ( w->isPopup()
+			    || w->testWFlags(WStyle_DialogBorder)
+			    || w->testWFlags(WType_Dialog)
+			    || w->testWFlags(WStyle_Tool) ) {
+		    /*
+		      when reparenting toplevel windows with toplevel-transient children,
+		      we need to make sure that the window manager gets the updated
+		      WM_TRANSIENT_FOR information... unfortunately, some window managers
+		      don't handle changing WM_TRANSIENT_FOR before the toplevel window is
+		      visible, so we unmap and remap all toplevel-transient children *after*
+		      the toplevel parent has been mapped.  thankfully, this is easy in Qt :)
+		    */
+		    XUnmapWindow(w->x11Display(), w->winId());
+		    XSetTransientForHint(w->x11Display(), w->winId(), winId());
+		    QApplication::postEvent(w, new QEvent(QEvent::ShowWindowRequest));
+		}
+	    }
+	    ++it;
+	}
+    }
+    qPRCreate( this, old_winid );
+    if ( bgp )
+	XSetWindowBackgroundPixmap( dpy, winid, bgp->handle() );
+    else
+	XSetWindowBackground( dpy, winid, bgc.pixel(x11Screen()) );
+
+    if (isTopLevel()) {
+        // preserve maximized/fullscreen flags and the normal geometry
+        uint save_state = widget_state & (WState_Maximized | WState_FullScreen);
+        const QRect r = topData()->normalGeometry;
+        setGeometry(p.x(), p.y(), s.width(), s.height());
+        widget_state |= save_state;
+        topData()->normalGeometry = r;
+    } else {
+        setGeometry(p.x(), p.y(), s.width(), s.height());
+    }
+
+    setEnabled( enable );
+    setFocusPolicy( fp );
+    if ( !capt.isNull() ) {
+	extra->topextra->caption = QString::null;
+	setCaption( capt );
+    }
+    if ( showIt )
+	show();
+    if ( old_winid )
+	qt_XDestroyWindow( this, dpy, old_winid );
+    if ( setcurs )
+	setCursor(oldcurs);
+
+    reparentFocusWidgets( oldtlw );
+
+    // re-register dnd
+    if (oldparent)
+	oldparent->checkChildrenDnd();
+
+    if ( accept_drops )
+	setAcceptDrops( TRUE );
+    else {
+	checkChildrenDnd();
+	topData()->dnd = 0;
+	qt_dnd_enable(this, (extra && extra->children_use_dnd));
+    }
+
+    // re-enable mouse tracking
+    if (mouse_tracking)
+	setMouseTracking(mouse_tracking);
+}
+
+
+/*!
+    Translates the widget coordinate \a pos to global screen
+    coordinates. For example, \c{mapToGlobal(QPoint(0,0))} would give
+    the global coordinates of the top-left pixel of the widget.
+
+    \sa mapFromGlobal() mapTo() mapToParent()
+*/
+
+QPoint QWidget::mapToGlobal( const QPoint &pos ) const
+{
+    int	   x, y;
+    Window child;
+    XTranslateCoordinates( x11Display(), winId(),
+			   QApplication::desktop()->screen(x11Screen())->winId(),
+			   pos.x(), pos.y(), &x, &y, &child );
+    return QPoint( x, y );
+}
+
+/*!
+    Translates the global screen coordinate \a pos to widget
+    coordinates.
+
+    \sa mapToGlobal() mapFrom() mapFromParent()
+*/
+
+QPoint QWidget::mapFromGlobal( const QPoint &pos ) const
+{
+    int	   x, y;
+    Window child;
+    XTranslateCoordinates( x11Display(),
+			   QApplication::desktop()->screen(x11Screen())->winId(),
+			   winId(), pos.x(), pos.y(), &x, &y, &child );
+    return QPoint( x, y );
+}
+
+/*!
+    When a widget gets focus, it should call setMicroFocusHint() with
+    some appropriate position and size, \a x, \a y, \a width and \a
+    height. This has no \e visual effect, it just provides hints to
+    any system-specific input handling tools.
+
+    The \a text argument should be TRUE if this is a position for text
+    input.
+
+    In the Windows version of Qt, this method sets the system caret,
+    which is used for user Accessibility focus handling.  If \a text
+    is TRUE, it also sets the IME composition window in Far East Asian
+    language input systems.
+
+    In the X11 version of Qt, if \a text is TRUE, this method sets the
+    XIM "spot" point for complex language input handling.
+
+    The font \a f is a rendering hint to the currently active input method.
+    If \a f is 0 the widget's font is used.
+
+    \sa microFocusHint()
+*/
+void QWidget::setMicroFocusHint(int x, int y, int width, int height,
+				bool text, QFont *f )
+{
+#ifndef QT_NO_XIM
+    if ( text ) {
+	QWidget* tlw = topLevelWidget();
+	QTLWExtra *topdata = tlw->topData();
+
+	// trigger input context creation if it hasn't happened already
+	createInputContext();
+	QInputContext *qic = (QInputContext *) topdata->xic;
+
+	if ( qt_xim && qic ) {
+	    QPoint p( x, y );
+	    QPoint p2 = mapTo( topLevelWidget(), QPoint( 0, 0 ) );
+	    p = mapTo( topLevelWidget(), p);
+	    qic->setXFontSet( f ? *f : fnt );
+	    qic->setComposePosition(p.x(), p.y() + height);
+	    qic->setComposeArea(p2.x(), p2.y(), this->width(), this->height());
+	}
+    }
+#endif
+
+    if ( QRect( x, y, width, height ) != microFocusHint() ) {
+	createExtra();
+	extraData()->micro_focus_hint.setRect( x, y, width, height );
+    }
+}
+
+
+void QWidget::setFontSys( QFont * )
+{
+    // Nothing
+}
+
+
+void QWidget::setBackgroundColorDirect( const QColor &color )
+{
+    bg_col = color;
+    if ( extra && extra->bg_pix ) {		// kill the background pixmap
+	delete extra->bg_pix;
+	extra->bg_pix = 0;
+    }
+    XSetWindowBackground( x11Display(), winId(), bg_col.pixel(x11Screen()) );
+}
+
+static int allow_null_pixmaps = 0;
+
+
+void QWidget::setBackgroundPixmapDirect( const QPixmap &pixmap )
+{
+    QPixmap old;
+    if ( extra && extra->bg_pix )
+	old = *extra->bg_pix;
+    if ( !allow_null_pixmaps && pixmap.isNull() ) {
+	XSetWindowBackground( x11Display(), winId(), bg_col.pixel(x11Screen()) );
+	if ( extra && extra->bg_pix ) {
+	    delete extra->bg_pix;
+	    extra->bg_pix = 0;
+	}
+    } else {
+	QPixmap pm = pixmap;
+	if (!pm.isNull()) {
+	    if ( pm.depth() == 1 && QPixmap::defaultDepth() > 1 ) {
+		pm = QPixmap( pixmap.size() );
+		bitBlt( &pm, 0, 0, &pixmap, 0, 0, pm.width(), pm.height() );
+	    }
+	}
+	if ( extra && extra->bg_pix )
+	    delete extra->bg_pix;
+	else
+	    createExtra();
+	extra->bg_pix = new QPixmap( pm );
+	Q_CHECK_PTR( extra->bg_pix );
+	extra->bg_pix->x11SetScreen( x11Screen() );
+	XSetWindowBackgroundPixmap( x11Display(), winId(), extra->bg_pix->handle() );
+	if ( testWFlags(WType_Desktop) )	// save rootinfo later
+	    qt_updated_rootinfo();
+    }
+}
+
+
+/*!
+    Sets the window-system background of the widget to nothing.
+
+    Note that "nothing" is actually a pixmap that isNull(), thus you
+    can check for an empty background by checking backgroundPixmap().
+
+    \sa setBackgroundPixmap(), setBackgroundColor()
+*/
+void QWidget::setBackgroundEmpty()
+{
+    allow_null_pixmaps++;
+    setErasePixmap(QPixmap());
+    allow_null_pixmaps--;
+}
+
+
+void QWidget::setBackgroundX11Relative()
+{
+    XSetWindowBackgroundPixmap( x11Display(), winId(), ParentRelative );
+}
+
+void QWidget::setCursor( const QCursor &cursor )
+{
+    if ( cursor.handle() != arrowCursor.handle()
+	 || (extra && extra->curs) ) {
+	createExtra();
+	delete extra->curs;
+	extra->curs = new QCursor(cursor);
+    }
+    setWState( WState_OwnCursor );
+    qt_x11_enforce_cursor( this );
+    XFlush( x11Display() );
+}
+
+void QWidget::unsetCursor()
+{
+    if ( extra ) {
+	delete extra->curs;
+	extra->curs = 0;
+    }
+    if ( !isTopLevel() )
+	clearWState( WState_OwnCursor );
+    qt_x11_enforce_cursor( this );
+    XFlush( x11Display() );
+}
+
+static XTextProperty*
+qstring_to_xtp( const QString& s )
+{
+    static XTextProperty tp = { 0, 0, 0, 0 };
+    static bool free_prop = TRUE; // we can't free tp.value in case it references
+    // the data of the static QCString below.
+    if ( tp.value ) {
+	if ( free_prop )
+	    XFree( tp.value );
+	tp.value = 0;
+	free_prop = TRUE;
+    }
+
+    static const QTextCodec* mapper = QTextCodec::codecForLocale();
+    int errCode = 0;
+    if ( mapper ) {
+	QCString mapped = mapper->fromUnicode(s);
+	char* tl[2];
+	tl[0] = mapped.data();
+	tl[1] = 0;
+	errCode = XmbTextListToTextProperty( QPaintDevice::x11AppDisplay(),
+					     tl, 1, XStdICCTextStyle, &tp );
+#if defined(QT_DEBUG)
+	if ( errCode < 0 )
+	    qDebug( "qstring_to_xtp result code %d", errCode );
+#endif
+    }
+    if ( !mapper || errCode < 0 ) {
+	static QCString qcs;
+	qcs = s.ascii();
+	tp.value = (uchar*)qcs.data();
+	tp.encoding = XA_STRING;
+	tp.format = 8;
+	tp.nitems = qcs.length();
+	free_prop = FALSE;
+    }
+
+    // ### If we knew WM could understand unicode, we could use
+    // ### a much simpler, cheaper encoding...
+    /*
+	tp.value = (XChar2b*)s.unicode();
+	tp.encoding = XA_UNICODE; // wish
+	tp.format = 16;
+	tp.nitems = s.length();
+    */
+
+    return &tp;
+}
+
+void QWidget::setCaption( const QString &caption )
+{
+    if ( QWidget::caption() == caption )
+	return;
+
+    topData()->caption = caption;
+    XSetWMName( x11Display(), winId(), qstring_to_xtp(caption) );
+
+    QCString net_wm_name = caption.utf8();
+    XChangeProperty(x11Display(), winId(), qt_net_wm_name, qt_utf8_string, 8,
+		    PropModeReplace, (unsigned char *)net_wm_name.data(),
+		    net_wm_name.length());
+
+    QEvent e( QEvent::CaptionChange );
+    QApplication::sendEvent( this, &e );
+}
+
+void QWidget::setIcon( const QPixmap &pixmap )
+{
+    if ( extra && extra->topextra ) {
+	delete extra->topextra->icon;
+	extra->topextra->icon = 0;
+    } else {
+	createTLExtra();
+    }
+    Pixmap icon_pixmap = 0;
+    Pixmap mask_pixmap = 0;
+    if ( !pixmap.isNull() ) {
+	QPixmap* pm = new QPixmap( pixmap );
+	extra->topextra->icon = pm;
+	if ( !pm->mask() )
+	    pm->setMask( pm->createHeuristicMask() ); // may do detach()
+	icon_pixmap = pm->handle();
+	if ( pm->mask() )
+	    mask_pixmap = pm->mask()->handle();
+    }
+    XWMHints *h = XGetWMHints( x11Display(), winId() );
+    XWMHints  wm_hints;
+    bool got_hints = h != 0;
+    if ( !got_hints ) {
+	h = &wm_hints;
+	h->flags = 0;
+    }
+    h->icon_pixmap = icon_pixmap;
+    h->icon_mask = mask_pixmap;
+    h->flags |= IconPixmapHint | IconMaskHint;
+    XSetWMHints( x11Display(), winId(), h );
+    if ( got_hints )
+	XFree( (char *)h );
+    QEvent e( QEvent::IconChange );
+    QApplication::sendEvent( this, &e );
+}
+
+void QWidget::setIconText( const QString &iconText )
+{
+    if (QWidget::iconText() == iconText)
+        return;
+
+    topData()->iconText = iconText;
+    XSetWMIconName( x11Display(), winId(), qstring_to_xtp(iconText) );
+
+    QCString net_wm_icon_name = iconText.utf8();
+    XChangeProperty(x11Display(), winId(), qt_net_wm_icon_name, qt_utf8_string, 8, PropModeReplace,
+		    (unsigned char *) net_wm_icon_name.data(), net_wm_icon_name.length());
+}
+
+void QWidget::setMouseTracking( bool enable )
+{
+    bool gmt = QApplication::hasGlobalMouseTracking();
+    if ( !enable == !testWState(WState_MouseTracking) && !gmt )
+	return;
+    uint m = (enable || gmt) ? (uint)PointerMotionMask : 0;
+    if ( enable )
+	setWState( WState_MouseTracking );
+    else
+	clearWState( WState_MouseTracking );
+    if ( testWFlags(WType_Desktop) ) {		// desktop widget?
+	QWidget* main_desktop = find( winId() );
+	if ( main_desktop->testWFlags(WPaintDesktop) )
+	    XSelectInput( x11Display(), winId(),
+			  stdDesktopEventMask | ExposureMask );
+	else
+	    XSelectInput( x11Display(), winId(), stdDesktopEventMask );
+    } else {
+	XSelectInput( x11Display(), winId(),
+		      m | stdWidgetEventMask );
+#if defined (QT_TABLET_SUPPORT)
+ 	if ( devStylus != NULL ) {
+ 	    XSelectExtensionEvent( x11Display(), winId(), event_list_stylus,
+ 				   qt_curr_events_stylus );
+ 	}
+	if ( devEraser != NULL ) {
+	    XSelectExtensionEvent( x11Display(), winId(), event_list_eraser,
+				   qt_curr_events_eraser );
+	}
+#endif
+    }
+}
+
+
+/*!
+    Grabs the mouse input.
+
+    This widget receives all mouse events until releaseMouse() is
+    called; other widgets get no mouse events at all. Keyboard
+    events are not affected. Use grabKeyboard() if you want to grab
+    that.
+
+    \warning Bugs in mouse-grabbing applications very often lock the
+    terminal. Use this function with extreme caution, and consider
+    using the \c -nograb command line option while debugging.
+
+    It is almost never necessary to grab the mouse when using Qt, as
+    Qt grabs and releases it sensibly. In particular, Qt grabs the
+    mouse when a mouse button is pressed and keeps it until the last
+    button is released.
+
+    Note that only visible widgets can grab mouse input. If
+    isVisible() returns FALSE for a widget, that widget cannot call
+    grabMouse().
+
+    \sa releaseMouse() grabKeyboard() releaseKeyboard() grabKeyboard()
+    focusWidget()
+*/
+
+void QWidget::grabMouse()
+{
+    if ( isVisible() && !qt_nograb() ) {
+	if ( mouseGrb )
+	    mouseGrb->releaseMouse();
+#if defined(QT_CHECK_STATE)
+	int status =
+#endif
+	    XGrabPointer( x11Display(), winId(), False,
+			  (uint)( ButtonPressMask | ButtonReleaseMask |
+				  PointerMotionMask | EnterWindowMask |
+				  LeaveWindowMask ),
+			  GrabModeAsync, GrabModeAsync,
+			  None, None, qt_x_time );
+#if defined(QT_CHECK_STATE)
+	if ( status ) {
+	    const char *s =
+		status == GrabNotViewable ? "\"GrabNotViewable\"" :
+		status == AlreadyGrabbed  ? "\"AlreadyGrabbed\"" :
+		status == GrabFrozen      ? "\"GrabFrozen\"" :
+		status == GrabInvalidTime ? "\"GrabInvalidTime\"" :
+		"<?>";
+	    qWarning( "Grabbing the mouse failed with %s", s );
+	}
+#endif
+	mouseGrb = this;
+    }
+}
+
+/*!
+    \overload
+
+    Grabs the mouse input and changes the cursor shape.
+
+    The cursor will assume shape \a cursor (for as long as the mouse
+    focus is grabbed) and this widget will be the only one to receive
+    mouse events until releaseMouse() is called().
+
+    \warning Grabbing the mouse might lock the terminal.
+
+    \sa releaseMouse(), grabKeyboard(), releaseKeyboard(), setCursor()
+*/
+
+void QWidget::grabMouse( const QCursor &cursor )
+{
+    if ( !qt_nograb() ) {
+	if ( mouseGrb )
+	    mouseGrb->releaseMouse();
+#if defined(QT_CHECK_STATE)
+	int status =
+#endif
+	XGrabPointer( x11Display(), winId(), False,
+		      (uint)(ButtonPressMask | ButtonReleaseMask |
+			     PointerMotionMask | EnterWindowMask | LeaveWindowMask),
+		      GrabModeAsync, GrabModeAsync,
+		      None, cursor.handle(), qt_x_time );
+#if defined(QT_CHECK_STATE)
+	if ( status ) {
+	    const char *s =
+		status == GrabNotViewable ? "\"GrabNotViewable\"" :
+		status == AlreadyGrabbed  ? "\"AlreadyGrabbed\"" :
+		status == GrabFrozen      ? "\"GrabFrozen\"" :
+		status == GrabInvalidTime ? "\"GrabInvalidTime\"" :
+					    "<?>";
+	    qWarning( "Grabbing the mouse failed with %s", s );
+	}
+#endif
+	mouseGrb = this;
+    }
+}
+
+/*!
+    Releases the mouse grab.
+
+    \sa grabMouse(), grabKeyboard(), releaseKeyboard()
+*/
+
+void QWidget::releaseMouse()
+{
+    if ( !qt_nograb() && mouseGrb == this ) {
+	XUngrabPointer( x11Display(),  qt_x_time );
+	XFlush( x11Display() );
+	mouseGrb = 0;
+    }
+}
+
+/*!
+    Grabs the keyboard input.
+
+    This widget reveives all keyboard events until releaseKeyboard()
+    is called; other widgets get no keyboard events at all. Mouse
+    events are not affected. Use grabMouse() if you want to grab that.
+
+    The focus widget is not affected, except that it doesn't receive
+    any keyboard events. setFocus() moves the focus as usual, but the
+    new focus widget receives keyboard events only after
+    releaseKeyboard() is called.
+
+    If a different widget is currently grabbing keyboard input, that
+    widget's grab is released first.
+
+    \sa releaseKeyboard() grabMouse() releaseMouse() focusWidget()
+*/
+
+void QWidget::grabKeyboard()
+{
+    if ( !qt_nograb() ) {
+	if ( keyboardGrb )
+	    keyboardGrb->releaseKeyboard();
+	XGrabKeyboard( x11Display(), winid, False, GrabModeAsync, GrabModeAsync,
+		       qt_x_time );
+	keyboardGrb = this;
+    }
+}
+
+/*!
+    Releases the keyboard grab.
+
+    \sa grabKeyboard(), grabMouse(), releaseMouse()
+*/
+
+void QWidget::releaseKeyboard()
+{
+    if ( !qt_nograb() && keyboardGrb == this ) {
+	XUngrabKeyboard( x11Display(), qt_x_time );
+	keyboardGrb = 0;
+    }
+}
+
+
+/*!
+    Returns the widget that is currently grabbing the mouse input.
+
+    If no widget in this application is currently grabbing the mouse,
+    0 is returned.
+
+    \sa grabMouse(), keyboardGrabber()
+*/
+
+QWidget *QWidget::mouseGrabber()
+{
+    return mouseGrb;
+}
+
+/*!
+    Returns the widget that is currently grabbing the keyboard input.
+
+    If no widget in this application is currently grabbing the
+    keyboard, 0 is returned.
+
+    \sa grabMouse(), mouseGrabber()
+*/
+
+QWidget *QWidget::keyboardGrabber()
+{
+    return keyboardGrb;
+}
+
+/*!
+    Sets the top-level widget containing this widget to be the active
+    window.
+
+    An active window is a visible top-level window that has the
+    keyboard input focus.
+
+    This function performs the same operation as clicking the mouse on
+    the title bar of a top-level window. On X11, the result depends on
+    the Window Manager. If you want to ensure that the window is
+    stacked on top as well you should also call raise(). Note that the
+    window must be visible, otherwise setActiveWindow() has no effect.
+
+    On Windows, if you are calling this when the application is not
+    currently the active one then it will not make it the active
+    window.  It will flash the task bar entry blue to indicate that
+    the window has done something. This is because Microsoft do not
+    allow an application to interrupt what the user is currently doing
+    in another application.
+
+    \sa isActiveWindow(), topLevelWidget(), show()
+*/
+
+void QWidget::setActiveWindow()
+{
+    QWidget *tlw = topLevelWidget();
+    if ( tlw->isVisible() && !tlw->topData()->embedded && !qt_deferred_map_contains(tlw) ) {
+	XSetInputFocus( x11Display(), tlw->winId(), RevertToNone, qt_x_time);
+        focusInputContext();
+    }
+}
+
+
+/*!
+    Updates the widget unless updates are disabled or the widget is
+    hidden.
+
+    This function does not cause an immediate repaint; instead it
+    schedules a paint event for processing when Qt returns to the main
+    event loop. This permits Qt to optimize for more speed and less
+    flicker than a call to repaint() does.
+
+    Calling update() several times normally results in just one
+    paintEvent() call.
+
+    Qt normally erases the widget's area before the paintEvent() call.
+    If the \c WRepaintNoErase widget flag is set, the widget is
+    responsible for painting all its pixels itself.
+
+    \sa repaint(), paintEvent(), setUpdatesEnabled(), erase(),
+    setWFlags()
+*/
+
+void QWidget::update()
+{
+    if ( (widget_state & (WState_Visible|WState_BlockUpdates)) ==
+	 WState_Visible )
+	QApplication::postEvent( this, new QPaintEvent( clipRegion(), !testWFlags(WRepaintNoErase) ) );
+}
+
+/*!
+    \overload
+
+    Updates a rectangle (\a x, \a y, \a w, \a h) inside the widget
+    unless updates are disabled or the widget is hidden.
+
+    This function does not cause an immediate repaint; instead it
+    schedules a paint event for processing when Qt returns to the main
+    event loop. This permits Qt to optimize for more speed and less
+    flicker and a call to repaint() does.
+
+    Calling update() several times normally results in just one
+    paintEvent() call.
+
+    If \a w is negative, it is replaced with \c{width() - x}. If \a h
+    is negative, it is replaced width \c{height() - y}.
+
+    Qt normally erases the specified area before the paintEvent()
+    call. If the \c WRepaintNoErase widget flag is set, the widget is
+    responsible for painting all its pixels itself.
+
+    \sa repaint(), paintEvent(), setUpdatesEnabled(), erase()
+*/
+
+void QWidget::update( int x, int y, int w, int h )
+{
+    if ( w && h &&
+	 (widget_state & (WState_Visible|WState_BlockUpdates)) == WState_Visible ) {
+	if ( w < 0 )
+	    w = crect.width()  - x;
+	if ( h < 0 )
+	    h = crect.height() - y;
+	if ( w != 0 && h != 0 )
+	    QApplication::postEvent( this,
+		new QPaintEvent( clipRegion().intersect(QRect(x,y,w,h)),
+				 !testWFlags( WRepaintNoErase ) ) );
+    }
+}
+
+/*!
+    \overload void QWidget::update( const QRect &r )
+
+    Updates a rectangle \a r inside the widget unless updates are
+    disabled or the widget is hidden.
+
+    This function does not cause an immediate repaint; instead it
+    schedules a paint event for processing when Qt returns to the main
+    event loop. This permits Qt to optimize for more speed and less
+    flicker and a call to repaint() does.
+
+    Calling update() several times normally results in just one
+    paintEvent() call.
+*/
+
+/*!
+    \overload void QWidget::repaint( bool erase )
+
+    This version repaints the entire widget.
+*/
+
+/*!
+    \overload void QWidget::repaint()
+
+    This version erases and repaints the entire widget.
+*/
+
+/*!
+    Repaints the widget directly by calling paintEvent() immediately,
+    unless updates are disabled or the widget is hidden.
+
+    If \a erase is TRUE, Qt erases the area \a (x, y, w, h) before the
+    paintEvent() call.
+
+    If \a w is negative, it is replaced with \c{width() - x}, and if
+    \a h is negative, it is replaced width \c{height() - y}.
+
+    We suggest only using repaint() if you need an immediate repaint,
+    for example during animation. In almost all circumstances update()
+    is better, as it permits Qt to optimize for speed and minimize
+    flicker.
+
+    \warning If you call repaint() in a function which may itself be
+    called from paintEvent(), you may get infinite recursion. The
+    update() function never causes recursion.
+
+    \sa update(), paintEvent(), setUpdatesEnabled(), erase()
+*/
+
+void QWidget::repaint( int x, int y, int w, int h, bool erase )
+{
+    if ( (widget_state & (WState_Visible|WState_BlockUpdates)) == WState_Visible ) {
+	if ( x > crect.width() || y > crect.height() )
+	    return;
+	if ( w < 0 )
+	    w = crect.width()  - x;
+	if ( h < 0 )
+	    h = crect.height() - y;
+	QRect r(x,y,w,h);
+	if ( r.isEmpty() )
+	    return; // nothing to do
+	QPaintEvent e( r, erase );
+	if ( r != rect() )
+	    qt_set_paintevent_clipping( this, r );
+	if ( erase && w != 0 && h != 0 ) {
+	    if ( backgroundOrigin() == WidgetOrigin )
+		XClearArea( x11Display(), winId(), x, y, w, h, False );
+	    else
+		this->erase( x, y, w, h);
+	}
+	QApplication::sendEvent( this, &e );
+	qt_clear_paintevent_clipping();
+    }
+}
+
+/*!
+    \overload
+
+    Repaints the widget directly by calling paintEvent() directly,
+    unless updates are disabled or the widget is hidden.
+
+    Erases the widget region \a reg if \a erase is TRUE.
+
+    Only use repaint if your widget needs to be repainted immediately,
+    for example when doing some animation. In all other cases, use
+    update(). Calling update() many times in a row will generate a
+    single paint event.
+
+    \warning If you call repaint() in a function which may itself be
+    called from paintEvent(), you may get infinite recursion. The
+    update() function never causes recursion.
+
+    \sa update(), paintEvent(), setUpdatesEnabled(), erase()
+*/
+
+void QWidget::repaint( const QRegion& reg, bool erase )
+{
+    if ( (widget_state & (WState_Visible|WState_BlockUpdates)) == WState_Visible ) {
+	QPaintEvent e( reg, erase );
+	qt_set_paintevent_clipping( this, reg );
+	if ( erase )
+	    this->erase(reg);
+	QApplication::sendEvent( this, &e );
+	qt_clear_paintevent_clipping();
+    }
+}
+
+/*!
+    \overload void QWidget::repaint( const QRect &r, bool erase )
+
+    Repaints the widget directly by calling paintEvent() directly,
+    unless updates are disabled or the widget is hidden.
+
+    Erases the widget region \a r if \a erase is TRUE.
+*/
+
+void QWidget::setWindowState(uint newstate)
+{
+    bool needShow = FALSE;
+    uint oldstate = windowState();
+    if (isTopLevel()) {
+        QTLWExtra *top = topData();
+
+	if ((oldstate & WindowMaximized) != (newstate & WindowMaximized)) {
+	    if (qt_net_supports(qt_net_wm_state_max_h) && qt_net_supports(qt_net_wm_state_max_v)) {
+		qt_net_change_wm_state(this, (newstate & WindowMaximized),
+				       qt_net_wm_state_max_h, qt_net_wm_state_max_v);
+	    } else if (! (newstate & WindowFullScreen)) {
+		if (newstate & WindowMaximized) {
+		    // save original geometry
+                    const QRect normalGeometry = geometry();
+
+		    if (isVisible()) {
+			updateFrameStrut();
+			const QRect maxRect = QApplication::desktop()->availableGeometry(this);
+			const QRect r = top->normalGeometry;
+			setGeometry(maxRect.x() + top->fleft,
+				    maxRect.y() + top->ftop,
+				    maxRect.width() - top->fleft - top->fright,
+				    maxRect.height() - top->ftop - top->fbottom);
+                        top->normalGeometry = r;
+		    }
+
+                    if (top->normalGeometry.width() < 0)
+			top->normalGeometry = normalGeometry;
+		} else {
+		    // restore original geometry
+		    setGeometry(top->normalGeometry);
+		}
+	    }
+	}
+
+	if ((oldstate & WindowFullScreen) != (newstate & WindowFullScreen)) {
+	    if (qt_net_supports(qt_net_wm_state_fullscreen)) {
+		qt_net_change_wm_state(this, (newstate & WindowFullScreen),
+				       qt_net_wm_state_fullscreen);
+	    } else {
+                needShow = isVisible();
+
+		if (newstate & WindowFullScreen) {
+                    const QRect normalGeometry = QRect(pos(), size());
+
+		    top->savedFlags = getWFlags();
+                    reparent(0, WType_TopLevel | WStyle_Customize | WStyle_NoBorder |
+			     // preserve some widget flags
+			     (getWFlags() & 0xffff0000),
+			     mapToGlobal(QPoint(0, 0)));
+                    const QRect r = top->normalGeometry;
+                    setGeometry(qApp->desktop()->screenGeometry(this));
+                    top->normalGeometry = r;
+
+                    if ( top->normalGeometry.width() < 0 )
+			top->normalGeometry = normalGeometry;
+                } else {
+		    reparent( 0, top->savedFlags, mapToGlobal(QPoint(0, 0)) );
+
+                    if (newstate & WindowMaximized) {
+                        // from fullscreen to maximized
+			updateFrameStrut();
+			const QRect maxRect = QApplication::desktop()->availableGeometry(this);
+			const QRect r = top->normalGeometry;
+			setGeometry(maxRect.x() + top->fleft,
+				    maxRect.y() + top->ftop,
+				    maxRect.width() - top->fleft - top->fright,
+				    maxRect.height() - top->ftop - top->fbottom);
+                        top->normalGeometry = r;
+                    } else {
+                        // restore original geometry
+                        setGeometry(top->normalGeometry);
+                    }
+		}
+	    }
+	}
+
+	if ((oldstate & WindowMinimized) != (newstate & WindowMinimized)) {
+	    if (isVisible()) {
+		if (newstate & WindowMinimized) {
+		    XEvent e;
+		    e.xclient.type = ClientMessage;
+		    e.xclient.message_type = qt_wm_change_state;
+		    e.xclient.display = x11Display();
+		    e.xclient.window = winid;
+		    e.xclient.format = 32;
+		    e.xclient.data.l[0] = IconicState;
+		    e.xclient.data.l[1] = 0;
+		    e.xclient.data.l[2] = 0;
+		    e.xclient.data.l[3] = 0;
+		    e.xclient.data.l[4] = 0;
+		    XSendEvent(x11Display(), RootWindow(x11Display(), x11Screen()),
+			       False, (SubstructureNotifyMask|SubstructureRedirectMask), &e);
+		} else {
+		    XMapWindow(x11Display(), winId());
+		}
+	    }
+
+	    needShow = FALSE;
+	}
+    }
+
+    widget_state &= ~(WState_Minimized | WState_Maximized | WState_FullScreen);
+    if (newstate & WindowMinimized)
+	widget_state |= WState_Minimized;
+    if (newstate & WindowMaximized)
+	widget_state |= WState_Maximized;
+    if (newstate & WindowFullScreen)
+	widget_state |= WState_FullScreen;
+
+    if (needShow)
+	show();
+
+    if (newstate & WindowActive)
+	setActiveWindow();
+
+    QEvent e(QEvent::WindowStateChange);
+    QApplication::sendEvent(this, &e);
+}
+
+/*!
+  \internal
+  Platform-specific part of QWidget::show().
+*/
+
+void QWidget::showWindow()
+{
+    if ( isTopLevel()  ) {
+	XWMHints *h = XGetWMHints( x11Display(), winId() );
+	XWMHints  wm_hints;
+	bool got_hints = h != 0;
+	if ( !got_hints ) {
+	    h = &wm_hints;
+	    h->flags = 0;
+	}
+	h->initial_state = testWState(WState_Minimized) ? IconicState : NormalState;
+	h->flags |= StateHint;
+	XSetWMHints( x11Display(), winId(), h );
+	if ( got_hints )
+	    XFree( (char *)h );
+
+	if (qt_x_user_time != CurrentTime) {
+	    XChangeProperty(x11Display(), winId(), qt_net_wm_user_time, XA_CARDINAL,
+			    32, PropModeReplace, (unsigned char *) &qt_x_user_time, 1);
+	}
+
+	if (!topData()->embedded &&
+	    topData()->parentWinId &&
+	    topData()->parentWinId != QPaintDevice::x11AppRootWindow(x11Screen()) &&
+	    !isMinimized() ) {
+	    qt_deferred_map_add( this );
+	    return;
+	}
+
+ 	if (isMaximized() && !isFullScreen()
+	    && !(qt_net_supports(qt_net_wm_state_max_h)
+		 && qt_net_supports(qt_net_wm_state_max_v))) {
+ 	    XMapWindow( x11Display(), winId() );
+ 	    qt_wait_for_window_manager(this);
+
+ 	    // if the wm was not smart enough to adjust our size, do that manually
+ 	    updateFrameStrut();
+	    QRect maxRect = QApplication::desktop()->availableGeometry(this);
+
+ 	    QTLWExtra *top = topData();
+ 	    QRect normalRect = top->normalGeometry;
+
+ 	    setGeometry(maxRect.x() + top->fleft,
+			maxRect.y() + top->ftop,
+ 			maxRect.width() - top->fleft - top->fright,
+ 			maxRect.height() - top->ftop - top->fbottom);
+
+	    // restore the original normalGeometry
+ 	    top->normalGeometry = normalRect;
+ 	    // internalSetGeometry() clears the maximized flag... make sure we set it back
+ 	    setWState(WState_Maximized);
+
+ 	    return;
+ 	}
+
+	if (isFullScreen() && !qt_net_supports(qt_net_wm_state_fullscreen)) {
+ 	    XMapWindow(x11Display(), winId());
+ 	    qt_wait_for_window_manager(this);
+	    return;
+	}
+    }
+    XMapWindow( x11Display(), winId() );
+}
+
+
+/*!
+  \internal
+  Platform-specific part of QWidget::hide().
+*/
+
+void QWidget::hideWindow()
+{
+    clearWState( WState_Exposed );
+    deactivateWidgetCleanup();
+    if ( isTopLevel() ) {
+	qt_deferred_map_take( this );
+	if ( winId() ) // in nsplugin, may be 0
+	    XWithdrawWindow( x11Display(), winId(), x11Screen() );
+
+	QTLWExtra *top = topData();
+	crect.moveTopLeft( QPoint(crect.x() - top->fleft, crect.y() - top->ftop ) );
+
+	// zero the frame strut and mark it dirty
+	top->fleft = top->fright = top->ftop = top->fbottom = 0;
+	fstrut_dirty = TRUE;
+
+	XFlush( x11Display() );
+    } else {
+	if ( winId() ) // in nsplugin, may be 0
+	    XUnmapWindow( x11Display(), winId() );
+    }
+}
+
+/*!
+    Raises this widget to the top of the parent widget's stack.
+
+    After this call the widget will be visually in front of any
+    overlapping sibling widgets.
+
+    \sa lower(), stackUnder()
+*/
+
+void QWidget::raise()
+{
+    QWidget *p = parentWidget();
+    if ( p && p->childObjects && p->childObjects->findRef(this) >= 0 )
+	p->childObjects->append( p->childObjects->take() );
+    XRaiseWindow( x11Display(), winId() );
+}
+
+/*!
+    Lowers the widget to the bottom of the parent widget's stack.
+
+    After this call the widget will be visually behind (and therefore
+    obscured by) any overlapping sibling widgets.
+
+    \sa raise(), stackUnder()
+*/
+
+void QWidget::lower()
+{
+    QWidget *p = parentWidget();
+    if ( p && p->childObjects && p->childObjects->findRef(this) >= 0 )
+	p->childObjects->insert( 0, p->childObjects->take() );
+    XLowerWindow( x11Display(), winId() );
+}
+
+
+/*!
+    Places the widget under \a w in the parent widget's stack.
+
+    To make this work, the widget itself and \a w must be siblings.
+
+    \sa raise(), lower()
+*/
+void QWidget::stackUnder( QWidget* w)
+{
+    QWidget *p = parentWidget();
+    if ( !w || isTopLevel() || p != w->parentWidget() || this == w )
+	return;
+    if ( p && p->childObjects && p->childObjects->findRef(w) >= 0 && p->childObjects->findRef(this) >= 0 ) {
+	p->childObjects->take();
+	p->childObjects->insert( p->childObjects->findRef(w), this );
+    }
+    Window stack[2];
+    stack[0] = w->winId();;
+    stack[1] = winId();
+    XRestackWindows( x11Display(), stack, 2 );
+}
+
+
+
+/*
+  The global variable qt_widget_tlw_gravity defines the window gravity of
+  the next top level window to be created. We do this when setting the
+  main widget's geometry and the "-geometry" command line option contains
+  a negative position.
+*/
+
+int qt_widget_tlw_gravity = NorthWestGravity;
+
+static void do_size_hints( QWidget* widget, QWExtra *x )
+{
+    XSizeHints s;
+    s.flags = 0;
+    if ( x ) {
+	s.x = widget->x();
+	s.y = widget->y();
+	s.width = widget->width();
+	s.height = widget->height();
+	if ( x->minw > 0 || x->minh > 0 ) {	// add minimum size hints
+	    s.flags |= PMinSize;
+	    s.min_width  = x->minw;
+	    s.min_height = x->minh;
+	}
+	if ( x->maxw < QWIDGETSIZE_MAX || x->maxh < QWIDGETSIZE_MAX ) {
+	    s.flags |= PMaxSize;		// add maximum size hints
+	    s.max_width  = x->maxw;
+	    s.max_height = x->maxh;
+	}
+	if ( x->topextra &&
+	   (x->topextra->incw > 0 || x->topextra->inch > 0) )
+	{					// add resize increment hints
+	    s.flags |= PResizeInc | PBaseSize;
+	    s.width_inc = x->topextra->incw;
+	    s.height_inc = x->topextra->inch;
+	    s.base_width = x->topextra->basew;
+	    s.base_height = x->topextra->baseh;
+	}
+
+	if ( x->topextra && x->topextra->uspos) {
+	    s.flags |= USPosition;
+	    s.flags |= PPosition;
+	}
+	if ( x->topextra && x->topextra->ussize) {
+	    s.flags |= USSize;
+	    s.flags |= PSize;
+	}
+    }
+    s.flags |= PWinGravity;
+    s.win_gravity = qt_widget_tlw_gravity;	// usually NorthWest
+    // reset in case it was set
+    qt_widget_tlw_gravity =
+        QApplication::reverseLayout() ? NorthEastGravity : NorthWestGravity;
+    XSetWMNormalHints( widget->x11Display(), widget->winId(), &s );
+}
+
+
+void QWidget::internalSetGeometry( int x, int y, int w, int h, bool isMove )
+{
+    Display *dpy = x11Display();
+
+    if ( testWFlags(WType_Desktop) )
+	return;
+    if (isTopLevel()) {
+        if (!qt_net_supports(qt_net_wm_state_max_h)
+            && !qt_net_supports(qt_net_wm_state_max_v))
+            clearWState(WState_Maximized);
+        if (!qt_net_supports(qt_net_wm_state_fullscreen))
+            clearWState(WState_FullScreen);
+	topData()->normalGeometry = QRect(0, 0, -1, -1);
+    } else {
+        // for QWorkspace
+        clearWState(WState_Maximized);
+        clearWState(WState_FullScreen);
+    }
+    if ( extra ) {				// any size restrictions?
+	w = QMIN(w,extra->maxw);
+	h = QMIN(h,extra->maxh);
+	w = QMAX(w,extra->minw);
+	h = QMAX(h,extra->minh);
+    }
+    if ( w < 1 )				// invalid size
+	w = 1;
+    if ( h < 1 )
+	h = 1;
+    QPoint oldPos( pos() );
+    QSize oldSize( size() );
+    QRect oldGeom( crect );
+    QRect  r( x, y, w, h );
+
+    // We only care about stuff that changes the geometry, or may
+    // cause the window manager to change its state
+    if ( !isTopLevel() && oldGeom == r )
+	return;
+
+    crect = r;
+    bool isResize = size() != oldSize;
+
+    if ( isTopLevel() ) {
+	if ( isMove )
+	    topData()->uspos = 1;
+	if ( isResize )
+	    topData()->ussize = 1;
+	do_size_hints( this, extra );
+    }
+
+    if ( isMove ) {
+	if (! qt_broken_wm)
+	    // pos() is right according to ICCCM 4.1.5
+	    XMoveResizeWindow( dpy, winid, pos().x(), pos().y(), w, h );
+	else
+	    // work around 4Dwm's incompliance with ICCCM 4.1.5
+	    XMoveResizeWindow( dpy, winid, x, y, w, h );
+    } else if ( isResize )
+	XResizeWindow( dpy, winid, w, h );
+
+    if ( isVisible() ) {
+	if ( isMove && pos() != oldPos ) {
+	    if ( ! qt_broken_wm ) {
+		// pos() is right according to ICCCM 4.1.5
+		QMoveEvent e( pos(), oldPos );
+		QApplication::sendEvent( this, &e );
+	    } else {
+		// work around 4Dwm's incompliance with ICCCM 4.1.5
+		QMoveEvent e( crect.topLeft(), oldGeom.topLeft() );
+		QApplication::sendEvent( this, &e );
+	    }
+	}
+	if ( isResize ) {
+
+	    // set config pending only on resize, see qapplication_x11.cpp, translateConfigEvent()
+	    setWState( WState_ConfigPending );
+
+	    QResizeEvent e( size(), oldSize );
+	    QApplication::sendEvent( this, &e );
+	}
+    } else {
+	if ( isMove && pos() != oldPos ) {
+	    if ( ! qt_broken_wm )
+		// pos() is right according to ICCCM 4.1.5
+		QApplication::postEvent( this, new QMoveEvent( pos(), oldPos ) );
+	    else
+		// work around 4Dwm's incompliance with ICCCM 4.1.5
+		QApplication::postEvent( this, new QMoveEvent( crect.topLeft(),
+							       oldGeom.topLeft() ) );
+	}
+	if ( isResize )
+	    QApplication::postEvent( this,
+				     new QResizeEvent( size(), oldSize ) );
+    }
+}
+
+
+/*!
+    \overload
+
+    This function corresponds to setMinimumSize( QSize(minw, minh) ).
+    Sets the minimum width to \a minw and the minimum height to \a
+    minh.
+*/
+
+void QWidget::setMinimumSize( int minw, int minh )
+{
+#if defined(QT_CHECK_RANGE)
+    if ( minw < 0 || minh < 0 )
+	qWarning("QWidget::setMinimumSize: The smallest allowed size is (0,0)");
+#endif
+    createExtra();
+    if ( extra->minw == minw && extra->minh == minh )
+	return;
+    extra->minw = minw;
+    extra->minh = minh;
+    if ( minw > width() || minh > height() ) {
+	bool resized = testWState( WState_Resized );
+	resize( QMAX(minw,width()), QMAX(minh,height()) );
+	if ( !resized )
+	    clearWState( WState_Resized ); // not a user resize
+    }
+    if ( testWFlags(WType_TopLevel) )
+	do_size_hints( this, extra );
+    updateGeometry();
+}
+
+/*!
+    \overload
+
+    This function corresponds to setMaximumSize( QSize(\a maxw, \a
+    maxh) ). Sets the maximum width to \a maxw and the maximum height
+    to \a maxh.
+*/
+void QWidget::setMaximumSize( int maxw, int maxh )
+{
+#if defined(QT_CHECK_RANGE)
+    if ( maxw > QWIDGETSIZE_MAX || maxh > QWIDGETSIZE_MAX ) {
+	qWarning("QWidget::setMaximumSize: (%s/%s) "
+		"The largest allowed size is (%d,%d)",
+		 name( "unnamed" ), className(), QWIDGETSIZE_MAX,
+		QWIDGETSIZE_MAX );
+	maxw = QMIN( maxw, QWIDGETSIZE_MAX );
+	maxh = QMIN( maxh, QWIDGETSIZE_MAX );
+    }
+    if ( maxw < 0 || maxh < 0 ) {
+	qWarning("QWidget::setMaximumSize: (%s/%s) Negative sizes (%d,%d) "
+		"are not possible",
+		name( "unnamed" ), className(), maxw, maxh );
+	maxw = QMAX( maxw, 0 );
+	maxh = QMAX( maxh, 0 );
+    }
+#endif
+    createExtra();
+    if ( extra->maxw == maxw && extra->maxh == maxh )
+	return;
+    extra->maxw = maxw;
+    extra->maxh = maxh;
+    if ( maxw < width() || maxh < height() ) {
+	bool resized = testWState( WState_Resized );
+	resize( QMIN(maxw,width()), QMIN(maxh,height()) );
+	if ( !resized )
+	    clearWState( WState_Resized ); // not a user resize
+    }
+    if ( testWFlags(WType_TopLevel) )
+	do_size_hints( this, extra );
+    updateGeometry();
+}
+
+/*!
+    \overload
+
+    Sets the x (width) size increment to \a w and the y (height) size
+    increment to \a h.
+*/
+void QWidget::setSizeIncrement( int w, int h )
+{
+    QTLWExtra* x = topData();
+    if ( x->incw == w && x->inch == h )
+	return;
+    x->incw = w;
+    x->inch = h;
+    if ( testWFlags(WType_TopLevel) )
+	do_size_hints( this, extra );
+}
+
+/*!
+    \overload
+
+    This corresponds to setBaseSize( QSize(\a basew, \a baseh) ). Sets
+    the widgets base size to width \a basew and height \a baseh.
+*/
+void QWidget::setBaseSize( int basew, int baseh )
+{
+    createTLExtra();
+    QTLWExtra* x = topData();
+    if ( x->basew == basew && x->baseh == baseh )
+	return;
+    x->basew = basew;
+    x->baseh = baseh;
+    if ( testWFlags(WType_TopLevel) )
+	do_size_hints( this, extra );
+}
+
+/*!
+    \overload void QWidget::erase()
+
+    This version erases the entire widget.
+*/
+
+/*!
+  \overload void QWidget::erase( const QRect &r )
+
+  Erases the specified area \a r in the widget without generating a
+  \link paintEvent() paint event\endlink.
+*/
+
+/*!
+    Erases the specified area \a (x, y, w, h) in the widget without
+    generating a \link paintEvent() paint event\endlink.
+
+    If \a w is negative, it is replaced with \c{width() - x}. If \a h
+    is negative, it is replaced width \c{height() - y}.
+
+    Child widgets are not affected.
+
+    \sa repaint()
+*/
+
+void QWidget::erase( int x, int y, int w, int h )
+{
+    extern void qt_erase_rect( QWidget*, const QRect& ); // in qpainer_x11.cpp
+    if ( w < 0 )
+	w = crect.width()  - x;
+    if ( h < 0 )
+	h = crect.height() - y;
+    if ( w != 0 && h != 0 )
+	qt_erase_rect( this, QRect(x, y, w, h ) );
+}
+
+/*!
+    \overload
+
+    Erases the area defined by \a reg, without generating a \link
+    paintEvent() paint event\endlink.
+
+    Child widgets are not affected.
+*/
+
+void QWidget::erase( const QRegion& reg )
+{
+    extern void qt_erase_region( QWidget*, const QRegion& ); // in qpainer_x11.cpp
+    qt_erase_region( this, reg );
+}
+
+/*!
+    Scrolls the widget including its children \a dx pixels to the
+    right and \a dy downwards. Both \a dx and \a dy may be negative.
+
+    After scrolling, scroll() sends a paint event for the the part
+    that is read but not written. For example, when scrolling 10
+    pixels rightwards, the leftmost ten pixels of the widget need
+    repainting. The paint event may be delivered immediately or later,
+    depending on some heuristics (note that you might have to force
+    processing of paint events using QApplication::sendPostedEvents()
+    when using scroll() and move() in combination).
+
+    \sa QScrollView erase() bitBlt()
+*/
+
+void QWidget::scroll( int dx, int dy )
+{
+    scroll( dx, dy, QRect() );
+}
+
+/*!
+    \overload
+
+    This version only scrolls \a r and does not move the children of
+    the widget.
+
+    If \a r is empty or invalid, the result is undefined.
+
+    \sa QScrollView erase() bitBlt()
+*/
+void QWidget::scroll( int dx, int dy, const QRect& r )
+{
+    if ( testWState( WState_BlockUpdates ) && !children() )
+	return;
+    bool valid_rect = r.isValid();
+    bool just_update = QABS( dx ) > width() || QABS( dy ) > height();
+    if ( just_update )
+	update();
+    QRect sr = valid_rect?r:clipRegion().boundingRect();
+    int x1, y1, x2, y2, w=sr.width(), h=sr.height();
+    if ( dx > 0 ) {
+	x1 = sr.x();
+	x2 = x1+dx;
+	w -= dx;
+    } else {
+	x2 = sr.x();
+	x1 = x2-dx;
+	w += dx;
+    }
+    if ( dy > 0 ) {
+	y1 = sr.y();
+	y2 = y1+dy;
+	h -= dy;
+    } else {
+	y2 = sr.y();
+	y1 = y2-dy;
+	h += dy;
+    }
+
+    if ( dx == 0 && dy == 0 )
+	return;
+
+    Display *dpy = x11Display();
+    GC gc = qt_xget_readonly_gc( x11Screen(), FALSE );
+    // Want expose events
+    if ( w > 0 && h > 0 && !just_update ) {
+	XSetGraphicsExposures( dpy, gc, True );
+	XCopyArea( dpy, winId(), winId(), gc, x1, y1, w, h, x2, y2);
+	XSetGraphicsExposures( dpy, gc, False );
+    }
+
+    if ( !valid_rect && children() ) {	// scroll children
+	QPoint pd( dx, dy );
+	QObjectListIt it(*children());
+	register QObject *object;
+	while ( it ) {				// move all children
+	    object = it.current();
+	    if ( object->isWidgetType() ) {
+		QWidget *w = (QWidget *)object;
+		w->move( w->pos() + pd );
+	    }
+	    ++it;
+	}
+    }
+
+    if ( just_update )
+	return;
+
+    // Don't let the server be bogged-down with repaint events
+    bool repaint_immediately = qt_sip_count( this ) < 3;
+
+    if ( dx ) {
+	int x = x2 == sr.x() ? sr.x()+w : sr.x();
+	if ( repaint_immediately )
+	    repaint( x, sr.y(), QABS(dx), sr.height(), !testWFlags(WRepaintNoErase) );
+	else
+	    XClearArea( dpy, winid, x, sr.y(), QABS(dx), sr.height(), True );
+    }
+    if ( dy ) {
+	int y = y2 == sr.y() ? sr.y()+h : sr.y();
+	if ( repaint_immediately )
+	    repaint( sr.x(), y, sr.width(), QABS(dy), !testWFlags(WRepaintNoErase) );
+	else
+	    XClearArea( dpy, winid, sr.x(), y, sr.width(), QABS(dy), True );
+    }
+
+    qt_insert_sip( this, dx, dy ); // #### ignores r
+}
+
+
+/*!
+    \overload void QWidget::drawText( const QPoint &pos, const QString& str )
+
+    Draws the string \a str at position \a pos.
+*/
+
+/*!
+    Draws the string \a str at position \a(x, y).
+
+    The \a y position is the base line position of the text. The text
+    is drawn using the default font and the default foreground color.
+
+    This function is provided for convenience. You will generally get
+    more flexible results and often higher speed by using a a \link
+    QPainter painter\endlink instead.
+
+    \sa setFont(), foregroundColor(), QPainter::drawText()
+*/
+
+void QWidget::drawText( int x, int y, const QString &str )
+{
+    if ( testWState(WState_Visible) ) {
+	QPainter paint;
+	paint.begin( this );
+	paint.drawText( x, y, str );
+	paint.end();
+    }
+}
+
+
+/*!
+    Internal implementation of the virtual QPaintDevice::metric()
+    function.
+
+    Use the QPaintDeviceMetrics class instead.
+
+    \a m is the metric to get.
+*/
+
+int QWidget::metric( int m ) const
+{
+    int val;
+    if ( m == QPaintDeviceMetrics::PdmWidth ) {
+	val = crect.width();
+    } else if ( m == QPaintDeviceMetrics::PdmHeight ) {
+	val = crect.height();
+    } else {
+	Display *dpy = x11Display();
+	int scr = x11Screen();
+	switch ( m ) {
+	    case QPaintDeviceMetrics::PdmDpiX:
+	    case QPaintDeviceMetrics::PdmPhysicalDpiX:
+		val = QPaintDevice::x11AppDpiX( scr );
+		break;
+	    case QPaintDeviceMetrics::PdmDpiY:
+	    case QPaintDeviceMetrics::PdmPhysicalDpiY:
+		val = QPaintDevice::x11AppDpiY( scr );
+		break;
+	    case QPaintDeviceMetrics::PdmWidthMM:
+		val = (DisplayWidthMM(dpy,scr)*crect.width())/
+		      DisplayWidth(dpy,scr);
+		break;
+	    case QPaintDeviceMetrics::PdmHeightMM:
+		val = (DisplayHeightMM(dpy,scr)*crect.height())/
+		      DisplayHeight(dpy,scr);
+		break;
+	    case QPaintDeviceMetrics::PdmNumColors:
+		val = x11Cells();
+		break;
+	    case QPaintDeviceMetrics::PdmDepth:
+		val = x11Depth();
+		break;
+	    default:
+		val = 0;
+#if defined(QT_CHECK_RANGE)
+		qWarning( "QWidget::metric: Invalid metric command" );
+#endif
+	}
+    }
+    return val;
+}
+
+void QWidget::createSysExtra()
+{
+    extra->xDndProxy = 0;
+    extra->children_use_dnd = FALSE;
+    extra->compress_events = TRUE;
+}
+
+void QWidget::deleteSysExtra()
+{
+}
+
+void QWidget::createTLSysExtra()
+{
+    // created lazily
+    extra->topextra->xic = 0;
+}
+
+void QWidget::deleteTLSysExtra()
+{
+    destroyInputContext();
+}
+
+/*
+   examine the children of our parent up the tree and set the
+   children_use_dnd extra data appropriately... this is used to keep DND enabled
+   for widgets that are reparented and don't have DND enabled, BUT *DO* have
+   children (or children of children ...) with DND enabled...
+*/
+void QWidget::checkChildrenDnd()
+{
+    QWidget *widget = this;
+    const QObjectList *children;
+    const QObject *object;
+    const QWidget *child;
+    while (widget && ! widget->isDesktop()) {
+	// note: this isn't done for the desktop widget
+
+	bool children_use_dnd = FALSE;
+	children = widget->children();
+	if ( children ) {
+	    QObjectListIt it(*children);
+	    while ( (object = it.current()) ) {
+		++it;
+		if ( object->isWidgetType() ) {
+		    child = (const QWidget *) object;
+		    children_use_dnd = (children_use_dnd ||
+					child->acceptDrops() ||
+					(child->extra &&
+					 child->extra->children_use_dnd));
+		}
+	    }
+	}
+
+	widget->createExtra();
+	widget->extra->children_use_dnd = children_use_dnd;
+
+	widget = widget->parentWidget();
+    }
+}
+
+/*!
+    \property QWidget::acceptDrops
+    \brief whether drop events are enabled for this widget
+
+    Setting this property to TRUE announces to the system that this
+    widget \e may be able to accept drop events.
+
+    If the widget is the desktop (QWidget::isDesktop()), this may
+    fail if another application is using the desktop; you can call
+    acceptDrops() to test if this occurs.
+
+    \warning
+    Do not modify this property in a Drag&Drop event handler.
+*/
+bool QWidget::acceptDrops() const
+{
+    return testWState( WState_DND );
+}
+
+void QWidget::setAcceptDrops( bool on )
+{
+    if ( testWState(WState_DND) != on ) {
+	if ( qt_dnd_enable( this, on ) ) {
+	    if ( on )
+		setWState( WState_DND );
+	    else
+		clearWState( WState_DND );
+	}
+
+	checkChildrenDnd();
+    }
+}
+
+/*!
+    \overload
+
+    Causes only the parts of the widget which overlap \a region to be
+    visible. If the region includes pixels outside the rect() of the
+    widget, window system controls in that area may or may not be
+    visible, depending on the platform.
+
+    Note that this effect can be slow if the region is particularly
+    complex.
+
+    \sa setMask(), clearMask()
+*/
+
+void QWidget::setMask( const QRegion& region )
+{
+    XShapeCombineRegion( x11Display(), winId(), ShapeBounding, 0, 0,
+			 region.handle(), ShapeSet );
+}
+
+/*!
+    Causes only the pixels of the widget for which \a bitmap has a
+    corresponding 1 bit to be visible. Use Qt::color0 to draw
+    transparent regions and Qt::color1 to draw opaque regions of the
+    bitmap.
+
+    If the region includes pixels outside the rect() of the widget,
+    window system controls in that area may or may not be visible,
+    depending on the platform.
+
+    Note that this effect can be slow if the region is particularly
+    complex.
+
+    See \c examples/tux for an example of masking for transparency.
+
+    \sa setMask(), clearMask()
+*/
+
+void QWidget::setMask( const QBitmap &bitmap )
+{
+    QBitmap bm = bitmap;
+    if ( bm.x11Screen() != x11Screen() )
+	bm.x11SetScreen( x11Screen() );
+    XShapeCombineMask( x11Display(), winId(), ShapeBounding, 0, 0,
+		       bm.handle(), ShapeSet );
+}
+
+/*!
+    Removes any mask set by setMask().
+
+    \sa setMask()
+*/
+
+void QWidget::clearMask()
+{
+    XShapeCombineMask( x11Display(), winId(), ShapeBounding, 0, 0,
+		       None, ShapeSet );
+}
+
+/*!\reimp
+ */
+void QWidget::setName( const char *name )
+{
+    QObject::setName( name );
+    if ( isTopLevel() ) {
+	XChangeProperty( x11Display(), winId(),
+			 qt_window_role, XA_STRING, 8, PropModeReplace,
+			 (unsigned char *)name, qstrlen( name ) );
+    }
+}
+
+
+/*!
+  \internal
+
+  Computes the frame rectangle when needed.  This is an internal function, you
+  should never call this.
+*/
+
+void QWidget::updateFrameStrut() const
+{
+    QWidget *that = (QWidget *) this;
+
+    if (! isVisible() || isDesktop()) {
+	that->fstrut_dirty = (! isVisible());
+	return;
+    }
+
+    Atom type_ret;
+    Window l = winId(), w = winId(), p, r; // target window, it's parent, root
+    Window *c;
+    int i_unused;
+    unsigned int nc;
+    unsigned char *data_ret;
+    unsigned long l_unused;
+
+    while (XQueryTree(QPaintDevice::x11AppDisplay(), w, &r, &p, &c, &nc)) {
+	if (c && nc > 0)
+	    XFree(c);
+
+	if (! p) {
+	    qWarning("QWidget::updateFrameStrut(): ERROR - no parent");
+	    return;
+	}
+
+	// if the parent window is the root window, an Enlightenment virtual root or
+	// a NET WM virtual root window, stop here
+	data_ret = 0;
+	if (p == r ||
+	    (XGetWindowProperty(QPaintDevice::x11AppDisplay(), p,
+				qt_enlightenment_desktop, 0, 1, False, XA_CARDINAL,
+				&type_ret, &i_unused, &l_unused, &l_unused,
+				&data_ret) == Success &&
+	     type_ret == XA_CARDINAL)) {
+	    if (data_ret)
+		XFree(data_ret);
+
+	    break;
+	} else if (qt_net_supports(qt_net_virtual_roots) && qt_net_virtual_root_list) {
+	    int i = 0;
+	    while (qt_net_virtual_root_list[i] != 0) {
+		if (qt_net_virtual_root_list[i++] == p)
+		    break;
+	    }
+	}
+
+	l = w;
+	w = p;
+    }
+
+    // we have our window
+    int transx, transy;
+    XWindowAttributes wattr;
+    if (XTranslateCoordinates(QPaintDevice::x11AppDisplay(), l, w,
+			      0, 0, &transx, &transy, &p) &&
+	XGetWindowAttributes(QPaintDevice::x11AppDisplay(), w, &wattr)) {
+	QTLWExtra *top = that->topData();
+	top->fleft = transx;
+	top->ftop = transy;
+	top->fright = wattr.width - crect.width() - top->fleft;
+	top->fbottom = wattr.height - crect.height() - top->ftop;
+
+	// add the border_width for the window managers frame... some window managers
+	// do not use a border_width of zero for their frames, and if we the left and
+	// top strut, we ensure that pos() is absolutely correct.  frameGeometry()
+	// will still be incorrect though... perhaps i should have foffset as well, to
+	// indicate the frame offset (equal to the border_width on X).
+	// - Brad
+	top->fleft += wattr.border_width;
+	top->fright += wattr.border_width;
+	top->ftop += wattr.border_width;
+	top->fbottom += wattr.border_width;
+    }
+
+    that->fstrut_dirty = 0;
+}
+
+
+void QWidget::createInputContext()
+{
+    QWidget *tlw = topLevelWidget();
+    QTLWExtra *topdata = tlw->topData();
+
+#ifndef QT_NO_XIM
+    if (qt_xim) {
+	if (! topdata->xic) {
+	    QInputContext *qic = new QInputContext(tlw);
+	    topdata->xic = (void *) qic;
+	}
+    } else
+#endif // QT_NO_XIM
+	{
+	    // qDebug("QWidget::createInputContext: no xim");
+	    topdata->xic = 0;
+	}
+}
+
+
+void QWidget::destroyInputContext()
+{
+#ifndef QT_NO_XIM
+    QInputContext *qic = (QInputContext *) extra->topextra->xic;
+    delete qic;
+#endif // QT_NO_XIM
+    extra->topextra->xic = 0;
+}
+
+
+/*!
+    This function is called when the user finishes input composition,
+    e.g. changes focus to another widget, moves the cursor, etc.
+*/
+void QWidget::resetInputContext()
+{
+#ifndef QT_NO_XIM
+    if ((qt_xim_style & XIMPreeditCallbacks) && hasFocus()) {
+	QWidget *tlw = topLevelWidget();
+	QTLWExtra *topdata = tlw->topData();
+
+	// trigger input context creation if it hasn't happened already
+	createInputContext();
+
+	if (topdata->xic) {
+	    QInputContext *qic = (QInputContext *) topdata->xic;
+	    qic->reset();
+	}
+    }
+#endif // QT_NO_XIM
+}
+
+
+void QWidget::focusInputContext()
+{
+#ifndef QT_NO_XIM
+    QWidget *tlw = topLevelWidget();
+    if (!tlw->isPopup() || isInputMethodEnabled()) {
+        QTLWExtra *topdata = tlw->topData();
+
+        // trigger input context creation if it hasn't happened already
+        createInputContext();
+
+        if (topdata->xic) {
+            QInputContext *qic = (QInputContext *) topdata->xic;
+            qic->setFocus();
+        }
+    }
+#endif // QT_NO_XIM
+}
+
+void QWidget::setWindowOpacity(double)
+{
+}
+
+double QWidget::windowOpacity() const
+{
+    return 1.0;
+}
diff -r -U2 -N qt-x11-free-3.3.8b/src/qt.pro qt-x11-free-3.3.8b/src/qt.pro
--- qt-x11-free-3.3.8b/src/qt.pro	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/qt.pro	2009-10-18 14:38:39.301868931 -0700
@@ -38,4 +38,5 @@
 CODECS_CPP	= codecs
 WORKSPACE_CPP	= workspace
+INPUTMETHOD_CPP	= inputmethod
 XML_CPP	        = xml
 STYLES_CPP	= styles
@@ -55,4 +56,5 @@
 		CODECS_H	= $$CODECS_CPP
 		WORKSPACE_H	= $$WORKSPACE_CPP
+                #INPUTMETHOD_H 	= $$INPUTMETHOD_CPP
 		XML_H		= $$XML_CPP
 		CANVAS_H	= $$CANVAS_CPP
@@ -71,4 +73,5 @@
 		CODECS_H	= $$WIN_ALL_H
 		WORKSPACE_H	= $$WIN_ALL_H
+                #INPUTMETHOD_H 	= $$WIN_ALL_H
 		XML_H		= $$WIN_ALL_H
 		CANVAS_H	= $$WIN_ALL_H
@@ -99,4 +102,5 @@
 	CODECS_H	= $$CODECS_CPP
 	WORKSPACE_H	= $$WORKSPACE_CPP
+        INPUTMETHOD_H 	= $$INPUTMETHOD_CPP
 	XML_H		= $$XML_CPP
 	STYLES_H	= $$STYLES_CPP
@@ -113,5 +117,5 @@
 }
 
-DEPENDPATH += ;$$NETWORK_H;$$KERNEL_H;$$WIDGETS_H;$$SQL_H;$$TABLE_H;$$DIALOGS_H;
+DEPENDPATH += ;$$NETWORK_H;$$KERNEL_H;$$WIDGETS_H;$$INPUTMETHOD_H;$$SQL_H;$$TABLE_H;$$DIALOGS_H;
 DEPENDPATH += $$ICONVIEW_H;$$OPENGL_H;$$TOOLS_H;$$CODECS_H;$$WORKSPACE_H;$$XML_H;
 DEPENDPATH += $$CANVAS_H;$$STYLES_H
@@ -148,4 +152,5 @@
 include($$ICONVIEW_CPP/qt_iconview.pri)
 include($$WORKSPACE_CPP/qt_workspace.pri)
+include($$INPUTMETHOD_CPP/qt_inputmethod.pri)
 include($$NETWORK_CPP/qt_network.pri)
 include($$CANVAS_CPP/qt_canvas.pri)
diff -r -U2 -N qt-x11-free-3.3.8b/src/tools/qfeatures.h qt-x11-free-3.3.8b/src/tools/qfeatures.h
--- qt-x11-free-3.3.8b/src/tools/qfeatures.h	2008-01-15 12:09:13.000000000 -0700
+++ qt-x11-free-3.3.8b/src/tools/qfeatures.h	2009-10-18 14:38:39.301868931 -0700
@@ -983,2 +983,12 @@
 #endif
 
+// Input method
+#if !defined(QT_NO_IM) && (defined(QT_NO_STRINGLIST))
+#define QT_NO_IM
+#endif
+
+// Input method extensions
+#if !defined(QT_NO_IM_EXTENSIONS) && (defined(QT_NO_IM) || defined(QT_NO_STRINGLIST))
+#define QT_NO_IM_EXTENSIONS
+#endif
+
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp
--- qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp	2009-10-18 14:38:39.325202691 -0700
@@ -41,4 +41,10 @@
 #include "qlineedit.h"
 #ifndef QT_NO_LINEEDIT
+
+// Keep this position to avoid patch rejection
+#ifndef QT_NO_IM
+#include "qinputcontext.h"
+#endif
+
 #include "qpainter.h"
 #include "qdrawutil.h"
@@ -249,4 +255,8 @@
     // input methods
     int imstart, imend, imselstart, imselend;
+    bool composeMode() const { return preeditLength(); }
+    bool hasIMSelection() const { return imSelectionLength(); }
+    int preeditLength() const { return ( imend - imstart ); }
+    int imSelectionLength() const { return ( imselend - imselstart ); }
 
     // complex text layout
@@ -255,4 +265,5 @@
     void moveCursor( int pos, bool mark = FALSE );
     void setText( const QString& txt );
+    int xToPosInternal( int x, QTextItem::CursorPosition ) const;
     int xToPos( int x, QTextItem::CursorPosition = QTextItem::BetweenCharacters ) const;
     inline int visualAlignment() const { return alignment ? alignment : int( isRightToLeft() ? AlignRight : AlignLeft ); }
@@ -592,4 +603,5 @@
     d->echoMode = mode;
     d->updateTextLayout();
+    setInputMethodEnabled( mode == Normal );
     update();
 }
@@ -1423,4 +1435,6 @@
 void QLineEdit::mousePressEvent( QMouseEvent* e )
 {
+    if ( sendMouseEventToInputContext( e ) )
+	return;
     if ( e->button() == RightButton )
 	return;
@@ -1452,5 +1466,6 @@
 void QLineEdit::mouseMoveEvent( QMouseEvent * e )
 {
-
+    if ( sendMouseEventToInputContext( e ) )
+	return;
 #ifndef QT_NO_CURSOR
     if ( ( e->state() & MouseButtonMask ) == 0 ) {
@@ -1481,4 +1496,6 @@
 void QLineEdit::mouseReleaseEvent( QMouseEvent* e )
 {
+    if ( sendMouseEventToInputContext( e ) )
+	return;
 #ifndef QT_NO_DRAGANDDROP
     if ( e->button() == LeftButton ) {
@@ -1507,4 +1524,6 @@
 void QLineEdit::mouseDoubleClickEvent( QMouseEvent* e )
 {
+    if ( sendMouseEventToInputContext( e ) )
+	return;
     if ( e->button() == Qt::LeftButton ) {
 	deselect();
@@ -1776,4 +1795,31 @@
 }
 
+
+/*!
+  This function is not intended as polymorphic usage. Just a shared code
+  fragment that calls QWidget::sendMouseEventToInputContext() easily for this
+  class.
+ */
+bool QLineEdit::sendMouseEventToInputContext( QMouseEvent *e )
+{
+#ifndef QT_NO_IM
+    if ( d->composeMode() ) {
+	int cursor = d->xToPosInternal( e->pos().x(), QTextItem::OnCharacters );
+	int mousePos = cursor - d->imstart;
+	if ( mousePos >= 0 && mousePos < d->preeditLength() ) {
+	    QWidget::sendMouseEventToInputContext( mousePos, e->type(),
+						   e->button(), e->state() );
+	} else if ( e->type() != QEvent::MouseMove ) {
+	    // send button events on out of preedit
+	    QWidget::sendMouseEventToInputContext( -1, e->type(),
+						   e->button(), e->state() );
+	}
+	return TRUE;
+    }
+#endif
+    return FALSE;
+}
+
+
 /*! \reimp
  */
@@ -1836,4 +1882,6 @@
     if( !hasSelectedText() || style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ) )
 	d->setCursorVisible( TRUE );
+    if ( d->hasIMSelection() )
+	d->cursor = d->imselstart;
     d->updateMicroFocusHint();
 }
@@ -1920,4 +1968,12 @@
         d->hscroll = 0;
     }
+    // This updateMicroFocusHint() is corresponding to update() at
+    // IMCompose event. Although the function is invoked from various
+    // other points, some situations such as "candidate selection on
+    // AlignHCenter'ed text" need this invocation because
+    // updateMicroFocusHint() requires updated contentsRect(), and
+    // there are no other chances in such situation that invoke the
+    // function.
+    d->updateMicroFocusHint();
     // the y offset is there to keep the baseline constant in case we have script changes in the text.
     QPoint topLeft = lineRect.topLeft() - QPoint(d->hscroll, d->ascent-fm.ascent());
@@ -1960,5 +2016,5 @@
 
 	// input method edit area
-	if ( d->imstart < d->imend && (last >= d->imstart && first < d->imend ) ) {
+	if ( d->composeMode() && (last >= d->imstart && first < d->imend ) ) {
 	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->imstart - first, 0 ) ), lineRect.top() ),
 			      QPoint( tix + ti.cursorToX( QMIN( d->imend - first, last - first + 1 ) )-1, lineRect.bottom() ) ).normalize();
@@ -1973,9 +2029,14 @@
 	    p->fillRect( highlight, imCol );
 	    p->drawTextItem( topLeft, ti, textflags );
+            // draw preedit's underline
+            if (d->imend - d->imstart > 0) {
+                p->setPen( cg.text() );
+                p->drawLine( highlight.bottomLeft(), highlight.bottomRight() );
+            }
 	    p->restore();
 	}
 
 	// input method selection
-	if ( d->imselstart < d->imselend && (last >= d->imselstart && first < d->imselend ) ) {
+	if ( d->hasIMSelection() && (last >= d->imselstart && first < d->imselend ) ) {
 	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->imselstart - first, 0 ) ), lineRect.top() ),
 			      QPoint( tix + ti.cursorToX( QMIN( d->imselend - first, last - first + 1 ) )-1, lineRect.bottom() ) ).normalize();
@@ -2005,5 +2066,9 @@
 
     // draw cursor
-    if ( d->cursorVisible && !supressCursor ) {
+    // 
+    // Asian users regard IM selection text as cursor on candidate
+    // selection phase of input method, so ordinary cursor should be
+    // invisible if IM selection text exists.
+    if ( d->cursorVisible && !supressCursor && !d->hasIMSelection() ) {
 	QPoint from( topLeft.x() + cix, lineRect.top() );
 	QPoint to = from + QPoint( 0, lineRect.height() );
@@ -2120,4 +2185,8 @@
 {
 #ifndef QT_NO_POPUPMENU
+#ifndef QT_NO_IM
+    if ( d->composeMode() )
+	return;
+#endif
     d->separate();
     QPopupMenu *menu = createPopupMenu();
@@ -2173,4 +2242,11 @@
 #endif
 	);
+
+#ifndef QT_NO_IM
+    QInputContext *qic = getInputContext();
+    if ( qic )
+	qic->addMenusTo( popup );
+#endif
+    
     popup->setItemEnabled( id - IdUndo, d->isUndoAvailable() );
     popup->setItemEnabled( id - IdRedo, d->isRedoAvailable() );
@@ -2306,5 +2382,5 @@
 }
 
-int QLineEditPrivate::xToPos( int x, QTextItem::CursorPosition betweenOrOn ) const
+int QLineEditPrivate::xToPosInternal( int x, QTextItem::CursorPosition betweenOrOn ) const
 {
     x-= q->contentsRect().x() - hscroll + innerMargin;
@@ -2315,5 +2391,11 @@
 	    return ti.xToCursor( x - tir.x(), betweenOrOn ) + ti.from();
     }
-    return x < 0 ? 0 : text.length();
+    return x < 0 ? -1 : text.length();
+}
+
+int QLineEditPrivate::xToPos( int x, QTextItem::CursorPosition betweenOrOn ) const
+{
+    int pos = xToPosInternal( x, betweenOrOn );
+    return ( pos < 0 ) ? 0 : pos;
 }
 
@@ -2336,7 +2418,17 @@
 void QLineEditPrivate::updateMicroFocusHint()
 {
+    // To reduce redundant microfocus update notification, we remember
+    // the old rect and update the microfocus if actual update is
+    // required. The rect o is intentionally static because some
+    // notifyee requires the microfocus information as global update
+    // rather than per notifyee update to place shared widget around
+    // microfocus.
+    static QRect o;
     if ( q->hasFocus() ) {
-	QRect r = cursorRect();
-	q->setMicroFocusHint( r.x(), r.y(), r.width(), r.height() );
+        QRect r = cursorRect();
+        if ( o != r ) {
+	    o = r;
+	    q->setMicroFocusHint( r.x(), r.y(), r.width(), r.height() );
+	}
     }
 }
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp.orig qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp.orig
--- qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qlineedit.cpp.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,2833 @@
+/**********************************************************************
+**
+** Implementation of QLineEdit widget class
+**
+** Created : 941011
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qlineedit.h"
+#ifndef QT_NO_LINEEDIT
+#include "qpainter.h"
+#include "qdrawutil.h"
+#include "qfontmetrics.h"
+#include "qpixmap.h"
+#include "qclipboard.h"
+#include "qapplication.h"
+#include "qvalidator.h"
+#include "qdragobject.h"
+#include "qtimer.h"
+#include "qpopupmenu.h"
+#include "qstringlist.h"
+#include "qguardedptr.h"
+#include "qstyle.h"
+#include "qwhatsthis.h"
+#include "../kernel/qinternal_p.h"
+#include "private/qtextlayout_p.h"
+#include "qvaluevector.h"
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+#include "qaccessible.h"
+#endif
+
+#ifndef QT_NO_ACCEL
+#include "qkeysequence.h"
+#define ACCEL_KEY(k) "\t" + QString(QKeySequence( Qt::CTRL | Qt::Key_ ## k ))
+#else
+#define ACCEL_KEY(k) "\t" + QString("Ctrl+" #k)
+#endif
+
+#define innerMargin 1
+
+struct QLineEditPrivate : public Qt
+{
+    QLineEditPrivate( QLineEdit *q )
+	: q(q), cursor(0), cursorTimer(0), tripleClickTimer(0), frame(1),
+	  cursorVisible(0), separator(0), readOnly(0), modified(0),
+	  direction(QChar::DirON), dragEnabled(1), alignment(0),
+	  echoMode(0), textDirty(0), selDirty(0), validInput(1),
+	  ascent(0), maxLength(32767), menuId(0),
+	  hscroll(0), validator(0), maskData(0),
+	  undoState(0), selstart(0), selend(0),
+	  imstart(0), imend(0), imselstart(0), imselend(0)
+#ifndef QT_NO_DRAGANDDROP
+	,dndTimer(0)
+#endif
+	{}
+    void init( const QString&);
+
+    QLineEdit *q;
+    QString text;
+    int cursor;
+    int cursorTimer;
+    QPoint tripleClick;
+    int tripleClickTimer;
+    uint frame : 1;
+    uint cursorVisible : 1;
+    uint separator : 1;
+    uint readOnly : 1;
+    uint modified : 1;
+    uint direction : 5;
+    uint dragEnabled : 1;
+    uint alignment : 3;
+    uint echoMode : 2;
+    uint textDirty : 1;
+    uint selDirty : 1;
+    uint validInput : 1;
+    int ascent;
+    int maxLength;
+    int menuId;
+    int hscroll;
+    QChar passwordChar; // obsolete
+
+    void finishChange( int validateFromState = -1, bool setModified = TRUE );
+
+    const QValidator* validator;
+    struct MaskInputData {
+	enum Casemode { NoCaseMode, Upper, Lower };
+	QChar maskChar; // either the separator char or the inputmask
+	bool separator;
+	Casemode caseMode;
+    };
+    QString inputMask;
+    QChar blank;
+    MaskInputData *maskData;
+    inline int nextMaskBlank( int pos ) {
+	int c = findInMask( pos, TRUE, FALSE );
+	separator |= ( c != pos );
+	return ( c != -1 ?  c : maxLength );
+    }
+    inline int prevMaskBlank( int pos ) {
+	int c = findInMask( pos, FALSE, FALSE );
+	separator |= ( c != pos );
+	return ( c != -1 ? c : 0 );
+    }
+
+    void setCursorVisible( bool visible );
+
+
+    // undo/redo handling
+    enum CommandType { Separator, Insert, Remove, Delete, RemoveSelection, DeleteSelection };
+    struct Command {
+	inline Command(){}
+	inline Command( CommandType type, int pos, QChar c )
+	    :type(type),c(c),pos(pos){}
+	uint type : 4;
+	QChar c;
+	int pos;
+    };
+    int undoState;
+    QValueVector<Command> history;
+    void addCommand( const Command& cmd );
+    void insert( const QString& s );
+    void del( bool wasBackspace = FALSE );
+    void remove( int pos );
+
+    inline void separate() { separator = TRUE; }
+    inline void undo( int until = -1 ) {
+	if ( !isUndoAvailable() )
+	    return;
+	deselect();
+	while ( undoState && undoState > until ) {
+	    Command& cmd = history[--undoState];
+	    switch ( cmd.type ) {
+	    case Insert:
+		text.remove( cmd.pos, 1);
+		cursor = cmd.pos;
+		break;
+	    case Remove:
+	    case RemoveSelection:
+		text.insert( cmd.pos, cmd.c );
+		cursor = cmd.pos + 1;
+		break;
+	    case Delete:
+	    case DeleteSelection:
+		text.insert( cmd.pos, cmd.c );
+		cursor = cmd.pos;
+		break;
+	    case Separator:
+		continue;
+	    }
+	    if ( until < 0 && undoState ) {
+		Command& next = history[undoState-1];
+		if ( next.type != cmd.type && next.type < RemoveSelection
+		     && !( cmd.type >= RemoveSelection && next.type != Separator ) )
+		    break;
+	    }
+	}
+	modified = ( undoState != 0 );
+	textDirty = TRUE;
+    }
+    inline void redo() {
+	if ( !isRedoAvailable() )
+	    return;
+	deselect();
+	while ( undoState < (int)history.size() ) {
+	    Command& cmd = history[undoState++];
+	    switch ( cmd.type ) {
+	    case Insert:
+		text.insert( cmd.pos, cmd.c );
+		cursor = cmd.pos + 1;
+		break;
+	    case Remove:
+	    case Delete:
+	    case RemoveSelection:
+	    case DeleteSelection:
+		text.remove( cmd.pos, 1 );
+		cursor = cmd.pos;
+		break;
+	    case Separator:
+		continue;
+	    }
+	    if ( undoState < (int)history.size() ) {
+		Command& next = history[undoState];
+		if ( next.type != cmd.type && cmd.type < RemoveSelection
+		     && !( next.type >= RemoveSelection && cmd.type != Separator ) )
+		    break;
+	    }
+	}
+	textDirty = TRUE;
+    }
+    inline bool isUndoAvailable() const { return !readOnly && undoState; }
+    inline bool isRedoAvailable() const { return !readOnly && undoState < (int)history.size(); }
+
+    // bidi
+    inline bool isRightToLeft() const { return direction==QChar::DirON?text.isRightToLeft():(direction==QChar::DirR); }
+
+    // selection
+    int selstart, selend;
+    inline bool allSelected() const { return !text.isEmpty() && selstart == 0 && selend == (int)text.length(); }
+    inline bool hasSelectedText() const { return !text.isEmpty() && selend > selstart; }
+    inline void deselect() { selDirty |= (selend > selstart); selstart = selend = 0; }
+    void removeSelectedText();
+#ifndef QT_NO_CLIPBOARD
+    void copy( bool clipboard = TRUE ) const;
+#endif
+    inline bool inSelection( int x ) const
+    { if ( selstart >= selend ) return FALSE;
+    int pos = xToPos( x, QTextItem::OnCharacters );  return pos >= selstart && pos < selend; }
+
+    // masking
+    void parseInputMask( const QString &maskFields );
+    bool isValidInput( QChar key, QChar mask ) const;
+    QString maskString( uint pos, const QString &str, bool clear = FALSE ) const;
+    QString clearString( uint pos, uint len ) const;
+    QString stripString( const QString &str ) const;
+    int findInMask( int pos, bool forward, bool findSeparator, QChar searchChar = QChar() ) const;
+
+    // input methods
+    int imstart, imend, imselstart, imselend;
+
+    // complex text layout
+    QTextLayout textLayout;
+    void updateTextLayout();
+    void moveCursor( int pos, bool mark = FALSE );
+    void setText( const QString& txt );
+    int xToPos( int x, QTextItem::CursorPosition = QTextItem::BetweenCharacters ) const;
+    inline int visualAlignment() const { return alignment ? alignment : int( isRightToLeft() ? AlignRight : AlignLeft ); }
+    QRect cursorRect() const;
+    void updateMicroFocusHint();
+
+#ifndef QT_NO_DRAGANDDROP
+    // drag and drop
+    QPoint dndPos;
+    int dndTimer;
+    bool drag();
+#endif
+};
+
+
+/*!
+    \class QLineEdit
+    \brief The QLineEdit widget is a one-line text editor.
+
+    \ingroup basic
+    \mainclass
+
+    A line edit allows the user to enter and edit a single line of
+    plain text with a useful collection of editing functions,
+    including undo and redo, cut and paste, and drag and drop.
+
+    By changing the echoMode() of a line edit, it can also be used as
+    a "write-only" field, for inputs such as passwords.
+
+    The length of the text can be constrained to maxLength(). The text
+    can be arbitrarily constrained using a validator() or an
+    inputMask(), or both.
+
+    A related class is QTextEdit which allows multi-line, rich-text
+    editing.
+
+    You can change the text with setText() or insert(). The text is
+    retrieved with text(); the displayed text (which may be different,
+    see \l{EchoMode}) is retrieved with displayText(). Text can be
+    selected with setSelection() or selectAll(), and the selection can
+    be cut(), copy()ied and paste()d. The text can be aligned with
+    setAlignment().
+
+    When the text changes the textChanged() signal is emitted; when
+    the Return or Enter key is pressed the returnPressed() signal is
+    emitted. Note that if there is a validator set on the line edit,
+    the returnPressed() signal will only be emitted if the validator
+    returns \c Acceptable.
+
+    By default, QLineEdits have a frame as specified by the Windows
+    and Motif style guides; you can turn it off by calling
+    setFrame(FALSE).
+
+    The default key bindings are described below. The line edit also
+    provides a context menu (usually invoked by a right mouse click)
+    that presents some of these editing options.
+    \target desc
+    \table
+    \header \i Keypress \i Action
+    \row \i Left Arrow \i Moves the cursor one character to the left.
+    \row \i Shift+Left Arrow \i Moves and selects text one character to the left.
+    \row \i Right Arrow \i Moves the cursor one character to the right.
+    \row \i Shift+Right Arrow \i Moves and selects text one character to the right.
+    \row \i Home \i Moves the cursor to the beginning of the line.
+    \row \i End \i Moves the cursor to the end of the line.
+    \row \i Backspace \i Deletes the character to the left of the cursor.
+    \row \i Ctrl+Backspace \i Deletes the word to the left of the cursor.
+    \row \i Delete \i Deletes the character to the right of the cursor.
+    \row \i Ctrl+Delete \i Deletes the word to the right of the cursor.
+    \row \i Ctrl+A \i Moves the cursor to the beginning of the line.
+    \row \i Ctrl+B \i Moves the cursor one character to the left.
+    \row \i Ctrl+C \i Copies the selected text to the clipboard.
+		      (Windows also supports Ctrl+Insert for this operation.)
+    \row \i Ctrl+D \i Deletes the character to the right of the cursor.
+    \row \i Ctrl+E \i Moves the cursor to the end of the line.
+    \row \i Ctrl+F \i Moves the cursor one character to the right.
+    \row \i Ctrl+H \i Deletes the character to the left of the cursor.
+    \row \i Ctrl+K \i Deletes to the end of the line.
+    \row \i Ctrl+V \i Pastes the clipboard text into line edit.
+		      (Windows also supports Shift+Insert for this operation.)
+    \row \i Ctrl+X \i Deletes the selected text and copies it to the clipboard.
+		      (Windows also supports Shift+Delete for this operation.)
+    \row \i Ctrl+Z \i Undoes the last operation.
+    \row \i Ctrl+Y \i Redoes the last undone operation.
+    \endtable
+
+    Any other key sequence that represents a valid character, will
+    cause the character to be inserted into the line edit.
+
+    <img src=qlined-m.png> <img src=qlined-w.png>
+
+    \sa QTextEdit QLabel QComboBox
+	\link guibooks.html#fowler GUI Design Handbook: Field, Entry\endlink
+*/
+
+
+/*!
+    \fn void QLineEdit::textChanged( const QString& )
+
+    This signal is emitted whenever the text changes. The argument is
+    the new text.
+*/
+
+/*!
+    \fn void QLineEdit::selectionChanged()
+
+    This signal is emitted whenever the selection changes.
+
+    \sa hasSelectedText(), selectedText()
+*/
+
+/*!
+    \fn void QLineEdit::lostFocus()
+
+    This signal is emitted when the line edit has lost focus.
+
+    \sa hasFocus(), QWidget::focusInEvent(), QWidget::focusOutEvent()
+*/
+
+
+
+/*!
+    Constructs a line edit with no text.
+
+    The maximum text length is set to 32767 characters.
+
+    The \a parent and \a name arguments are sent to the QWidget constructor.
+
+    \sa setText(), setMaxLength()
+*/
+
+QLineEdit::QLineEdit( QWidget* parent, const char* name )
+    : QFrame( parent, name, WNoAutoErase ), d(new QLineEditPrivate( this ))
+{
+    d->init( QString::null );
+}
+
+/*!
+    Constructs a line edit containing the text \a contents.
+
+    The cursor position is set to the end of the line and the maximum
+    text length to 32767 characters.
+
+    The \a parent and \a name arguments are sent to the QWidget
+    constructor.
+
+    \sa text(), setMaxLength()
+*/
+
+QLineEdit::QLineEdit( const QString& contents, QWidget* parent, const char* name )
+    : QFrame( parent, name, WNoAutoErase ), d(new QLineEditPrivate( this ))
+{
+    d->init( contents );
+}
+
+/*!
+    Constructs a line edit with an input \a inputMask and the text \a
+    contents.
+
+    The cursor position is set to the end of the line and the maximum
+    text length is set to the length of the mask (the number of mask
+    characters and separators).
+
+    The \a parent and \a name arguments are sent to the QWidget
+    constructor.
+
+    \sa setMask() text()
+*/
+QLineEdit::QLineEdit( const QString& contents, const QString &inputMask, QWidget* parent, const char* name )
+    : QFrame( parent, name, WNoAutoErase ), d(new QLineEditPrivate( this ))
+{
+    d->parseInputMask( inputMask );
+    if ( d->maskData ) {
+	QString ms = d->maskString( 0, contents );
+	d->init( ms + d->clearString( ms.length(), d->maxLength - ms.length() ) );
+	d->cursor = d->nextMaskBlank( ms.length() );
+    } else {
+	d->init( contents );
+    }
+}
+
+/*!
+    Destroys the line edit.
+*/
+
+QLineEdit::~QLineEdit()
+{
+    delete [] d->maskData;
+    delete d;
+}
+
+
+/*!
+    \property QLineEdit::text
+    \brief the line edit's text
+
+    Note that setting this property clears the selection, clears the
+    undo/redo history, moves the cursor to the end of the line and
+    resets the \c modified property to FALSE. The text is not
+    validated when inserted with setText().
+
+    The text is truncated to maxLength() length.
+
+    \sa insert()
+*/
+QString QLineEdit::text() const
+{
+    QString res = d->text;
+    if ( d->maskData )
+	res = d->stripString( d->text );
+    return ( res.isNull() ? QString::fromLatin1("") : res );
+}
+
+void QLineEdit::setText( const QString& text)
+{
+    resetInputContext();
+    d->setText( text );
+    d->modified = FALSE;
+    d->finishChange( -1, FALSE );
+}
+
+
+/*!
+    \property QLineEdit::displayText
+    \brief the displayed text
+
+    If \c EchoMode is \c Normal this returns the same as text(); if
+    \c EchoMode is \c Password it returns a string of asterisks
+    text().length() characters long, e.g. "******"; if \c EchoMode is
+    \c NoEcho returns an empty string, "".
+
+    \sa setEchoMode() text() EchoMode
+*/
+
+QString QLineEdit::displayText() const
+{
+    if ( d->echoMode == NoEcho )
+	return QString::fromLatin1("");
+    QString res = d->text;
+    if ( d->echoMode == Password )
+	res.fill( passwordChar() );
+    return ( res.isNull() ? QString::fromLatin1("") : res );
+}
+
+
+/*!
+    \property QLineEdit::maxLength
+    \brief the maximum permitted length of the text
+
+    If the text is too long, it is truncated at the limit.
+
+    If truncation occurs any selected text will be unselected, the
+    cursor position is set to 0 and the first part of the string is
+    shown.
+
+    If the line edit has an input mask, the mask defines the maximum
+    string length.
+
+    \sa inputMask
+*/
+
+int QLineEdit::maxLength() const
+{
+    return d->maxLength;
+}
+
+void QLineEdit::setMaxLength( int maxLength )
+{
+    if ( d->maskData )
+	return;
+    d->maxLength = maxLength;
+    setText( d->text );
+}
+
+
+
+/*!
+    \property QLineEdit::frame
+    \brief whether the line edit draws itself with a frame
+
+    If enabled (the default) the line edit draws itself inside a
+    two-pixel frame, otherwise the line edit draws itself without any
+    frame.
+*/
+bool QLineEdit::frame() const
+{
+    return frameShape() != NoFrame;
+}
+
+
+void QLineEdit::setFrame( bool enable )
+{
+    setFrameStyle( enable ? ( LineEditPanel | Sunken ) : NoFrame  );
+}
+
+
+/*!
+    \enum QLineEdit::EchoMode
+
+    This enum type describes how a line edit should display its
+    contents.
+
+    \value Normal   Display characters as they are entered. This is the
+		    default.
+    \value NoEcho   Do not display anything. This may be appropriate
+		    for passwords where even the length of the
+		    password should be kept secret.
+    \value Password  Display asterisks instead of the characters
+		    actually entered.
+
+    \sa setEchoMode() echoMode()
+*/
+
+
+/*!
+    \property QLineEdit::echoMode
+    \brief the line edit's echo mode
+
+    The initial setting is \c Normal, but QLineEdit also supports \c
+    NoEcho and \c Password modes.
+
+    The widget's display and the ability to copy or drag the text is
+    affected by this setting.
+
+    \sa EchoMode displayText()
+*/
+
+QLineEdit::EchoMode QLineEdit::echoMode() const
+{
+    return (EchoMode) d->echoMode;
+}
+
+void QLineEdit::setEchoMode( EchoMode mode )
+{
+    if (mode == (EchoMode)d->echoMode)
+	return;
+    d->echoMode = mode;
+    d->updateTextLayout();
+    update();
+}
+
+
+
+/*!
+    Returns a pointer to the current input validator, or 0 if no
+    validator has been set.
+
+    \sa setValidator()
+*/
+
+const QValidator * QLineEdit::validator() const
+{
+    return d->validator;
+}
+
+/*!
+    Sets this line edit to only accept input that the validator, \a v,
+    will accept. This allows you to place any arbitrary constraints on
+    the text which may be entered.
+
+    If \a v == 0, setValidator() removes the current input validator.
+    The initial setting is to have no input validator (i.e. any input
+    is accepted up to maxLength()).
+
+    \sa validator() QIntValidator QDoubleValidator QRegExpValidator
+*/
+
+void QLineEdit::setValidator( const QValidator *v )
+{
+    if ( d->validator )
+	disconnect( (QObject*)d->validator, SIGNAL( destroyed() ),
+		    this, SLOT( clearValidator() ) );
+    d->validator = v;
+    if ( d->validator )
+	connect( (QObject*)d->validator, SIGNAL( destroyed() ),
+	         this, SLOT( clearValidator() ) );
+}
+
+
+
+/*!
+    Returns a recommended size for the widget.
+
+    The width returned, in pixels, is usually enough for about 15 to
+    20 characters.
+*/
+
+QSize QLineEdit::sizeHint() const
+{
+    constPolish();
+    QFontMetrics fm( font() );
+    int h = QMAX(fm.lineSpacing(), 14) + 2*innerMargin;
+    int w = fm.width( 'x' ) * 17; // "some"
+    int m = frameWidth() * 2;
+    return (style().sizeFromContents(QStyle::CT_LineEdit, this,
+				     QSize( w + m, h + m ).
+				     expandedTo(QApplication::globalStrut())));
+}
+
+
+/*!
+    Returns a minimum size for the line edit.
+
+    The width returned is enough for at least one character.
+*/
+
+QSize QLineEdit::minimumSizeHint() const
+{
+    constPolish();
+    QFontMetrics fm = fontMetrics();
+    int h = fm.height() + QMAX( 2*innerMargin, fm.leading() );
+    int w = fm.maxWidth();
+    int m = frameWidth() * 2;
+    return QSize( w + m, h + m );
+}
+
+
+/*!
+    \property QLineEdit::cursorPosition
+    \brief the current cursor position for this line edit
+
+    Setting the cursor position causes a repaint when appropriate.
+*/
+
+int QLineEdit::cursorPosition() const
+{
+    return d->cursor;
+}
+
+
+void QLineEdit::setCursorPosition( int pos )
+{
+    if (pos < 0)
+        pos = 0;
+
+    if ( pos <= (int) d->text.length() )
+	d->moveCursor( pos );
+}
+
+
+/*! \obsolete Use setText(), setCursorPosition() and setSelection() instead.
+*/
+
+bool QLineEdit::validateAndSet( const QString &newText, int newPos,
+				 int newMarkAnchor, int newMarkDrag )
+{
+    int priorState = d->undoState;
+    d->selstart = 0;
+    d->selend = d->text.length();
+    d->removeSelectedText();
+    d->insert( newText );
+    d->finishChange( priorState );
+    if ( d->undoState > priorState ) {
+	d->cursor = newPos;
+	d->selstart = QMIN( newMarkAnchor, newMarkDrag );
+	d->selend = QMAX( newMarkAnchor, newMarkDrag );
+	d->updateMicroFocusHint();
+	update();
+	return TRUE;
+    }
+    return FALSE;
+}
+
+
+/*!
+    \property QLineEdit::alignment
+    \brief the alignment of the line edit
+
+    Possible Values are \c Qt::AlignAuto, \c Qt::AlignLeft, \c
+    Qt::AlignRight and \c Qt::AlignHCenter.
+
+    Attempting to set the alignment to an illegal flag combination
+    does nothing.
+
+    \sa Qt::AlignmentFlags
+*/
+
+int QLineEdit::alignment() const
+{
+    return d->alignment;
+}
+
+void QLineEdit::setAlignment( int flag )
+{
+    d->alignment = flag & 0x7;
+    update();
+}
+
+
+/*!
+  \obsolete
+  \fn void QLineEdit::cursorRight( bool, int )
+
+  Use cursorForward() instead.
+
+  \sa cursorForward()
+*/
+
+/*!
+  \obsolete
+  \fn void QLineEdit::cursorLeft( bool, int )
+  For compatibilty with older applications only. Use cursorBackward()
+  instead.
+  \sa cursorBackward()
+*/
+
+/*!
+    Moves the cursor forward \a steps characters. If \a mark is TRUE
+    each character moved over is added to the selection; if \a mark is
+    FALSE the selection is cleared.
+
+    \sa cursorBackward()
+*/
+
+void QLineEdit::cursorForward( bool mark, int steps )
+{
+    int cursor = d->cursor;
+    if ( steps > 0 ) {
+	while( steps-- )
+	    cursor = d->textLayout.nextCursorPosition( cursor );
+    } else if ( steps < 0 ) {
+	while ( steps++ )
+	    cursor = d->textLayout.previousCursorPosition( cursor );
+    }
+    d->moveCursor( cursor, mark );
+}
+
+
+/*!
+    Moves the cursor back \a steps characters. If \a mark is TRUE each
+    character moved over is added to the selection; if \a mark is
+    FALSE the selection is cleared.
+
+    \sa cursorForward()
+*/
+void QLineEdit::cursorBackward( bool mark, int steps )
+{
+    cursorForward( mark, -steps );
+}
+
+/*!
+    Moves the cursor one word forward. If \a mark is TRUE, the word is
+    also selected.
+
+    \sa cursorWordBackward()
+*/
+void QLineEdit::cursorWordForward( bool mark )
+{
+    d->moveCursor( d->textLayout.nextCursorPosition(d->cursor, QTextLayout::SkipWords), mark );
+}
+
+/*!
+    Moves the cursor one word backward. If \a mark is TRUE, the word
+    is also selected.
+
+    \sa cursorWordForward()
+*/
+
+void QLineEdit::cursorWordBackward( bool mark )
+{
+    d->moveCursor( d->textLayout.previousCursorPosition(d->cursor, QTextLayout::SkipWords), mark );
+}
+
+
+/*!
+    If no text is selected, deletes the character to the left of the
+    text cursor and moves the cursor one position to the left. If any
+    text is selected, the cursor is moved to the beginning of the
+    selected text and the selected text is deleted.
+
+    \sa del()
+*/
+void QLineEdit::backspace()
+{
+    int priorState = d->undoState;
+    if ( d->hasSelectedText() ) {
+	d->removeSelectedText();
+    } else if ( d->cursor ) {
+	    --d->cursor;
+	    if ( d->maskData )
+		d->cursor = d->prevMaskBlank( d->cursor );
+	    d->del( TRUE );
+    }
+    d->finishChange( priorState );
+}
+
+/*!
+    If no text is selected, deletes the character to the right of the
+    text cursor. If any text is selected, the cursor is moved to the
+    beginning of the selected text and the selected text is deleted.
+
+    \sa backspace()
+*/
+
+void QLineEdit::del()
+{
+    int priorState = d->undoState;
+    if ( d->hasSelectedText() ) {
+	d->removeSelectedText();
+    } else {
+	int n = d->textLayout.nextCursorPosition( d->cursor ) - d->cursor;
+	while ( n-- )
+	    d->del();
+    }
+    d->finishChange( priorState );
+}
+
+/*!
+    Moves the text cursor to the beginning of the line unless it is
+    already there. If \a mark is TRUE, text is selected towards the
+    first position; otherwise, any selected text is unselected if the
+    cursor is moved.
+
+    \sa end()
+*/
+
+void QLineEdit::home( bool mark )
+{
+    d->moveCursor( 0, mark );
+}
+
+/*!
+    Moves the text cursor to the end of the line unless it is already
+    there. If \a mark is TRUE, text is selected towards the last
+    position; otherwise, any selected text is unselected if the cursor
+    is moved.
+
+    \sa home()
+*/
+
+void QLineEdit::end( bool mark )
+{
+    d->moveCursor( d->text.length(), mark );
+}
+
+
+/*!
+    \property QLineEdit::modified
+    \brief whether the line edit's contents has been modified by the user
+
+    The modified flag is never read by QLineEdit; it has a default value
+    of FALSE and is changed to TRUE whenever the user changes the line
+    edit's contents.
+
+    This is useful for things that need to provide a default value but
+    do not start out knowing what the default should be (perhaps it
+    depends on other fields on the form). Start the line edit without
+    the best default, and when the default is known, if modified()
+    returns FALSE (the user hasn't entered any text), insert the
+    default value.
+
+    Calling clearModified() or setText() resets the modified flag to
+    FALSE.
+*/
+
+bool QLineEdit::isModified() const
+{
+    return d->modified;
+}
+
+/*!
+    Resets the modified flag to FALSE.
+
+    \sa isModified()
+*/
+void QLineEdit::clearModified()
+{
+    d->modified = FALSE;
+    d->history.clear();
+    d->undoState = 0;
+}
+
+/*!
+  \obsolete
+  \property QLineEdit::edited
+  \brief whether the line edit has been edited. Use modified instead.
+*/
+bool QLineEdit::edited() const { return d->modified; }
+void QLineEdit::setEdited( bool on ) { d->modified = on; }
+
+/*!
+    \obsolete
+    \property QLineEdit::hasMarkedText
+    \brief whether part of the text has been selected by the user. Use hasSelectedText instead.
+*/
+
+/*!
+    \property QLineEdit::hasSelectedText
+    \brief whether there is any text selected
+
+    hasSelectedText() returns TRUE if some or all of the text has been
+    selected by the user; otherwise returns FALSE.
+
+    \sa selectedText()
+*/
+
+
+bool QLineEdit::hasSelectedText() const
+{
+    return d->hasSelectedText();
+}
+
+/*!
+  \obsolete
+  \property QLineEdit::markedText
+  \brief the text selected by the user. Use selectedText instead.
+*/
+
+/*!
+    \property QLineEdit::selectedText
+    \brief the selected text
+
+    If there is no selected text this property's value is
+    QString::null.
+
+    \sa hasSelectedText()
+*/
+
+QString QLineEdit::selectedText() const
+{
+    if ( d->hasSelectedText() )
+	return d->text.mid( d->selstart, d->selend - d->selstart );
+    return QString::null;
+}
+
+/*!
+    selectionStart() returns the index of the first selected character in the
+    line edit or -1 if no text is selected.
+
+    \sa selectedText()
+*/
+
+int QLineEdit::selectionStart() const
+{
+    return d->hasSelectedText() ? d->selstart : -1;
+}
+
+/*! \obsolete use selectedText(), selectionStart() */
+bool QLineEdit::getSelection( int *start, int *end )
+{
+    if ( d->hasSelectedText() && start && end ) {
+	*start = d->selstart;
+	*end = d->selend;
+	return TRUE;
+    }
+    return FALSE;
+}
+
+
+/*!
+    Selects text from position \a start and for \a length characters.
+
+    Note that this function sets the cursor's position to the end of
+    the selection regardless of its current position.
+
+    \sa deselect() selectAll() getSelection() cursorForward() cursorBackward()
+*/
+
+void QLineEdit::setSelection( int start, int length )
+{
+    if ( start < 0 || start > (int)d->text.length() || length < 0 ) {
+	d->selstart = d->selend = 0;
+    } else {
+	d->selstart = start;
+	d->selend = QMIN( start + length, (int)d->text.length() );
+	d->cursor = d->selend;
+    }
+    update();
+}
+
+
+/*!
+    \property QLineEdit::undoAvailable
+    \brief whether undo is available
+*/
+
+bool QLineEdit::isUndoAvailable() const
+{
+    return d->isUndoAvailable();
+}
+
+/*!
+    \property QLineEdit::redoAvailable
+    \brief whether redo is available
+*/
+
+bool QLineEdit::isRedoAvailable() const
+{
+    return d->isRedoAvailable();
+}
+
+/*!
+    \property QLineEdit::dragEnabled
+    \brief whether the lineedit starts a drag if the user presses and
+    moves the mouse on some selected text
+*/
+
+bool QLineEdit::dragEnabled() const
+{
+    return d->dragEnabled;
+}
+
+void QLineEdit::setDragEnabled( bool b )
+{
+    d->dragEnabled = b;
+}
+
+/*!
+    \property QLineEdit::acceptableInput
+    \brief whether the input satisfies the inputMask and the
+    validator.
+
+    \sa setInputMask(), setValidator()
+*/
+bool QLineEdit::hasAcceptableInput() const
+{
+#ifndef QT_NO_VALIDATOR
+    QString text = d->text;
+    int cursor = d->cursor;
+    if ( d->validator && d->validator->validate( text, cursor ) != QValidator::Acceptable )
+	return FALSE;
+#endif
+
+    if ( !d->maskData )
+	return TRUE;
+
+    if ( d->text.length() != (uint)d->maxLength )
+ 	return FALSE;
+
+    for ( uint i=0; i < (uint)d->maxLength; i++) {
+	if ( d->maskData[i].separator ) {
+	    if ( d->text[(int)i] != d->maskData[i].maskChar )
+		return FALSE;
+	} else {
+	    if ( !d->isValidInput( d->text[(int)i], d->maskData[i].maskChar ) )
+		return FALSE;
+	}
+    }
+    return TRUE;
+}
+
+
+/*!
+    \property QLineEdit::inputMask
+    \brief The validation input mask
+
+    If no mask is set, inputMask() returns QString::null.
+
+    Sets the QLineEdit's validation mask. Validators can be used
+    instead of, or in conjunction with masks; see setValidator().
+
+    Unset the mask and return to normal QLineEdit operation by passing
+    an empty string ("") or just calling setInputMask() with no
+    arguments.
+
+    The mask format understands these mask characters:
+    \table
+    \header \i Character \i Meaning
+    \row \i \c A \i ASCII alphabetic character required. A-Z, a-z.
+    \row \i \c a \i ASCII alphabetic character permitted but not required.
+    \row \i \c N \i ASCII alphanumeric character required. A-Z, a-z, 0-9.
+    \row \i \c n \i ASCII alphanumeric character permitted but not required.
+    \row \i \c X \i Any character required.
+    \row \i \c x \i Any character permitted but not required.
+    \row \i \c 9 \i ASCII digit required. 0-9.
+    \row \i \c 0 \i ASCII digit permitted but not required.
+    \row \i \c D \i ASCII digit required. 1-9.
+    \row \i \c d \i ASCII digit permitted but not required (1-9).
+    \row \i \c # \i ASCII digit or plus/minus sign permitted but not required.
+    \row \i \c > \i All following alphabetic characters are uppercased.
+    \row \i \c < \i All following alphabetic characters are lowercased.
+    \row \i \c ! \i Switch off case conversion.
+    \row \i <tt>\\</tt> \i Use <tt>\\</tt> to escape the special
+			   characters listed above to use them as
+			   separators.
+    \endtable
+
+    The mask consists of a string of mask characters and separators,
+    optionally followed by a semi-colon and the character used for
+    blanks: the blank characters are always removed from the text
+    after editing. The default blank character is space.
+
+    Examples:
+    \table
+    \header \i Mask \i Notes
+    \row \i \c 000.000.000.000;_ \i IP address; blanks are \c{_}.
+    \row \i \c 0000-00-00 \i ISO Date; blanks are \c space
+    \row \i \c >AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;# \i License number;
+    blanks are \c - and all (alphabetic) characters are converted to
+    uppercase.
+    \endtable
+
+    To get range control (e.g. for an IP address) use masks together
+    with \link setValidator() validators\endlink.
+
+    \sa maxLength
+*/
+QString QLineEdit::inputMask() const
+{
+    return ( d->maskData ? d->inputMask + ';' + d->blank : QString::null );
+}
+
+void QLineEdit::setInputMask( const QString &inputMask )
+{
+    d->parseInputMask( inputMask );
+    if ( d->maskData )
+	d->moveCursor( d->nextMaskBlank( 0 ) );
+}
+
+/*!
+    Selects all the text (i.e. highlights it) and moves the cursor to
+    the end. This is useful when a default value has been inserted
+    because if the user types before clicking on the widget, the
+    selected text will be deleted.
+
+    \sa setSelection() deselect()
+*/
+
+void QLineEdit::selectAll()
+{
+    d->selstart = d->selend = d->cursor = 0;
+    d->moveCursor( d->text.length(), TRUE );
+}
+
+/*!
+    Deselects any selected text.
+
+    \sa setSelection() selectAll()
+*/
+
+void QLineEdit::deselect()
+{
+    d->deselect();
+    d->finishChange();
+}
+
+
+/*!
+    This slot is equivalent to setValidator(0).
+*/
+
+void QLineEdit::clearValidator()
+{
+    setValidator( 0 );
+}
+
+/*!
+    Deletes any selected text, inserts \a newText, and validates the
+    result. If it is valid, it sets it as the new contents of the line
+    edit.
+*/
+void QLineEdit::insert( const QString &newText )
+{
+//     q->resetInputContext(); //#### FIX ME IN QT
+    int priorState = d->undoState;
+    d->removeSelectedText();
+    d->insert( newText );
+    d->finishChange( priorState );
+}
+
+/*!
+    Clears the contents of the line edit.
+*/
+void QLineEdit::clear()
+{
+    int priorState = d->undoState;
+    resetInputContext();
+    d->selstart = 0;
+    d->selend = d->text.length();
+    d->removeSelectedText();
+    d->separate();
+    d->finishChange( priorState );
+}
+
+/*!
+    Undoes the last operation if undo is \link
+    QLineEdit::undoAvailable available\endlink. Deselects any current
+    selection, and updates the selection start to the current cursor
+    position.
+*/
+void QLineEdit::undo()
+{
+    resetInputContext();
+    d->undo();
+    d->finishChange( -1, FALSE );
+}
+
+/*!
+    Redoes the last operation if redo is \link
+    QLineEdit::redoAvailable available\endlink.
+*/
+void QLineEdit::redo()
+{
+    resetInputContext();
+    d->redo();
+    d->finishChange();
+}
+
+
+/*!
+    \property QLineEdit::readOnly
+    \brief whether the line edit is read only.
+
+    In read-only mode, the user can still copy the text to the
+    clipboard or drag-and-drop the text (if echoMode() is \c Normal),
+    but cannot edit it.
+
+    QLineEdit does not show a cursor in read-only mode.
+
+    \sa setEnabled()
+*/
+
+bool QLineEdit::isReadOnly() const
+{
+    return d->readOnly;
+}
+
+void QLineEdit::setReadOnly( bool enable )
+{
+    d->readOnly = enable;
+#ifndef QT_NO_CURSOR
+    setCursor( enable ? arrowCursor : ibeamCursor );
+#endif
+    update();
+}
+
+
+#ifndef QT_NO_CLIPBOARD
+/*!
+    Copies the selected text to the clipboard and deletes it, if there
+    is any, and if echoMode() is \c Normal.
+
+    If the current validator disallows deleting the selected text,
+    cut() will copy without deleting.
+
+    \sa copy() paste() setValidator()
+*/
+
+void QLineEdit::cut()
+{
+    if ( hasSelectedText() ) {
+	copy();
+	del();
+    }
+}
+
+
+/*!
+    Copies the selected text to the clipboard, if there is any, and if
+    echoMode() is \c Normal.
+
+    \sa cut() paste()
+*/
+
+void QLineEdit::copy() const
+{
+    d->copy();
+}
+
+/*!
+    Inserts the clipboard's text at the cursor position, deleting any
+    selected text, providing the line edit is not \link
+    QLineEdit::readOnly read-only\endlink.
+
+    If the end result would not be acceptable to the current
+    \link setValidator() validator\endlink, nothing happens.
+
+    \sa copy() cut()
+*/
+
+void QLineEdit::paste()
+{
+    insert( QApplication::clipboard()->text( QClipboard::Clipboard ) );
+}
+
+void QLineEditPrivate::copy( bool clipboard ) const
+{
+    QString t = q->selectedText();
+    if ( !t.isEmpty() && echoMode == QLineEdit::Normal ) {
+	q->disconnect( QApplication::clipboard(), SIGNAL(selectionChanged()), q, 0);
+	QApplication::clipboard()->setText( t, clipboard ? QClipboard::Clipboard : QClipboard::Selection );
+	q->connect( QApplication::clipboard(), SIGNAL(selectionChanged()),
+		 q, SLOT(clipboardChanged()) );
+    }
+}
+
+#endif // !QT_NO_CLIPBOARD
+
+/*!\reimp
+*/
+
+void QLineEdit::resizeEvent( QResizeEvent *e )
+{
+    QFrame::resizeEvent( e );
+}
+
+/*! \reimp
+*/
+bool QLineEdit::event( QEvent * e )
+{
+    if ( e->type() == QEvent::AccelOverride && !d->readOnly ) {
+	QKeyEvent* ke = (QKeyEvent*) e;
+	if ( ke->state() == NoButton || ke->state() == ShiftButton
+	     || ke->state() == Keypad ) {
+	    if ( ke->key() < Key_Escape ) {
+		ke->accept();
+	    } else {
+		switch ( ke->key() ) {
+  		case Key_Delete:
+  		case Key_Home:
+  		case Key_End:
+  		case Key_Backspace:
+ 		case Key_Left:
+		case Key_Right:
+ 		    ke->accept();
+ 		default:
+  		    break;
+  		}
+	    }
+	} else if ( ke->state() & ControlButton ) {
+	    switch ( ke->key() ) {
+// Those are too frequently used for application functionality
+/*	    case Key_A:
+	    case Key_B:
+	    case Key_D:
+	    case Key_E:
+	    case Key_F:
+	    case Key_H:
+	    case Key_K:
+*/
+	    case Key_C:
+	    case Key_V:
+	    case Key_X:
+	    case Key_Y:
+	    case Key_Z:
+	    case Key_Left:
+	    case Key_Right:
+#if defined (Q_WS_WIN)
+	    case Key_Insert:
+	    case Key_Delete:
+#endif
+		ke->accept();
+	    default:
+		break;
+	    }
+	}
+    } else if ( e->type() == QEvent::Timer ) {
+	// should be timerEvent, is here for binary compatibility
+	int timerId = ((QTimerEvent*)e)->timerId();
+	if ( timerId == d->cursorTimer ) {
+	    if(!hasSelectedText() || style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ))
+		d->setCursorVisible( !d->cursorVisible );
+#ifndef QT_NO_DRAGANDDROP
+	} else if ( timerId == d->dndTimer ) {
+	    if( !d->drag() )
+                return TRUE;
+#endif
+	} else if ( timerId == d->tripleClickTimer ) {
+	    killTimer( d->tripleClickTimer );
+	    d->tripleClickTimer = 0;
+	}
+    }
+    return QWidget::event( e );
+}
+
+/*! \reimp
+*/
+void QLineEdit::mousePressEvent( QMouseEvent* e )
+{
+    if ( e->button() == RightButton )
+	return;
+    if ( d->tripleClickTimer && ( e->pos() - d->tripleClick ).manhattanLength() <
+	 QApplication::startDragDistance() ) {
+	selectAll();
+	return;
+    }
+    bool mark = e->state() & ShiftButton;
+    int cursor = d->xToPos( e->pos().x() );
+#ifndef QT_NO_DRAGANDDROP
+    if ( !mark && d->dragEnabled && d->echoMode == Normal &&
+	 e->button() == LeftButton && d->inSelection( e->pos().x() ) ) {
+	d->cursor = cursor;
+	d->updateMicroFocusHint();
+	update();
+	d->dndPos = e->pos();
+	if ( !d->dndTimer )
+	    d->dndTimer = startTimer( QApplication::startDragTime() );
+    } else
+#endif
+    {
+	d->moveCursor( cursor, mark );
+    }
+}
+
+/*! \reimp
+*/
+void QLineEdit::mouseMoveEvent( QMouseEvent * e )
+{
+
+#ifndef QT_NO_CURSOR
+    if ( ( e->state() & MouseButtonMask ) == 0 ) {
+	if ( !d->readOnly && d->dragEnabled
+#ifndef QT_NO_WHATSTHIS
+	     && !QWhatsThis::inWhatsThisMode()
+#endif
+	    )
+	    setCursor( ( d->inSelection( e->pos().x() ) ? arrowCursor : ibeamCursor ) );
+    }
+#endif
+
+    if ( e->state() & LeftButton ) {
+#ifndef QT_NO_DRAGANDDROP
+	if ( d->dndTimer ) {
+	    if ( ( d->dndPos - e->pos() ).manhattanLength() > QApplication::startDragDistance() )
+		d->drag();
+	} else
+#endif
+	{
+	    d->moveCursor( d->xToPos( e->pos().x() ), TRUE );
+	}
+    }
+}
+
+/*! \reimp
+*/
+void QLineEdit::mouseReleaseEvent( QMouseEvent* e )
+{
+#ifndef QT_NO_DRAGANDDROP
+    if ( e->button() == LeftButton ) {
+	if ( d->dndTimer ) {
+	    killTimer( d->dndTimer );
+	    d->dndTimer = 0;
+	    deselect();
+	    return;
+	}
+    }
+#endif
+#ifndef QT_NO_CLIPBOARD
+    if (QApplication::clipboard()->supportsSelection() ) {
+	if ( e->button() == LeftButton ) {
+	    d->copy( FALSE );
+	} else if ( !d->readOnly && e->button() == MidButton ) {
+	    d->deselect();
+	    insert( QApplication::clipboard()->text( QClipboard::Selection ) );
+	}
+    }
+#endif
+}
+
+/*! \reimp
+*/
+void QLineEdit::mouseDoubleClickEvent( QMouseEvent* e )
+{
+    if ( e->button() == Qt::LeftButton ) {
+	deselect();
+	d->cursor = d->xToPos( e->pos().x() );
+	d->cursor = d->textLayout.previousCursorPosition( d->cursor, QTextLayout::SkipWords );
+	// ## text layout should support end of words.
+	int end = d->textLayout.nextCursorPosition( d->cursor, QTextLayout::SkipWords );
+	while ( end > d->cursor && d->text[end-1].isSpace() )
+	    --end;
+	d->moveCursor( end, TRUE );
+	d->tripleClickTimer = startTimer( QApplication::doubleClickInterval() );
+	d->tripleClick = e->pos();
+    }
+}
+
+/*!
+    \fn void  QLineEdit::returnPressed()
+
+    This signal is emitted when the Return or Enter key is pressed.
+    Note that if there is a validator() or inputMask() set on the line
+    edit, the returnPressed() signal will only be emitted if the input
+    follows the inputMask() and the validator() returns \c Acceptable.
+*/
+
+/*!
+    Converts key press event \a e into a line edit action.
+
+    If Return or Enter is pressed and the current text is valid (or
+    can be \link QValidator::fixup() made valid\endlink by the
+    validator), the signal returnPressed() is emitted.
+
+    The default key bindings are listed in the \link #desc detailed
+    description.\endlink
+*/
+
+void QLineEdit::keyPressEvent( QKeyEvent * e )
+{
+    d->setCursorVisible( TRUE );
+    if ( e->key() == Key_Enter || e->key() == Key_Return ) {
+	const QValidator * v = d->validator;
+	if ( hasAcceptableInput() ) {
+	    emit returnPressed();
+	}
+#ifndef QT_NO_VALIDATOR
+	else if ( v && v->validate( d->text, d->cursor ) != QValidator::Acceptable ) {
+	    QString vstr = d->text;
+	    v->fixup( vstr );
+	    if ( vstr != d->text ) {
+		setText( vstr );
+		if ( hasAcceptableInput() )
+		    emit returnPressed();
+	    }
+	}
+#endif
+	e->ignore();
+	return;
+    }
+    if ( !d->readOnly ) {
+	QString t = e->text();
+	if ( !t.isEmpty() && (!e->ascii() || e->ascii()>=32) &&
+	     e->key() != Key_Delete &&
+	     e->key() != Key_Backspace ) {
+#ifdef Q_WS_X11
+	    extern bool qt_hebrew_keyboard_hack;
+	    if ( qt_hebrew_keyboard_hack ) {
+		// the X11 keyboard layout is broken and does not reverse
+		// braces correctly. This is a hack to get halfway correct
+		// behaviour
+		if ( d->isRightToLeft() ) {
+		    QChar *c = (QChar *)t.unicode();
+		    int l = t.length();
+		    while( l-- ) {
+			if ( c->mirrored() )
+			    *c = c->mirroredChar();
+			c++;
+		    }
+		}
+	    }
+#endif
+	    insert( t );
+	    return;
+	}
+    }
+    bool unknown = FALSE;
+    if ( e->state() & ControlButton ) {
+	switch ( e->key() ) {
+	case Key_A:
+#if defined(Q_WS_X11)
+	    home( e->state() & ShiftButton );
+#else
+	    selectAll();
+#endif
+	    break;
+	case Key_B:
+	    cursorForward( e->state() & ShiftButton, -1 );
+	    break;
+#ifndef QT_NO_CLIPBOARD
+	case Key_C:
+	    copy();
+	    break;
+#endif
+	case Key_D:
+	    if ( !d->readOnly ) {
+		del();
+	    }
+	    break;
+	case Key_E:
+	    end( e->state() & ShiftButton );
+	    break;
+	case Key_F:
+	    cursorForward( e->state() & ShiftButton, 1 );
+	    break;
+	case Key_H:
+	    if ( !d->readOnly ) {
+		backspace();
+	    }
+	    break;
+	case Key_K:
+	    if ( !d->readOnly ) {
+		int priorState = d->undoState;
+		d->deselect();
+		while ( d->cursor < (int) d->text.length() )
+		    d->del();
+		d->finishChange( priorState );
+	    }
+	    break;
+#if defined(Q_WS_X11)
+        case Key_U:
+	    if ( !d->readOnly )
+		clear();
+	    break;
+#endif
+#ifndef QT_NO_CLIPBOARD
+	case Key_V:
+	    if ( !d->readOnly )
+		paste();
+	    break;
+	case Key_X:
+	    if ( !d->readOnly && d->hasSelectedText() && echoMode() == Normal ) {
+		copy();
+		del();
+	    }
+	    break;
+#if defined (Q_WS_WIN)
+	case Key_Insert:
+	    copy();
+	    break;
+#endif
+#endif
+	case Key_Delete:
+	    if ( !d->readOnly ) {
+		cursorWordForward( TRUE );
+		del();
+	    }
+	    break;
+	case Key_Backspace:
+	    if ( !d->readOnly ) {
+		cursorWordBackward( TRUE );
+		del();
+	    }
+	    break;
+	case Key_Right:
+	case Key_Left:
+	    if ( d->isRightToLeft() == (e->key() == Key_Right) ) {
+	        if ( echoMode() == Normal )
+		    cursorWordBackward( e->state() & ShiftButton );
+		else
+		    home( e->state() & ShiftButton );
+	    } else {
+		if ( echoMode() == Normal )
+		    cursorWordForward( e->state() & ShiftButton );
+		else
+		    end( e->state() & ShiftButton );
+	    }
+	    break;
+	case Key_Z:
+	    if ( !d->readOnly ) {
+		if(e->state() & ShiftButton)
+		    redo();
+		else
+		    undo();
+	    }
+	    break;
+	case Key_Y:
+	    if ( !d->readOnly )
+		redo();
+	    break;
+	default:
+	    unknown = TRUE;
+	}
+    } else { // ### check for *no* modifier
+	switch ( e->key() ) {
+	case Key_Shift:
+	    // ### TODO
+	    break;
+	case Key_Left:
+	case Key_Right: {
+	    int step =  (d->isRightToLeft() == (e->key() == Key_Right)) ? -1 : 1;
+	    cursorForward( e->state() & ShiftButton, step );
+	}
+	break;
+	case Key_Backspace:
+	    if ( !d->readOnly ) {
+		backspace();
+	    }
+	    break;
+	case Key_Home:
+#ifdef Q_WS_MACX
+	case Key_Up:
+#endif
+	    home( e->state() & ShiftButton );
+	    break;
+	case Key_End:
+#ifdef Q_WS_MACX
+	case Key_Down:
+#endif
+	    end( e->state() & ShiftButton );
+	    break;
+	case Key_Delete:
+	    if ( !d->readOnly ) {
+#if defined (Q_WS_WIN)
+		if ( e->state() & ShiftButton ) {
+		    cut();
+		    break;
+		}
+#endif
+		del();
+	    }
+	    break;
+#if defined (Q_WS_WIN)
+	case Key_Insert:
+	    if ( !d->readOnly && e->state() & ShiftButton )
+		paste();
+	    else
+		unknown = TRUE;
+	    break;
+#endif
+	case Key_F14: // Undo key on Sun keyboards
+	    if ( !d->readOnly )
+		undo();
+	    break;
+#ifndef QT_NO_CLIPBOARD
+	case Key_F16: // Copy key on Sun keyboards
+	    copy();
+	    break;
+	case Key_F18: // Paste key on Sun keyboards
+	    if ( !d->readOnly )
+		paste();
+	    break;
+	case Key_F20: // Cut key on Sun keyboards
+	    if ( !d->readOnly && hasSelectedText() && echoMode() == Normal ) {
+		copy();
+		del();
+	    }
+	    break;
+#endif
+	default:
+	    unknown = TRUE;
+	}
+    }
+    if ( e->key() == Key_Direction_L || e->key() == Key_Direction_R ) {
+	d->direction = (e->key() == Key_Direction_L) ? QChar::DirL : QChar::DirR;
+        d->updateTextLayout();
+	update();
+    }
+
+    if ( unknown )
+	e->ignore();
+}
+
+/*! \reimp
+ */
+void QLineEdit::imStartEvent( QIMEvent *e )
+{
+    if ( d->readOnly ) {
+	e->ignore();
+	return;
+    }
+    d->removeSelectedText();
+    d->updateMicroFocusHint();
+    d->imstart = d->imend = d->imselstart = d->imselend = d->cursor;
+}
+
+/*! \reimp
+ */
+void QLineEdit::imComposeEvent( QIMEvent *e )
+{
+    if ( d->readOnly ) {
+	e->ignore();
+	return;
+    }
+    d->text.replace( d->imstart, d->imend - d->imstart, e->text() );
+    d->imend = d->imstart + e->text().length();
+    d->imselstart = d->imstart + e->cursorPos();
+    d->imselend = d->imselstart + e->selectionLength();
+    d->cursor = d->imstart + e->cursorPos();
+    d->updateTextLayout();
+    d->updateMicroFocusHint();
+    update();
+}
+
+/*! \reimp
+ */
+void QLineEdit::imEndEvent( QIMEvent *e )
+{
+    if ( d->readOnly) {
+	e->ignore();
+	return;
+    }
+    d->text.remove( d->imstart, d->imend - d->imstart );
+    d->cursor = d->imselstart = d->imselend = d->imend = d->imstart;
+    d->textDirty = TRUE;
+    insert( e->text() );
+}
+
+/*!\reimp
+*/
+
+void QLineEdit::focusInEvent( QFocusEvent* )
+{
+    if ( QFocusEvent::reason() == QFocusEvent::Tab ||
+	 QFocusEvent::reason() == QFocusEvent::Backtab  ||
+	 QFocusEvent::reason() == QFocusEvent::Shortcut )
+	d->maskData ? d->moveCursor( d->nextMaskBlank( 0 ) ) : selectAll();
+    if ( !d->cursorTimer ) {
+	int cft = QApplication::cursorFlashTime();
+	d->cursorTimer = cft ? startTimer( cft/2 ) : -1;
+    }
+    if( !hasSelectedText() || style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ) )
+	d->setCursorVisible( TRUE );
+    d->updateMicroFocusHint();
+}
+
+/*!\reimp
+*/
+
+void QLineEdit::focusOutEvent( QFocusEvent* )
+{
+    if ( QFocusEvent::reason() != QFocusEvent::ActiveWindow &&
+	 QFocusEvent::reason() != QFocusEvent::Popup )
+	deselect();
+    d->setCursorVisible( FALSE );
+    if ( d->cursorTimer > 0 )
+	killTimer( d->cursorTimer );
+    d->cursorTimer = 0;
+    if (QFocusEvent::reason() != QFocusEvent::Popup)
+        emit lostFocus();
+}
+
+/*!\reimp
+*/
+void QLineEdit::drawContents( QPainter *p )
+{
+    const QColorGroup& cg = colorGroup();
+    QRect cr = contentsRect();
+    QFontMetrics fm = fontMetrics();
+    QRect lineRect( cr.x() + innerMargin, cr.y() + (cr.height() - fm.height() + 1) / 2,
+		    cr.width() - 2*innerMargin, fm.height() );
+    QBrush bg = QBrush( paletteBackgroundColor() );
+    if ( paletteBackgroundPixmap() )
+	bg = QBrush( cg.background(), *paletteBackgroundPixmap() );
+    else if ( !isEnabled() )
+	bg = cg.brush( QColorGroup::Background );
+    QPoint brushOrigin = p->brushOrigin();
+    p->save();
+    p->setClipRegion( QRegion(cr) - lineRect );
+    p->setBrushOrigin(brushOrigin - backgroundOffset());
+    p->fillRect( cr, bg );
+    p->restore();
+    QSharedDoubleBuffer buffer( p, lineRect.x(), lineRect.y(),
+ 				lineRect.width(), lineRect.height(),
+ 				hasFocus() ? QSharedDoubleBuffer::Force : 0 );
+    p = buffer.painter();
+    brushOrigin = p->brushOrigin();
+    p->setBrushOrigin(brushOrigin - backgroundOffset());
+    p->fillRect( lineRect, bg );
+    p->setBrushOrigin(brushOrigin);
+
+    // locate cursor position
+    int cix = 0;
+    QTextItem ci = d->textLayout.findItem( d->cursor );
+    if ( ci.isValid() ) {
+	if ( d->cursor != (int)d->text.length() && d->cursor == ci.from() + ci.length()
+	     && ci.isRightToLeft() != d->isRightToLeft() )
+	    ci = d->textLayout.findItem( d->cursor + 1 );
+	cix = ci.x() + ci.cursorToX( d->cursor - ci.from() );
+    }
+
+    // horizontal scrolling
+    int minLB = QMAX( 0, -fm.minLeftBearing() );
+    int minRB = QMAX( 0, -fm.minRightBearing() );
+    int widthUsed = d->textLayout.widthUsed() + 1 + minRB;
+    if ( (minLB + widthUsed) <=  lineRect.width() ) {
+	switch ( d->visualAlignment() ) {
+	case AlignRight:
+	    d->hscroll = widthUsed - lineRect.width() + 1;
+	    break;
+	case AlignHCenter:
+	    d->hscroll = ( widthUsed - lineRect.width() ) / 2;
+	    break;
+	default:
+	    d->hscroll = 0;
+	    break;
+	}
+	d->hscroll -= minLB;
+    } else if ( cix - d->hscroll >= lineRect.width() ) {
+	d->hscroll = cix - lineRect.width() + 1;
+    } else if ( cix - d->hscroll < 0 ) {
+	d->hscroll = cix;
+    } else if ( widthUsed - d->hscroll < lineRect.width() ) {
+	d->hscroll = widthUsed - lineRect.width() + 1;
+    } else if (d->hscroll < 0) {
+        d->hscroll = 0;
+    }
+    // the y offset is there to keep the baseline constant in case we have script changes in the text.
+    QPoint topLeft = lineRect.topLeft() - QPoint(d->hscroll, d->ascent-fm.ascent());
+
+    // draw text, selections and cursors
+    p->setPen( cg.text() );
+    bool supressCursor = d->readOnly, hasRightToLeft = d->isRightToLeft();
+    int textflags = 0;
+    if ( font().underline() )
+	textflags |= Qt::Underline;
+    if ( font().strikeOut() )
+	textflags |= Qt::StrikeOut;
+    if ( font().overline() )
+	textflags |= Qt::Overline;
+
+    for ( int i = 0; i < d->textLayout.numItems(); i++ ) {
+	QTextItem ti = d->textLayout.itemAt( i );
+	hasRightToLeft |= ti.isRightToLeft();
+	int tix = topLeft.x() + ti.x();
+	int first = ti.from();
+	int last = ti.from() + ti.length() - 1;
+
+	// text and selection
+	if ( d->selstart < d->selend && (last >= d->selstart && first < d->selend ) ) {
+	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->selstart - first, 0 ) ),
+					     lineRect.top() ),
+				     QPoint( tix + ti.cursorToX( QMIN( d->selend - first, last - first + 1 ) ) - 1,
+					     lineRect.bottom() ) ).normalize();
+	    p->save();
+  	    p->setClipRegion( QRegion( lineRect ) - highlight, QPainter::CoordPainter );
+ 	    p->drawTextItem( topLeft, ti, textflags );
+ 	    p->setClipRect( lineRect & highlight, QPainter::CoordPainter );
+	    p->fillRect( highlight, cg.highlight() );
+ 	    p->setPen( cg.highlightedText() );
+	    p->drawTextItem( topLeft, ti, textflags );
+	    p->restore();
+	} else {
+	    p->drawTextItem( topLeft, ti, textflags );
+	}
+
+	// input method edit area
+	if ( d->imstart < d->imend && (last >= d->imstart && first < d->imend ) ) {
+	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->imstart - first, 0 ) ), lineRect.top() ),
+			      QPoint( tix + ti.cursorToX( QMIN( d->imend - first, last - first + 1 ) )-1, lineRect.bottom() ) ).normalize();
+	    p->save();
+ 	    p->setClipRect( lineRect & highlight, QPainter::CoordPainter );
+
+	    int h1, s1, v1, h2, s2, v2;
+	    cg.color( QColorGroup::Base ).hsv( &h1, &s1, &v1 );
+	    cg.color( QColorGroup::Background ).hsv( &h2, &s2, &v2 );
+	    QColor imCol;
+	    imCol.setHsv( h1, s1, ( v1 + v2 ) / 2 );
+	    p->fillRect( highlight, imCol );
+	    p->drawTextItem( topLeft, ti, textflags );
+	    p->restore();
+	}
+
+	// input method selection
+	if ( d->imselstart < d->imselend && (last >= d->imselstart && first < d->imselend ) ) {
+	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->imselstart - first, 0 ) ), lineRect.top() ),
+			      QPoint( tix + ti.cursorToX( QMIN( d->imselend - first, last - first + 1 ) )-1, lineRect.bottom() ) ).normalize();
+	    p->save();
+	    p->setClipRect( lineRect & highlight, QPainter::CoordPainter );
+	    p->fillRect( highlight, cg.text() );
+	    p->setPen( paletteBackgroundColor() );
+	    p->drawTextItem( topLeft, ti, textflags );
+	    p->restore();
+            supressCursor = TRUE;
+	}
+
+	// overwrite cursor
+	if ( d->cursorVisible && d->maskData &&
+	     d->selend <= d->selstart && (last >= d->cursor && first <= d->cursor ) ) {
+	    QRect highlight = QRect( QPoint( tix + ti.cursorToX( QMAX( d->cursor - first, 0 ) ), lineRect.top() ),
+				     QPoint( tix + ti.cursorToX( QMIN( d->cursor + 1 - first, last - first + 1 ) )-1, lineRect.bottom() ) ).normalize();
+	    p->save();
+	    p->setClipRect( lineRect & highlight, QPainter::CoordPainter );
+	    p->fillRect( highlight, cg.text() );
+	    p->setPen( paletteBackgroundColor() );
+	    p->drawTextItem( topLeft, ti, textflags );
+	    p->restore();
+	    supressCursor = TRUE;
+	}
+    }
+
+    // draw cursor
+    if ( d->cursorVisible && !supressCursor ) {
+	QPoint from( topLeft.x() + cix, lineRect.top() );
+	QPoint to = from + QPoint( 0, lineRect.height() );
+	p->drawLine( from, to );
+	if ( hasRightToLeft ) {
+	    bool rtl = ci.isValid() ? ci.isRightToLeft() : TRUE;
+	    to = from + QPoint( (rtl ? -2 : 2), 2 );
+	    p->drawLine( from, to );
+	    from.ry() += 4;
+	    p->drawLine( from, to );
+	}
+    }
+    buffer.end();
+}
+
+
+#ifndef QT_NO_DRAGANDDROP
+/*!\reimp
+*/
+void QLineEdit::dragMoveEvent( QDragMoveEvent *e )
+{
+    if ( !d->readOnly && QTextDrag::canDecode(e) ) {
+	e->acceptAction();
+	d->cursor = d->xToPos( e->pos().x() );
+	d->cursorVisible = TRUE;
+	update();
+    }
+}
+
+/*!\reimp */
+void QLineEdit::dragEnterEvent( QDragEnterEvent * e )
+{
+    QLineEdit::dragMoveEvent( e );
+}
+
+/*!\reimp */
+void QLineEdit::dragLeaveEvent( QDragLeaveEvent *)
+{
+    if ( d->cursorVisible ) {
+	d->cursorVisible = FALSE;
+	update();
+    }
+}
+
+/*!\reimp */
+void QLineEdit::dropEvent( QDropEvent* e )
+{
+    QString str;
+    // try text/plain
+    QCString plain = "plain";
+    bool decoded = QTextDrag::decode(e, str, plain);
+    // otherwise we'll accept any kind of text (like text/uri-list)
+    if (! decoded)
+	decoded = QTextDrag::decode(e, str);
+
+    if ( decoded && !d->readOnly ) {
+	if ( e->source() == this && e->action() == QDropEvent::Copy )
+ 	    deselect();
+	d->cursor =d->xToPos( e->pos().x() );
+	int selStart = d->cursor;
+	int oldSelStart = d->selstart;
+	int oldSelEnd = d->selend;
+	d->cursorVisible = FALSE;
+	e->acceptAction();
+	insert( str );
+	if ( e->source() == this ) {
+	    if ( e->action() == QDropEvent::Move ) {
+		if ( selStart > oldSelStart && selStart <= oldSelEnd )
+		    setSelection( oldSelStart, str.length() );
+		else if ( selStart > oldSelEnd )
+		    setSelection( selStart - str.length(), str.length() );
+		else
+		    setSelection( selStart, str.length() );
+	    } else {
+		setSelection( selStart, str.length() );
+	    }
+	}
+    } else {
+	e->ignore();
+	update();
+    }
+}
+
+bool QLineEditPrivate::drag()
+{
+    q->killTimer( dndTimer );
+    dndTimer = 0;
+    QTextDrag *tdo = new QTextDrag( q->selectedText(), q );
+
+    QGuardedPtr<QLineEdit> gptr = q;
+    bool r = tdo->drag();
+    if ( !gptr )
+        return FALSE;
+
+    // ### fix the check QDragObject::target() != q in Qt4 (should not be needed)
+    if ( r && !readOnly && QDragObject::target() != q ) {
+	int priorState = undoState;
+	removeSelectedText();
+	finishChange( priorState );
+    }
+#ifndef QT_NO_CURSOR
+    q->setCursor( readOnly ? arrowCursor : ibeamCursor );
+#endif
+    return TRUE;
+}
+
+#endif // QT_NO_DRAGANDDROP
+
+enum { IdUndo, IdRedo, IdSep1, IdCut, IdCopy, IdPaste, IdClear, IdSep2, IdSelectAll };
+
+/*!\reimp
+*/
+void QLineEdit::contextMenuEvent( QContextMenuEvent * e )
+{
+#ifndef QT_NO_POPUPMENU
+    d->separate();
+    QPopupMenu *menu = createPopupMenu();
+    if (!menu)
+        return;
+    QGuardedPtr<QPopupMenu> popup = menu;
+    QGuardedPtr<QLineEdit> that = this;
+    QPoint pos = e->reason() == QContextMenuEvent::Mouse ? e->globalPos() :
+		 mapToGlobal( QPoint(e->pos().x(), 0) ) + QPoint( width() / 2, height() / 2 );
+    int r = popup->exec( pos );
+    delete (QPopupMenu*)popup;
+    if ( that && d->menuId ) {
+	switch ( d->menuId - r ) {
+	case IdClear: clear(); break;
+	case IdSelectAll: selectAll(); break;
+	case IdUndo: undo(); break;
+	case IdRedo: redo(); break;
+#ifndef QT_NO_CLIPBOARD
+	case IdCut: cut(); break;
+	case IdCopy: copy(); break;
+	case IdPaste: paste(); break;
+#endif
+	default:
+	    ; // nothing selected or lineedit destroyed. Be careful.
+	}
+    }
+#endif //QT_NO_POPUPMENU
+}
+
+/*!
+    This function is called to create the popup menu which is shown
+    when the user clicks on the line edit with the right mouse button.
+    If you want to create a custom popup menu, reimplement this
+    function and return the popup menu you create. The popup menu's
+    ownership is transferred to the caller.
+*/
+
+QPopupMenu *QLineEdit::createPopupMenu()
+{
+#ifndef QT_NO_POPUPMENU
+    QPopupMenu *popup = new QPopupMenu( this, "qt_edit_menu" );
+    int id = d->menuId = popup->insertItem( tr( "&Undo" ) + ACCEL_KEY( Z ) );
+    popup->insertItem( tr( "&Redo" ) + ACCEL_KEY( Y ) );
+    popup->insertSeparator();
+    popup->insertItem( tr( "Cu&t" ) + ACCEL_KEY( X ) );
+    popup->insertItem( tr( "&Copy" ) + ACCEL_KEY( C ) );
+    popup->insertItem( tr( "&Paste" ) + ACCEL_KEY( V ) );
+    popup->insertItem( tr( "Clear" ) );
+    popup->insertSeparator();
+    popup->insertItem( tr( "Select All" )
+#ifndef Q_WS_X11
+    + ACCEL_KEY( A )
+#endif
+	);
+    popup->setItemEnabled( id - IdUndo, d->isUndoAvailable() );
+    popup->setItemEnabled( id - IdRedo, d->isRedoAvailable() );
+#ifndef QT_NO_CLIPBOARD
+    popup->setItemEnabled( id - IdCut, !d->readOnly && d->hasSelectedText() );
+    popup->setItemEnabled( id - IdCopy, d->hasSelectedText() );
+    popup->setItemEnabled( id - IdPaste, !d->readOnly && !QApplication::clipboard()->text().isEmpty() );
+#else
+    popup->setItemVisible( id - IdCut, FALSE );
+    popup->setItemVisible( id - IdCopy, FALSE );
+    popup->setItemVisible( id - IdPaste, FALSE );
+#endif
+    popup->setItemEnabled( id - IdClear, !d->readOnly && !d->text.isEmpty() );
+    popup->setItemEnabled( id - IdSelectAll, !d->text.isEmpty() && !d->allSelected() );
+    return popup;
+#else
+    return 0;
+#endif
+}
+
+/*! \reimp */
+void QLineEdit::windowActivationChange( bool b )
+{
+    //### remove me with WHighlightSelection attribute
+    if ( palette().active() != palette().inactive() )
+	update();
+    QWidget::windowActivationChange( b );
+}
+
+/*! \reimp */
+
+void QLineEdit::setPalette( const QPalette & p )
+{
+    //### remove me with WHighlightSelection attribute
+    QWidget::setPalette( p );
+    update();
+}
+
+/*!
+  \obsolete
+  \fn void QLineEdit::repaintArea( int from, int to )
+  Repaints all characters from \a from to \a to. If cursorPos is
+  between from and to, ensures that cursorPos is visible.
+*/
+
+/*! \reimp
+ */
+void QLineEdit::setFont( const QFont & f )
+{
+    QWidget::setFont( f );
+    d->updateTextLayout();
+}
+
+/*! \obsolete
+*/
+int QLineEdit::characterAt( int xpos, QChar *chr ) const
+{
+    int pos = d->xToPos( xpos + contentsRect().x() - d->hscroll + innerMargin );
+    if ( chr && pos < (int) d->text.length() )
+	*chr = d->text.at( pos );
+    return pos;
+}
+
+/*!
+    \internal
+
+    Sets the password character to \a c.
+
+    \sa passwordChar()
+*/
+
+void QLineEdit::setPasswordChar( QChar c )
+{
+    d->passwordChar = c;
+}
+
+/*!
+    \internal
+
+    Returns the password character.
+
+    \sa setPasswordChar()
+*/
+QChar QLineEdit::passwordChar() const
+{
+    return ( d->passwordChar.isNull() ? QChar( style().styleHint( QStyle::SH_LineEdit_PasswordCharacter, this ) ) : d->passwordChar );
+}
+
+void QLineEdit::clipboardChanged()
+{
+}
+
+void QLineEditPrivate::init( const QString& txt )
+{
+#ifndef QT_NO_CURSOR
+    q->setCursor( readOnly ? arrowCursor : ibeamCursor );
+#endif
+    q->setFocusPolicy( QWidget::StrongFocus );
+    q->setInputMethodEnabled( TRUE );
+    //   Specifies that this widget can use more, but is able to survive on
+    //   less, horizontal space; and is fixed vertically.
+    q->setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
+    q->setBackgroundMode( PaletteBase );
+    q->setKeyCompression( TRUE );
+    q->setMouseTracking( TRUE );
+    q->setAcceptDrops( TRUE );
+    q->setFrame( TRUE );
+    text = txt;
+    updateTextLayout();
+    cursor = text.length();
+}
+
+void QLineEditPrivate::updateTextLayout()
+{
+    // replace all non-printable characters with spaces (to avoid
+    // drawing boxes when using fonts that don't have glyphs for such
+    // characters)
+    const QString &displayText = q->displayText();
+    QString str(displayText.unicode(), displayText.length());
+    QChar* uc = (QChar*)str.unicode();
+    for (int i = 0; i < (int)str.length(); ++i) {
+	if (! uc[i].isPrint())
+	    uc[i] = QChar(0x0020);
+    }
+    textLayout.setText( str, q->font() );
+    textLayout.setDirection((QChar::Direction)direction);
+    textLayout.beginLayout(QTextLayout::SingleLine);
+    textLayout.beginLine( INT_MAX );
+    while ( !textLayout.atEnd() )
+	textLayout.addCurrentItem();
+    ascent = 0;
+    textLayout.endLine(0, 0, Qt::AlignLeft|Qt::SingleLine, &ascent);
+}
+
+int QLineEditPrivate::xToPos( int x, QTextItem::CursorPosition betweenOrOn ) const
+{
+    x-= q->contentsRect().x() - hscroll + innerMargin;
+    for ( int i = 0; i < textLayout.numItems(); ++i ) {
+	QTextItem ti = textLayout.itemAt( i );
+	QRect tir = ti.rect();
+	if ( x >= tir.left() && x <= tir.right() )
+	    return ti.xToCursor( x - tir.x(), betweenOrOn ) + ti.from();
+    }
+    return x < 0 ? 0 : text.length();
+}
+
+
+QRect QLineEditPrivate::cursorRect() const
+{
+    QRect cr = q->contentsRect();
+    int cix = cr.x() - hscroll + innerMargin;
+    QTextItem ci = textLayout.findItem( cursor );
+    if ( ci.isValid() ) {
+	if ( cursor != (int)text.length() && cursor == ci.from() + ci.length()
+	     && ci.isRightToLeft() != isRightToLeft() )
+	    ci = textLayout.findItem( cursor + 1 );
+	cix += ci.x() + ci.cursorToX( cursor - ci.from() );
+    }
+    int ch = q->fontMetrics().height();
+    return QRect( cix-4, cr.y() + ( cr.height() -  ch + 1) / 2, 8, ch + 1 );
+}
+
+void QLineEditPrivate::updateMicroFocusHint()
+{
+    if ( q->hasFocus() ) {
+	QRect r = cursorRect();
+	q->setMicroFocusHint( r.x(), r.y(), r.width(), r.height() );
+    }
+}
+
+void QLineEditPrivate::moveCursor( int pos, bool mark )
+{
+    if ( pos != cursor )
+	separate();
+    if ( maskData && pos > cursor )
+	pos = nextMaskBlank( pos );
+    else if ( maskData && pos < cursor )
+	pos = prevMaskBlank( pos );
+    bool fullUpdate = mark || hasSelectedText();
+    if ( mark ) {
+	int anchor;
+	if ( selend > selstart && cursor == selstart )
+	    anchor = selend;
+	else if ( selend > selstart && cursor == selend )
+	    anchor = selstart;
+	else
+	    anchor = cursor;
+	selstart = QMIN( anchor, pos );
+	selend = QMAX( anchor, pos );
+    } else {
+	deselect();
+    }
+    if ( fullUpdate ) {
+	cursor = pos;
+	q->update();
+    } else {
+	setCursorVisible( FALSE );
+	cursor = pos;
+	setCursorVisible( TRUE );
+    }
+    updateMicroFocusHint();
+    if ( mark && !q->style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ) )
+	setCursorVisible( FALSE );
+    if ( mark || selDirty ) {
+	selDirty = FALSE;
+	emit q->selectionChanged();
+    }
+}
+
+void QLineEditPrivate::finishChange( int validateFromState, bool setModified )
+{
+    bool lineDirty = selDirty;
+    if ( textDirty ) {
+	// do validation
+	bool wasValidInput = validInput;
+	validInput = TRUE;
+#ifndef QT_NO_VALIDATOR
+	if ( validator && validateFromState >= 0 ) {
+	    QString textCopy = text;
+	    int cursorCopy = cursor;
+	    validInput = ( validator->validate( textCopy, cursorCopy ) != QValidator::Invalid );
+	    if ( validInput ) {
+		if ( text != textCopy ) {
+		    q->setText( textCopy );
+		    cursor = cursorCopy;
+		    return;
+		}
+		cursor = cursorCopy;
+	    }
+	}
+#endif
+	if ( validateFromState >= 0 && wasValidInput && !validInput ) {
+	    undo( validateFromState );
+	    history.resize( undoState );
+	    validInput = TRUE;
+	    textDirty = setModified = FALSE;
+	}
+	updateTextLayout();
+	updateMicroFocusHint();
+	lineDirty |= textDirty;
+	if ( setModified )
+	    modified = TRUE;
+	if ( textDirty ) {
+	    textDirty = FALSE;
+	    emit q->textChanged( maskData ? stripString(text) : text );
+	}
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+	QAccessible::updateAccessibility( q, 0, QAccessible::ValueChanged );
+#endif
+    }
+    if ( selDirty ) {
+	selDirty = FALSE;
+	emit q->selectionChanged();
+    }
+    if ( lineDirty || !setModified )
+	q->update();
+}
+
+void QLineEditPrivate::setText( const QString& txt )
+{
+    deselect();
+    QString oldText = text;
+    if ( maskData ) {
+	text = maskString( 0, txt, TRUE );
+	text += clearString( text.length(), maxLength - text.length() );
+    } else {
+ 	text = txt.isEmpty() ? txt : txt.left( maxLength );
+    }
+    history.clear();
+    undoState = 0;
+    cursor = text.length();
+    textDirty = ( oldText != text );
+}
+
+
+void QLineEditPrivate::setCursorVisible( bool visible )
+{
+    if ( (bool)cursorVisible == visible )
+	return;
+    if ( cursorTimer )
+	cursorVisible = visible;
+    QRect r = cursorRect();
+    if ( maskData || !q->contentsRect().contains( r ) )
+	q->update();
+    else
+	q->update( r );
+}
+
+void QLineEditPrivate::addCommand( const Command& cmd )
+{
+    if ( separator && undoState && history[undoState-1].type != Separator ) {
+	history.resize( undoState + 2 );
+	history[undoState++] = Command( Separator, 0, 0 );
+    } else {
+	history.resize( undoState + 1);
+    }
+    separator = FALSE;
+    history[ undoState++ ] = cmd;
+}
+
+void QLineEditPrivate::insert( const QString& s )
+{
+    if ( maskData ) {
+	QString ms = maskString( cursor, s );
+	for ( int i = 0; i < (int) ms.length(); ++i ) {
+	    addCommand ( Command( DeleteSelection, cursor+i, text.at(cursor+i) ) );
+	    addCommand( Command( Insert, cursor+i, ms.at(i) ) );
+	}
+	text.replace( cursor, ms.length(), ms );
+	cursor += ms.length();
+	cursor = nextMaskBlank( cursor );
+    } else {
+	int remaining = maxLength - text.length();
+	text.insert( cursor, s.left(remaining) );
+	for ( int i = 0; i < (int) s.left(remaining).length(); ++i )
+	    addCommand( Command( Insert, cursor++, s.at(i) ) );
+    }
+    textDirty = TRUE;
+}
+
+void QLineEditPrivate::del( bool wasBackspace )
+{
+    if ( cursor < (int) text.length() ) {
+	addCommand ( Command( (CommandType)((maskData?2:0)+(wasBackspace?Remove:Delete)), cursor, text.at(cursor) ) );
+	if ( maskData ) {
+	    text.replace( cursor, 1, clearString( cursor, 1 ) );
+	    addCommand( Command( Insert, cursor, text.at( cursor ) ) );
+	} else {
+	    text.remove( cursor, 1 );
+	}
+	textDirty = TRUE;
+    }
+}
+
+void QLineEditPrivate::removeSelectedText()
+{
+    if ( selstart < selend && selend <= (int) text.length() ) {
+	separate();
+	int i ;
+	if ( selstart <= cursor && cursor < selend ) {
+	    // cursor is within the selection. Split up the commands
+	    // to be able to restore the correct cursor position
+	    for ( i = cursor; i >= selstart; --i )
+		addCommand ( Command( DeleteSelection, i, text.at(i) ) );
+	    for ( i = selend - 1; i > cursor; --i )
+		addCommand ( Command( DeleteSelection, i - cursor + selstart - 1, text.at(i) ) );
+	} else {
+	    for ( i = selend-1; i >= selstart; --i )
+		addCommand ( Command( RemoveSelection, i, text.at(i) ) );
+	}
+	if ( maskData ) {
+	    text.replace( selstart, selend - selstart,  clearString( selstart, selend - selstart ) );
+	    for ( int i = 0; i < selend - selstart; ++i )
+		addCommand( Command( Insert, selstart + i, text.at( selstart + i ) ) );
+	} else {
+	    text.remove( selstart, selend - selstart );
+	}
+	if ( cursor > selstart )
+	    cursor -= QMIN( cursor, selend ) - selstart;
+	deselect();
+	textDirty = TRUE;
+    }
+}
+
+void QLineEditPrivate::parseInputMask( const QString &maskFields )
+{
+    if ( maskFields.isEmpty() || maskFields.section( ';', 0, 0 ).isEmpty() ) {
+	if ( maskData ) {
+	    delete [] maskData;
+	    maskData = 0;
+	    maxLength = 32767;
+	    q->setText( QString::null );
+	}
+	return;
+    }
+
+    inputMask =  maskFields.section( ';', 0, 0 );
+    blank = maskFields.section( ';', 1, 1 ).at(0);
+    if ( blank.isNull() )
+	blank = ' ';
+
+    // calculate maxLength / maskData length
+    maxLength = 0;
+    QChar c = 0;
+    uint i;
+    for ( i=0; i<inputMask.length(); i++ ) {
+	c = inputMask.at(i);
+	if ( i > 0 && inputMask.at( i-1 ) == '\\' ) {
+	    maxLength++;
+	    continue;
+	}
+	if ( c != '\\' && c != '!' &&
+	     c != '<' && c != '>' &&
+	     c != '{' && c != '}' &&
+	     c != '[' && c != ']' )
+	    maxLength++;
+    }
+
+    delete [] maskData;
+    maskData = new MaskInputData[ maxLength ];
+
+    MaskInputData::Casemode m = MaskInputData::NoCaseMode;
+    c = 0;
+    bool s;
+    bool escape = FALSE;
+    int index = 0;
+    for ( i = 0; i < inputMask.length(); i++ ) {
+	c = inputMask.at(i);
+	if ( escape ) {
+	    s = TRUE;
+	    maskData[ index ].maskChar = c;
+	    maskData[ index ].separator = s;
+	    maskData[ index ].caseMode = m;
+	    index++;
+	    escape = FALSE;
+	} else if ( c == '<' || c == '>' || c == '!') {
+	    switch ( c ) {
+	    case '<':
+		m = MaskInputData::Lower;
+		break;
+	    case '>':
+		m = MaskInputData::Upper;
+		break;
+	    case '!':
+		m = MaskInputData::NoCaseMode;
+		break;
+	    }
+	} else if ( c != '{' && c != '}' && c != '[' && c != ']' ) {
+	    switch ( c ) {
+	    case 'A':
+	    case 'a':
+	    case 'N':
+	    case 'n':
+	    case 'X':
+	    case 'x':
+	    case '9':
+	    case '0':
+	    case 'D':
+	    case 'd':
+	    case '#':
+		s = FALSE;
+		break;
+	    case '\\':
+		escape = TRUE;
+	    default:
+		s = TRUE;
+		break;
+	    }
+
+	    if ( !escape ) {
+		maskData[ index ].maskChar = c;
+		maskData[ index ].separator = s;
+		maskData[ index ].caseMode = m;
+		index++;
+	    }
+	}
+    }
+    q->setText( QString::null );
+}
+
+
+/* checks if the key is valid compared to the inputMask */
+bool QLineEditPrivate::isValidInput( QChar key, QChar mask ) const
+{
+    switch ( mask ) {
+    case 'A':
+	if ( key.isLetter() && key != blank )
+	    return TRUE;
+	break;
+    case 'a':
+	if ( key.isLetter() || key == blank )
+	    return TRUE;
+	break;
+    case 'N':
+	if ( key.isLetterOrNumber() && key != blank )
+	    return TRUE;
+	break;
+    case 'n':
+	if ( key.isLetterOrNumber() || key == blank )
+	    return TRUE;
+	break;
+    case 'X':
+	if ( key.isPrint() && key != blank )
+	    return TRUE;
+	break;
+    case 'x':
+	if ( key.isPrint() || key == blank )
+	    return TRUE;
+	break;
+    case '9':
+	if ( key.isNumber() && key != blank )
+	    return TRUE;
+	break;
+    case '0':
+	if ( key.isNumber() || key == blank )
+	    return TRUE;
+	break;
+    case 'D':
+	if ( key.isNumber() && key.digitValue() > 0 && key != blank )
+	    return TRUE;
+	break;
+    case 'd':
+	if ( (key.isNumber() && key.digitValue() > 0) || key == blank )
+	    return TRUE;
+	break;
+    case '#':
+	if ( key.isNumber() || key == '+' || key == '-' || key == blank )
+	    return TRUE;
+	break;
+    default:
+	break;
+    }
+    return FALSE;
+}
+
+/*
+  Applies the inputMask on \a str starting from position \a pos in the mask. \a clear
+  specifies from where characters should be gotten when a separator is met in \a str - TRUE means
+  that blanks will be used, FALSE that previous input is used.
+  Calling this when no inputMask is set is undefined.
+*/
+QString QLineEditPrivate::maskString( uint pos, const QString &str, bool clear) const
+{
+    if ( pos >= (uint)maxLength )
+	return QString::fromLatin1("");
+
+    QString fill;
+    fill = clear ? clearString( 0, maxLength ) : text;
+
+    uint strIndex = 0;
+    QString s = QString::fromLatin1("");
+    int i = pos;
+    while ( i < maxLength ) {
+	if ( strIndex < str.length() ) {
+	    if ( maskData[ i ].separator ) {
+		s += maskData[ i ].maskChar;
+		if ( str[(int)strIndex] == maskData[ i ].maskChar )
+		    strIndex++;
+		++i;
+	    } else {
+		if ( isValidInput( str[(int)strIndex], maskData[ i ].maskChar ) ) {
+		    switch ( maskData[ i ].caseMode ) {
+		    case MaskInputData::Upper:
+			s += str[(int)strIndex].upper();
+			break;
+		    case MaskInputData::Lower:
+			s += str[(int)strIndex].lower();
+			break;
+		    default:
+			s += str[(int)strIndex];
+		    }
+		    ++i;
+		} else {
+		    // search for separator first
+		    int n = findInMask( i, TRUE, TRUE, str[(int)strIndex] );
+		    if ( n != -1 ) {
+			if ( str.length() != 1 || i == 0 || (i > 0 && (!maskData[i-1].separator || maskData[i-1].maskChar != str[(int)strIndex])) ) {
+			    s += fill.mid( i, n-i+1 );
+			    i = n + 1; // update i to find + 1
+			}
+		    } else {
+			// search for valid blank if not
+			n = findInMask( i, TRUE, FALSE, str[(int)strIndex] );
+			if ( n != -1 ) {
+			    s += fill.mid( i, n-i );
+			    switch ( maskData[ n ].caseMode ) {
+			    case MaskInputData::Upper:
+				s += str[(int)strIndex].upper();
+				break;
+			    case MaskInputData::Lower:
+				s += str[(int)strIndex].lower();
+				break;
+			    default:
+				s += str[(int)strIndex];
+			    }
+			    i = n + 1; // updates i to find + 1
+			}
+		    }
+		}
+		strIndex++;
+	    }
+	} else
+	    break;
+    }
+
+    return s;
+}
+
+
+
+/*
+  Returns a "cleared" string with only separators and blank chars.
+  Calling this when no inputMask is set is undefined.
+*/
+QString QLineEditPrivate::clearString( uint pos, uint len ) const
+{
+    if ( pos >= (uint)maxLength )
+	return QString::null;
+
+    QString s;
+    int end = QMIN( (uint)maxLength, pos + len );
+    for ( int i=pos; i<end; i++ )
+	if ( maskData[ i ].separator )
+	    s += maskData[ i ].maskChar;
+	else
+	    s += blank;
+
+    return s;
+}
+
+/*
+  Strips blank parts of the input in a QLineEdit when an inputMask is set,
+  separators are still included. Typically "127.0__.0__.1__" becomes "127.0.0.1".
+*/
+QString QLineEditPrivate::stripString( const QString &str ) const
+{
+    if ( !maskData )
+	return str;
+
+    QString s;
+    int end = QMIN( maxLength, (int)str.length() );
+    for (int i=0; i < end; i++ )
+	if ( maskData[ i ].separator )
+	    s += maskData[ i ].maskChar;
+	else
+	    if ( str[i] != blank )
+		s += str[i];
+
+    return s;
+}
+
+/* searches forward/backward in maskData for either a separator or a blank */
+int QLineEditPrivate::findInMask( int pos, bool forward, bool findSeparator, QChar searchChar ) const
+{
+    if ( pos >= maxLength || pos < 0 )
+	return -1;
+
+    int end = forward ? maxLength : -1;
+    int step = forward ? 1 : -1;
+    int i = pos;
+
+    while ( i != end ) {
+	if ( findSeparator ) {
+	    if ( maskData[ i ].separator && maskData[ i ].maskChar == searchChar )
+		return i;
+	} else {
+	    if ( !maskData[ i ].separator ) {
+ 		if ( searchChar.isNull() )
+		    return i;
+ 		else if ( isValidInput( searchChar, maskData[ i ].maskChar ) )
+ 		    return i;
+	    }
+	}
+	i += step;
+    }
+    return -1;
+}
+
+
+#endif // QT_NO_LINEEDIT
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qlineedit.h qt-x11-free-3.3.8b/src/widgets/qlineedit.h
--- qt-x11-free-3.3.8b/src/widgets/qlineedit.h	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qlineedit.h	2009-10-18 14:38:39.325202691 -0700
@@ -200,4 +200,5 @@
 #endif
     void contextMenuEvent( QContextMenuEvent * );
+    bool sendMouseEventToInputContext( QMouseEvent *e );
     virtual QPopupMenu *createPopupMenu();
     void windowActivationChange( bool );
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qlineedit.h.orig qt-x11-free-3.3.8b/src/widgets/qlineedit.h.orig
--- qt-x11-free-3.3.8b/src/widgets/qlineedit.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qlineedit.h.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,231 @@
+/**********************************************************************
+**
+** Definition of QLineEdit widget class
+**
+** Created : 941011
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QLINEEDIT_H
+#define QLINEEDIT_H
+
+struct QLineEditPrivate;
+
+class QValidator;
+class QPopupMenu;
+
+#ifndef QT_H
+#include "qframe.h"
+#include "qstring.h"
+#endif // QT_H
+
+#ifndef QT_NO_LINEEDIT
+
+class QTextParagraph;
+class QTextCursor;
+
+class Q_EXPORT QLineEdit : public QFrame
+{
+    Q_OBJECT
+    Q_ENUMS( EchoMode )
+    Q_PROPERTY( QString text READ text WRITE setText )
+    Q_PROPERTY( int maxLength READ maxLength WRITE setMaxLength )
+    Q_PROPERTY( bool frame READ frame WRITE setFrame )
+    Q_PROPERTY( EchoMode echoMode READ echoMode WRITE setEchoMode )
+    Q_PROPERTY( QString displayText READ displayText )
+    Q_PROPERTY( int cursorPosition READ cursorPosition WRITE setCursorPosition )
+    Q_PROPERTY( Alignment alignment READ alignment WRITE setAlignment )
+    Q_PROPERTY( bool edited READ edited WRITE setEdited DESIGNABLE false )
+    Q_PROPERTY( bool modified READ isModified )
+    Q_PROPERTY( bool hasMarkedText READ hasMarkedText DESIGNABLE false )
+    Q_PROPERTY( bool hasSelectedText READ hasSelectedText )
+    Q_PROPERTY( QString markedText READ markedText DESIGNABLE false )
+    Q_PROPERTY( QString selectedText READ selectedText )
+    Q_PROPERTY( bool dragEnabled READ dragEnabled WRITE setDragEnabled )
+    Q_PROPERTY( bool readOnly READ isReadOnly WRITE setReadOnly )
+    Q_PROPERTY( bool undoAvailable READ isUndoAvailable )
+    Q_PROPERTY( bool redoAvailable READ isRedoAvailable )
+    Q_PROPERTY( QString inputMask READ inputMask WRITE setInputMask )
+    Q_PROPERTY( bool acceptableInput READ hasAcceptableInput )
+
+public:
+    QLineEdit( QWidget* parent, const char* name=0 );
+    QLineEdit( const QString &, QWidget* parent, const char* name=0 );
+    QLineEdit( const QString &, const QString &, QWidget* parent, const char* name=0 );
+    ~QLineEdit();
+
+    QString text() const;
+
+    QString displayText() const;
+
+    int maxLength() const;
+
+    bool frame() const;
+
+    enum EchoMode { Normal, NoEcho, Password };
+    EchoMode echoMode() const;
+
+    bool isReadOnly() const;
+
+    const QValidator * validator() const;
+
+    QSize sizeHint() const;
+    QSize minimumSizeHint() const;
+
+    int cursorPosition() const;
+    bool validateAndSet( const QString &, int, int, int ); // obsolete
+
+    int alignment() const;
+
+#ifndef QT_NO_COMPAT
+    void cursorLeft( bool mark, int steps = 1 ) { cursorForward( mark, -steps ); }
+    void cursorRight( bool mark, int steps = 1 ) { cursorForward( mark, steps ); }
+#endif
+    void cursorForward( bool mark, int steps = 1 );
+    void cursorBackward( bool mark, int steps = 1 );
+    void cursorWordForward( bool mark );
+    void cursorWordBackward( bool mark );
+    void backspace();
+    void del();
+    void home( bool mark );
+    void end( bool mark );
+
+    bool isModified() const;
+    void clearModified();
+
+    bool edited() const; // obsolete, use isModified()
+    void setEdited( bool ); // obsolete, use clearModified()
+
+    bool hasSelectedText() const;
+    QString selectedText() const;
+    int selectionStart() const;
+
+    bool isUndoAvailable() const;
+    bool isRedoAvailable() const;
+
+#ifndef QT_NO_COMPAT
+    bool hasMarkedText() const { return hasSelectedText(); }
+    QString markedText() const { return selectedText(); }
+#endif
+
+    bool dragEnabled() const;
+
+    QString inputMask() const;
+    void setInputMask( const QString &inputMask );
+    bool hasAcceptableInput() const;
+
+public slots:
+    virtual void setText( const QString &);
+    virtual void selectAll();
+    virtual void deselect();
+    virtual void clearValidator();
+    virtual void insert( const QString &);
+    virtual void clear();
+    virtual void undo();
+    virtual void redo();
+    virtual void setMaxLength( int );
+    virtual void setFrame( bool );
+    virtual void setEchoMode( EchoMode );
+    virtual void setReadOnly( bool );
+    virtual void setValidator( const QValidator * );
+    virtual void setFont( const QFont & );
+    virtual void setPalette( const QPalette & );
+    virtual void setSelection( int, int );
+    virtual void setCursorPosition( int );
+    virtual void setAlignment( int flag );
+#ifndef QT_NO_CLIPBOARD
+    virtual void cut();
+    virtual void copy() const;
+    virtual void paste();
+#endif
+    virtual void setDragEnabled( bool b );
+
+signals:
+    void textChanged( const QString &);
+    void returnPressed();
+    void lostFocus();
+    void selectionChanged();
+
+protected:
+    bool event( QEvent * );
+    void mousePressEvent( QMouseEvent * );
+    void mouseMoveEvent( QMouseEvent * );
+    void mouseReleaseEvent( QMouseEvent * );
+    void mouseDoubleClickEvent( QMouseEvent * );
+    void keyPressEvent( QKeyEvent * );
+    void imStartEvent( QIMEvent * );
+    void imComposeEvent( QIMEvent * );
+    void imEndEvent( QIMEvent * );
+    void focusInEvent( QFocusEvent * );
+    void focusOutEvent( QFocusEvent * );
+    void resizeEvent( QResizeEvent * );
+    void drawContents( QPainter * );
+#ifndef QT_NO_DRAGANDDROP
+    void dragEnterEvent( QDragEnterEvent * );
+    void dragMoveEvent( QDragMoveEvent *e );
+    void dragLeaveEvent( QDragLeaveEvent *e );
+    void dropEvent( QDropEvent * );
+#endif
+    void contextMenuEvent( QContextMenuEvent * );
+    virtual QPopupMenu *createPopupMenu();
+    void windowActivationChange( bool );
+#ifndef QT_NO_COMPAT
+    void repaintArea( int, int ) { update(); }
+#endif
+
+private slots:
+    void clipboardChanged();
+
+public:
+    void setPasswordChar( QChar c ); // internal obsolete
+    QChar passwordChar() const; // obsolete internal
+    int characterAt( int, QChar* ) const; // obsolete
+    bool getSelection( int *, int * ); // obsolete
+
+private:
+    friend struct QLineEditPrivate;
+    QLineEditPrivate * d;
+
+private:	// Disabled copy constructor and operator=
+#if defined(Q_DISABLE_COPY)
+    QLineEdit( const QLineEdit & );
+    QLineEdit &operator=( const QLineEdit & );
+#endif
+};
+
+
+#endif // QT_NO_LINEEDIT
+
+#endif // QLINEEDIT_H
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp
--- qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp	2009-10-18 14:38:39.361872979 -0700
@@ -43,4 +43,9 @@
 #ifndef QT_NO_TEXTEDIT
 
+// Keep this position to avoid patch rejection
+#ifndef QT_NO_IM
+#include "qinputcontext.h"
+#endif
+
 #include "../kernel/qrichtext_p.h"
 #include "qpainter.h"
@@ -112,4 +117,6 @@
     int preeditStart;
     int preeditLength;
+    bool composeMode() const { return ( preeditLength > 0 ); }
+
     uint ensureCursorVisibleInShowEvent : 1;
     uint tabChangesFocus : 1;
@@ -1082,4 +1089,8 @@
 	}
     }
+
+    // This invocation is required to follow dragging of active window
+    // by the showed candidate window.
+    updateMicroFocusHint();
 }
 
@@ -1557,4 +1568,33 @@
 
 /*!
+  This function is not intended as polymorphic usage. Just a shared code
+  fragment that calls QWidget::sendMouseEventToInputContext() easily for this
+  class.
+ */
+bool QTextEdit::sendMouseEventToInputContext( QMouseEvent *e )
+{
+#ifndef QT_NO_IM
+    if ( d->composeMode() ) {
+	QTextCursor c( doc );
+	if ( c.place( e->pos(), doc->firstParagraph(), FALSE, FALSE, FALSE ) ) {
+	    int mousePos = c.index() - d->preeditStart;
+	    if ( cursor->globalY() == c.globalY() &&
+		 mousePos >= 0 && mousePos < d->preeditLength ) {
+		QWidget::sendMouseEventToInputContext( mousePos, e->type(),
+						       e->button(), e->state() );
+	    }
+	} else if ( e->type() != QEvent::MouseMove ) {
+	    // send button events on out of preedit
+	    QWidget::sendMouseEventToInputContext( -1, e->type(),
+						   e->button(), e->state() );
+	}
+	return TRUE;
+    }
+#endif
+    return FALSE;
+}
+
+
+/*!
     \reimp
 */
@@ -1586,9 +1626,15 @@
     doc->removeSelection( QTextDocument::IMSelectionText );
 
-    if ( d->preeditLength > 0 && cursor->paragraph() )
+    if ( d->composeMode() && cursor->paragraph() )
 	cursor->paragraph()->remove( d->preeditStart, d->preeditLength );
     cursor->setIndex( d->preeditStart );
     d->preeditLength = e->text().length();
-    insert( e->text() );
+
+    int sellen = e->selectionLength();
+    uint insertionFlags = CheckNewLines | RemoveSelected | AsIMCompositionText;
+    if ( sellen > 0 ) {
+      insertionFlags |= WithIMSelection;
+    }
+    insert( e->text(), insertionFlags );
     // insert can trigger an imEnd event as it emits a textChanged signal, so better
     // be careful
@@ -1609,5 +1655,12 @@
 	    doc->setSelectionStart( QTextDocument::IMSelectionText, *cursor );
 	    doc->setSelectionEnd( QTextDocument::IMSelectionText, c );
+#if 0
+	    // Disabled for Asian input method that shows candidate
+	    // window. This behavior is same as Qt/E 2.3.7 which supports
+	    // Asian input methods. Asian input methods need start point
+	    // of IM selection text to place candidate window as adjacent
+	    // to the selection text.
 	    cursor->setIndex( d->preeditStart + d->preeditLength );
+#endif
 	}
     }
@@ -1633,9 +1686,10 @@
         undoRedoInfo.type = UndoRedoInfo::Invalid;
 
-    if ( d->preeditLength > 0 && cursor->paragraph() )
+    if ( d->composeMode() && cursor->paragraph() )
 	cursor->paragraph()->remove( d->preeditStart, d->preeditLength );
     if ( d->preeditStart >= 0 ) {
         cursor->setIndex( d->preeditStart );
-        insert( e->text() );
+	//TODO: Qt 4 we should use the new virtual insert function
+	insert( e->text(), FALSE );
     }
     d->preeditStart = d->preeditLength = -1;
@@ -2128,4 +2182,11 @@
 	return;
 
+    // Asian users regard selection text as cursor on candidate
+    // selection phase of input method, so ordinary cursor should be
+    // invisible if IM selection text exists.
+    if ( doc->hasSelection( QTextDocument::IMSelectionText ) ) {
+        visible = FALSE;
+    }
+
     QPainter p( viewport() );
     QRect r( cursor->topParagraph()->rect() );
@@ -2202,4 +2263,7 @@
 #endif
 
+    if ( sendMouseEventToInputContext( e ) )
+	return;
+
     if ( d->trippleClickTimer->isActive() &&
 	 ( e->globalPos() - d->trippleClickPoint ).manhattanLength() <
@@ -2307,5 +2371,7 @@
     }
 #endif
-    if ( mousePressed ) {
+    if ( sendMouseEventToInputContext( e ) ) {
+	// don't return from here to avoid cursor vanishing
+    } else if ( mousePressed ) {
 #ifndef QT_NO_DRAGANDDROP
 	if ( mightStartDrag ) {
@@ -2364,5 +2430,5 @@
 void QTextEdit::contentsMouseReleaseEvent( QMouseEvent * e )
 {
-    if ( !inDoubleClick ) { // could be the release of a dblclick
+    if ( !inDoubleClick && !d->composeMode() ) { // could be the release of a dblclick
 	int para = 0;
 	int index = charAt( e->pos(), &para );
@@ -2375,4 +2441,6 @@
     }
 #endif
+    if ( sendMouseEventToInputContext( e ) )
+	return;
     QTextCursor oldCursor = *cursor;
     if ( scrollTimer->isActive() )
@@ -2468,5 +2536,5 @@
 void QTextEdit::contentsMouseDoubleClickEvent( QMouseEvent * e )
 {
-    if ( e->button() != Qt::LeftButton ) {
+    if ( e->button() != Qt::LeftButton && !d->composeMode() ) {
 	e->ignore();
 	return;
@@ -2499,4 +2567,7 @@
 #endif
     {
+	if ( sendMouseEventToInputContext( e ) )
+	    return;
+
 	QTextCursor c1 = *cursor;
 	QTextCursor c2 = *cursor;
@@ -2674,8 +2745,13 @@
 void QTextEdit::contentsContextMenuEvent( QContextMenuEvent *e )
 {
+    e->accept();
+#ifndef QT_NO_IM
+    if ( d->composeMode() )
+	return;
+#endif
+
     clearUndoRedo();
     mousePressed = FALSE;
 
-    e->accept();
 #ifndef QT_NO_POPUPMENU
     QGuardedPtr<QTextEdit> that = this;
@@ -2999,4 +3075,6 @@
     bool checkNewLine = insertionFlags & CheckNewLines;
     bool removeSelected = insertionFlags & RemoveSelected;
+    bool imComposition = insertionFlags & AsIMCompositionText;
+    bool imSelection = insertionFlags & WithIMSelection;
     QString txt( text );
     drawCursor( FALSE );
@@ -3038,5 +3116,8 @@
     repaintChanged();
     ensureCursorVisible();
-    drawCursor( TRUE );
+    // Asian users regard selection text as cursor on candidate
+    // selection phase of input method, so ordinary cursor should be
+    // invisible if IM selection text exists.
+    drawCursor( !imSelection );
 
     if ( undoEnabled && !isReadOnly() && undoRedoInfo.type != UndoRedoInfo::IME ) {
@@ -3060,5 +3141,11 @@
 	repaintChanged();
     }
-    updateMicroFocusHint();
+    // updateMicroFocusHint() should not be invoked here when this
+    // function is invoked from imComposeEvent() because cursor
+    // postion is incorrect yet. imComposeEvent() invokes
+    // updateMicroFocusHint() later.
+    if ( !imComposition ) {
+      updateMicroFocusHint();
+    }
     setModified();
     emit textChanged();
@@ -5572,4 +5659,11 @@
     d->id[ IdSelectAll ] = popup->insertItem( tr( "Select All" ) + ACCEL_KEY( A ) );
 #endif
+
+#ifndef QT_NO_IM
+    QInputContext *qic = getInputContext();
+    if ( qic )
+	qic->addMenusTo( popup );
+#endif
+    
     popup->setItemEnabled( d->id[ IdUndo ], !isReadOnly() && doc->commands()->isUndoAvailable() );
     popup->setItemEnabled( d->id[ IdRedo ], !isReadOnly() && doc->commands()->isRedoAvailable() );
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp.orig qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp.orig
--- qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qtextedit.cpp.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,7367 @@
+/****************************************************************************
+**
+** Implementation of the QTextEdit class
+**
+** Created : 990101
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "qtextedit.h"
+
+#ifndef QT_NO_TEXTEDIT
+
+#include "../kernel/qrichtext_p.h"
+#include "qpainter.h"
+#include "qpen.h"
+#include "qbrush.h"
+#include "qpixmap.h"
+#include "qfont.h"
+#include "qcolor.h"
+#include "qstyle.h"
+#include "qsize.h"
+#include "qevent.h"
+#include "qtimer.h"
+#include "qapplication.h"
+#include "qlistbox.h"
+#include "qvbox.h"
+#include "qapplication.h"
+#include "qclipboard.h"
+#include "qcolordialog.h"
+#include "qfontdialog.h"
+#include "qstylesheet.h"
+#include "qdragobject.h"
+#include "qurl.h"
+#include "qcursor.h"
+#include "qregexp.h"
+#include "qpopupmenu.h"
+#include "qptrstack.h"
+#include "qmetaobject.h"
+#include "qtextbrowser.h"
+#include <private/qucom_p.h>
+#include "private/qsyntaxhighlighter_p.h"
+#include <qguardedptr.h>
+
+#ifndef QT_NO_ACCEL
+#include <qkeysequence.h>
+#define ACCEL_KEY(k) "\t" + QString(QKeySequence( Qt::CTRL | Qt::Key_ ## k ))
+#else
+#define ACCEL_KEY(k) "\t" + QString("Ctrl+" #k)
+#endif
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+#define LOGOFFSET(i) d->logOffset + i
+#endif
+
+struct QUndoRedoInfoPrivate
+{
+    QTextString text;
+};
+
+class QTextEditPrivate
+{
+public:
+    QTextEditPrivate()
+	:preeditStart(-1),preeditLength(-1),ensureCursorVisibleInShowEvent(FALSE),
+	 tabChangesFocus(FALSE),
+#ifndef QT_NO_CLIPBOARD
+	 clipboard_mode( QClipboard::Clipboard ),
+#endif
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+	 od(0), optimMode(FALSE),
+	 maxLogLines(-1),
+	 logOffset(0),
+#endif
+	 autoFormatting( (uint)QTextEdit::AutoAll )
+    {
+	for ( int i=0; i<7; i++ )
+	    id[i] = 0;
+    }
+    int id[ 7 ];
+    int preeditStart;
+    int preeditLength;
+    uint ensureCursorVisibleInShowEvent : 1;
+    uint tabChangesFocus : 1;
+    QString scrollToAnchor; // used to deferr scrollToAnchor() until the show event when we are resized
+    QString pressedName;
+    QString onName;
+#ifndef QT_NO_CLIPBOARD
+    QClipboard::Mode clipboard_mode;
+#endif
+    QTimer *trippleClickTimer;
+    QPoint trippleClickPoint;
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    QTextEditOptimPrivate * od;
+    bool optimMode : 1;
+    int maxLogLines;
+    int logOffset;
+#endif
+    uint autoFormatting;
+};
+
+#ifndef QT_NO_MIME
+class QRichTextDrag : public QTextDrag
+{
+public:
+    QRichTextDrag( QWidget *dragSource = 0, const char *name = 0 );
+
+    void setPlainText( const QString &txt ) { setText( txt ); }
+    void setRichText( const QString &txt ) { richTxt = txt; }
+
+    virtual QByteArray encodedData( const char *mime ) const;
+    virtual const char* format( int i ) const;
+
+    static bool decode( QMimeSource *e, QString &str, const QCString &mimetype,
+			const QCString &subtype );
+    static bool canDecode( QMimeSource* e );
+
+private:
+    QString richTxt;
+
+};
+
+QRichTextDrag::QRichTextDrag( QWidget *dragSource, const char *name )
+    : QTextDrag( dragSource, name )
+{
+}
+
+QByteArray QRichTextDrag::encodedData( const char *mime ) const
+{
+    if ( qstrcmp( "application/x-qrichtext", mime ) == 0 ) {
+	return richTxt.utf8(); // #### perhaps we should use USC2 instead?
+    } else
+	return QTextDrag::encodedData( mime );
+}
+
+bool QRichTextDrag::decode( QMimeSource *e, QString &str, const QCString &mimetype,
+			    const QCString &subtype )
+{
+    if ( mimetype == "application/x-qrichtext" ) {
+	// do richtext decode
+	const char *mime;
+	int i;
+	for ( i = 0; ( mime = e->format( i ) ); ++i ) {
+	    if ( qstrcmp( "application/x-qrichtext", mime ) != 0 )
+		continue;
+	    str = QString::fromUtf8( e->encodedData( mime ) );
+	    return TRUE;
+	}
+	return FALSE;
+    }
+
+    // do a regular text decode
+    QCString subt = subtype;
+    return QTextDrag::decode( e, str, subt );
+}
+
+bool QRichTextDrag::canDecode( QMimeSource* e )
+{
+    if ( e->provides( "application/x-qrichtext" ) )
+	return TRUE;
+    return QTextDrag::canDecode( e );
+}
+
+const char* QRichTextDrag::format( int i ) const
+{
+    if ( QTextDrag::format( i ) )
+	return QTextDrag::format( i );
+    if ( QTextDrag::format( i-1 ) )
+	return "application/x-qrichtext";
+    return 0;
+}
+
+#endif
+
+static bool block_set_alignment = FALSE;
+
+/*!
+    \class QTextEdit qtextedit.h
+    \brief The QTextEdit widget provides a powerful single-page rich text editor.
+
+    \ingroup basic
+    \ingroup text
+    \mainclass
+
+    \tableofcontents
+
+    \section1 Introduction and Concepts
+
+    QTextEdit is an advanced WYSIWYG viewer/editor supporting rich
+    text formatting using HTML-style tags. It is optimized to handle
+    large documents and to respond quickly to user input.
+
+    QTextEdit has four modes of operation:
+    \table
+    \header \i Mode \i Command \i Notes
+    \row \i Plain Text Editor \i setTextFormat(PlainText)
+	 \i Set text with setText(); text() returns plain text. Text
+	 attributes (e.g. colors) can be set, but plain text is always
+	 returned.
+    \row \i Rich Text Editor \i setTextFormat(RichText)
+	 \i Set text with setText(); text() returns rich text. Rich
+	 text editing is fairly limited. You can't set margins or
+	 insert images for example (although you can read and
+	 correctly display files that have margins set and that
+	 include images). This mode is mostly useful for editing small
+	 amounts of rich text. <sup>1.</sup>
+    \row \i Text Viewer \i setReadOnly(TRUE)
+         \i Set text with setText() or append() (which has no undo
+	 history so is faster and uses less memory); text() returns
+	 plain or rich text depending on the textFormat(). This mode
+	 can correctly display a large subset of HTML tags.
+    \row \i Log Viewer \i setTextFormat(LogText)
+	 \i Append text using append(). The widget is set to be read
+	 only and rich text support is disabled although a few HTML
+	 tags (for color, bold, italic and underline) may be used.
+	 (See \link #logtextmode LogText mode\endlink for details.)
+    \endtable
+
+    <sup>1.</sup><small>A more complete API that supports setting
+    margins, images, etc., is planned for a later Qt release.</small>
+
+    QTextEdit can be used as a syntax highlighting editor when used in
+    conjunction with QSyntaxHighlighter.
+
+    We recommend that you always call setTextFormat() to set the mode
+    you want to use. If you use \c AutoText then setText() and
+    append() will try to determine whether the text they are given is
+    plain text or rich text. If you use \c RichText then setText() and
+    append() will assume that the text they are given is rich text.
+    insert() simply inserts the text it is given.
+
+    QTextEdit works on paragraphs and characters. A paragraph is a
+    formatted string which is word-wrapped to fit into the width of
+    the widget. By default when reading plain text, one newline
+    signify a paragraph. A document consists of zero or more
+    paragraphs, indexed from 0. Characters are indexed on a
+    per-paragraph basis, also indexed from 0. The words in the
+    paragraph are aligned in accordance with the paragraph's
+    alignment(). Paragraphs are separated by hard line breaks. Each
+    character within a paragraph has its own attributes, for example,
+    font and color.
+
+    The text edit documentation uses the following concepts:
+    \list
+    \i \e{current format} --
+    this is the format at the current cursor position, \e and it
+    is the format of the selected text if any.
+    \i \e{current paragraph} -- the paragraph which contains the
+    cursor.
+    \endlist
+
+    QTextEdit can display images (using QMimeSourceFactory), lists and
+    tables. If the text is too large to view within the text edit's
+    viewport, scrollbars will appear. The text edit can load both
+    plain text and HTML files (a subset of HTML 3.2 and 4). The
+    rendering style and the set of valid tags are defined by a
+    styleSheet(). Custom tags can be created and placed in a custom
+    style sheet. Change the style sheet with \l{setStyleSheet()}; see
+    QStyleSheet for details. The images identified by image tags are
+    displayed if they can be interpreted using the text edit's
+    \l{QMimeSourceFactory}; see setMimeSourceFactory().
+
+    If you want a text browser with more navigation use QTextBrowser.
+    If you just need to display a small piece of rich text use QLabel
+    or QSimpleRichText.
+
+    If you create a new QTextEdit, and want to allow the user to edit
+    rich text, call setTextFormat(Qt::RichText) to ensure that the
+    text is treated as rich text. (Rich text uses HTML tags to set
+    text formatting attributes. See QStyleSheet for information on the
+    HTML tags that are supported.). If you don't call setTextFormat()
+    explicitly the text edit will guess from the text itself whether
+    it is rich text or plain text. This means that if the text looks
+    like HTML or XML it will probably be interpreted as rich text, so
+    you should call setTextFormat(Qt::PlainText) to preserve such
+    text.
+
+    Note that we do not intend to add a full-featured web browser
+    widget to Qt (because that would easily double Qt's size and only
+    a few applications would benefit from it). The rich
+    text support in Qt is designed to provide a fast, portable and
+    efficient way to add reasonable online help facilities to
+    applications, and to provide a basis for rich text editors.
+
+    \section1 Using QTextEdit as a Display Widget
+
+    QTextEdit can display a large HTML subset, including tables and
+    images.
+
+    The text is set or replaced using setText() which deletes any
+    existing text and replaces it with the text passed in the
+    setText() call. If you call setText() with legacy HTML (with
+    setTextFormat(RichText) in force), and then call text(), the text
+    that is returned may have different markup, but will render the
+    same. Text can be inserted with insert(), paste(), pasteSubType()
+    and append(). Text that is appended does not go into the undo
+    history; this makes append() faster and consumes less memory. Text
+    can also be cut(). The entire text is deleted with clear() and the
+    selected text is deleted with removeSelectedText(). Selected
+    (marked) text can also be deleted with del() (which will delete
+    the character to the right of the cursor if no text is selected).
+
+    Loading and saving text is achieved using setText() and text(),
+    for example:
+    \code
+    QFile file( fileName ); // Read the text from a file
+    if ( file.open( IO_ReadOnly ) ) {
+	QTextStream stream( &file );
+	textEdit->setText( stream.read() );
+    }
+
+    QFile file( fileName ); // Write the text to a file
+    if ( file.open( IO_WriteOnly ) ) {
+	QTextStream stream( &file );
+	stream << textEdit->text();
+	textEdit->setModified( FALSE );
+    }
+    \endcode
+
+    By default the text edit wraps words at whitespace to fit within
+    the text edit widget. The setWordWrap() function is used to
+    specify the kind of word wrap you want, or \c NoWrap if you don't
+    want any wrapping. Call setWordWrap() to set a fixed pixel width
+    \c FixedPixelWidth, or character column (e.g. 80 column) \c
+    FixedColumnWidth with the pixels or columns specified with
+    setWrapColumnOrWidth(). If you use word wrap to the widget's width
+    \c WidgetWidth, you can specify whether to break on whitespace or
+    anywhere with setWrapPolicy().
+
+    The background color is set differently than other widgets, using
+    setPaper(). You specify a brush style which could be a plain color
+    or a complex pixmap.
+
+    Hypertext links are automatically underlined; this can be changed
+    with setLinkUnderline(). The tab stop width is set with
+    setTabStopWidth().
+
+    The zoomIn() and zoomOut() functions can be used to resize the
+    text by increasing (decreasing for zoomOut()) the point size used.
+    Images are not affected by the zoom functions.
+
+    The lines() function returns the number of lines in the text and
+    paragraphs() returns the number of paragraphs. The number of lines
+    within a particular paragraph is returned by linesOfParagraph().
+    The length of the entire text in characters is returned by
+    length().
+
+    You can scroll to an anchor in the text, e.g.
+    \c{<a name="anchor">} with scrollToAnchor(). The find() function
+    can be used to find and select a given string within the text.
+
+    A read-only QTextEdit provides the same functionality as the
+    (obsolete) QTextView. (QTextView is still supplied for
+    compatibility with old code.)
+
+    \section2 Read-only key bindings
+
+    When QTextEdit is used read-only the key-bindings are limited to
+    navigation, and text may only be selected with the mouse:
+    \table
+    \header \i Keypresses \i Action
+    \row \i UpArrow	\i Move one line up
+    \row \i DownArrow	\i Move one line down
+    \row \i LeftArrow	\i Move one character left
+    \row \i RightArrow	\i Move one character right
+    \row \i PageUp	\i Move one (viewport) page up
+    \row \i PageDown	\i Move one (viewport) page down
+    \row \i Home	\i Move to the beginning of the text
+    \row \i End		\i Move to the end of the text
+    \row \i Shift+Wheel
+	 \i Scroll the page horizontally (the Wheel is the mouse wheel)
+    \row \i Ctrl+Wheel	\i Zoom the text
+    \endtable
+
+    The text edit may be able to provide some meta-information. For
+    example, the documentTitle() function will return the text from
+    within HTML \c{<title>} tags.
+
+    The text displayed in a text edit has a \e context. The context is
+    a path which the text edit's QMimeSourceFactory uses to resolve
+    the locations of files and images. It is passed to the
+    mimeSourceFactory() when quering data. (See QTextEdit() and
+    \l{context()}.)
+
+    \target logtextmode
+    \section2 Using QTextEdit in LogText Mode
+
+    Setting the text format to \c LogText puts the widget in a special
+    mode which is optimized for very large texts. Editing, word wrap,
+    and rich text support are disabled in this mode (the widget is
+    explicitly made read-only). This allows the text to be stored in a
+    different, more memory efficient manner. However, a certain degree
+    of text formatting is supported through the use of formatting tags.
+    A tag is delimited by \c < and \c {>}. The characters \c {<}, \c >
+    and \c & are escaped by using \c {&lt;}, \c {&gt;} and \c {&amp;}.
+    A tag pair consists of a left and a right tag (or open/close tags).
+    Left-tags mark the starting point for formatting, while right-tags
+    mark the ending point. A right-tag always start with a \c / before
+    the tag keyword. For example \c <b> and \c </b> are a tag pair.
+    Tags can be nested, but they have to be closed in the same order as
+    they are opened. For example, \c <b><u></u></b> is valid, while \c
+    <b><u></b></u> will output an error message.
+
+    By using tags it is possible to change the color, bold, italic and
+    underline settings for a piece of text. A color can be specified
+    by using the HTML font tag \c {<font color=colorname>}. The color
+    name can be one of the color names from the X11 color database, or
+    a RGB hex value (e.g \c {#00ff00}). Example of valid color tags:
+    \c {<font color=red>}, \c {<font color="light blue">}, \c {<font
+    color="#223344">}. Bold, italic and underline settings can be
+    specified by the tags \c {<b>}, \c <i> and \c {<u>}. Note that a
+    tag does not necessarily have to be closed. A valid example:
+    \code
+    This is <font color=red>red</font> while <b>this</b> is <font color=blue>blue</font>.
+    <font color=green><font color=yellow>Yellow,</font> and <u>green</u>.
+    \endcode
+
+    Stylesheets can also be used in LogText mode. To create and use a
+    custom tag, you could do the following:
+    \code
+    QTextEdit * log = new QTextEdit( this );
+    log->setTextFormat( Qt::LogText );
+    QStyleSheetItem * item = new QStyleSheetItem( log->styleSheet(), "mytag" );
+    item->setColor( "red" );
+    item->setFontWeight( QFont::Bold );
+    item->setFontUnderline( TRUE );
+    log->append( "This is a <mytag>custom tag</mytag>!" );
+    \endcode
+    Note that only the color, bold, underline and italic attributes of
+    a QStyleSheetItem is used in LogText mode.
+
+    Note that you can use setMaxLogLines() to limit the number of
+    lines the widget can hold in LogText mode.
+
+    There are a few things that you need to be aware of when the
+    widget is in this mode:
+    \list
+    \i Functions that deal with rich text formatting and cursor
+    movement will not work or return anything valid.
+    \i Lines are equivalent to paragraphs.
+    \endlist
+
+    \section1 Using QTextEdit as an Editor
+
+    All the information about using QTextEdit as a display widget also
+    applies here.
+
+    The current format's attributes are set with setItalic(),
+    setBold(), setUnderline(), setFamily() (font family),
+    setPointSize(), setColor() and setCurrentFont(). The current
+    paragraph's alignment is set with setAlignment().
+
+    Use setSelection() to select text. The setSelectionAttributes()
+    function is used to indicate how selected text should be
+    displayed. Use hasSelectedText() to find out if any text is
+    selected. The currently selected text's position is available
+    using getSelection() and the selected text itself is returned by
+    selectedText(). The selection can be copied to the clipboard with
+    copy(), or cut to the clipboard with cut(). It can be deleted with
+    removeSelectedText(). The entire text can be selected (or
+    unselected) using selectAll(). QTextEdit supports multiple
+    selections. Most of the selection functions operate on the default
+    selection, selection 0. If the user presses a non-selecting key,
+    e.g. a cursor key without also holding down Shift, all selections
+    are cleared.
+
+    Set and get the position of the cursor with setCursorPosition()
+    and getCursorPosition() respectively. When the cursor is moved,
+    the signals currentFontChanged(), currentColorChanged() and
+    currentAlignmentChanged() are emitted to reflect the font, color
+    and alignment at the new cursor position.
+
+    If the text changes, the textChanged() signal is emitted, and if
+    the user inserts a new line by pressing Return or Enter,
+    returnPressed() is emitted. The isModified() function will return
+    TRUE if the text has been modified.
+
+    QTextEdit provides command-based undo and redo. To set the depth
+    of the command history use setUndoDepth() which defaults to 100
+    steps. To undo or redo the last operation call undo() or redo().
+    The signals undoAvailable() and redoAvailable() indicate whether
+    the undo and redo operations can be executed.
+
+    The indent() function is used to reindent a paragraph. It is
+    useful for code editors, for example in \link designer-manual.book
+    Qt Designer\endlink's code editor \e{Ctrl+I} invokes the indent()
+    function.
+
+    \section2 Editing key bindings
+
+    The list of key-bindings which are implemented for editing:
+    \table
+    \header \i Keypresses \i Action
+    \row \i Backspace \i Delete the character to the left of the cursor
+    \row \i Delete \i Delete the character to the right of the cursor
+    \row \i Ctrl+A \i Move the cursor to the beginning of the line
+    \row \i Ctrl+B \i Move the cursor one character left
+    \row \i Ctrl+C \i Copy the marked text to the clipboard (also
+		      Ctrl+Insert under Windows)
+    \row \i Ctrl+D \i Delete the character to the right of the cursor
+    \row \i Ctrl+E \i Move the cursor to the end of the line
+    \row \i Ctrl+F \i Move the cursor one character right
+    \row \i Ctrl+H \i Delete the character to the left of the cursor
+    \row \i Ctrl+K \i Delete to end of line
+    \row \i Ctrl+N \i Move the cursor one line down
+    \row \i Ctrl+P \i Move the cursor one line up
+    \row \i Ctrl+V \i Paste the clipboard text into line edit
+		      (also Shift+Insert under Windows)
+    \row \i Ctrl+X \i Cut the marked text, copy to clipboard
+		      (also Shift+Delete under Windows)
+    \row \i Ctrl+Z \i Undo the last operation
+    \row \i Ctrl+Y \i Redo the last operation
+    \row \i LeftArrow	    \i Move the cursor one character left
+    \row \i Ctrl+LeftArrow  \i Move the cursor one word left
+    \row \i RightArrow	    \i Move the cursor one character right
+    \row \i Ctrl+RightArrow \i Move the cursor one word right
+    \row \i UpArrow	    \i Move the cursor one line up
+    \row \i Ctrl+UpArrow    \i Move the cursor one word up
+    \row \i DownArrow	    \i Move the cursor one line down
+    \row \i Ctrl+Down Arrow \i Move the cursor one word down
+    \row \i PageUp	    \i Move the cursor one page up
+    \row \i PageDown	    \i Move the cursor one page down
+    \row \i Home	    \i Move the cursor to the beginning of the line
+    \row \i Ctrl+Home	    \i Move the cursor to the beginning of the text
+    \row \i End		    \i Move the cursor to the end of the line
+    \row \i Ctrl+End	    \i Move the cursor to the end of the text
+    \row \i Shift+Wheel	    \i Scroll the page horizontally
+			    (the Wheel is the mouse wheel)
+    \row \i Ctrl+Wheel	    \i Zoom the text
+    \endtable
+
+    To select (mark) text hold down the Shift key whilst pressing one
+    of the movement keystrokes, for example, \e{Shift+Right Arrow}
+    will select the character to the right, and \e{Shift+Ctrl+Right
+    Arrow} will select the word to the right, etc.
+
+    By default the text edit widget operates in insert mode so all
+    text that the user enters is inserted into the text edit and any
+    text to the right of the cursor is moved out of the way. The mode
+    can be changed to overwrite, where new text overwrites any text to
+    the right of the cursor, using setOverwriteMode().
+*/
+
+/*!
+    \enum QTextEdit::AutoFormatting
+
+    \value AutoNone Do not perform any automatic formatting
+    \value AutoBulletList Only automatically format bulletted lists
+    \value AutoAll Apply all available autoformatting
+*/
+
+
+/*!
+    \enum QTextEdit::KeyboardAction
+
+    This enum is used by doKeyboardAction() to specify which action
+    should be executed:
+
+    \value ActionBackspace  Delete the character to the left of the
+    cursor.
+
+    \value ActionDelete  Delete the character to the right of the
+    cursor.
+
+    \value ActionReturn  Split the paragraph at the cursor position.
+
+    \value ActionKill If the cursor is not at the end of the
+    paragraph, delete the text from the cursor position until the end
+    of the paragraph. If the cursor is at the end of the paragraph,
+    delete the hard line break at the end of the paragraph: this will
+    cause this paragraph to be joined with the following paragraph.
+
+    \value ActionWordBackspace Delete the word to the left of the
+    cursor position.
+
+    \value ActionWordDelete Delete the word to the right of the
+    cursor position
+
+*/
+
+/*!
+    \enum QTextEdit::VerticalAlignment
+
+    This enum is used to set the vertical alignment of the text.
+
+    \value AlignNormal Normal alignment
+    \value AlignSuperScript Superscript
+    \value AlignSubScript Subscript
+*/
+
+/*!
+    \enum QTextEdit::TextInsertionFlags
+
+    \internal
+
+    \value RedoIndentation
+    \value CheckNewLines
+    \value RemoveSelected
+*/
+
+
+/*!
+    \fn void QTextEdit::copyAvailable(bool yes)
+
+    This signal is emitted when text is selected or de-selected in the
+    text edit.
+
+    When text is selected this signal will be emitted with \a yes set
+    to TRUE. If no text has been selected or if the selected text is
+    de-selected this signal is emitted with \a yes set to FALSE.
+
+    If \a yes is TRUE then copy() can be used to copy the selection to
+    the clipboard. If \a yes is FALSE then copy() does nothing.
+
+    \sa selectionChanged()
+*/
+
+
+/*!
+    \fn void QTextEdit::textChanged()
+
+    This signal is emitted whenever the text in the text edit changes.
+
+    \sa setText() append()
+*/
+
+/*!
+    \fn void QTextEdit::selectionChanged()
+
+    This signal is emitted whenever the selection changes.
+
+    \sa setSelection() copyAvailable()
+*/
+
+/*!  \fn QTextDocument *QTextEdit::document() const
+
+    \internal
+
+  This function returns the QTextDocument which is used by the text
+  edit.
+*/
+
+/*!  \fn void QTextEdit::setDocument( QTextDocument *doc )
+
+    \internal
+
+  This function sets the QTextDocument which should be used by the text
+  edit to \a doc. This can be used, for example, if you want to
+  display a document using multiple views. You would create a
+  QTextDocument and set it to the text edits which should display it.
+  You would need to connect to the textChanged() and
+  selectionChanged() signals of all the text edits and update them all
+  accordingly (preferably with a slight delay for efficiency reasons).
+*/
+
+/*!
+    \enum QTextEdit::CursorAction
+
+    This enum is used by moveCursor() to specify in which direction
+    the cursor should be moved:
+
+    \value MoveBackward  Moves the cursor one character backward
+
+    \value MoveWordBackward Moves the cursor one word backward
+
+    \value MoveForward  Moves the cursor one character forward
+
+    \value MoveWordForward Moves the cursor one word forward
+
+    \value MoveUp  Moves the cursor up one line
+
+    \value MoveDown  Moves the cursor down one line
+
+    \value MoveLineStart  Moves the cursor to the beginning of the line
+
+    \value MoveLineEnd Moves the cursor to the end of the line
+
+    \value MoveHome  Moves the cursor to the beginning of the document
+
+    \value MoveEnd Moves the cursor to the end of the document
+
+    \value MovePgUp  Moves the cursor one viewport page up
+
+    \value MovePgDown  Moves the cursor one viewport page down
+*/
+
+/*!
+  \enum Qt::AnchorAttribute
+
+  An anchor has one or more of the following attributes:
+
+  \value AnchorName the name attribute of the anchor. This attribute is
+  used when scrolling to an anchor in the document.
+
+  \value AnchorHref the href attribute of the anchor. This attribute is
+  used when a link is clicked to determine what content to load.
+*/
+
+/*!
+    \property QTextEdit::overwriteMode
+    \brief the text edit's overwrite mode
+
+    If FALSE (the default) characters entered by the user are inserted
+    with any characters to the right being moved out of the way. If
+    TRUE, the editor is in overwrite mode, i.e. characters entered by
+    the user overwrite any characters to the right of the cursor
+    position.
+*/
+
+/*!
+    \fn void QTextEdit::setCurrentFont( const QFont &f )
+
+    Sets the font of the current format to \a f.
+
+    If the widget is in \c LogText mode this function will do
+    nothing. Use setFont() instead.
+
+    \sa currentFont() setPointSize() setFamily()
+*/
+
+/*!
+    \property QTextEdit::undoDepth
+    \brief the depth of the undo history
+
+    The maximum number of steps in the undo/redo history. The default
+    is 100.
+
+    \sa undo() redo()
+*/
+
+/*!
+    \fn void QTextEdit::undoAvailable( bool yes )
+
+    This signal is emitted when the availability of undo changes. If
+    \a yes is TRUE, then undo() will work until undoAvailable( FALSE )
+    is next emitted.
+
+    \sa undo() undoDepth()
+*/
+
+/*!
+    \fn void QTextEdit::modificationChanged( bool m )
+
+    This signal is emitted when the modification status of the
+    document has changed. If \a m is TRUE, the document was modified,
+    otherwise the modification state has been reset to unmodified.
+
+    \sa modified
+*/
+
+/*!
+    \fn void QTextEdit::redoAvailable( bool yes )
+
+    This signal is emitted when the availability of redo changes. If
+    \a yes is TRUE, then redo() will work until redoAvailable( FALSE )
+    is next emitted.
+
+    \sa redo() undoDepth()
+*/
+
+/*!
+    \fn void QTextEdit::currentFontChanged( const QFont &f )
+
+    This signal is emitted if the font of the current format has
+    changed.
+
+    The new font is \a f.
+
+    \sa setCurrentFont()
+*/
+
+/*!
+    \fn void QTextEdit::currentColorChanged( const QColor &c )
+
+    This signal is emitted if the color of the current format has
+    changed.
+
+    The new color is \a c.
+
+    \sa setColor()
+*/
+
+/*!
+    \fn void QTextEdit::currentVerticalAlignmentChanged( VerticalAlignment a )
+
+    This signal is emitted if the vertical alignment of the current
+    format has changed.
+
+    The new vertical alignment is \a a.
+
+    \sa setVerticalAlignment()
+*/
+
+/*!
+    \fn void QTextEdit::currentAlignmentChanged( int a )
+
+    This signal is emitted if the alignment of the current paragraph
+    has changed.
+
+    The new alignment is \a a.
+
+    \sa setAlignment()
+*/
+
+/*!
+    \fn void QTextEdit::cursorPositionChanged( QTextCursor *c )
+
+    \internal
+*/
+
+/*!
+    \fn void QTextEdit::cursorPositionChanged( int para, int pos )
+
+    This signal is emitted if the position of the cursor has changed.
+    \a para contains the paragraph index and \a pos contains the
+    character position within the paragraph.
+
+    \sa setCursorPosition()
+*/
+
+/*!
+    \fn void QTextEdit::clicked( int para, int pos )
+
+    This signal is emitted when the mouse is clicked on the paragraph
+    \a para at character position \a pos.
+
+    \sa doubleClicked()
+*/
+
+/*! \fn void QTextEdit::doubleClicked( int para, int pos )
+
+  This signal is emitted when the mouse is double-clicked on the
+  paragraph \a para at character position \a pos.
+
+  \sa clicked()
+*/
+
+
+/*!
+    \fn void QTextEdit::returnPressed()
+
+    This signal is emitted if the user pressed the Return or the Enter
+    key.
+*/
+
+/*!
+    \fn QTextCursor *QTextEdit::textCursor() const
+
+    Returns the text edit's text cursor.
+
+    \warning QTextCursor is not in the public API, but in special
+    circumstances you might wish to use it.
+*/
+
+/*!
+    Constructs an empty QTextEdit called \a name, with parent \a
+    parent.
+*/
+
+QTextEdit::QTextEdit( QWidget *parent, const char *name )
+    : QScrollView( parent, name, WStaticContents | WNoAutoErase ),
+      doc( new QTextDocument( 0 ) ), undoRedoInfo( doc )
+{
+    init();
+}
+
+/*!
+    Constructs a QTextEdit called \a name, with parent \a parent. The
+    text edit will display the text \a text using context \a context.
+
+    The \a context is a path which the text edit's QMimeSourceFactory
+    uses to resolve the locations of files and images. It is passed to
+    the mimeSourceFactory() when quering data.
+
+    For example if the text contains an image tag,
+    \c{<img src="image.png">}, and the context is "path/to/look/in", the
+    QMimeSourceFactory will try to load the image from
+    "path/to/look/in/image.png". If the tag was
+    \c{<img src="/image.png">}, the context will not be used (because
+    QMimeSourceFactory recognizes that we have used an absolute path)
+    and will try to load "/image.png". The context is applied in exactly
+    the same way to \e hrefs, for example,
+    \c{<a href="target.html">Target</a>}, would resolve to
+    "path/to/look/in/target.html".
+*/
+
+QTextEdit::QTextEdit( const QString& text, const QString& context,
+		      QWidget *parent, const char *name)
+    : QScrollView( parent, name, WStaticContents | WNoAutoErase ),
+      doc( new QTextDocument( 0 ) ), undoRedoInfo( doc )
+{
+    init();
+    setText( text, context );
+}
+
+/*!
+    \reimp
+*/
+
+QTextEdit::~QTextEdit()
+{
+    delete undoRedoInfo.d;
+    undoRedoInfo.d = 0;
+    delete cursor;
+    delete doc;
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	delete d->od;
+#endif
+    delete d;
+}
+
+void QTextEdit::init()
+{
+    d = new QTextEditPrivate;
+    doc->formatCollection()->setPaintDevice( this );
+    undoEnabled = TRUE;
+    readonly = TRUE;
+    setReadOnly( FALSE );
+    setFrameStyle( LineEditPanel | Sunken );
+    connect( doc, SIGNAL( minimumWidthChanged(int) ),
+	     this, SLOT( documentWidthChanged(int) ) );
+
+    mousePressed = FALSE;
+    inDoubleClick = FALSE;
+    modified = FALSE;
+    onLink = QString::null;
+    d->onName = QString::null;
+    overWrite = FALSE;
+    wrapMode = WidgetWidth;
+    wrapWidth = -1;
+    wPolicy = AtWhiteSpace;
+    inDnD = FALSE;
+    doc->setFormatter( new QTextFormatterBreakWords );
+    doc->formatCollection()->defaultFormat()->setFont( QScrollView::font() );
+    doc->formatCollection()->defaultFormat()->setColor( colorGroup().color( QColorGroup::Text ) );
+    currentFormat = doc->formatCollection()->defaultFormat();
+    currentAlignment = Qt::AlignAuto;
+
+    setBackgroundMode( PaletteBase );
+    viewport()->setBackgroundMode( PaletteBase );
+    viewport()->setAcceptDrops( TRUE );
+    resizeContents( 0, doc->lastParagraph() ?
+		    ( doc->lastParagraph()->paragId() + 1 ) * doc->formatCollection()->defaultFormat()->height() : 0 );
+
+    setKeyCompression( TRUE );
+    viewport()->setMouseTracking( TRUE );
+#ifndef QT_NO_CURSOR
+    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+    cursor = new QTextCursor( doc );
+
+    formatTimer = new QTimer( this );
+    connect( formatTimer, SIGNAL( timeout() ),
+	     this, SLOT( formatMore() ) );
+    lastFormatted = doc->firstParagraph();
+
+    scrollTimer = new QTimer( this );
+    connect( scrollTimer, SIGNAL( timeout() ),
+	     this, SLOT( autoScrollTimerDone() ) );
+
+    interval = 0;
+    changeIntervalTimer = new QTimer( this );
+    connect( changeIntervalTimer, SIGNAL( timeout() ),
+	     this, SLOT( doChangeInterval() ) );
+
+    cursorVisible = TRUE;
+    blinkTimer = new QTimer( this );
+    connect( blinkTimer, SIGNAL( timeout() ),
+	     this, SLOT( blinkCursor() ) );
+
+#ifndef QT_NO_DRAGANDDROP
+    dragStartTimer = new QTimer( this );
+    connect( dragStartTimer, SIGNAL( timeout() ),
+	     this, SLOT( startDrag() ) );
+#endif
+
+    d->trippleClickTimer = new QTimer( this );
+
+    formatMore();
+
+    blinkCursorVisible = FALSE;
+
+    viewport()->setFocusProxy( this );
+    viewport()->setFocusPolicy( WheelFocus );
+    setInputMethodEnabled( TRUE );
+    viewport()->installEventFilter( this );
+    connect( this, SIGNAL(horizontalSliderReleased()), this, SLOT(sliderReleased()) );
+    connect( this, SIGNAL(verticalSliderReleased()), this, SLOT(sliderReleased()) );
+    installEventFilter( this );
+}
+
+void QTextEdit::paintDocument( bool drawAll, QPainter *p, int cx, int cy, int cw, int ch )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    Q_ASSERT( !d->optimMode );
+    if ( d->optimMode )
+	return;
+#endif
+
+    bool drawCur = hasFocus() || viewport()->hasFocus();
+    if (( hasSelectedText() && !style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ) ) ||
+	isReadOnly() || !cursorVisible || doc->hasSelection( QTextDocument::IMSelectionText ))
+	drawCur = FALSE;
+    QColorGroup g = colorGroup();
+    const QColorGroup::ColorRole backRole = QPalette::backgroundRoleFromMode(backgroundMode());
+    if ( doc->paper() )
+	g.setBrush( backRole, *doc->paper() );
+
+    if ( contentsY() < doc->y() ) {
+	p->fillRect( contentsX(), contentsY(), visibleWidth(), doc->y(),
+		     g.brush( backRole ) );
+    }
+    if ( drawAll && doc->width() - contentsX() < cx + cw ) {
+	p->fillRect( doc->width() - contentsX(), cy, cx + cw - doc->width() + contentsX(), ch,
+		     g.brush( backRole ) );
+    }
+
+    p->setBrushOrigin( -contentsX(), -contentsY() );
+
+    lastFormatted = doc->draw( p, cx, cy, cw, ch, g, !drawAll, drawCur, cursor );
+
+    if ( lastFormatted == doc->lastParagraph() )
+	resizeContents( contentsWidth(), doc->height() );
+
+    if ( contentsHeight() < visibleHeight() && ( !doc->lastParagraph() || doc->lastParagraph()->isValid() ) && drawAll )
+	p->fillRect( 0, contentsHeight(), visibleWidth(),
+		     visibleHeight() - contentsHeight(), g.brush( backRole ) );
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::drawContents( QPainter *p, int cx, int cy, int cw, int ch )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimDrawContents( p, cx, cy, cw, ch );
+	return;
+    }
+#endif
+    paintDocument( TRUE, p, cx, cy, cw, ch );
+    int v;
+    p->setPen( foregroundColor() );
+    if ( document()->isPageBreakEnabled() &&  ( v = document()->flow()->pageSize() ) > 0 ) {
+	int l = int(cy / v) * v;
+	while ( l < cy + ch ) {
+	    p->drawLine( cx, l, cx + cw - 1, l );
+	    l += v;
+	}
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::drawContents( QPainter *p )
+{
+    if ( horizontalScrollBar()->isVisible() &&
+	 verticalScrollBar()->isVisible() ) {
+	const QRect verticalRect = verticalScrollBar()->geometry();
+	const QRect horizontalRect = horizontalScrollBar()->geometry();
+
+	QRect cornerRect;
+	cornerRect.setTop( verticalRect.bottom() );
+	cornerRect.setBottom( horizontalRect.bottom() );
+	cornerRect.setLeft( verticalRect.left() );
+	cornerRect.setRight( verticalRect.right() );
+
+	p->fillRect( cornerRect, colorGroup().background() );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+bool QTextEdit::event( QEvent *e )
+{
+    if ( e->type() == QEvent::AccelOverride && !isReadOnly() ) {
+	QKeyEvent* ke = (QKeyEvent*) e;
+	switch(ke->state()) {
+	case NoButton:
+	case Keypad:
+	case ShiftButton:
+	    if ( ke->key() < Key_Escape ) {
+		ke->accept();
+	    } else {
+		switch ( ke->key() ) {
+		case Key_Return:
+		case Key_Enter:
+		case Key_Delete:
+		case Key_Home:
+		case Key_End:
+		case Key_Backspace:
+		case Key_Left:
+		case Key_Right:
+		    ke->accept();
+		default:
+		    break;
+		}
+	    }
+	    break;
+
+	case ControlButton:
+	case ControlButton|ShiftButton:
+	case ControlButton|Keypad:
+	case ControlButton|ShiftButton|Keypad:
+	    switch ( ke->key() ) {
+	    case Key_Tab:
+	    case Key_Backtab:
+		ke->ignore();
+		break;
+// Those are too frequently used for application functionality
+/*	    case Key_A:
+	    case Key_B:
+	    case Key_D:
+	    case Key_E:
+	    case Key_F:
+	    case Key_H:
+	    case Key_I:
+	    case Key_K:
+	    case Key_N:
+	    case Key_P:
+	    case Key_T:
+*/
+	    case Key_C:
+	    case Key_V:
+	    case Key_X:
+	    case Key_Y:
+	    case Key_Z:
+	    case Key_Left:
+	    case Key_Right:
+	    case Key_Up:
+	    case Key_Down:
+	    case Key_Home:
+	    case Key_End:
+#if defined (Q_WS_WIN)
+	    case Key_Insert:
+	    case Key_Delete:
+#endif
+		ke->accept();
+	    default:
+		break;
+	    }
+	    break;
+
+	default:
+	    switch ( ke->key() ) {
+#if defined (Q_WS_WIN)
+	    case Key_Insert:
+		ke->accept();
+#endif
+	    default:
+		break;
+	    }
+	    break;
+	}
+    }
+
+    if ( e->type() == QEvent::Show ) {
+	if (
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+	     !d->optimMode &&
+#endif
+	     d->ensureCursorVisibleInShowEvent  ) {
+	    ensureCursorVisible();
+	    d->ensureCursorVisibleInShowEvent = FALSE;
+	}
+	if ( !d->scrollToAnchor.isEmpty() ) {
+	    scrollToAnchor( d->scrollToAnchor );
+	    d->scrollToAnchor = QString::null;
+	}
+    }
+    return QWidget::event( e );
+}
+
+/*!
+    Processes the key event, \a e. By default key events are used to
+    provide keyboard navigation and text editing.
+*/
+
+void QTextEdit::keyPressEvent( QKeyEvent *e )
+{
+    changeIntervalTimer->stop();
+    interval = 10;
+    bool unknownKey = FALSE;
+    if ( isReadOnly() ) {
+	if ( !handleReadOnlyKeyEvent( e ) )
+	    QScrollView::keyPressEvent( e );
+	changeIntervalTimer->start( 100, TRUE );
+	return;
+    }
+
+
+    bool selChanged = FALSE;
+    for ( int i = 1; i < doc->numSelections(); ++i ) // start with 1 as we don't want to remove the Standard-Selection
+	selChanged = doc->removeSelection( i ) || selChanged;
+
+    if ( selChanged ) {
+	cursor->paragraph()->document()->nextDoubleBuffered = TRUE;
+	repaintChanged();
+    }
+
+    bool clearUndoRedoInfo = TRUE;
+
+
+    switch ( e->key() ) {
+    case Key_Left:
+    case Key_Right: {
+	// a bit hacky, but can't change this without introducing new enum values for move and keeping the
+	// correct semantics and movement for BiDi and non BiDi text.
+	CursorAction a;
+	if ( cursor->paragraph()->string()->isRightToLeft() == (e->key() == Key_Right) )
+	    a = e->state() & ControlButton ? MoveWordBackward : MoveBackward;
+	else
+	    a = e->state() & ControlButton ? MoveWordForward : MoveForward;
+	moveCursor( a, e->state() & ShiftButton );
+	break;
+    }
+    case Key_Up:
+	moveCursor( e->state() & ControlButton ? MovePgUp : MoveUp, e->state() & ShiftButton );
+	break;
+    case Key_Down:
+	moveCursor( e->state() & ControlButton ? MovePgDown : MoveDown, e->state() & ShiftButton );
+	break;
+    case Key_Home:
+	moveCursor( e->state() & ControlButton ? MoveHome : MoveLineStart, e->state() & ShiftButton );
+	break;
+    case Key_End:
+	moveCursor( e->state() & ControlButton ? MoveEnd : MoveLineEnd, e->state() & ShiftButton );
+	break;
+    case Key_Prior:
+	moveCursor( MovePgUp, e->state() & ShiftButton );
+	break;
+    case Key_Next:
+	moveCursor( MovePgDown, e->state() & ShiftButton );
+	break;
+    case Key_Return: case Key_Enter:
+	if ( doc->hasSelection( QTextDocument::Standard, FALSE ) )
+	    removeSelectedText();
+	if ( textFormat() == Qt::RichText && ( e->state() & ControlButton ) ) {
+	    // Ctrl-Enter inserts a line break in rich text mode
+	    insert( QString( QChar( 0x2028) ), TRUE, FALSE );
+	} else {
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	    clearUndoRedoInfo = FALSE;
+	    doKeyboardAction( ActionReturn );
+	    emit returnPressed();
+	}
+	break;
+    case Key_Delete:
+#if defined (Q_WS_WIN)
+	if ( e->state() & ShiftButton ) {
+	    cut();
+	    break;
+	} else
+#endif
+        if ( doc->hasSelection( QTextDocument::Standard, TRUE ) ) {
+	    removeSelectedText();
+	    break;
+	}
+	doKeyboardAction( e->state() & ControlButton ? ActionWordDelete
+			  : ActionDelete );
+	clearUndoRedoInfo = FALSE;
+
+	break;
+    case Key_Insert:
+	if ( e->state() & ShiftButton )
+	    paste();
+#if defined (Q_WS_WIN)
+	else if ( e->state() & ControlButton )
+	    copy();
+#endif
+	else
+	    setOverwriteMode( !isOverwriteMode() );
+	break;
+    case Key_Backspace:
+#if defined (Q_WS_WIN)
+	if ( e->state() & AltButton ) {
+	    if (e->state() & ControlButton ) {
+		break;
+	    } else if ( e->state() & ShiftButton ) {
+		redo();
+		break;
+	    } else {
+		undo();
+		break;
+	    }
+	} else
+#endif
+	if ( doc->hasSelection( QTextDocument::Standard, TRUE ) ) {
+	    removeSelectedText();
+	    break;
+	}
+
+	doKeyboardAction( e->state() & ControlButton ? ActionWordBackspace
+			  : ActionBackspace );
+	clearUndoRedoInfo = FALSE;
+	break;
+    case Key_F16: // Copy key on Sun keyboards
+	copy();
+	break;
+    case Key_F18:  // Paste key on Sun keyboards
+	paste();
+	break;
+    case Key_F20:  // Cut key on Sun keyboards
+	cut();
+	break;
+    case Key_Direction_L:
+	if ( doc->textFormat() == Qt::PlainText ) {
+	    // change the whole doc
+	    QTextParagraph *p = doc->firstParagraph();
+	    while ( p ) {
+		p->setDirection( QChar::DirL );
+		p->setAlignment( Qt::AlignLeft );
+		p->invalidate( 0 );
+		p = p->next();
+	    }
+	} else {
+	    if ( !cursor->paragraph() || cursor->paragraph()->direction() == QChar::DirL )
+		return;
+	    cursor->paragraph()->setDirection( QChar::DirL );
+	    if ( cursor->paragraph()->length() <= 1&&
+		 ( (cursor->paragraph()->alignment() & (Qt::AlignLeft | Qt::AlignRight) ) != 0 ) )
+		setAlignment( Qt::AlignLeft );
+	}
+	repaintChanged();
+	break;
+    case Key_Direction_R:
+	if ( doc->textFormat() == Qt::PlainText ) {
+	    // change the whole doc
+	    QTextParagraph *p = doc->firstParagraph();
+	    while ( p ) {
+		p->setDirection( QChar::DirR );
+		p->setAlignment( Qt::AlignRight );
+		p->invalidate( 0 );
+		p = p->next();
+	    }
+	} else {
+	    if ( !cursor->paragraph() || cursor->paragraph()->direction() == QChar::DirR )
+		return;
+	    cursor->paragraph()->setDirection( QChar::DirR );
+	    if ( cursor->paragraph()->length() <= 1&&
+		 ( (cursor->paragraph()->alignment() & (Qt::AlignLeft | Qt::AlignRight) ) != 0 ) )
+		setAlignment( Qt::AlignRight );
+	}
+	repaintChanged();
+	break;
+    default: {
+	    if ( e->text().length() &&
+		( !( e->state() & ControlButton ) &&
+#ifndef Q_OS_MACX
+		  !( e->state() & AltButton ) &&
+#endif
+		  !( e->state() & MetaButton ) ||
+		 ( ( (e->state()&ControlButton) | AltButton ) == (ControlButton|AltButton) ) ) &&
+		 ( !e->ascii() || e->ascii() >= 32 || e->text() == "\t" ) ) {
+		clearUndoRedoInfo = FALSE;
+		if ( e->key() == Key_Tab ) {
+		    if ( d->tabChangesFocus ) {
+			e->ignore();
+			break;
+		    }
+		    if ( textFormat() == Qt::RichText && cursor->index() == 0
+			 && ( cursor->paragraph()->isListItem() || cursor->paragraph()->listDepth() ) ) {
+			clearUndoRedo();
+			undoRedoInfo.type = UndoRedoInfo::Style;
+			undoRedoInfo.id = cursor->paragraph()->paragId();
+			undoRedoInfo.eid = undoRedoInfo.id;
+			undoRedoInfo.styleInformation = QTextStyleCommand::readStyleInformation( doc, undoRedoInfo.id, undoRedoInfo.eid );
+			cursor->paragraph()->setListDepth( cursor->paragraph()->listDepth() +1 );
+			clearUndoRedo();
+			drawCursor( FALSE );
+			repaintChanged();
+			drawCursor( TRUE );
+			break;
+		    }
+		} else if ( e->key() == Key_BackTab ) {
+		    if ( d->tabChangesFocus ) {
+			e->ignore();
+			break;
+		    }
+		}
+
+		if ( ( autoFormatting() & AutoBulletList ) &&
+		     textFormat() == Qt::RichText && cursor->index() == 0
+		     && !cursor->paragraph()->isListItem()
+		     && ( e->text()[0] == '-' || e->text()[0] == '*' ) ) {
+			clearUndoRedo();
+			undoRedoInfo.type = UndoRedoInfo::Style;
+			undoRedoInfo.id = cursor->paragraph()->paragId();
+			undoRedoInfo.eid = undoRedoInfo.id;
+			undoRedoInfo.styleInformation = QTextStyleCommand::readStyleInformation( doc, undoRedoInfo.id, undoRedoInfo.eid );
+			setParagType( QStyleSheetItem::DisplayListItem, QStyleSheetItem::ListDisc );
+			clearUndoRedo();
+			drawCursor( FALSE );
+			repaintChanged();
+			drawCursor( TRUE );
+			break;
+		}
+		if (overWrite && !cursor->atParagEnd() && !doc->hasSelection(QTextDocument::Standard)) {
+                    doKeyboardAction(ActionDelete);
+                    clearUndoRedoInfo = FALSE;
+                }
+		QString t = e->text();
+#ifdef Q_WS_X11
+		extern bool qt_hebrew_keyboard_hack;
+		if ( qt_hebrew_keyboard_hack ) {
+		    // the X11 keyboard layout is broken and does not reverse
+		    // braces correctly. This is a hack to get halfway correct
+		    // behaviour
+		    QTextParagraph *p = cursor->paragraph();
+		    if ( p && p->string() && p->string()->isRightToLeft() ) {
+			QChar *c = (QChar *)t.unicode();
+			int l = t.length();
+			while( l-- ) {
+			    if ( c->mirrored() )
+				*c = c->mirroredChar();
+			    c++;
+			}
+		    }
+		}
+#endif
+		insert( t, TRUE, FALSE );
+		break;
+	    } else if ( e->state() & ControlButton ) {
+		switch ( e->key() ) {
+		case Key_C: case Key_F16: // Copy key on Sun keyboards
+		    copy();
+		    break;
+		case Key_V:
+		    paste();
+		    break;
+		case Key_X:
+		    cut();
+		    break;
+		case Key_I: case Key_T: case Key_Tab:
+		    if ( !d->tabChangesFocus )
+			indent();
+		    break;
+		case Key_A:
+#if defined(Q_WS_X11)
+		    moveCursor( MoveLineStart, e->state() & ShiftButton );
+#else
+		    selectAll( TRUE );
+#endif
+		    break;
+		case Key_B:
+		    moveCursor( MoveBackward, e->state() & ShiftButton );
+		    break;
+		case Key_F:
+		    moveCursor( MoveForward, e->state() & ShiftButton );
+		    break;
+		case Key_D:
+		    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+			removeSelectedText();
+			break;
+		    }
+		    doKeyboardAction( ActionDelete );
+		    clearUndoRedoInfo = FALSE;
+		    break;
+		case Key_H:
+		    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+			removeSelectedText();
+			break;
+		    }
+		    if ( !cursor->paragraph()->prev() &&
+			 cursor->atParagStart() )
+			break;
+
+		    doKeyboardAction( ActionBackspace );
+		    clearUndoRedoInfo = FALSE;
+		    break;
+		case Key_E:
+		    moveCursor( MoveLineEnd, e->state() & ShiftButton );
+		    break;
+		case Key_N:
+		    moveCursor( MoveDown, e->state() & ShiftButton );
+		    break;
+		case Key_P:
+		    moveCursor( MoveUp, e->state() & ShiftButton );
+		    break;
+		case Key_Z:
+		    if(e->state() & ShiftButton)
+			redo();
+		    else
+			undo();
+		    break;
+		case Key_Y:
+		    redo();
+		    break;
+		case Key_K:
+		    doKeyboardAction( ActionKill );
+		    break;
+#if defined(Q_WS_WIN)
+		case Key_Insert:
+		    copy();
+		    break;
+		case Key_Delete:
+		    del();
+		    break;
+#endif
+		default:
+		    unknownKey = FALSE;
+		    break;
+		}
+	    } else {
+		unknownKey = TRUE;
+	    }
+        }
+    }
+
+    emit cursorPositionChanged( cursor );
+    emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+    if ( clearUndoRedoInfo )
+	clearUndoRedo();
+    changeIntervalTimer->start( 100, TRUE );
+    if ( unknownKey )
+	e->ignore();
+}
+
+/*!
+    \reimp
+*/
+void QTextEdit::imStartEvent( QIMEvent *e )
+{
+    if ( isReadOnly() ) {
+	e->ignore();
+	return;
+    }
+
+    if ( hasSelectedText() )
+	removeSelectedText();
+    d->preeditStart = cursor->index();
+    clearUndoRedo();
+    undoRedoInfo.type = UndoRedoInfo::IME;
+}
+
+/*!
+    \reimp
+*/
+void QTextEdit::imComposeEvent( QIMEvent *e )
+{
+    if ( isReadOnly() ) {
+	e->ignore();
+	return;
+    }
+
+    doc->removeSelection( QTextDocument::IMCompositionText );
+    doc->removeSelection( QTextDocument::IMSelectionText );
+
+    if ( d->preeditLength > 0 && cursor->paragraph() )
+	cursor->paragraph()->remove( d->preeditStart, d->preeditLength );
+    cursor->setIndex( d->preeditStart );
+    d->preeditLength = e->text().length();
+    insert( e->text() );
+    // insert can trigger an imEnd event as it emits a textChanged signal, so better
+    // be careful
+    if(d->preeditStart != -1) {
+	cursor->setIndex( d->preeditStart + d->preeditLength );
+	QTextCursor c = *cursor;
+	cursor->setIndex( d->preeditStart );
+	doc->setSelectionStart( QTextDocument::IMCompositionText, *cursor );
+	doc->setSelectionEnd( QTextDocument::IMCompositionText, c );
+
+	cursor->setIndex( d->preeditStart + e->cursorPos() );
+
+	int sellen = e->selectionLength();
+	if ( sellen > 0 ) {
+	    cursor->setIndex( d->preeditStart + e->cursorPos() + sellen );
+	    c = *cursor;
+	    cursor->setIndex( d->preeditStart + e->cursorPos() );
+	    doc->setSelectionStart( QTextDocument::IMSelectionText, *cursor );
+	    doc->setSelectionEnd( QTextDocument::IMSelectionText, c );
+	    cursor->setIndex( d->preeditStart + d->preeditLength );
+	}
+    }
+
+    updateMicroFocusHint();
+    repaintChanged();
+}
+
+/*!
+    \reimp
+*/
+void QTextEdit::imEndEvent( QIMEvent *e )
+{
+    if ( isReadOnly() ) {
+	e->ignore();
+	return;
+    }
+
+    doc->removeSelection( QTextDocument::IMCompositionText );
+    doc->removeSelection( QTextDocument::IMSelectionText );
+
+    if (undoRedoInfo.type == UndoRedoInfo::IME)
+        undoRedoInfo.type = UndoRedoInfo::Invalid;
+
+    if ( d->preeditLength > 0 && cursor->paragraph() )
+	cursor->paragraph()->remove( d->preeditStart, d->preeditLength );
+    if ( d->preeditStart >= 0 ) {
+        cursor->setIndex( d->preeditStart );
+        insert( e->text() );
+    }
+    d->preeditStart = d->preeditLength = -1;
+
+    repaintChanged();
+}
+
+
+static bool qtextedit_ignore_readonly = FALSE;
+
+/*!
+    Executes keyboard action \a action. This is normally called by a
+    key event handler.
+*/
+
+void QTextEdit::doKeyboardAction( KeyboardAction action )
+{
+    if ( isReadOnly() && !qtextedit_ignore_readonly )
+	return;
+
+    if ( cursor->nestedDepth() != 0 ) // #### for 3.0, disable editing of tables as this is not advanced enough
+	return;
+
+    lastFormatted = cursor->paragraph();
+    drawCursor( FALSE );
+    bool doUpdateCurrentFormat = TRUE;
+
+    switch ( action ) {
+    case ActionWordDelete:
+    case ActionDelete:
+	if ( action == ActionDelete && !cursor->atParagEnd() ) {
+	    if ( undoEnabled ) {
+		checkUndoRedoInfo( UndoRedoInfo::Delete );
+		if ( !undoRedoInfo.valid() ) {
+		    undoRedoInfo.id = cursor->paragraph()->paragId();
+		    undoRedoInfo.index = cursor->index();
+		    undoRedoInfo.d->text = QString::null;
+		}
+		int idx = cursor->index();
+		do {
+		    undoRedoInfo.d->text.insert( undoRedoInfo.d->text.length(), cursor->paragraph()->at( idx++ ), TRUE );
+		} while ( !cursor->paragraph()->string()->validCursorPosition( idx ) );
+	    }
+	    cursor->remove();
+	} else {
+	    clearUndoRedo();
+	    doc->setSelectionStart( QTextDocument::Temp, *cursor );
+	    if ( action == ActionWordDelete && !cursor->atParagEnd() ) {
+		cursor->gotoNextWord();
+	    } else {
+		cursor->gotoNextLetter();
+	    }
+	    doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+	    removeSelectedText( QTextDocument::Temp );
+	}
+	break;
+    case ActionWordBackspace:
+    case ActionBackspace:
+	if ( textFormat() == Qt::RichText
+	     && (cursor->paragraph()->isListItem()
+		 || cursor->paragraph()->listDepth() )
+	     && cursor->index() == 0 ) {
+	    if ( undoEnabled ) {
+		clearUndoRedo();
+		undoRedoInfo.type = UndoRedoInfo::Style;
+		undoRedoInfo.id = cursor->paragraph()->paragId();
+		undoRedoInfo.eid = undoRedoInfo.id;
+		undoRedoInfo.styleInformation = QTextStyleCommand::readStyleInformation( doc, undoRedoInfo.id, undoRedoInfo.eid );
+	    }
+	    int ldepth = cursor->paragraph()->listDepth();
+	    if ( cursor->paragraph()->isListItem() && ldepth == 1 ) {
+		cursor->paragraph()->setListItem( FALSE );
+	    } else if ( QMAX( ldepth, 1 ) == 1 ) {
+		cursor->paragraph()->setListItem( FALSE );
+		cursor->paragraph()->setListDepth( 0 );
+	    } else {
+		cursor->paragraph()->setListDepth( ldepth - 1 );
+	    }
+	    clearUndoRedo();
+	    lastFormatted = cursor->paragraph();
+	    repaintChanged();
+	    drawCursor( TRUE );
+	    return;
+	}
+
+	if ( action == ActionBackspace && !cursor->atParagStart() ) {
+	    if ( undoEnabled ) {
+		checkUndoRedoInfo( UndoRedoInfo::Delete );
+		if ( !undoRedoInfo.valid() ) {
+		    undoRedoInfo.id = cursor->paragraph()->paragId();
+		    undoRedoInfo.index = cursor->index();
+		    undoRedoInfo.d->text = QString::null;
+		}
+		undoRedoInfo.d->text.insert( 0, cursor->paragraph()->at( cursor->index()-1 ), TRUE );
+		undoRedoInfo.index = cursor->index()-1;
+	    }
+	    cursor->removePreviousChar();
+	    lastFormatted = cursor->paragraph();
+	} else if ( cursor->paragraph()->prev()
+		    || (action == ActionWordBackspace
+			&& !cursor->atParagStart()) ) {
+	    clearUndoRedo();
+	    doc->setSelectionStart( QTextDocument::Temp, *cursor );
+	    if ( action == ActionWordBackspace && !cursor->atParagStart() ) {
+		cursor->gotoPreviousWord();
+	    } else {
+		cursor->gotoPreviousLetter();
+	    }
+	    doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+	    removeSelectedText( QTextDocument::Temp );
+	}
+	break;
+    case ActionReturn:
+	if ( undoEnabled ) {
+	    checkUndoRedoInfo( UndoRedoInfo::Return );
+	    if ( !undoRedoInfo.valid() ) {
+		undoRedoInfo.id = cursor->paragraph()->paragId();
+		undoRedoInfo.index = cursor->index();
+		undoRedoInfo.d->text = QString::null;
+	    }
+	    undoRedoInfo.d->text += "\n";
+	}
+	cursor->splitAndInsertEmptyParagraph();
+	if ( cursor->paragraph()->prev() ) {
+	    lastFormatted = cursor->paragraph()->prev();
+	    lastFormatted->invalidate( 0 );
+	}
+	doUpdateCurrentFormat = FALSE;
+	break;
+    case ActionKill:
+	clearUndoRedo();
+	doc->setSelectionStart( QTextDocument::Temp, *cursor );
+	if ( cursor->atParagEnd() )
+	    cursor->gotoNextLetter();
+	else
+	    cursor->setIndex( cursor->paragraph()->length() - 1 );
+	doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+	removeSelectedText( QTextDocument::Temp );
+	break;
+    }
+
+    formatMore();
+    repaintChanged();
+    ensureCursorVisible();
+    drawCursor( TRUE );
+    updateMicroFocusHint();
+    if ( doUpdateCurrentFormat )
+	updateCurrentFormat();
+    setModified();
+    emit textChanged();
+}
+
+void QTextEdit::readFormats( QTextCursor &c1, QTextCursor &c2, QTextString &text, bool fillStyles )
+{
+#ifndef QT_NO_DATASTREAM
+    QDataStream styleStream( undoRedoInfo.styleInformation, IO_WriteOnly );
+#endif
+    c2.restoreState();
+    c1.restoreState();
+    int lastIndex = text.length();
+    if ( c1.paragraph() == c2.paragraph() ) {
+	for ( int i = c1.index(); i < c2.index(); ++i )
+	    text.insert( lastIndex + i - c1.index(), c1.paragraph()->at( i ), TRUE );
+#ifndef QT_NO_DATASTREAM
+	if ( fillStyles ) {
+	    styleStream << (int) 1;
+	    c1.paragraph()->writeStyleInformation( styleStream );
+	}
+#endif
+    } else {
+	int i;
+	for ( i = c1.index(); i < c1.paragraph()->length()-1; ++i )
+	    text.insert( lastIndex++, c1.paragraph()->at( i ), TRUE );
+	int num = 2; // start and end, being different
+	text += "\n"; lastIndex++;
+
+        if (c1.paragraph()->next() != c2.paragraph()) {
+            num += text.appendParagraphs(c1.paragraph()->next(), c2.paragraph());
+            lastIndex = text.length();
+        }
+
+	for ( i = 0; i < c2.index(); ++i )
+	    text.insert( i + lastIndex, c2.paragraph()->at( i ), TRUE );
+#ifndef QT_NO_DATASTREAM
+	if ( fillStyles ) {
+	    styleStream << num;
+	    for ( QTextParagraph *p = c1.paragraph(); --num >= 0; p = p->next() )
+		p->writeStyleInformation( styleStream );
+	}
+#endif
+    }
+}
+
+/*!
+    Removes the selection \a selNum (by default 0). This does not
+    remove the selected text.
+
+    \sa removeSelectedText()
+*/
+
+void QTextEdit::removeSelection( int selNum )
+{
+    doc->removeSelection( selNum );
+    repaintChanged();
+}
+
+/*!
+    Deletes the text of selection \a selNum (by default, the default
+    selection, 0). If there is no selected text nothing happens.
+
+    \sa selectedText removeSelection()
+*/
+
+void QTextEdit::removeSelectedText( int selNum )
+{
+    if(selNum != 0)
+        resetInputContext();
+
+    QTextCursor c1 = doc->selectionStartCursor( selNum );
+    c1.restoreState();
+    QTextCursor c2 = doc->selectionEndCursor( selNum );
+    c2.restoreState();
+
+    // ### no support for editing tables yet, plus security for broken selections
+    if ( c1.nestedDepth() || c2.nestedDepth() )
+	return;
+
+    for ( int i = 0; i < (int)doc->numSelections(); ++i ) {
+	if ( i == selNum )
+	    continue;
+	doc->removeSelection( i );
+    }
+
+    drawCursor( FALSE );
+    if ( undoEnabled ) {
+	checkUndoRedoInfo( UndoRedoInfo::RemoveSelected );
+	if ( !undoRedoInfo.valid() ) {
+	    doc->selectionStart( selNum, undoRedoInfo.id, undoRedoInfo.index );
+	    undoRedoInfo.d->text = QString::null;
+	}
+	readFormats( c1, c2, undoRedoInfo.d->text, TRUE );
+    }
+
+    doc->removeSelectedText( selNum, cursor );
+    if ( cursor->isValid() ) {
+	lastFormatted = 0; // make sync a noop
+	ensureCursorVisible();
+	lastFormatted = cursor->paragraph();
+	formatMore();
+	repaintContents( FALSE );
+	ensureCursorVisible();
+	drawCursor( TRUE );
+	clearUndoRedo();
+#if defined(Q_WS_WIN)
+	// there seems to be a problem with repainting or erasing the area
+	// of the scrollview which is not the contents on windows
+	if ( contentsHeight() < visibleHeight() )
+	    viewport()->repaint( 0, contentsHeight(), visibleWidth(), visibleHeight() - contentsHeight(), TRUE );
+#endif
+#ifndef QT_NO_CURSOR
+	viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	updateMicroFocusHint();
+    } else {
+	delete cursor;
+	cursor = new QTextCursor( doc );
+	drawCursor( TRUE );
+	repaintContents( TRUE );
+    }
+    setModified();
+    emit textChanged();
+    emit selectionChanged();
+    emit copyAvailable( doc->hasSelection( QTextDocument::Standard ) );
+}
+
+/*!
+    Moves the text cursor according to \a action. This is normally
+    used by some key event handler. \a select specifies whether the
+    text between the current cursor position and the new position
+    should be selected.
+*/
+
+void QTextEdit::moveCursor( CursorAction action, bool select )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return;
+#endif
+#ifdef Q_WS_MACX
+    QTextCursor c1 = *cursor;
+    QTextCursor c2;
+#endif
+    drawCursor( FALSE );
+    if ( select ) {
+	if ( !doc->hasSelection( QTextDocument::Standard ) )
+	    doc->setSelectionStart( QTextDocument::Standard, *cursor );
+	moveCursor( action );
+#ifdef Q_WS_MACX
+	c2 = *cursor;
+	if (c1 == c2)
+	    if (action == MoveDown || action == MovePgDown)
+		moveCursor( MoveEnd );
+	    else if (action == MoveUp || action == MovePgUp)
+		moveCursor( MoveHome );
+#endif
+	if ( doc->setSelectionEnd( QTextDocument::Standard, *cursor ) ) {
+	    cursor->paragraph()->document()->nextDoubleBuffered = TRUE;
+	    repaintChanged();
+	} else {
+	    drawCursor( TRUE );
+	}
+	ensureCursorVisible();
+	emit selectionChanged();
+	emit copyAvailable( doc->hasSelection( QTextDocument::Standard ) );
+    } else {
+#ifdef Q_WS_MACX
+	QTextCursor cStart = doc->selectionStartCursor( QTextDocument::Standard );
+	QTextCursor cEnd = doc->selectionEndCursor( QTextDocument::Standard );
+	bool redraw = doc->removeSelection( QTextDocument::Standard );
+	if (redraw && action == MoveDown)
+	    *cursor = cEnd;
+	else if (redraw && action == MoveUp)
+	    *cursor = cStart;
+	if (redraw && action == MoveForward)
+	    *cursor = cEnd;
+	else if (redraw && action == MoveBackward)
+	    *cursor = cStart;
+	else
+	    moveCursor( action );
+	c2 = *cursor;
+	if (c1 == c2)
+	    if (action == MoveDown)
+		moveCursor( MoveEnd );
+	    else if (action == MoveUp)
+		moveCursor( MoveHome );
+#else
+	bool redraw = doc->removeSelection( QTextDocument::Standard );
+	moveCursor( action );
+#endif
+	if ( !redraw ) {
+	    ensureCursorVisible();
+	    drawCursor( TRUE );
+	} else {
+	    cursor->paragraph()->document()->nextDoubleBuffered = TRUE;
+	    repaintChanged();
+	    ensureCursorVisible();
+	    drawCursor( TRUE );
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	}
+	if ( redraw ) {
+	    emit copyAvailable( doc->hasSelection( QTextDocument::Standard ) );
+	    emit selectionChanged();
+	}
+    }
+
+    drawCursor( TRUE );
+    updateCurrentFormat();
+    updateMicroFocusHint();
+}
+
+/*!
+    \overload
+*/
+
+void QTextEdit::moveCursor( CursorAction action )
+{
+    resetInputContext();
+    switch ( action ) {
+    case MoveBackward:
+	cursor->gotoPreviousLetter();
+	break;
+    case MoveWordBackward:
+	cursor->gotoPreviousWord();
+	break;
+    case MoveForward:
+	cursor->gotoNextLetter();
+	break;
+    case MoveWordForward:
+	cursor->gotoNextWord();
+	break;
+    case MoveUp:
+	cursor->gotoUp();
+	break;
+    case MovePgUp:
+	cursor->gotoPageUp( visibleHeight() );
+	break;
+    case MoveDown:
+	cursor->gotoDown();
+	break;
+    case MovePgDown:
+	cursor->gotoPageDown( visibleHeight() );
+	break;
+    case MoveLineStart:
+	cursor->gotoLineStart();
+	break;
+    case MoveHome:
+	cursor->gotoHome();
+	break;
+    case MoveLineEnd:
+	cursor->gotoLineEnd();
+	break;
+    case MoveEnd:
+	ensureFormatted( doc->lastParagraph() );
+	cursor->gotoEnd();
+	break;
+    }
+    updateMicroFocusHint();
+    updateCurrentFormat();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::resizeEvent( QResizeEvent *e )
+{
+    QScrollView::resizeEvent( e );
+    if ( doc->visibleWidth() == 0 )
+	doResize();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::viewportResizeEvent( QResizeEvent *e )
+{
+    QScrollView::viewportResizeEvent( e );
+    if ( e->oldSize().width() != e->size().width() ) {
+	bool stayAtBottom = e->oldSize().height() != e->size().height() &&
+	       contentsY() > 0 && contentsY() >= doc->height() - e->oldSize().height();
+	doResize();
+	if ( stayAtBottom )
+	    scrollToBottom();
+    }
+}
+
+/*!
+    Ensures that the cursor is visible by scrolling the text edit if
+    necessary.
+
+    \sa setCursorPosition()
+*/
+
+void QTextEdit::ensureCursorVisible()
+{
+    // Not visible or the user is draging the window, so don't position to caret yet
+    if ( !isUpdatesEnabled() || !isVisible() || isHorizontalSliderPressed() || isVerticalSliderPressed() ) {
+	d->ensureCursorVisibleInShowEvent = TRUE;
+	return;
+    }
+    sync();
+    QTextStringChar *chr = cursor->paragraph()->at( cursor->index() );
+    int h = cursor->paragraph()->lineHeightOfChar( cursor->index() );
+    int x = cursor->paragraph()->rect().x() + chr->x + cursor->offsetX();
+    int y = 0; int dummy;
+    cursor->paragraph()->lineHeightOfChar( cursor->index(), &dummy, &y );
+    y += cursor->paragraph()->rect().y() + cursor->offsetY();
+    int w = 1;
+    ensureVisible( x, y + h / 2, w, h / 2 + 2 );
+}
+
+/*!
+    \internal
+*/
+void QTextEdit::sliderReleased()
+{
+    if ( d->ensureCursorVisibleInShowEvent && isVisible() ) {
+	d->ensureCursorVisibleInShowEvent = FALSE;
+	ensureCursorVisible();
+    }
+}
+
+/*!
+    \internal
+*/
+void QTextEdit::drawCursor( bool visible )
+{
+    if ( !isUpdatesEnabled() ||
+	 !viewport()->isUpdatesEnabled() ||
+	 !cursor->paragraph() ||
+	 !cursor->paragraph()->isValid() ||
+	 ( !style().styleHint( QStyle::SH_BlinkCursorWhenTextSelected ) &&
+	   ( d->optimMode ? optimHasSelection() : doc->hasSelection( QTextDocument::Standard, TRUE ))) ||
+	 ( visible && !hasFocus() && !viewport()->hasFocus() && !inDnD ) ||
+         doc->hasSelection( QTextDocument::IMSelectionText ) ||
+	 isReadOnly() )
+	return;
+
+    QPainter p( viewport() );
+    QRect r( cursor->topParagraph()->rect() );
+    cursor->paragraph()->setChanged( TRUE );
+    p.translate( -contentsX() + cursor->totalOffsetX(), -contentsY() + cursor->totalOffsetY() );
+    QPixmap *pix = 0;
+    QColorGroup cg( colorGroup() );
+    const QColorGroup::ColorRole backRole = QPalette::backgroundRoleFromMode(backgroundMode());
+    if ( cursor->paragraph()->background() )
+	cg.setBrush( backRole, *cursor->paragraph()->background() );
+    else if ( doc->paper() )
+	cg.setBrush( backRole, *doc->paper() );
+    p.setBrushOrigin( -contentsX(), -contentsY() );
+    cursor->paragraph()->document()->nextDoubleBuffered = TRUE;
+    if ( !cursor->nestedDepth() ) {
+	int h = cursor->paragraph()->lineHeightOfChar( cursor->index() );
+	int dist = 5;
+	if ( ( cursor->paragraph()->alignment() & Qt::AlignJustify ) == Qt::AlignJustify )
+	    dist = 50;
+	int x = r.x() - cursor->totalOffsetX() + cursor->x() - dist;
+	x = QMAX( x, 0 );
+	p.setClipRect( QRect( x - contentsX(),
+			      r.y() - cursor->totalOffsetY() + cursor->y() - contentsY(), 2 * dist, h ) );
+	doc->drawParagraph( &p, cursor->paragraph(), x,
+			r.y() - cursor->totalOffsetY() + cursor->y(), 2 * dist, h, pix, cg, visible, cursor );
+    } else {
+	doc->drawParagraph( &p, cursor->paragraph(), r.x() - cursor->totalOffsetX(),
+			r.y() - cursor->totalOffsetY(), r.width(), r.height(),
+			pix, cg, visible, cursor );
+    }
+    cursorVisible = visible;
+}
+
+enum {
+    IdUndo = 0,
+    IdRedo = 1,
+    IdCut = 2,
+    IdCopy = 3,
+    IdPaste = 4,
+    IdClear = 5,
+    IdSelectAll = 6
+};
+
+/*!
+    \reimp
+*/
+#ifndef QT_NO_WHEELEVENT
+void QTextEdit::contentsWheelEvent( QWheelEvent *e )
+{
+    if ( isReadOnly() ) {
+	if ( e->state() & ControlButton ) {
+	    if ( e->delta() > 0 )
+		zoomOut();
+	    else if ( e->delta() < 0 )
+		zoomIn();
+	    return;
+	}
+    }
+    QScrollView::contentsWheelEvent( e );
+}
+#endif
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsMousePressEvent( QMouseEvent *e )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimMousePressEvent( e );
+	return;
+    }
+#endif
+
+    if ( d->trippleClickTimer->isActive() &&
+	 ( e->globalPos() - d->trippleClickPoint ).manhattanLength() <
+	 QApplication::startDragDistance() ) {
+	QTextCursor c1 = *cursor;
+	QTextCursor c2 = *cursor;
+	c1.gotoLineStart();
+	c2.gotoLineEnd();
+	doc->setSelectionStart( QTextDocument::Standard, c1 );
+	doc->setSelectionEnd( QTextDocument::Standard, c2 );
+	*cursor = c2;
+	repaintChanged();
+	mousePressed = TRUE;
+	return;
+    }
+
+    clearUndoRedo();
+    QTextCursor oldCursor = *cursor;
+    QTextCursor c = *cursor;
+    mousePos = e->pos();
+    mightStartDrag = FALSE;
+    pressedLink = QString::null;
+    d->pressedName = QString::null;
+
+    if ( e->button() == LeftButton ) {
+	mousePressed = TRUE;
+	drawCursor( FALSE );
+	placeCursor( e->pos() );
+	ensureCursorVisible();
+
+	if ( isReadOnly() && linksEnabled() ) {
+	    QTextCursor c = *cursor;
+	    placeCursor( e->pos(), &c, TRUE );
+	    if ( c.paragraph() && c.paragraph()->at( c.index() ) &&
+		 c.paragraph()->at( c.index() )->isAnchor() ) {
+		pressedLink = c.paragraph()->at( c.index() )->anchorHref();
+		d->pressedName = c.paragraph()->at( c.index() )->anchorName();
+	    }
+	}
+
+#ifndef QT_NO_DRAGANDDROP
+	if ( doc->inSelection( QTextDocument::Standard, e->pos() ) ) {
+	    mightStartDrag = TRUE;
+	    drawCursor( TRUE );
+	    dragStartTimer->start( QApplication::startDragTime(), TRUE );
+	    dragStartPos = e->pos();
+	    return;
+	}
+#endif
+
+	bool redraw = FALSE;
+	if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	    if ( !( e->state() & ShiftButton ) ) {
+		redraw = doc->removeSelection( QTextDocument::Standard );
+		doc->setSelectionStart( QTextDocument::Standard, *cursor );
+	    } else {
+		redraw = doc->setSelectionEnd( QTextDocument::Standard, *cursor ) || redraw;
+	    }
+	} else {
+	    if ( isReadOnly() || !( e->state() & ShiftButton ) ) {
+		doc->setSelectionStart( QTextDocument::Standard, *cursor );
+	    } else {
+		doc->setSelectionStart( QTextDocument::Standard, c );
+		redraw = doc->setSelectionEnd( QTextDocument::Standard, *cursor ) || redraw;
+	    }
+	}
+
+	for ( int i = 1; i < doc->numSelections(); ++i ) // start with 1 as we don't want to remove the Standard-Selection
+	    redraw = doc->removeSelection( i ) || redraw;
+
+	if ( !redraw ) {
+	    drawCursor( TRUE );
+	} else {
+	    repaintChanged();
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	}
+    } else if ( e->button() == MidButton ) {
+	bool redraw = doc->removeSelection( QTextDocument::Standard );
+	if ( !redraw ) {
+	    drawCursor( TRUE );
+	} else {
+	    repaintChanged();
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	}
+    }
+
+    if ( *cursor != oldCursor )
+	updateCurrentFormat();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsMouseMoveEvent( QMouseEvent *e )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimMouseMoveEvent( e );
+	return;
+    }
+#endif
+    if ( mousePressed ) {
+#ifndef QT_NO_DRAGANDDROP
+	if ( mightStartDrag ) {
+	    dragStartTimer->stop();
+	    if ( ( e->pos() - dragStartPos ).manhattanLength() > QApplication::startDragDistance() ) {
+		QGuardedPtr<QTextEdit> guard( this );
+		startDrag();
+		if (guard.isNull()) // we got deleted during the dnd
+                    return;
+	    }
+#ifndef QT_NO_CURSOR
+	    if ( !isReadOnly() )
+		viewport()->setCursor( ibeamCursor );
+#endif
+	    return;
+	}
+#endif
+	mousePos = e->pos();
+	handleMouseMove( mousePos );
+	oldMousePos = mousePos;
+    }
+
+#ifndef QT_NO_CURSOR
+    if ( !isReadOnly() && !mousePressed ) {
+	if ( doc->hasSelection( QTextDocument::Standard ) && doc->inSelection( QTextDocument::Standard, e->pos() ) )
+	    viewport()->setCursor( arrowCursor );
+	else
+	    viewport()->setCursor( ibeamCursor );
+    }
+#endif
+    updateCursor( e->pos() );
+}
+
+void QTextEdit::copyToClipboard()
+{
+#ifndef QT_NO_CLIPBOARD
+    if (QApplication::clipboard()->supportsSelection()) {
+	d->clipboard_mode = QClipboard::Selection;
+
+	// don't listen to selection changes
+	disconnect( QApplication::clipboard(), SIGNAL(selectionChanged()), this, 0);
+	copy();
+	// listen to selection changes
+	connect( QApplication::clipboard(), SIGNAL(selectionChanged()),
+		 this, SLOT(clipboardChanged()) );
+
+	d->clipboard_mode = QClipboard::Clipboard;
+    }
+#endif
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsMouseReleaseEvent( QMouseEvent * e )
+{
+    if ( !inDoubleClick ) { // could be the release of a dblclick
+	int para = 0;
+	int index = charAt( e->pos(), &para );
+	emit clicked( para, index );
+    }
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimMouseReleaseEvent( e );
+	return;
+    }
+#endif
+    QTextCursor oldCursor = *cursor;
+    if ( scrollTimer->isActive() )
+	scrollTimer->stop();
+#ifndef QT_NO_DRAGANDDROP
+    if ( dragStartTimer->isActive() )
+	dragStartTimer->stop();
+    if ( mightStartDrag ) {
+	selectAll( FALSE );
+	mousePressed = FALSE;
+    }
+#endif
+    bool mouseWasPressed = mousePressed;
+    if ( mousePressed ) {
+	mousePressed = FALSE;
+	copyToClipboard();
+    }
+#ifndef QT_NO_CLIPBOARD
+    else if ( e->button() == MidButton && !isReadOnly() ) {
+        // only do middle-click pasting on systems that have selections (ie. X11)
+        if (QApplication::clipboard()->supportsSelection()) {
+            drawCursor( FALSE );
+            placeCursor( e->pos() );
+            ensureCursorVisible();
+            doc->setSelectionStart( QTextDocument::Standard, oldCursor );
+            bool redraw = FALSE;
+            if ( doc->hasSelection( QTextDocument::Standard ) ) {
+                redraw = doc->removeSelection( QTextDocument::Standard );
+                doc->setSelectionStart( QTextDocument::Standard, *cursor );
+            } else {
+                doc->setSelectionStart( QTextDocument::Standard, *cursor );
+            }
+            // start with 1 as we don't want to remove the Standard-Selection
+            for ( int i = 1; i < doc->numSelections(); ++i )
+                redraw = doc->removeSelection( i ) || redraw;
+            if ( !redraw ) {
+                drawCursor( TRUE );
+            } else {
+                repaintChanged();
+#ifndef QT_NO_CURSOR
+                viewport()->setCursor( ibeamCursor );
+#endif
+            }
+	    d->clipboard_mode = QClipboard::Selection;
+            paste();
+	    d->clipboard_mode = QClipboard::Clipboard;
+        }
+    }
+#endif
+    emit cursorPositionChanged( cursor );
+    emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+    if ( oldCursor != *cursor )
+	updateCurrentFormat();
+    inDoubleClick = FALSE;
+
+#ifndef QT_NO_NETWORKPROTOCOL
+    if ( (   (!onLink.isEmpty() && onLink == pressedLink)
+	  || (!d->onName.isEmpty() && d->onName == d->pressedName))
+	 && linksEnabled() && mouseWasPressed ) {
+	if (!onLink.isEmpty()) {
+	    QUrl u( doc->context(), onLink, TRUE );
+	    emitLinkClicked( u.toString( FALSE, FALSE ) );
+	}
+	if (::qt_cast<QTextBrowser*>(this)) { // change for 4.0
+	    QConnectionList *clist = receivers(
+			"anchorClicked(const QString&,const QString&)");
+	    if (!signalsBlocked() && clist) {
+		QUObject o[3];
+		static_QUType_QString.set(o+1, d->onName);
+		static_QUType_QString.set(o+2, onLink);
+		activate_signal( clist, o);
+	    }
+	}
+
+	// emitting linkClicked() may result in that the cursor winds
+	// up hovering over a different valid link - check this and
+	// set the appropriate cursor shape
+	updateCursor( e->pos() );
+    }
+#endif
+    drawCursor( TRUE );
+    if ( !doc->hasSelection( QTextDocument::Standard, TRUE ) )
+	doc->removeSelection( QTextDocument::Standard );
+
+    emit copyAvailable( doc->hasSelection( QTextDocument::Standard ) );
+    emit selectionChanged();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsMouseDoubleClickEvent( QMouseEvent * e )
+{
+    if ( e->button() != Qt::LeftButton ) {
+	e->ignore();
+	return;
+    }
+    int para = 0;
+    int index = charAt( e->pos(), &para );
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	QString str = d->od->lines[ LOGOFFSET(para) ];
+	int startIdx = index, endIdx = index, i;
+	if ( !str[ index ].isSpace() ) {
+	    i = startIdx;
+	    // find start of word
+	    while ( i >= 0 && !str[ i ].isSpace() ) {
+		startIdx = i--;
+	    }
+	    i = endIdx;
+	    // find end of word..
+	    while ( (uint) i < str.length() && !str[ i ].isSpace() ) {
+		endIdx = ++i;
+	    }
+	    // ..and start of next
+	    while ( (uint) i < str.length() && str[ i ].isSpace() ) {
+		endIdx = ++i;
+	    }
+	    optimSetSelection( para, startIdx, para, endIdx );
+	    repaintContents( FALSE );
+	}
+    } else
+#endif
+    {
+	QTextCursor c1 = *cursor;
+	QTextCursor c2 = *cursor;
+#if defined(Q_OS_MAC)
+	QTextParagraph *para = cursor->paragraph();
+	if ( cursor->isValid() ) {
+	    if ( para->at( cursor->index() )->c.isLetterOrNumber() ) {
+		while ( c1.index() > 0 &&
+			c1.paragraph()->at( c1.index()-1 )->c.isLetterOrNumber() )
+		    c1.gotoPreviousLetter();
+		while ( c2.paragraph()->at( c2.index() )->c.isLetterOrNumber() &&
+			!c2.atParagEnd() )
+		    c2.gotoNextLetter();
+	    } else if ( para->at( cursor->index() )->c.isSpace() ) {
+		while ( c1.index() > 0 &&
+			c1.paragraph()->at( c1.index()-1 )->c.isSpace() )
+		    c1.gotoPreviousLetter();
+		while ( c2.paragraph()->at( c2.index() )->c.isSpace() &&
+			!c2.atParagEnd() )
+		    c2.gotoNextLetter();
+	    } else if ( !c2.atParagEnd() ) {
+		c2.gotoNextLetter();
+	    }
+	}
+#else
+	if ( cursor->index() > 0 && !cursor->paragraph()->at( cursor->index()-1 )->c.isSpace() )
+	    c1.gotoPreviousWord();
+	if ( !cursor->paragraph()->at( cursor->index() )->c.isSpace() && !cursor->atParagEnd() )
+	    c2.gotoNextWord();
+#endif
+	doc->setSelectionStart( QTextDocument::Standard, c1 );
+	doc->setSelectionEnd( QTextDocument::Standard, c2 );
+
+	*cursor = c2;
+
+	repaintChanged();
+
+	d->trippleClickTimer->start( qApp->doubleClickInterval(), TRUE );
+	d->trippleClickPoint = e->globalPos();
+    }
+    inDoubleClick = TRUE;
+    mousePressed = TRUE;
+    emit doubleClicked( para, index );
+}
+
+#ifndef QT_NO_DRAGANDDROP
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsDragEnterEvent( QDragEnterEvent *e )
+{
+    if ( isReadOnly() || !QTextDrag::canDecode( e ) ) {
+	e->ignore();
+	return;
+    }
+    e->acceptAction();
+    inDnD = TRUE;
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsDragMoveEvent( QDragMoveEvent *e )
+{
+    if ( isReadOnly() || !QTextDrag::canDecode( e ) ) {
+	e->ignore();
+	return;
+    }
+    drawCursor( FALSE );
+    placeCursor( e->pos(),  cursor );
+    drawCursor( TRUE );
+    e->acceptAction();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsDragLeaveEvent( QDragLeaveEvent * )
+{
+    drawCursor( FALSE );
+    inDnD = FALSE;
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::contentsDropEvent( QDropEvent *e )
+{
+    if ( isReadOnly() )
+	return;
+    inDnD = FALSE;
+    e->acceptAction();
+    bool intern = FALSE;
+    if ( QRichTextDrag::canDecode( e ) ) {
+	bool hasSel = doc->hasSelection( QTextDocument::Standard );
+	bool internalDrag = e->source() == this || e->source() == viewport();
+	int dropId, dropIndex;
+	QTextCursor insertCursor = *cursor;
+	dropId = cursor->paragraph()->paragId();
+	dropIndex = cursor->index();
+	if ( hasSel && internalDrag ) {
+	    QTextCursor c1, c2;
+	    int selStartId, selStartIndex;
+	    int selEndId, selEndIndex;
+	    c1 = doc->selectionStartCursor( QTextDocument::Standard );
+	    c1.restoreState();
+	    c2 = doc->selectionEndCursor( QTextDocument::Standard );
+	    c2.restoreState();
+	    selStartId = c1.paragraph()->paragId();
+	    selStartIndex = c1.index();
+	    selEndId = c2.paragraph()->paragId();
+	    selEndIndex = c2.index();
+	    if ( ( ( dropId > selStartId ) ||
+		   ( dropId == selStartId && dropIndex > selStartIndex ) ) &&
+		 ( ( dropId < selEndId ) ||
+		   ( dropId == selEndId && dropIndex <= selEndIndex ) ) )
+		insertCursor = c1;
+	    if ( dropId == selEndId && dropIndex > selEndIndex ) {
+		insertCursor = c1;
+		if ( selStartId == selEndId ) {
+		    insertCursor.setIndex( dropIndex -
+					   ( selEndIndex - selStartIndex ) );
+		} else {
+		    insertCursor.setIndex( dropIndex - selEndIndex +
+					   selStartIndex );
+		}
+	    }
+	 }
+
+	if ( internalDrag && e->action() == QDropEvent::Move ) {
+	    removeSelectedText();
+	    intern = TRUE;
+	    doc->removeSelection( QTextDocument::Standard );
+	} else {
+	    doc->removeSelection( QTextDocument::Standard );
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	}
+	drawCursor( FALSE );
+	cursor->setParagraph( insertCursor.paragraph() );
+	cursor->setIndex( insertCursor.index() );
+	drawCursor( TRUE );
+	if ( !cursor->nestedDepth() ) {
+	    QString subType = "plain";
+	    if ( textFormat() != PlainText ) {
+		if ( e->provides( "application/x-qrichtext" ) )
+		    subType = "x-qrichtext";
+	    }
+#ifndef QT_NO_CLIPBOARD
+	    pasteSubType( subType.latin1(), e );
+#endif
+	    // emit appropriate signals.
+	    emit selectionChanged();
+	    emit cursorPositionChanged( cursor );
+	    emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+	} else {
+	    if ( intern )
+		undo();
+	    e->ignore();
+	}
+    }
+}
+
+#endif
+
+/*!
+    \reimp
+*/
+void QTextEdit::contentsContextMenuEvent( QContextMenuEvent *e )
+{
+    clearUndoRedo();
+    mousePressed = FALSE;
+
+    e->accept();
+#ifndef QT_NO_POPUPMENU
+    QGuardedPtr<QTextEdit> that = this;
+    QGuardedPtr<QPopupMenu> popup = createPopupMenu( e->pos() );
+    if ( !popup )
+	popup = createPopupMenu();
+    if ( !popup )
+	return;
+
+    int r = popup->exec( e->globalPos() );
+    delete popup;
+    if (!that)
+        return;
+
+    if ( r == d->id[ IdClear ] )
+	clear();
+    else if ( r == d->id[ IdSelectAll ] ) {
+	selectAll();
+#ifndef QT_NO_CLIPBOARD
+        // if the clipboard support selections, put the newly selected text into
+        // the clipboard
+	if (QApplication::clipboard()->supportsSelection()) {
+	    d->clipboard_mode = QClipboard::Selection;
+
+            // don't listen to selection changes
+            disconnect( QApplication::clipboard(), SIGNAL(selectionChanged()), this, 0);
+	    copy();
+            // listen to selection changes
+            connect( QApplication::clipboard(), SIGNAL(selectionChanged()),
+                     this, SLOT(clipboardChanged()) );
+
+	    d->clipboard_mode = QClipboard::Clipboard;
+	}
+#endif
+    } else if ( r == d->id[ IdUndo ] )
+	undo();
+    else if ( r == d->id[ IdRedo ] )
+	redo();
+#ifndef QT_NO_CLIPBOARD
+    else if ( r == d->id[ IdCut ] )
+	cut();
+    else if ( r == d->id[ IdCopy ] )
+	copy();
+    else if ( r == d->id[ IdPaste ] )
+	paste();
+#endif
+#endif
+}
+
+
+void QTextEdit::autoScrollTimerDone()
+{
+    if ( mousePressed )
+	handleMouseMove(  viewportToContents( viewport()->mapFromGlobal( QCursor::pos() )  ) );
+}
+
+void QTextEdit::handleMouseMove( const QPoint& pos )
+{
+    if ( !mousePressed )
+	return;
+
+    if ( !scrollTimer->isActive() && pos.y() < contentsY() || pos.y() > contentsY() + visibleHeight() )
+	scrollTimer->start( 100, FALSE );
+    else if ( scrollTimer->isActive() && pos.y() >= contentsY() && pos.y() <= contentsY() + visibleHeight() )
+	scrollTimer->stop();
+
+    drawCursor( FALSE );
+    QTextCursor oldCursor = *cursor;
+
+    placeCursor( pos );
+
+    if ( inDoubleClick ) {
+	QTextCursor cl = *cursor;
+	cl.gotoPreviousWord();
+	QTextCursor cr = *cursor;
+	cr.gotoNextWord();
+
+	int diff = QABS( oldCursor.paragraph()->at( oldCursor.index() )->x - mousePos.x() );
+	int ldiff = QABS( cl.paragraph()->at( cl.index() )->x - mousePos.x() );
+	int rdiff = QABS( cr.paragraph()->at( cr.index() )->x - mousePos.x() );
+
+
+	if ( cursor->paragraph()->lineStartOfChar( cursor->index() ) !=
+	     oldCursor.paragraph()->lineStartOfChar( oldCursor.index() ) )
+	    diff = 0xFFFFFF;
+
+	if ( rdiff < diff && rdiff < ldiff )
+	    *cursor = cr;
+	else if ( ldiff < diff && ldiff < rdiff )
+	    *cursor = cl;
+	else
+	    *cursor = oldCursor;
+
+    }
+    ensureCursorVisible();
+
+    bool redraw = FALSE;
+    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	redraw = doc->setSelectionEnd( QTextDocument::Standard, *cursor ) || redraw;
+    }
+
+    if ( !redraw ) {
+	drawCursor( TRUE );
+    } else {
+	repaintChanged();
+	drawCursor( TRUE );
+    }
+
+    if ( currentFormat && currentFormat->key() != cursor->paragraph()->at( cursor->index() )->format()->key() ) {
+	currentFormat->removeRef();
+	currentFormat = doc->formatCollection()->format( cursor->paragraph()->at( cursor->index() )->format() );
+	if ( currentFormat->isMisspelled() ) {
+	    currentFormat->removeRef();
+	    currentFormat = doc->formatCollection()->format( currentFormat->font(), currentFormat->color() );
+	}
+	emit currentFontChanged( currentFormat->font() );
+	emit currentColorChanged( currentFormat->color() );
+	emit currentVerticalAlignmentChanged( (VerticalAlignment)currentFormat->vAlign() );
+    }
+
+    if ( currentAlignment != cursor->paragraph()->alignment() ) {
+	currentAlignment = cursor->paragraph()->alignment();
+	block_set_alignment = TRUE;
+	emit currentAlignmentChanged( currentAlignment );
+	block_set_alignment = FALSE;
+    }
+}
+
+/*! \internal */
+
+void QTextEdit::placeCursor( const QPoint &pos, QTextCursor *c, bool link )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return;
+#endif
+    if ( !c )
+	c = cursor;
+
+    resetInputContext();
+    c->restoreState();
+    QTextParagraph *s = doc->firstParagraph();
+    c->place( pos, s, link );
+    updateMicroFocusHint();
+}
+
+
+void QTextEdit::updateMicroFocusHint()
+{
+    QTextCursor c( *cursor );
+    if ( d->preeditStart != -1 ) {
+	c.setIndex( d->preeditStart );
+        if(doc->hasSelection(QTextDocument::IMSelectionText)) {
+            int para, index;
+            doc->selectionStart(QTextDocument::IMSelectionText, para, index);
+            c.setIndex(index);
+        }
+    }
+
+    if ( hasFocus() || viewport()->hasFocus() ) {
+	int h = c.paragraph()->lineHeightOfChar( cursor->index() );
+	if ( !readonly ) {
+	    QFont f = c.paragraph()->at( c.index() )->format()->font();
+	    setMicroFocusHint( c.x() - contentsX() + frameWidth(),
+			       c.y() + cursor->paragraph()->rect().y() - contentsY() + frameWidth(), 0, h, TRUE, &f );
+	}
+    }
+}
+
+
+
+void QTextEdit::formatMore()
+{
+    if ( !lastFormatted )
+	return;
+
+    int bottom = contentsHeight();
+    int lastTop = -1;
+    int lastBottom = -1;
+    int to = 20;
+    bool firstVisible = FALSE;
+    QRect cr( contentsX(), contentsY(), visibleWidth(), visibleHeight() );
+    for ( int i = 0; lastFormatted &&
+	  ( i < to || ( firstVisible && lastTop < contentsY()+height() ) );
+	  i++ ) {
+	lastFormatted->format();
+	lastTop = lastFormatted->rect().top();
+	lastBottom = lastFormatted->rect().bottom();
+	if ( i == 0 )
+	    firstVisible = lastBottom < cr.bottom();
+	bottom = QMAX( bottom, lastBottom );
+	lastFormatted = lastFormatted->next();
+    }
+
+    if ( bottom > contentsHeight() ) {
+	resizeContents( contentsWidth(), QMAX( doc->height(), bottom ) );
+    } else if ( !lastFormatted && lastBottom < contentsHeight() ) {
+	resizeContents( contentsWidth(), QMAX( doc->height(), lastBottom ) );
+	if ( contentsHeight() < visibleHeight() )
+	    updateContents( 0, contentsHeight(), visibleWidth(),
+			    visibleHeight() - contentsHeight() );
+    }
+
+    if ( lastFormatted )
+	formatTimer->start( interval, TRUE );
+    else
+	interval = QMAX( 0, interval );
+}
+
+void QTextEdit::doResize()
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( !d->optimMode )
+#endif
+    {
+	if ( wrapMode == FixedPixelWidth )
+	    return;
+	doc->setMinimumWidth( -1 );
+	resizeContents( 0, 0 );
+	doc->setWidth( visibleWidth() );
+	doc->invalidate();
+	lastFormatted = doc->firstParagraph();
+	interval = 0;
+	formatMore();
+    }
+    repaintContents( FALSE );
+}
+
+/*! \internal */
+
+void QTextEdit::doChangeInterval()
+{
+    interval = 0;
+}
+
+/*!
+    \reimp
+*/
+
+bool QTextEdit::eventFilter( QObject *o, QEvent *e )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( !d->optimMode && (o == this || o == viewport()) ) {
+#else
+    if ( o == this || o == viewport() ) {
+#endif
+	if ( e->type() == QEvent::FocusIn ) {
+	    if ( QApplication::cursorFlashTime() > 0 )
+		blinkTimer->start( QApplication::cursorFlashTime() / 2 );
+	    drawCursor( TRUE );
+	    updateMicroFocusHint();
+	} else if ( e->type() == QEvent::FocusOut ) {
+	    blinkTimer->stop();
+	    drawCursor( FALSE );
+	}
+    }
+
+    if ( o == this && e->type() == QEvent::PaletteChange ) {
+	QColor old( viewport()->colorGroup().color( QColorGroup::Text ) );
+	if ( old != colorGroup().color( QColorGroup::Text ) ) {
+	    QColor c( colorGroup().color( QColorGroup::Text ) );
+	    doc->setMinimumWidth( -1 );
+	    doc->setDefaultFormat( doc->formatCollection()->defaultFormat()->font(), c );
+	    lastFormatted = doc->firstParagraph();
+	    formatMore();
+	    repaintChanged();
+	}
+    }
+
+    return QScrollView::eventFilter( o, e );
+}
+
+/*!
+  \obsolete
+ */
+void QTextEdit::insert( const QString &text, bool indent,
+			bool checkNewLine, bool removeSelected )
+{
+    uint f = 0;
+    if ( indent )
+	f |= RedoIndentation;
+    if ( checkNewLine )
+	f |= CheckNewLines;
+    if ( removeSelected )
+	f |= RemoveSelected;
+    insert( text, f );
+}
+
+/*!
+    Inserts \a text at the current cursor position.
+
+    The \a insertionFlags define how the text is inserted. If \c
+    RedoIndentation is set, the paragraph is re-indented. If \c
+    CheckNewLines is set, newline characters in \a text result in hard
+    line breaks (i.e. new paragraphs). If \c checkNewLine is not set,
+    the behaviour of the editor is undefined if the \a text contains
+    newlines. (It is not possible to change QTextEdit's newline handling
+    behavior, but you can use QString::replace() to preprocess text
+    before inserting it.) If \c RemoveSelected is set, any selected
+    text (in selection 0) is removed before the text is inserted.
+
+    The default flags are \c CheckNewLines | \c RemoveSelected.
+
+    If the widget is in \c LogText mode this function will do nothing.
+
+    \sa paste() pasteSubType()
+*/
+
+
+void QTextEdit::insert( const QString &text, uint insertionFlags )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return;
+#endif
+
+    if ( cursor->nestedDepth() != 0 ) // #### for 3.0, disable editing of tables as this is not advanced enough
+	return;
+
+    bool indent = insertionFlags & RedoIndentation;
+    bool checkNewLine = insertionFlags & CheckNewLines;
+    bool removeSelected = insertionFlags & RemoveSelected;
+    QString txt( text );
+    drawCursor( FALSE );
+    if ( !isReadOnly() && doc->hasSelection( QTextDocument::Standard ) && removeSelected )
+	removeSelectedText();
+    QTextCursor c2 = *cursor;
+    int oldLen = 0;
+
+    if ( undoEnabled && !isReadOnly() && undoRedoInfo.type != UndoRedoInfo::IME ) {
+	checkUndoRedoInfo( UndoRedoInfo::Insert );
+
+        if (undoRedoInfo.valid() && undoRedoInfo.index + undoRedoInfo.d->text.length() != cursor->index()) {
+            clearUndoRedo();
+            undoRedoInfo.type = UndoRedoInfo::Insert;
+        }
+
+	if ( !undoRedoInfo.valid() ) {
+	    undoRedoInfo.id = cursor->paragraph()->paragId();
+	    undoRedoInfo.index = cursor->index();
+	    undoRedoInfo.d->text = QString::null;
+	}
+	oldLen = undoRedoInfo.d->text.length();
+    }
+
+    lastFormatted = checkNewLine && cursor->paragraph()->prev() ?
+		    cursor->paragraph()->prev() : cursor->paragraph();
+    QTextCursor oldCursor = *cursor;
+    cursor->insert( txt, checkNewLine );
+    if ( doc->useFormatCollection() && !doc->preProcessor() ) {
+	doc->setSelectionStart( QTextDocument::Temp, oldCursor );
+	doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+	doc->setFormat( QTextDocument::Temp, currentFormat, QTextFormat::Format );
+	doc->removeSelection( QTextDocument::Temp );
+    }
+
+    if ( indent && ( txt == "{" || txt == "}" || txt == ":" || txt == "#" ) )
+	cursor->indent();
+    formatMore();
+    repaintChanged();
+    ensureCursorVisible();
+    drawCursor( TRUE );
+
+    if ( undoEnabled && !isReadOnly() && undoRedoInfo.type != UndoRedoInfo::IME ) {
+	undoRedoInfo.d->text += txt;
+	if ( !doc->preProcessor() ) {
+	    for ( int i = 0; i < (int)txt.length(); ++i ) {
+		if ( txt[ i ] != '\n' && c2.paragraph()->at( c2.index() )->format() ) {
+		    c2.paragraph()->at( c2.index() )->format()->addRef();
+		    undoRedoInfo.d->text.
+			setFormat( oldLen + i,
+				   c2.paragraph()->at( c2.index() )->format(), TRUE );
+		}
+		c2.gotoNextLetter();
+	    }
+	}
+    }
+
+    if ( !removeSelected ) {
+	doc->setSelectionStart( QTextDocument::Standard, oldCursor );
+	doc->setSelectionEnd( QTextDocument::Standard, *cursor );
+	repaintChanged();
+    }
+    updateMicroFocusHint();
+    setModified();
+    emit textChanged();
+}
+
+/*!
+    Inserts \a text in the paragraph \a para at position \a index.
+*/
+
+void QTextEdit::insertAt( const QString &text, int para, int index )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimInsert( text, para, index );
+	return;
+    }
+#endif
+    resetInputContext();
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return;
+    removeSelection( QTextDocument::Standard );
+    QTextCursor tmp = *cursor;
+    cursor->setParagraph( p );
+    cursor->setIndex( index );
+    insert( text, FALSE, TRUE, FALSE );
+    *cursor = tmp;
+    removeSelection( QTextDocument::Standard );
+}
+
+/*!
+    Inserts \a text as a new paragraph at position \a para. If \a para
+    is -1, the text is appended. Use append() if the append operation
+    is performance critical.
+*/
+
+void QTextEdit::insertParagraph( const QString &text, int para )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimInsert( text + "\n", para, 0 );
+	return;
+    }
+#endif
+    resetInputContext();
+    for ( int i = 0; i < (int)doc->numSelections(); ++i )
+	doc->removeSelection( i );
+
+    QTextParagraph *p = doc->paragAt( para );
+
+    bool append = !p;
+    if ( !p )
+	p = doc->lastParagraph();
+
+    QTextCursor old = *cursor;
+    drawCursor( FALSE );
+
+    cursor->setParagraph( p );
+    cursor->setIndex( 0 );
+    clearUndoRedo();
+    qtextedit_ignore_readonly = TRUE;
+    if ( append && cursor->paragraph()->length() > 1 ) {
+	cursor->setIndex( cursor->paragraph()->length() - 1 );
+	doKeyboardAction( ActionReturn );
+    }
+    insert( text, FALSE, TRUE, TRUE );
+    doKeyboardAction( ActionReturn );
+    qtextedit_ignore_readonly = FALSE;
+
+    drawCursor( FALSE );
+    *cursor = old;
+    drawCursor( TRUE );
+
+    repaintChanged();
+}
+
+/*!
+    Removes the paragraph \a para.
+*/
+
+void QTextEdit::removeParagraph( int para )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return;
+#endif
+    resetInputContext();
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return;
+
+    for ( int i = 0; i < doc->numSelections(); ++i )
+	doc->removeSelection( i );
+
+    QTextCursor start( doc );
+    QTextCursor end( doc );
+    start.setParagraph( p );
+    start.setIndex( 0 );
+    end.setParagraph( p );
+    end.setIndex( p->length() - 1 );
+
+    if ( !(p == doc->firstParagraph() && p == doc->lastParagraph()) ) {
+	if ( p->next() ) {
+	    end.setParagraph( p->next() );
+	    end.setIndex( 0 );
+	} else if ( p->prev() ) {
+	    start.setParagraph( p->prev() );
+	    start.setIndex( p->prev()->length() - 1 );
+	}
+    }
+
+    doc->setSelectionStart( QTextDocument::Temp, start );
+    doc->setSelectionEnd( QTextDocument::Temp, end );
+    removeSelectedText( QTextDocument::Temp );
+}
+
+/*!
+    Undoes the last operation.
+
+    If there is no operation to undo, i.e. there is no undo step in
+    the undo/redo history, nothing happens.
+
+    \sa undoAvailable() redo() undoDepth()
+*/
+
+void QTextEdit::undo()
+{
+    clearUndoRedo();
+    if ( isReadOnly() || !doc->commands()->isUndoAvailable() || !undoEnabled )
+	return;
+
+    resetInputContext();
+    for ( int i = 0; i < (int)doc->numSelections(); ++i )
+	doc->removeSelection( i );
+
+#ifndef QT_NO_CURSOR
+    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+
+    clearUndoRedo();
+    drawCursor( FALSE );
+    QTextCursor *c = doc->undo( cursor );
+    if ( !c ) {
+	drawCursor( TRUE );
+	return;
+    }
+    lastFormatted = 0;
+    repaintChanged();
+    ensureCursorVisible();
+    drawCursor( TRUE );
+    updateMicroFocusHint();
+    setModified();
+    // ### If we get back to a completely blank textedit, it
+    // is possible that cursor is invalid and further actions
+    // might not fix the problem, so reset the cursor here.
+    // This is copied from removeSeletedText(), it might be
+    // okay to just call that.
+    if ( !cursor->isValid() ) {
+	delete cursor;
+	cursor = new QTextCursor( doc );
+	drawCursor( TRUE );
+	repaintContents( TRUE );
+    }
+    emit undoAvailable( isUndoAvailable() );
+    emit redoAvailable( isRedoAvailable() );
+    emit textChanged();
+}
+
+/*!
+    Redoes the last operation.
+
+    If there is no operation to redo, i.e. there is no redo step in
+    the undo/redo history, nothing happens.
+
+    \sa redoAvailable() undo() undoDepth()
+*/
+
+void QTextEdit::redo()
+{
+    if ( isReadOnly() || !doc->commands()->isRedoAvailable() || !undoEnabled )
+	return;
+
+    resetInputContext();
+    for ( int i = 0; i < (int)doc->numSelections(); ++i )
+	doc->removeSelection( i );
+
+#ifndef QT_NO_CURSOR
+    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+
+    clearUndoRedo();
+    drawCursor( FALSE );
+    QTextCursor *c = doc->redo( cursor );
+    if ( !c ) {
+	drawCursor( TRUE );
+	return;
+    }
+    lastFormatted = 0;
+    ensureCursorVisible();
+    repaintChanged();
+    ensureCursorVisible();
+    drawCursor( TRUE );
+    updateMicroFocusHint();
+    setModified();
+    emit undoAvailable( isUndoAvailable() );
+    emit redoAvailable( isRedoAvailable() );
+    emit textChanged();
+}
+
+/*!
+    Pastes the text from the clipboard into the text edit at the
+    current cursor position. Only plain text is pasted.
+
+    If there is no text in the clipboard nothing happens.
+
+    \sa pasteSubType() cut() QTextEdit::copy()
+*/
+
+void QTextEdit::paste()
+{
+#ifndef QT_NO_MIMECLIPBOARD
+    if ( isReadOnly() )
+	return;
+    QString subType = "plain";
+    if ( textFormat() != PlainText ) {
+	QMimeSource *m = QApplication::clipboard()->data( d->clipboard_mode );
+	if ( !m )
+	    return;
+	if ( m->provides( "application/x-qrichtext" ) )
+	    subType = "x-qrichtext";
+    }
+
+    pasteSubType( subType.latin1() );
+    updateMicroFocusHint();
+#endif
+}
+
+void QTextEdit::checkUndoRedoInfo( UndoRedoInfo::Type t )
+{
+    if ( undoRedoInfo.valid() && t != undoRedoInfo.type ) {
+	clearUndoRedo();
+    }
+    undoRedoInfo.type = t;
+}
+
+/*!
+    Repaints any paragraphs that have changed.
+
+    Although used extensively internally you shouldn't need to call
+    this yourself.
+*/
+
+void QTextEdit::repaintChanged()
+{
+    if ( !isUpdatesEnabled() || !viewport()->isUpdatesEnabled() )
+	return;
+
+    QPainter p( viewport() );
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimDrawContents( &p, contentsX(), contentsY(), visibleWidth(), visibleHeight() );
+	return;
+    }
+#endif
+    p.translate( -contentsX(), -contentsY() );
+    paintDocument( FALSE, &p, contentsX(), contentsY(), visibleWidth(), visibleHeight() );
+}
+
+#ifndef QT_NO_MIME
+QTextDrag *QTextEdit::dragObject( QWidget *parent ) const
+{
+    if ( !doc->hasSelection( QTextDocument::Standard ) ||
+	 doc->selectedText( QTextDocument::Standard ).isEmpty() )
+	return 0;
+    if ( textFormat() != RichText )
+	return new QTextDrag( doc->selectedText( QTextDocument::Standard ), parent );
+    QRichTextDrag *drag = new QRichTextDrag( parent );
+    drag->setPlainText( doc->selectedText( QTextDocument::Standard ) );
+    drag->setRichText( doc->selectedText( QTextDocument::Standard, TRUE ) );
+    return drag;
+}
+#endif
+
+/*!
+    Copies the selected text (from selection 0) to the clipboard and
+    deletes it from the text edit.
+
+    If there is no selected text (in selection 0) nothing happens.
+
+    \sa QTextEdit::copy() paste() pasteSubType()
+*/
+
+void QTextEdit::cut()
+{
+    if ( isReadOnly() )
+	return;
+    resetInputContext();
+    normalCopy();
+    removeSelectedText();
+    updateMicroFocusHint();
+}
+
+void QTextEdit::normalCopy()
+{
+#ifndef QT_NO_MIME
+    QTextDrag *drag = dragObject();
+    if ( !drag )
+	return;
+#ifndef QT_NO_MIMECLIPBOARD
+    QApplication::clipboard()->setData( drag, d->clipboard_mode );
+#endif // QT_NO_MIMECLIPBOARD
+#endif // QT_NO_MIME
+}
+
+/*!
+    Copies any selected text (from selection 0) to the clipboard.
+
+    \sa hasSelectedText() copyAvailable()
+*/
+
+void QTextEdit::copy()
+{
+#ifndef QT_NO_CLIPBOARD
+# ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode && optimHasSelection() )
+	QApplication::clipboard()->setText( optimSelectedText(), d->clipboard_mode );
+    else
+	normalCopy();
+# else
+    normalCopy();
+# endif
+#endif
+}
+
+/*!
+    \internal
+
+    Re-indents the current paragraph.
+*/
+
+void QTextEdit::indent()
+{
+    if ( isReadOnly() )
+	return;
+
+    drawCursor( FALSE );
+    if ( !doc->hasSelection( QTextDocument::Standard ) )
+	cursor->indent();
+    else
+	doc->indentSelection( QTextDocument::Standard );
+    repaintChanged();
+    drawCursor( TRUE );
+    setModified();
+    emit textChanged();
+}
+
+/*!
+    Reimplemented to allow tabbing through links. If \a n is TRUE the
+    tab moves the focus to the next child; if \a n is FALSE the tab
+    moves the focus to the previous child. Returns TRUE if the focus
+    was moved; otherwise returns FALSE.
+ */
+
+bool QTextEdit::focusNextPrevChild( bool n )
+{
+    if ( !isReadOnly() || !linksEnabled() )
+	return FALSE;
+    bool b = doc->focusNextPrevChild( n );
+    repaintChanged();
+    if ( b ) {
+        QTextParagraph *p = doc->focusIndicator.parag;
+        int start = doc->focusIndicator.start;
+        int len = doc->focusIndicator.len;
+
+        int y = p->rect().y();
+        while ( p
+                && len == 0
+                && p->at( start )->isCustom()
+                && p->at( start )->customItem()->isNested() ) {
+
+            QTextTable *t = (QTextTable*)p->at( start )->customItem();
+            QPtrList<QTextTableCell> cells = t->tableCells();
+            QTextTableCell *c;
+            for ( c = cells.first(); c; c = cells.next() ) {
+                QTextDocument *cellDoc = c->richText();
+                if ( cellDoc->hasFocusParagraph() ) {
+                    y += c->geometry().y() + c->verticalAlignmentOffset();
+
+                    p = cellDoc->focusIndicator.parag;
+                    start = cellDoc->focusIndicator.start;
+                    len = cellDoc->focusIndicator.len;
+                    if ( p )
+                        y += p->rect().y();
+
+                    break;
+                }
+            }
+        }
+        setContentsPos( contentsX(), QMIN( y, contentsHeight() - visibleHeight() ) );
+    }
+    return b;
+}
+
+/*!
+    \internal
+
+  This functions sets the current format to \a f. Only the fields of \a
+  f which are specified by the \a flags are used.
+*/
+
+void QTextEdit::setFormat( QTextFormat *f, int flags )
+{
+    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	drawCursor( FALSE );
+	QTextCursor c1 = doc->selectionStartCursor( QTextDocument::Standard );
+	c1.restoreState();
+	QTextCursor c2 = doc->selectionEndCursor( QTextDocument::Standard );
+	c2.restoreState();
+	if ( undoEnabled ) {
+	    clearUndoRedo();
+	    undoRedoInfo.type = UndoRedoInfo::Format;
+	    undoRedoInfo.id = c1.paragraph()->paragId();
+	    undoRedoInfo.index = c1.index();
+	    undoRedoInfo.eid = c2.paragraph()->paragId();
+	    undoRedoInfo.eindex = c2.index();
+	    readFormats( c1, c2, undoRedoInfo.d->text );
+	    undoRedoInfo.format = f;
+	    undoRedoInfo.flags = flags;
+	    clearUndoRedo();
+	}
+	doc->setFormat( QTextDocument::Standard, f, flags );
+	repaintChanged();
+	formatMore();
+	drawCursor( TRUE );
+	setModified();
+	emit textChanged();
+    }
+    if ( currentFormat && currentFormat->key() != f->key() ) {
+	currentFormat->removeRef();
+	currentFormat = doc->formatCollection()->format( f );
+	if ( currentFormat->isMisspelled() ) {
+	    currentFormat->removeRef();
+	    currentFormat = doc->formatCollection()->format( currentFormat->font(),
+							     currentFormat->color() );
+	}
+	emit currentFontChanged( currentFormat->font() );
+	emit currentColorChanged( currentFormat->color() );
+	emit currentVerticalAlignmentChanged( (VerticalAlignment)currentFormat->vAlign() );
+	if ( cursor->index() == cursor->paragraph()->length() - 1 ) {
+	    currentFormat->addRef();
+	    cursor->paragraph()->string()->setFormat( cursor->index(), currentFormat, TRUE );
+	    if ( cursor->paragraph()->length() == 1 ) {
+		cursor->paragraph()->invalidate( 0 );
+		cursor->paragraph()->format();
+		repaintChanged();
+	    }
+	}
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::setPalette( const QPalette &p )
+{
+    QScrollView::setPalette( p );
+    if ( textFormat() == PlainText ) {
+	QTextFormat *f = doc->formatCollection()->defaultFormat();
+	f->setColor( colorGroup().text() );
+	updateContents();
+    }
+}
+
+/*! \internal
+  \warning In Qt 3.1 we will provide a cleaer API for the
+  functionality which is provided by this function and in Qt 4.0 this
+  function will go away.
+
+  Sets the paragraph style of the current paragraph
+  to \a dm. If \a dm is QStyleSheetItem::DisplayListItem, the
+  type of the list item is set to \a listStyle.
+
+  \sa setAlignment()
+*/
+
+void QTextEdit::setParagType( QStyleSheetItem::DisplayMode dm,
+			      QStyleSheetItem::ListStyle listStyle )
+{
+    if ( isReadOnly() )
+	return;
+
+    drawCursor( FALSE );
+    QTextParagraph *start = cursor->paragraph();
+    QTextParagraph *end = start;
+    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	start = doc->selectionStartCursor( QTextDocument::Standard ).topParagraph();
+	end = doc->selectionEndCursor( QTextDocument::Standard ).topParagraph();
+	if ( end->paragId() < start->paragId() )
+	    return; // do not trust our selections
+    }
+
+    clearUndoRedo();
+    undoRedoInfo.type = UndoRedoInfo::Style;
+    undoRedoInfo.id = start->paragId();
+    undoRedoInfo.eid = end->paragId();
+    undoRedoInfo.styleInformation = QTextStyleCommand::readStyleInformation( doc, undoRedoInfo.id, undoRedoInfo.eid );
+
+    while ( start != end->next() ) {
+	start->setListStyle( listStyle );
+	if ( dm == QStyleSheetItem::DisplayListItem ) {
+	    start->setListItem( TRUE );
+	    if( start->listDepth() == 0 )
+		start->setListDepth( 1 );
+	} else if ( start->isListItem() ) {
+	    start->setListItem( FALSE );
+	    start->setListDepth( QMAX( start->listDepth()-1, 0 ) );
+	}
+	start = start->next();
+    }
+
+    clearUndoRedo();
+    repaintChanged();
+    formatMore();
+    drawCursor( TRUE );
+    setModified();
+    emit textChanged();
+}
+
+/*!
+    Sets the alignment of the current paragraph to \a a. Valid
+    alignments are \c Qt::AlignLeft, \c Qt::AlignRight,
+    \c Qt::AlignJustify and \c Qt::AlignCenter (which centers
+    horizontally).
+*/
+
+void QTextEdit::setAlignment( int a )
+{
+    if ( isReadOnly() || block_set_alignment )
+	return;
+
+    drawCursor( FALSE );
+    QTextParagraph *start = cursor->paragraph();
+    QTextParagraph *end = start;
+    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	start = doc->selectionStartCursor( QTextDocument::Standard ).topParagraph();
+	end = doc->selectionEndCursor( QTextDocument::Standard ).topParagraph();
+	if ( end->paragId() < start->paragId() )
+	    return; // do not trust our selections
+    }
+
+    clearUndoRedo();
+    undoRedoInfo.type = UndoRedoInfo::Style;
+    undoRedoInfo.id = start->paragId();
+    undoRedoInfo.eid = end->paragId();
+    undoRedoInfo.styleInformation = QTextStyleCommand::readStyleInformation( doc, undoRedoInfo.id, undoRedoInfo.eid );
+
+    while ( start != end->next() ) {
+	start->setAlignment( a );
+	start = start->next();
+    }
+
+    clearUndoRedo();
+    repaintChanged();
+    formatMore();
+    drawCursor( TRUE );
+    if ( currentAlignment != a ) {
+	currentAlignment = a;
+	emit currentAlignmentChanged( currentAlignment );
+    }
+    setModified();
+    emit textChanged();
+}
+
+void QTextEdit::updateCurrentFormat()
+{
+    int i = cursor->index();
+    if ( i > 0 )
+	--i;
+    if ( doc->useFormatCollection() &&
+	 ( !currentFormat || currentFormat->key() != cursor->paragraph()->at( i )->format()->key() ) ) {
+	if ( currentFormat )
+	    currentFormat->removeRef();
+	currentFormat = doc->formatCollection()->format( cursor->paragraph()->at( i )->format() );
+	if ( currentFormat->isMisspelled() ) {
+	    currentFormat->removeRef();
+	    currentFormat = doc->formatCollection()->format( currentFormat->font(), currentFormat->color() );
+	}
+	emit currentFontChanged( currentFormat->font() );
+	emit currentColorChanged( currentFormat->color() );
+	emit currentVerticalAlignmentChanged( (VerticalAlignment)currentFormat->vAlign() );
+    }
+
+    if ( currentAlignment != cursor->paragraph()->alignment() ) {
+	currentAlignment = cursor->paragraph()->alignment();
+	block_set_alignment = TRUE;
+	emit currentAlignmentChanged( currentAlignment );
+	block_set_alignment = FALSE;
+    }
+}
+
+/*!
+    If \a b is TRUE sets the current format to italic; otherwise sets
+    the current format to non-italic.
+
+    \sa italic()
+*/
+
+void QTextEdit::setItalic( bool b )
+{
+    QTextFormat f( *currentFormat );
+    f.setItalic( b );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat(f2, QTextFormat::Italic );
+}
+
+/*!
+    If \a b is TRUE sets the current format to bold; otherwise sets
+    the current format to non-bold.
+
+    \sa bold()
+*/
+
+void QTextEdit::setBold( bool b )
+{
+    QTextFormat f( *currentFormat );
+    f.setBold( b );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Bold );
+}
+
+/*!
+    If \a b is TRUE sets the current format to underline; otherwise
+    sets the current format to non-underline.
+
+    \sa underline()
+*/
+
+void QTextEdit::setUnderline( bool b )
+{
+    QTextFormat f( *currentFormat );
+    f.setUnderline( b );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Underline );
+}
+
+/*!
+    Sets the font family of the current format to \a fontFamily.
+
+    \sa family() setCurrentFont()
+*/
+
+void QTextEdit::setFamily( const QString &fontFamily )
+{
+    QTextFormat f( *currentFormat );
+    f.setFamily( fontFamily );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Family );
+}
+
+/*!
+    Sets the point size of the current format to \a s.
+
+    Note that if \a s is zero or negative, the behaviour of this
+    function is not defined.
+
+    \sa pointSize() setCurrentFont() setFamily()
+*/
+
+void QTextEdit::setPointSize( int s )
+{
+    QTextFormat f( *currentFormat );
+    f.setPointSize( s );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Size );
+}
+
+/*!
+    Sets the color of the current format, i.e. of the text, to \a c.
+
+    \sa color() setPaper()
+*/
+
+void QTextEdit::setColor( const QColor &c )
+{
+    QTextFormat f( *currentFormat );
+    f.setColor( c );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Color );
+}
+
+/*!
+    Sets the vertical alignment of the current format, i.e. of the
+    text, to \a a.
+
+    \sa color() setPaper()
+*/
+
+void QTextEdit::setVerticalAlignment( VerticalAlignment a )
+{
+    QTextFormat f( *currentFormat );
+    f.setVAlign( (QTextFormat::VerticalAlignment)a );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::VAlign );
+}
+
+void QTextEdit::setFontInternal( const QFont &f_ )
+{
+    QTextFormat f( *currentFormat );
+    f.setFont( f_ );
+    QTextFormat *f2 = doc->formatCollection()->format( &f );
+    setFormat( f2, QTextFormat::Font );
+}
+
+
+QString QTextEdit::text() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return optimText();
+#endif
+
+    QTextParagraph *p = doc->firstParagraph();
+    if ( !p || (!p->next() && p->length() <= 1) )
+	return QString::fromLatin1("");
+
+    if ( isReadOnly() )
+	return doc->originalText();
+    return doc->text();
+}
+
+/*!
+    \overload
+
+    Returns the text of paragraph \a para.
+
+    If textFormat() is \c RichText the text will contain HTML
+    formatting tags.
+*/
+
+QString QTextEdit::text( int para ) const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode && (d->od->numLines >= para) ) {
+	QString paraStr = d->od->lines[ LOGOFFSET(para) ];
+	if ( paraStr.isEmpty() )
+	    paraStr = "\n";
+	return paraStr;
+    } else
+#endif
+    return doc->text( para );
+}
+
+/*!
+    \overload
+
+    Changes the text of the text edit to the string \a text and the
+    context to \a context. Any previous text is removed.
+
+    \a text may be interpreted either as plain text or as rich text,
+    depending on the textFormat(). The default setting is \c AutoText,
+    i.e. the text edit auto-detects the format from \a text.
+
+    For rich text the rendering style and available tags are defined
+    by a styleSheet(); see QStyleSheet for details.
+
+    The optional \a context is a path which the text edit's
+    QMimeSourceFactory uses to resolve the locations of files and
+    images. (See \l{QTextEdit::QTextEdit()}.) It is passed to the text
+    edit's QMimeSourceFactory when quering data.
+
+    Note that the undo/redo history is cleared by this function.
+
+    \sa text(), setTextFormat()
+*/
+
+void QTextEdit::setText( const QString &text, const QString &context )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimSetText( text );
+	return;
+    }
+#endif
+    resetInputContext();
+    if ( !isModified() && isReadOnly() &&
+	 this->context() == context && this->text() == text )
+	return;
+
+    emit undoAvailable( FALSE );
+    emit redoAvailable( FALSE );
+    undoRedoInfo.clear();
+    doc->commands()->clear();
+
+    lastFormatted = 0;
+    int oldCursorPos = cursor->index();
+    int oldCursorPar = cursor->paragraph()->paragId();
+    cursor->restoreState();
+    delete cursor;
+    doc->setText( text, context );
+
+    if ( wrapMode == FixedPixelWidth ) {
+	resizeContents( wrapWidth, 0 );
+	doc->setWidth( wrapWidth );
+	doc->setMinimumWidth( wrapWidth );
+    } else {
+	doc->setMinimumWidth( -1 );
+	resizeContents( 0, 0 );
+    }
+
+    lastFormatted = doc->firstParagraph();
+    cursor = new QTextCursor( doc );
+    updateContents();
+
+    if ( isModified() )
+	setModified( FALSE );
+    emit textChanged();
+    if ( cursor->index() != oldCursorPos || cursor->paragraph()->paragId() != oldCursorPar ) {
+	emit cursorPositionChanged( cursor );
+	emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+    }
+    formatMore();
+    updateCurrentFormat();
+    d->scrollToAnchor = QString::null;
+}
+
+/*!
+    \property QTextEdit::text
+    \brief the text edit's text
+
+    There is no default text.
+
+    On setting, any previous text is deleted.
+
+    The text may be interpreted either as plain text or as rich text,
+    depending on the textFormat(). The default setting is \c AutoText,
+    i.e. the text edit auto-detects the format of the text.
+
+    For richtext, calling text() on an editable QTextEdit will cause
+    the text to be regenerated from the textedit. This may mean that
+    the QString returned may not be exactly the same as the one that
+    was set.
+
+    \sa textFormat
+*/
+
+
+/*!
+    \property QTextEdit::readOnly
+    \brief whether the text edit is read-only
+
+    In a read-only text edit the user can only navigate through the
+    text and select text; modifying the text is not possible.
+
+    This property's default is FALSE.
+*/
+
+/*!
+    Finds the next occurrence of the string, \a expr. Returns TRUE if
+    \a expr was found; otherwise returns FALSE.
+
+    If \a para and \a index are both 0 the search begins from the
+    current cursor position. If \a para and \a index are both not 0,
+    the search begins from the \a *index character position in the
+    \a *para paragraph.
+
+    If \a cs is TRUE the search is case sensitive, otherwise it is
+    case insensitive. If \a wo is TRUE the search looks for whole word
+    matches only; otherwise it searches for any matching text. If \a
+    forward is TRUE (the default) the search works forward from the
+    starting position to the end of the text, otherwise it works
+    backwards to the beginning of the text.
+
+    If \a expr is found the function returns TRUE. If \a index and \a
+    para are not 0, the number of the paragraph in which the first
+    character of the match was found is put into \a *para, and the
+    index position of that character within the paragraph is put into
+    \a *index.
+
+    If \a expr is not found the function returns FALSE. If \a index
+    and \a para are not 0 and \a expr is not found, \a *index
+    and \a *para are undefined.
+
+    Please note that this function will make the next occurrence of
+    the string (if found) the current selection, and will thus
+    modify the cursor position.
+
+    Using the \a para and \a index parameters will not work correctly
+    in case the document contains tables.
+*/
+
+bool QTextEdit::find( const QString &expr, bool cs, bool wo, bool forward,
+		      int *para, int *index )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return optimFind( expr, cs, wo, forward, para, index );
+#endif
+    drawCursor( FALSE );
+#ifndef QT_NO_CURSOR
+    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+    QTextCursor findcur = *cursor;
+    if ( para && index ) {
+	if ( doc->paragAt( *para ) )
+	    findcur.gotoPosition( doc->paragAt(*para), *index );
+	else
+	    findcur.gotoEnd();
+    } else if ( doc->hasSelection( QTextDocument::Standard ) ){
+	// maks sure we do not find the same selection again
+	if ( forward )
+	    findcur.gotoNextLetter();
+	else
+	    findcur.gotoPreviousLetter();
+    } else if (!forward && findcur.index() == 0 && findcur.paragraph() == findcur.topParagraph()) {
+	findcur.gotoEnd();
+    }
+    removeSelection( QTextDocument::Standard );
+    bool found = doc->find( findcur, expr, cs, wo, forward );
+    if ( found ) {
+	if ( para )
+	    *para = findcur.paragraph()->paragId();
+	if ( index )
+	    *index = findcur.index();
+	*cursor = findcur;
+	repaintChanged();
+	ensureCursorVisible();
+    }
+    drawCursor( TRUE );
+    if (found) {
+	emit cursorPositionChanged( cursor );
+	emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+    }
+    return found;
+}
+
+void QTextEdit::blinkCursor()
+{
+    if ( !cursorVisible )
+	return;
+    bool cv = cursorVisible;
+    blinkCursorVisible = !blinkCursorVisible;
+    drawCursor( blinkCursorVisible );
+    cursorVisible = cv;
+}
+
+/*!
+    Sets the cursor to position \a index in paragraph \a para.
+
+    \sa getCursorPosition()
+*/
+
+void QTextEdit::setCursorPosition( int para, int index )
+{
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return;
+
+    resetInputContext();
+    if ( index > p->length() - 1 )
+	index = p->length() - 1;
+
+    drawCursor( FALSE );
+    cursor->setParagraph( p );
+    cursor->setIndex( index );
+    ensureCursorVisible();
+    drawCursor( TRUE );
+    updateCurrentFormat();
+    emit cursorPositionChanged( cursor );
+    emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+}
+
+/*!
+    This function sets the \a *para and \a *index parameters to the
+    current cursor position. \a para and \a index must not be 0.
+
+    \sa setCursorPosition()
+*/
+
+void QTextEdit::getCursorPosition( int *para, int *index ) const
+{
+    if ( !para || !index )
+	return;
+    *para = cursor->paragraph()->paragId();
+    *index = cursor->index();
+}
+
+/*!
+    Sets a selection which starts at position \a indexFrom in
+    paragraph \a paraFrom and ends at position \a indexTo in paragraph
+    \a paraTo.
+
+    Any existing selections which have a different id (\a selNum) are
+    left alone, but if an existing selection has the same id as \a
+    selNum it is removed and replaced by this selection.
+
+    Uses the selection settings of selection \a selNum. If \a selNum
+    is 0, this is the default selection.
+
+    The cursor is moved to the end of the selection if \a selNum is 0,
+    otherwise the cursor position remains unchanged.
+
+    \sa getSelection() selectedText
+*/
+
+void QTextEdit::setSelection( int paraFrom, int indexFrom,
+			      int paraTo, int indexTo, int selNum )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if (d->optimMode) {
+	optimSetSelection(paraFrom, indexFrom, paraTo, indexTo);
+	repaintContents(FALSE);
+	return;
+    }
+#endif
+    resetInputContext();
+    if ( doc->hasSelection( selNum ) ) {
+	doc->removeSelection( selNum );
+	repaintChanged();
+    }
+    if ( selNum > doc->numSelections() - 1 )
+	doc->addSelection( selNum );
+    QTextParagraph *p1 = doc->paragAt( paraFrom );
+    if ( !p1 )
+	return;
+    QTextParagraph *p2 = doc->paragAt( paraTo );
+    if ( !p2 )
+	return;
+
+    if ( indexFrom > p1->length() - 1 )
+	indexFrom = p1->length() - 1;
+    if ( indexTo > p2->length() - 1 )
+	indexTo = p2->length() - 1;
+
+    drawCursor( FALSE );
+    QTextCursor c = *cursor;
+    QTextCursor oldCursor = *cursor;
+    c.setParagraph( p1 );
+    c.setIndex( indexFrom );
+    cursor->setParagraph( p2 );
+    cursor->setIndex( indexTo );
+    doc->setSelectionStart( selNum, c );
+    doc->setSelectionEnd( selNum, *cursor );
+    repaintChanged();
+    ensureCursorVisible();
+    if ( selNum != QTextDocument::Standard )
+	*cursor = oldCursor;
+    drawCursor( TRUE );
+}
+
+/*!
+    If there is a selection, \a *paraFrom is set to the number of the
+    paragraph in which the selection begins and \a *paraTo is set to
+    the number of the paragraph in which the selection ends. (They
+    could be the same.) \a *indexFrom is set to the index at which the
+    selection begins within \a *paraFrom, and \a *indexTo is set to
+    the index at which the selection ends within \a *paraTo.
+
+    If there is no selection, \a *paraFrom, \a *indexFrom, \a *paraTo
+    and \a *indexTo are all set to -1.
+
+    If \a paraFrom, \a indexFrom, \a paraTo or \a indexTo is 0 this
+    function does nothing.
+
+    The \a selNum is the number of the selection (multiple selections
+    are supported). It defaults to 0 (the default selection).
+
+    \sa setSelection() selectedText
+*/
+
+void QTextEdit::getSelection( int *paraFrom, int *indexFrom,
+			      int *paraTo, int *indexTo, int selNum ) const
+{
+    if ( !paraFrom || !paraTo || !indexFrom || !indexTo )
+	return;
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if (d->optimMode) {
+	*paraFrom = d->od->selStart.line;
+	*paraTo = d->od->selEnd.line;
+	*indexFrom = d->od->selStart.index;
+	*indexTo = d->od->selEnd.index;
+	return;
+    }
+#endif
+    if ( !doc->hasSelection( selNum ) ) {
+	*paraFrom = -1;
+	*indexFrom = -1;
+	*paraTo = -1;
+	*indexTo = -1;
+	return;
+    }
+
+    doc->selectionStart( selNum, *paraFrom, *indexFrom );
+    doc->selectionEnd( selNum, *paraTo, *indexTo );
+}
+
+/*!
+    \property QTextEdit::textFormat
+    \brief the text format: rich text, plain text, log text or auto text.
+
+    The text format is one of the following:
+    \list
+    \i PlainText - all characters, except newlines, are displayed
+    verbatim, including spaces. Whenever a newline appears in the text
+    the text edit inserts a hard line break and begins a new
+    paragraph.
+    \i RichText - rich text rendering. The available styles are
+    defined in the default stylesheet QStyleSheet::defaultSheet().
+    \i LogText -  optimized mode for very large texts. Supports a very
+    limited set of formatting tags (color, bold, underline and italic
+    settings).
+    \i AutoText - this is the default. The text edit autodetects which
+    rendering style is best, \c PlainText or \c RichText. This is done
+    by using the QStyleSheet::mightBeRichText() function.
+    \endlist
+*/
+
+void QTextEdit::setTextFormat( TextFormat format )
+{
+    doc->setTextFormat( format );
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    checkOptimMode();
+#endif
+}
+
+Qt::TextFormat QTextEdit::textFormat() const
+{
+    return doc->textFormat();
+}
+
+/*!
+    Returns the number of paragraphs in the text; an empty textedit is always
+    considered to have one paragraph, so 1 is returned in this case.
+*/
+
+int QTextEdit::paragraphs() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	return d->od->numLines;
+    }
+#endif
+    return doc->lastParagraph()->paragId() + 1;
+}
+
+/*!
+    Returns the number of lines in paragraph \a para, or -1 if there
+    is no paragraph with index \a para.
+*/
+
+int QTextEdit::linesOfParagraph( int para ) const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	if ( d->od->numLines >= para )
+	    return 1;
+	else
+	    return -1;
+    }
+#endif
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return -1;
+    return p->lines();
+}
+
+/*!
+    Returns the length of the paragraph \a para (i.e. the number of
+    characters), or -1 if there is no paragraph with index \a para.
+
+    This function ignores newlines.
+*/
+
+int QTextEdit::paragraphLength( int para ) const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	if ( d->od->numLines >= para ) {
+	    if ( d->od->lines[ LOGOFFSET(para) ].isEmpty() ) // CR
+		return 1;
+	    else
+		return d->od->lines[ LOGOFFSET(para) ].length();
+	}
+	return -1;
+    }
+#endif
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return -1;
+    return p->length() - 1;
+}
+
+/*!
+    Returns the number of lines in the text edit; this could be 0.
+
+    \warning This function may be slow. Lines change all the time
+    during word wrapping, so this function has to iterate over all the
+    paragraphs and get the number of lines from each one individually.
+*/
+
+int QTextEdit::lines() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	return d->od->numLines;
+    }
+#endif
+    QTextParagraph *p = doc->firstParagraph();
+    int l = 0;
+    while ( p ) {
+	l += p->lines();
+	p = p->next();
+    }
+
+    return l;
+}
+
+/*!
+    Returns the line number of the line in paragraph \a para in which
+    the character at position \a index appears. The \a index position is
+    relative to the beginning of the paragraph. If there is no such
+    paragraph or no such character at the \a index position (e.g. the
+    index is out of range) -1 is returned.
+*/
+
+int QTextEdit::lineOfChar( int para, int index )
+{
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return -1;
+
+    int idx, line;
+    QTextStringChar *c = p->lineStartOfChar( index, &idx, &line );
+    if ( !c )
+	return -1;
+
+    return line;
+}
+
+void QTextEdit::setModified( bool m )
+{
+    bool oldModified = modified;
+    modified = m;
+    if ( modified && doc->oTextValid )
+	doc->invalidateOriginalText();
+    if ( oldModified != modified )
+	emit modificationChanged( modified );
+}
+
+/*!
+    \property QTextEdit::modified
+    \brief whether the document has been modified by the user
+*/
+
+bool QTextEdit::isModified() const
+{
+    return modified;
+}
+
+void QTextEdit::setModified()
+{
+    if ( !isModified() )
+	setModified( TRUE );
+}
+
+/*!
+    Returns TRUE if the current format is italic; otherwise returns FALSE.
+
+    \sa setItalic()
+*/
+
+bool QTextEdit::italic() const
+{
+    return currentFormat->font().italic();
+}
+
+/*!
+    Returns TRUE if the current format is bold; otherwise returns FALSE.
+
+    \sa setBold()
+*/
+
+bool QTextEdit::bold() const
+{
+    return currentFormat->font().bold();
+}
+
+/*!
+    Returns TRUE if the current format is underlined; otherwise returns
+    FALSE.
+
+    \sa setUnderline()
+*/
+
+bool QTextEdit::underline() const
+{
+    return currentFormat->font().underline();
+}
+
+/*!
+    Returns the font family of the current format.
+
+    \sa setFamily() setCurrentFont() setPointSize()
+*/
+
+QString QTextEdit::family() const
+{
+    return currentFormat->font().family();
+}
+
+/*!
+    Returns the point size of the font of the current format.
+
+    \sa setFamily() setCurrentFont() setPointSize()
+*/
+
+int QTextEdit::pointSize() const
+{
+    return currentFormat->font().pointSize();
+}
+
+/*!
+    Returns the color of the current format.
+
+    \sa setColor() setPaper()
+*/
+
+QColor QTextEdit::color() const
+{
+    return currentFormat->color();
+}
+
+/*!
+    \obsolete
+
+    Returns QScrollView::font()
+
+    \warning In previous versions this function returned the font of
+    the current format. This lead to confusion. Please use
+    currentFont() instead.
+*/
+
+QFont QTextEdit::font() const
+{
+    return QScrollView::font();
+}
+
+/*!
+    Returns the font of the current format.
+
+    \sa setCurrentFont() setFamily() setPointSize()
+*/
+
+QFont QTextEdit::currentFont() const
+{
+    return currentFormat->font();
+}
+
+
+/*!
+    Returns the alignment of the current paragraph.
+
+    \sa setAlignment()
+*/
+
+int QTextEdit::alignment() const
+{
+    return currentAlignment;
+}
+
+void QTextEdit::startDrag()
+{
+#ifndef QT_NO_DRAGANDDROP
+    mousePressed = FALSE;
+    inDoubleClick = FALSE;
+    QDragObject *drag = dragObject( viewport() );
+    if ( !drag )
+	return;
+    if ( isReadOnly() ) {
+	drag->dragCopy();
+    } else {
+	if ( drag->drag() && QDragObject::target() != this && QDragObject::target() != viewport() )
+	    removeSelectedText();
+    }
+#endif
+}
+
+/*!
+    If \a select is TRUE (the default), all the text is selected as
+    selection 0. If \a select is FALSE any selected text is
+    unselected, i.e. the default selection (selection 0) is cleared.
+
+    \sa selectedText
+*/
+
+void QTextEdit::selectAll( bool select )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	if ( select )
+	    optimSelectAll();
+	else
+	    optimRemoveSelection();
+	return;
+    }
+#endif
+    if ( !select )
+	doc->removeSelection( QTextDocument::Standard );
+    else
+	doc->selectAll( QTextDocument::Standard );
+    repaintChanged();
+    emit copyAvailable( doc->hasSelection( QTextDocument::Standard ) );
+    emit selectionChanged();
+#ifndef QT_NO_CURSOR
+    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+}
+
+void QTextEdit::UndoRedoInfo::clear()
+{
+    if ( valid() ) {
+	if ( type == Insert || type == Return )
+	    doc->addCommand( new QTextInsertCommand( doc, id, index, d->text.rawData(), styleInformation ) );
+	else if ( type == Format )
+	    doc->addCommand( new QTextFormatCommand( doc, id, index, eid, eindex, d->text.rawData(), format, flags ) );
+	else if ( type == Style )
+	    doc->addCommand( new QTextStyleCommand( doc, id, eid, styleInformation ) );
+	else if ( type != Invalid ) {
+	    doc->addCommand( new QTextDeleteCommand( doc, id, index, d->text.rawData(), styleInformation ) );
+	}
+    }
+    type = Invalid;
+    d->text = QString::null;
+    id = -1;
+    index = -1;
+    styleInformation = QByteArray();
+}
+
+
+/*!
+    If there is some selected text (in selection 0) it is deleted. If
+    there is no selected text (in selection 0) the character to the
+    right of the text cursor is deleted.
+
+    \sa removeSelectedText() cut()
+*/
+
+void QTextEdit::del()
+{
+    if ( doc->hasSelection( QTextDocument::Standard ) ) {
+	removeSelectedText();
+	return;
+    }
+
+    doKeyboardAction( ActionDelete );
+}
+
+
+QTextEdit::UndoRedoInfo::UndoRedoInfo( QTextDocument *dc )
+    : type( Invalid ), doc( dc )
+{
+    d = new QUndoRedoInfoPrivate;
+    d->text = QString::null;
+    id = -1;
+    index = -1;
+}
+
+QTextEdit::UndoRedoInfo::~UndoRedoInfo()
+{
+    delete d;
+}
+
+bool QTextEdit::UndoRedoInfo::valid() const
+{
+    return id >= 0 &&  type != Invalid;
+}
+
+/*!
+    \internal
+
+  Resets the current format to the default format.
+*/
+
+void QTextEdit::resetFormat()
+{
+    setAlignment( Qt::AlignAuto );
+    setParagType( QStyleSheetItem::DisplayBlock, QStyleSheetItem::ListDisc );
+    setFormat( doc->formatCollection()->defaultFormat(), QTextFormat::Format );
+}
+
+/*!
+    Returns the QStyleSheet which is being used by this text edit.
+
+    \sa setStyleSheet()
+*/
+
+QStyleSheet* QTextEdit::styleSheet() const
+{
+    return doc->styleSheet();
+}
+
+/*!
+    Sets the stylesheet to use with this text edit to \a styleSheet.
+    Changes will only take effect for new text added with setText() or
+    append().
+
+    \sa styleSheet()
+*/
+
+void QTextEdit::setStyleSheet( QStyleSheet* styleSheet )
+{
+    doc->setStyleSheet( styleSheet );
+}
+
+/*!
+    \property QTextEdit::paper
+    \brief the background (paper) brush.
+
+    The brush that is currently used to draw the background of the
+    text edit. The initial setting is an empty brush.
+*/
+
+void QTextEdit::setPaper( const QBrush& pap )
+{
+    doc->setPaper( new QBrush( pap ) );
+
+    if ( pap.pixmap() ) {
+        viewport()->setBackgroundPixmap( *pap.pixmap() );
+    } else {
+        setPaletteBackgroundColor( pap.color() );
+        viewport()->setPaletteBackgroundColor( pap.color() );
+    }
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    // force a repaint of the entire viewport - using updateContents()
+    // would clip the coords to the content size
+    if (d->optimMode)
+	repaintContents(contentsX(), contentsY(), viewport()->width(), viewport()->height());
+    else
+#endif
+	updateContents();
+}
+
+QBrush QTextEdit::paper() const
+{
+    if ( doc->paper() )
+	return *doc->paper();
+    return QBrush( colorGroup().base() );
+}
+
+/*!
+    \property QTextEdit::linkUnderline
+    \brief whether hypertext links will be underlined
+
+    If TRUE (the default) hypertext links will be displayed
+    underlined. If FALSE links will not be displayed underlined.
+*/
+
+void QTextEdit::setLinkUnderline( bool b )
+{
+    if ( doc->underlineLinks() == b )
+	return;
+    doc->setUnderlineLinks( b );
+    repaintChanged();
+}
+
+bool QTextEdit::linkUnderline() const
+{
+    return doc->underlineLinks();
+}
+
+/*!
+    Sets the text edit's mimesource factory to \a factory. See
+    QMimeSourceFactory for further details.
+
+    \sa mimeSourceFactory()
+ */
+
+#ifndef QT_NO_MIME
+void QTextEdit::setMimeSourceFactory( QMimeSourceFactory* factory )
+{
+    doc->setMimeSourceFactory( factory );
+}
+
+/*!
+    Returns the QMimeSourceFactory which is being used by this text
+    edit.
+
+    \sa setMimeSourceFactory()
+*/
+
+QMimeSourceFactory* QTextEdit::mimeSourceFactory() const
+{
+    return doc->mimeSourceFactory();
+}
+#endif
+
+/*!
+    Returns how many pixels high the text edit needs to be to display
+    all the text if the text edit is \a w pixels wide.
+*/
+
+int QTextEdit::heightForWidth( int w ) const
+{
+    int oldw = doc->width();
+    doc->doLayout( 0, w );
+    int h = doc->height();
+    doc->setWidth( oldw );
+    doc->invalidate();
+    ( (QTextEdit*)this )->formatMore();
+    return h;
+}
+
+/*!
+    Appends a new paragraph with \a text to the end of the text edit. Note that
+    the undo/redo history is cleared by this function, and no undo
+    history is kept for appends which makes them faster than
+    insert()s. If you want to append text which is added to the
+    undo/redo history as well, use insertParagraph().
+*/
+
+void QTextEdit::append( const QString &text )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimAppend( text );
+	return;
+    }
+#endif
+    // flush and clear the undo/redo stack if necessary
+    undoRedoInfo.clear();
+    doc->commands()->clear();
+
+    doc->removeSelection( QTextDocument::Standard );
+    TextFormat f = doc->textFormat();
+    if ( f == AutoText ) {
+	if ( QStyleSheet::mightBeRichText( text ) )
+	    f = RichText;
+	else
+	    f = PlainText;
+    }
+
+    drawCursor( FALSE );
+    QTextCursor oldc( *cursor );
+    ensureFormatted( doc->lastParagraph() );
+    bool atBottom = contentsY() >= contentsHeight() - visibleHeight();
+    cursor->gotoEnd();
+    if ( cursor->index() > 0 )
+	cursor->splitAndInsertEmptyParagraph();
+    QTextCursor oldCursor2 = *cursor;
+
+    if ( f == Qt::PlainText ) {
+	cursor->insert( text, TRUE );
+	if ( doc->useFormatCollection() && !doc->preProcessor() &&
+	     currentFormat != cursor->paragraph()->at( cursor->index() )->format() ) {
+	    doc->setSelectionStart( QTextDocument::Temp, oldCursor2 );
+	    doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+	    doc->setFormat( QTextDocument::Temp, currentFormat, QTextFormat::Format );
+	    doc->removeSelection( QTextDocument::Temp );
+	}
+    } else {
+	cursor->paragraph()->setListItem( FALSE );
+	cursor->paragraph()->setListDepth( 0 );
+	if ( cursor->paragraph()->prev() )
+	    cursor->paragraph()->prev()->invalidate(0); // vertical margins might have to change
+	doc->setRichTextInternal( text );
+    }
+    formatMore();
+    repaintChanged();
+    if ( atBottom )
+        scrollToBottom();
+    *cursor = oldc;
+    if ( !isReadOnly() )
+	cursorVisible = TRUE;
+    setModified();
+    emit textChanged();
+}
+
+/*!
+    \property QTextEdit::hasSelectedText
+    \brief whether some text is selected in selection 0
+*/
+
+bool QTextEdit::hasSelectedText() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return optimHasSelection();
+    else
+#endif
+	return doc->hasSelection( QTextDocument::Standard );
+}
+
+/*!
+    \property QTextEdit::selectedText
+    \brief The selected text (from selection 0) or an empty string if
+    there is no currently selected text (in selection 0).
+
+    The text is always returned as \c PlainText if the textFormat() is
+    \c PlainText or \c AutoText, otherwise it is returned as HTML.
+
+    \sa hasSelectedText
+*/
+
+QString QTextEdit::selectedText() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return optimSelectedText();
+    else
+#endif
+	return doc->selectedText( QTextDocument::Standard, textFormat() == RichText );
+}
+
+bool QTextEdit::handleReadOnlyKeyEvent( QKeyEvent *e )
+{
+    switch( e->key() ) {
+    case Key_Down:
+	setContentsPos( contentsX(), contentsY() + 10 );
+	break;
+    case Key_Up:
+	setContentsPos( contentsX(), contentsY() - 10 );
+	break;
+    case Key_Left:
+	setContentsPos( contentsX() - 10, contentsY() );
+	break;
+    case Key_Right:
+	setContentsPos( contentsX() + 10, contentsY() );
+	break;
+    case Key_PageUp:
+	setContentsPos( contentsX(), contentsY() - visibleHeight() );
+	break;
+    case Key_PageDown:
+	setContentsPos( contentsX(), contentsY() + visibleHeight() );
+	break;
+    case Key_Home:
+	setContentsPos( contentsX(), 0 );
+	break;
+    case Key_End:
+	setContentsPos( contentsX(), contentsHeight() - visibleHeight() );
+	break;
+    case Key_F16: // Copy key on Sun keyboards
+	copy();
+	break;
+#ifndef QT_NO_NETWORKPROTOCOL
+    case Key_Return:
+    case Key_Enter:
+    case Key_Space: {
+	if (!doc->focusIndicator.href.isEmpty()
+		|| !doc->focusIndicator.name.isEmpty()) {
+	    if (!doc->focusIndicator.href.isEmpty()) {
+		QUrl u( doc->context(), doc->focusIndicator.href, TRUE );
+		emitLinkClicked( u.toString( FALSE, FALSE ) );
+	    }
+	    if (!doc->focusIndicator.name.isEmpty()) {
+		if (::qt_cast<QTextBrowser*>(this)) { // change for 4.0
+		    QConnectionList *clist = receivers(
+			    "anchorClicked(const QString&,const QString&)");
+		    if (!signalsBlocked() && clist) {
+			QUObject o[3];
+			static_QUType_QString.set(o+1,
+				doc->focusIndicator.name);
+			static_QUType_QString.set(o+2,
+				doc->focusIndicator.href);
+			activate_signal( clist, o);
+		    }
+		}
+	    }
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	}
+    } break;
+#endif
+    default:
+	if ( e->state() & ControlButton ) {
+	    switch ( e->key() ) {
+	    case Key_C: case Key_F16: // Copy key on Sun keyboards
+		copy();
+		break;
+#ifdef Q_WS_WIN
+	    case Key_Insert:
+		copy();
+		break;
+	    case Key_A:
+		selectAll();
+		break;
+#endif
+	    }
+
+	}
+	return FALSE;
+    }
+    return TRUE;
+}
+
+/*!
+    Returns the context of the text edit. The context is a path which
+    the text edit's QMimeSourceFactory uses to resolve the locations
+    of files and images.
+
+    \sa text
+*/
+
+QString QTextEdit::context() const
+{
+    return doc->context();
+}
+
+/*!
+    \property QTextEdit::documentTitle
+    \brief the title of the document parsed from the text.
+
+    For \c PlainText the title will be an empty string. For \c
+    RichText the title will be the text between the \c{<title>} tags,
+    if present, otherwise an empty string.
+*/
+
+QString QTextEdit::documentTitle() const
+{
+    return doc->attributes()[ "title" ];
+}
+
+void QTextEdit::makeParagVisible( QTextParagraph *p )
+{
+    setContentsPos( contentsX(), QMIN( p->rect().y(), contentsHeight() - visibleHeight() ) );
+}
+
+/*!
+    Scrolls the text edit to make the text at the anchor called \a
+    name visible, if it can be found in the document. If the anchor
+    isn't found no scrolling will occur. An anchor is defined using
+    the HTML anchor tag, e.g. \c{<a name="target">}.
+*/
+
+void QTextEdit::scrollToAnchor( const QString& name )
+{
+    if ( !isVisible() ) {
+	d->scrollToAnchor = name;
+	return;
+    }
+    if ( name.isEmpty() )
+	return;
+    sync();
+    QTextCursor cursor( doc );
+    QTextParagraph* last = doc->lastParagraph();
+    for (;;) {
+	QTextStringChar* c = cursor.paragraph()->at( cursor.index() );
+	if( c->isAnchor() ) {
+	    QString a = c->anchorName();
+	    if ( a == name ||
+		 (a.contains( '#' ) && QStringList::split( '#', a ).contains( name ) ) ) {
+		setContentsPos( contentsX(), QMIN( cursor.paragraph()->rect().top() + cursor.totalOffsetY(), contentsHeight() - visibleHeight() ) );
+		break;
+	    }
+	}
+	if ( cursor.paragraph() == last && cursor.atParagEnd()  )
+	    break;
+	cursor.gotoNextLetter();
+    }
+}
+
+#if (QT_VERSION-0 >= 0x040000)
+#error "function anchorAt(const QPoint& pos) should be merged into function anchorAt(const QPoint& pos, AnchorAttribute attr)"
+#endif
+
+/*!
+    \overload
+
+    If there is an anchor at position \a pos (in contents
+    coordinates), its \c href is returned, otherwise QString::null is
+    returned.
+*/
+
+QString QTextEdit::anchorAt( const QPoint& pos )
+{
+    return anchorAt(pos, AnchorHref);
+}
+
+/*!
+    If there is an anchor at position \a pos (in contents
+    coordinates), the text for attribute \a attr is returned,
+    otherwise QString::null is returned.
+*/
+
+QString QTextEdit::anchorAt( const QPoint& pos, AnchorAttribute attr )
+{
+    QTextCursor c( doc );
+    placeCursor( pos, &c );
+    switch(attr) {
+	case AnchorName:
+	    return c.paragraph()->at( c.index() )->anchorName();
+	case AnchorHref:
+	    return c.paragraph()->at( c.index() )->anchorHref();
+    }
+    // incase the compiler is really dumb about determining if a function
+    // returns something :)
+    return QString::null;
+}
+
+void QTextEdit::documentWidthChanged( int w )
+{
+    resizeContents( QMAX( visibleWidth(), w), contentsHeight() );
+}
+
+/*! \internal
+
+  This function does nothing
+*/
+
+void QTextEdit::updateStyles()
+{
+}
+
+void QTextEdit::setDocument( QTextDocument *dc )
+{
+    if ( dc == 0 ) {
+        qWarning( "Q3TextEdit::setDocument() called with null Q3TextDocument pointer" );
+        return;
+    }
+    if ( dc == doc )
+	return;
+    resetInputContext();
+    doc = dc;
+    delete cursor;
+    cursor = new QTextCursor( doc );
+    clearUndoRedo();
+    undoRedoInfo.doc = doc;
+    lastFormatted = 0;
+}
+
+#ifndef QT_NO_CLIPBOARD
+
+/*!
+    Pastes the text with format \a subtype from the clipboard into the
+    text edit at the current cursor position. The \a subtype can be
+    "plain" or "html".
+
+    If there is no text with format \a subtype in the clipboard
+    nothing happens.
+
+    \sa paste() cut() QTextEdit::copy()
+*/
+
+void QTextEdit::pasteSubType( const QCString &subtype )
+{
+#ifndef QT_NO_MIMECLIPBOARD
+    QMimeSource *m = QApplication::clipboard()->data( d->clipboard_mode );
+    pasteSubType( subtype, m );
+#endif
+}
+
+/*! \internal */
+
+void QTextEdit::pasteSubType( const QCString& subtype, QMimeSource *m )
+{
+#ifndef QT_NO_MIME
+    QCString st = subtype;
+    if ( subtype != "x-qrichtext" )
+	st.prepend( "text/" );
+    else
+	st.prepend( "application/" );
+    if ( !m )
+	return;
+    if ( doc->hasSelection( QTextDocument::Standard ) )
+	removeSelectedText();
+    if ( !QRichTextDrag::canDecode( m ) )
+	return;
+    QString t;
+    if ( !QRichTextDrag::decode( m, t, st.data(), subtype ) )
+	return;
+    if ( st == "application/x-qrichtext" ) {
+	int start;
+	if ( (start = t.find( "<!--StartFragment-->" )) != -1 ) {
+	    start += 20;
+	    int end = t.find( "<!--EndFragment-->" );
+	    QTextCursor oldC = *cursor;
+
+	    // during the setRichTextInternal() call the cursors
+	    // paragraph might get joined with the provious one, so
+	    // the cursors one would get deleted and oldC.paragraph()
+	    // would be a dnagling pointer. To avoid that try to go
+	    // one letter back and later go one forward again.
+	    oldC.gotoPreviousLetter();
+	    bool couldGoBack = oldC != *cursor;
+	    // first para might get deleted, so remember to reset it
+	    bool wasAtFirst = oldC.paragraph() == doc->firstParagraph();
+
+	    if ( start < end )
+		t = t.mid( start, end - start );
+	    else
+		t = t.mid( start );
+	    lastFormatted = cursor->paragraph();
+	    if ( lastFormatted->prev() )
+		lastFormatted = lastFormatted->prev();
+	    doc->setRichTextInternal( t, cursor );
+
+	    // the first para might have been deleted in
+	    // setRichTextInternal(). To be sure, reset it if
+	    // necessary.
+	    if ( wasAtFirst ) {
+		int index = oldC.index();
+		oldC.setParagraph( doc->firstParagraph() );
+		oldC.setIndex( index );
+	    }
+
+	    // if we went back one letter before (see last comment),
+	    // go one forward to point to the right position
+	    if ( couldGoBack )
+		oldC.gotoNextLetter();
+
+	    if ( undoEnabled && !isReadOnly() ) {
+		doc->setSelectionStart( QTextDocument::Temp, oldC );
+		doc->setSelectionEnd( QTextDocument::Temp, *cursor );
+
+		checkUndoRedoInfo( UndoRedoInfo::Insert );
+		if ( !undoRedoInfo.valid() ) {
+		    undoRedoInfo.id = oldC.paragraph()->paragId();
+		    undoRedoInfo.index = oldC.index();
+		    undoRedoInfo.d->text = QString::null;
+		}
+		int oldLen = undoRedoInfo.d->text.length();
+		if ( !doc->preProcessor() ) {
+		    QString txt = doc->selectedText( QTextDocument::Temp );
+		    undoRedoInfo.d->text += txt;
+		    for ( int i = 0; i < (int)txt.length(); ++i ) {
+			if ( txt[ i ] != '\n' && oldC.paragraph()->at( oldC.index() )->format() ) {
+			    oldC.paragraph()->at( oldC.index() )->format()->addRef();
+			    undoRedoInfo.d->text.
+				setFormat( oldLen + i, oldC.paragraph()->at( oldC.index() )->format(), TRUE );
+			}
+			oldC.gotoNextLetter();
+		    }
+		}
+		undoRedoInfo.clear();
+		removeSelection( QTextDocument::Temp );
+	    }
+
+	    formatMore();
+	    setModified();
+	    emit textChanged();
+	    repaintChanged();
+	    ensureCursorVisible();
+	    return;
+	}
+    } else {
+#if defined(Q_OS_WIN32)
+	// Need to convert CRLF to LF
+	t.replace( "\r\n", "\n" );
+#elif defined(Q_OS_MAC)
+	//need to convert CR to LF
+	t.replace( '\r', '\n' );
+#endif
+	QChar *uc = (QChar *)t.unicode();
+	for ( int i=0; (uint) i<t.length(); i++ ) {
+	    if ( uc[ i ] < ' ' && uc[ i ] != '\n' && uc[ i ] != '\t' )
+		uc[ i ] = ' ';
+	}
+	if ( !t.isEmpty() )
+	    insert( t, FALSE, TRUE );
+    }
+#endif //QT_NO_MIME
+}
+
+#ifndef QT_NO_MIMECLIPBOARD
+/*!
+    Prompts the user to choose a type from a list of text types
+    available, then copies text from the clipboard (if there is any)
+    into the text edit at the current text cursor position. Any
+    selected text (in selection 0) is first deleted.
+*/
+void QTextEdit::pasteSpecial( const QPoint& pt )
+{
+    QCString st = pickSpecial( QApplication::clipboard()->data( d->clipboard_mode ),
+			       TRUE, pt );
+    if ( !st.isEmpty() )
+	pasteSubType( st );
+}
+#endif
+#ifndef QT_NO_MIME
+QCString QTextEdit::pickSpecial( QMimeSource* ms, bool always_ask, const QPoint& pt )
+{
+    if ( ms )  {
+#ifndef QT_NO_POPUPMENU
+	QPopupMenu popup( this, "qt_pickspecial_menu" );
+	QString fmt;
+	int n = 0;
+	QDict<void> done;
+	for (int i = 0; !( fmt = ms->format( i ) ).isNull(); i++) {
+	    int semi = fmt.find( ";" );
+	    if ( semi >= 0 )
+		fmt = fmt.left( semi );
+	    if ( fmt.left( 5 ) == "text/" ) {
+		fmt = fmt.mid( 5 );
+		if ( !done.find( fmt ) ) {
+		    done.insert( fmt,(void*)1 );
+		    popup.insertItem( fmt, i );
+		    n++;
+		}
+	    }
+	}
+	if ( n ) {
+	    int i = n ==1 && !always_ask ? popup.idAt( 0 ) : popup.exec( pt );
+	    if ( i >= 0 )
+		return popup.text(i).latin1();
+	}
+#else
+	QString fmt;
+	for (int i = 0; !( fmt = ms->format( i ) ).isNull(); i++) {
+	    int semi = fmt.find( ";" );
+	    if ( semi >= 0 )
+		fmt = fmt.left( semi );
+	    if ( fmt.left( 5 ) == "text/" ) {
+		fmt = fmt.mid( 5 );
+		return fmt.latin1();
+	    }
+	}
+#endif
+    }
+    return QCString();
+}
+#endif // QT_NO_MIME
+#endif // QT_NO_CLIPBOARD
+
+/*!
+    \enum QTextEdit::WordWrap
+
+    This enum defines the QTextEdit's word wrap modes.
+
+    \value NoWrap Do not wrap the text.
+
+    \value WidgetWidth Wrap the text at the current width of the
+    widget (this is the default). Wrapping is at whitespace by
+    default; this can be changed with setWrapPolicy().
+
+    \value FixedPixelWidth Wrap the text at a fixed number of pixels
+    from the widget's left side. The number of pixels is set with
+    wrapColumnOrWidth().
+
+    \value FixedColumnWidth Wrap the text at a fixed number of
+    character columns from the widget's left side. The number of
+    characters is set with wrapColumnOrWidth(). This is useful if you
+    need formatted text that can also be displayed gracefully on
+    devices with monospaced fonts, for example a standard VT100
+    terminal, where you might set wrapColumnOrWidth() to 80.
+
+    \sa setWordWrap() wordWrap()
+*/
+
+/*!
+    \property QTextEdit::wordWrap
+    \brief the word wrap mode
+
+    The default mode is \c WidgetWidth which causes words to be
+    wrapped at the right edge of the text edit. Wrapping occurs at
+    whitespace, keeping whole words intact. If you want wrapping to
+    occur within words use setWrapPolicy(). If you set a wrap mode of
+    \c FixedPixelWidth or \c FixedColumnWidth you should also call
+    setWrapColumnOrWidth() with the width you want.
+
+    \sa WordWrap, wrapColumnOrWidth, wrapPolicy,
+*/
+
+void QTextEdit::setWordWrap( WordWrap mode )
+{
+    if ( wrapMode == mode )
+	return;
+    wrapMode = mode;
+    switch ( mode ) {
+    case NoWrap:
+	document()->formatter()->setWrapEnabled( FALSE );
+	document()->formatter()->setWrapAtColumn( -1 );
+	doc->setWidth( visibleWidth() );
+	doc->setMinimumWidth( -1 );
+	doc->invalidate();
+	updateContents();
+	lastFormatted = doc->firstParagraph();
+	interval = 0;
+	formatMore();
+	break;
+    case WidgetWidth:
+	document()->formatter()->setWrapEnabled( TRUE );
+	document()->formatter()->setWrapAtColumn( -1 );
+	doResize();
+	break;
+    case FixedPixelWidth:
+	document()->formatter()->setWrapEnabled( TRUE );
+	document()->formatter()->setWrapAtColumn( -1 );
+	if ( wrapWidth < 0 )
+	    wrapWidth = 200;
+	setWrapColumnOrWidth( wrapWidth );
+	break;
+    case FixedColumnWidth:
+	if ( wrapWidth < 0 )
+	    wrapWidth = 80;
+	document()->formatter()->setWrapEnabled( TRUE );
+	document()->formatter()->setWrapAtColumn( wrapWidth );
+	setWrapColumnOrWidth( wrapWidth );
+	break;
+    }
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    checkOptimMode();
+#endif
+}
+
+QTextEdit::WordWrap QTextEdit::wordWrap() const
+{
+    return wrapMode;
+}
+
+/*!
+    \property QTextEdit::wrapColumnOrWidth
+    \brief the position (in pixels or columns depending on the wrap mode) where text will be wrapped
+
+    If the wrap mode is \c FixedPixelWidth, the value is the number of
+    pixels from the left edge of the text edit at which text should be
+    wrapped. If the wrap mode is \c FixedColumnWidth, the value is the
+    column number (in character columns) from the left edge of the
+    text edit at which text should be wrapped.
+
+    \sa wordWrap
+*/
+void QTextEdit::setWrapColumnOrWidth( int value )
+{
+    wrapWidth = value;
+    if ( wrapMode == FixedColumnWidth ) {
+	document()->formatter()->setWrapAtColumn( wrapWidth );
+	resizeContents( 0, 0 );
+	doc->setWidth( visibleWidth() );
+	doc->setMinimumWidth( -1 );
+    } else if (wrapMode == FixedPixelWidth ) {
+	document()->formatter()->setWrapAtColumn( -1 );
+	resizeContents( wrapWidth, 0 );
+	doc->setWidth( wrapWidth );
+	doc->setMinimumWidth( wrapWidth );
+    } else {
+	return;
+    }
+    doc->invalidate();
+    updateContents();
+    lastFormatted = doc->firstParagraph();
+    interval = 0;
+    formatMore();
+}
+
+int QTextEdit::wrapColumnOrWidth() const
+{
+    if ( wrapMode == WidgetWidth )
+	return visibleWidth();
+    return wrapWidth;
+}
+
+
+/*!
+    \enum QTextEdit::WrapPolicy
+
+    This enum defines where text can be wrapped in word wrap mode.
+
+    \value AtWhiteSpace Don't use this deprecated value (it is a
+    synonym for \c AtWordBoundary which you should use instead).
+    \value Anywhere  Break anywhere, including within words.
+    \value AtWordBoundary Break lines at word boundaries, e.g. spaces or
+    newlines
+    \value AtWordOrDocumentBoundary Break lines at whitespace, e.g.
+    spaces or newlines if possible. Break it anywhere otherwise.
+
+    \sa setWrapPolicy()
+*/
+
+/*!
+    \property QTextEdit::wrapPolicy
+    \brief the word wrap policy, at whitespace or anywhere
+
+    Defines where text can be wrapped when word wrap mode is not \c
+    NoWrap. The choices are \c AtWordBoundary (the default), \c
+    Anywhere and \c AtWordOrDocumentBoundary
+
+    \sa wordWrap
+*/
+
+void QTextEdit::setWrapPolicy( WrapPolicy policy )
+{
+    if ( wPolicy == policy )
+	return;
+    wPolicy = policy;
+    QTextFormatter *formatter;
+    if ( policy == AtWordBoundary || policy == AtWordOrDocumentBoundary ) {
+	formatter = new QTextFormatterBreakWords;
+	formatter->setAllowBreakInWords( policy == AtWordOrDocumentBoundary );
+    } else {
+	formatter = new QTextFormatterBreakInWords;
+    }
+    formatter->setWrapAtColumn( document()->formatter()->wrapAtColumn() );
+    formatter->setWrapEnabled( document()->formatter()->isWrapEnabled( 0 ) );
+    document()->setFormatter( formatter );
+    doc->invalidate();
+    updateContents();
+    lastFormatted = doc->firstParagraph();
+    interval = 0;
+    formatMore();
+}
+
+QTextEdit::WrapPolicy QTextEdit::wrapPolicy() const
+{
+    return wPolicy;
+}
+
+/*!
+    Deletes all the text in the text edit.
+
+    \sa cut() removeSelectedText() setText()
+*/
+
+void QTextEdit::clear()
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	optimSetText("");
+    } else
+#endif
+    {
+	// make clear undoable
+	doc->selectAll( QTextDocument::Temp );
+	removeSelectedText( QTextDocument::Temp );
+	setContentsPos( 0, 0 );
+	if ( cursor->isValid() )
+	    cursor->restoreState();
+	doc->clear( TRUE );
+	delete cursor;
+	cursor = new QTextCursor( doc );
+	lastFormatted = 0;
+    }
+    updateContents();
+
+    emit cursorPositionChanged( cursor );
+    emit cursorPositionChanged( cursor->paragraph()->paragId(), cursor->index() );
+}
+
+int QTextEdit::undoDepth() const
+{
+    return document()->undoDepth();
+}
+
+/*!
+    \property QTextEdit::length
+    \brief the number of characters in the text
+*/
+
+int QTextEdit::length() const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode )
+	return d->od->len;
+    else
+#endif
+	return document()->length();
+}
+
+/*!
+    \property QTextEdit::tabStopWidth
+    \brief the tab stop width in pixels
+*/
+
+int QTextEdit::tabStopWidth() const
+{
+    return document()->tabStopWidth();
+}
+
+void QTextEdit::setUndoDepth( int d )
+{
+    document()->setUndoDepth( d );
+}
+
+void QTextEdit::setTabStopWidth( int ts )
+{
+    document()->setTabStops( ts );
+    doc->invalidate();
+    lastFormatted = doc->firstParagraph();
+    interval = 0;
+    formatMore();
+    updateContents();
+}
+
+/*!
+    \reimp
+*/
+
+QSize QTextEdit::sizeHint() const
+{
+    // cf. QScrollView::sizeHint()
+    constPolish();
+    int f = 2 * frameWidth();
+    int h = fontMetrics().height();
+    QSize sz( f, f );
+    return sz.expandedTo( QSize(12 * h, 8 * h) );
+}
+
+void QTextEdit::clearUndoRedo()
+{
+    if ( !undoEnabled )
+	return;
+    undoRedoInfo.clear();
+    emit undoAvailable( doc->commands()->isUndoAvailable() );
+    emit redoAvailable( doc->commands()->isRedoAvailable() );
+}
+
+/*!  \internal
+  \warning In Qt 3.1 we will provide a cleaer API for the
+  functionality which is provided by this function and in Qt 4.0 this
+  function will go away.
+
+  This function gets the format of the character at position \a
+  index in paragraph \a para. Sets \a font to the character's font, \a
+  color to the character's color and \a verticalAlignment to the
+  character's vertical alignment.
+
+  Returns FALSE if \a para or \a index is out of range otherwise
+  returns TRUE.
+*/
+
+bool QTextEdit::getFormat( int para, int index, QFont *font, QColor *color, VerticalAlignment *verticalAlignment )
+{
+    if ( !font || !color )
+	return FALSE;
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return FALSE;
+    if ( index < 0 || index >= p->length() )
+	return FALSE;
+    *font = p->at( index )->format()->font();
+    *color = p->at( index )->format()->color();
+    *verticalAlignment = (VerticalAlignment)p->at( index )->format()->vAlign();
+    return TRUE;
+}
+
+/*!  \internal
+  \warning In Qt 3.1 we will provide a cleaer API for the
+  functionality which is provided by this function and in Qt 4.0 this
+  function will go away.
+
+  This function gets the format of the paragraph \a para. Sets \a
+  font to the paragraphs's font, \a color to the paragraph's color, \a
+  verticalAlignment to the paragraph's vertical alignment, \a
+  alignment to the paragraph's alignment, \a displayMode to the
+  paragraph's display mode, \a listStyle to the paragraph's list style
+  (if the display mode is QStyleSheetItem::DisplayListItem) and \a
+  listDepth to the depth of the list (if the display mode is
+  QStyleSheetItem::DisplayListItem).
+
+  Returns FALSE if \a para is out of range otherwise returns TRUE.
+*/
+
+bool QTextEdit::getParagraphFormat( int para, QFont *font, QColor *color,
+				    VerticalAlignment *verticalAlignment, int *alignment,
+				    QStyleSheetItem::DisplayMode *displayMode,
+				    QStyleSheetItem::ListStyle *listStyle,
+				    int *listDepth )
+{
+    if ( !font || !color || !alignment || !displayMode || !listStyle )
+	return FALSE;
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return FALSE;
+    *font = p->at(0)->format()->font();
+    *color = p->at(0)->format()->color();
+    *verticalAlignment = (VerticalAlignment)p->at(0)->format()->vAlign();
+    *alignment = p->alignment();
+    *displayMode = p->isListItem() ? QStyleSheetItem::DisplayListItem : QStyleSheetItem::DisplayBlock;
+    *listStyle = p->listStyle();
+    *listDepth = p->listDepth();
+    return TRUE;
+}
+
+
+
+/*!
+    This function is called to create a right mouse button popup menu
+    at the document position \a pos. If you want to create a custom
+    popup menu, reimplement this function and return the created popup
+    menu. Ownership of the popup menu is transferred to the caller.
+
+    \warning The QPopupMenu ID values 0-7 are reserved, and they map to the
+    standard operations. When inserting items into your custom popup menu, be
+    sure to specify ID values larger than 7.
+*/
+
+QPopupMenu *QTextEdit::createPopupMenu( const QPoint& pos )
+{
+    Q_UNUSED( pos )
+#ifndef QT_NO_POPUPMENU
+    QPopupMenu *popup = new QPopupMenu( this, "qt_edit_menu" );
+    if ( !isReadOnly() ) {
+	d->id[ IdUndo ] = popup->insertItem( tr( "&Undo" ) + ACCEL_KEY( Z ) );
+	d->id[ IdRedo ] = popup->insertItem( tr( "&Redo" ) + ACCEL_KEY( Y ) );
+	popup->insertSeparator();
+    }
+#ifndef QT_NO_CLIPBOARD
+    if ( !isReadOnly() )
+	d->id[ IdCut ] = popup->insertItem( tr( "Cu&t" ) + ACCEL_KEY( X ) );
+    d->id[ IdCopy ] = popup->insertItem( tr( "&Copy" ) + ACCEL_KEY( C ) );
+    if ( !isReadOnly() )
+	d->id[ IdPaste ] = popup->insertItem( tr( "&Paste" ) + ACCEL_KEY( V ) );
+#endif
+    if ( !isReadOnly() ) {
+	d->id[ IdClear ] = popup->insertItem( tr( "Clear" ) );
+	popup->insertSeparator();
+    }
+#if defined(Q_WS_X11)
+    d->id[ IdSelectAll ] = popup->insertItem( tr( "Select All" ) );
+#else
+    d->id[ IdSelectAll ] = popup->insertItem( tr( "Select All" ) + ACCEL_KEY( A ) );
+#endif
+    popup->setItemEnabled( d->id[ IdUndo ], !isReadOnly() && doc->commands()->isUndoAvailable() );
+    popup->setItemEnabled( d->id[ IdRedo ], !isReadOnly() && doc->commands()->isRedoAvailable() );
+#ifndef QT_NO_CLIPBOARD
+    popup->setItemEnabled( d->id[ IdCut ], !isReadOnly() && doc->hasSelection( QTextDocument::Standard, TRUE ) );
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    popup->setItemEnabled( d->id[ IdCopy ], d->optimMode ? optimHasSelection() : doc->hasSelection( QTextDocument::Standard, TRUE ) );
+#else
+    popup->setItemEnabled( d->id[ IdCopy ], doc->hasSelection( QTextDocument::Standard, TRUE ) );
+#endif
+    popup->setItemEnabled( d->id[ IdPaste ], !isReadOnly() && !QApplication::clipboard()->text( d->clipboard_mode ).isEmpty() );
+#endif
+    const bool isEmptyDocument = (length() == 0);
+    popup->setItemEnabled( d->id[ IdClear ], !isReadOnly() && !isEmptyDocument );
+    popup->setItemEnabled( d->id[ IdSelectAll ], !isEmptyDocument );
+    return popup;
+#else
+    return 0;
+#endif
+}
+
+/*! \overload
+    \obsolete
+    This function is called to create a right mouse button popup menu.
+    If you want to create a custom popup menu, reimplement this function
+    and return the created popup menu. Ownership of the popup menu is
+    transferred to the caller.
+
+    This function is only called if createPopupMenu( const QPoint & )
+    returns 0.
+*/
+
+QPopupMenu *QTextEdit::createPopupMenu()
+{
+    return 0;
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::setFont( const QFont &f )
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	QScrollView::setFont( f );
+	doc->setDefaultFormat( f, doc->formatCollection()->defaultFormat()->color() );
+	// recalculate the max string width
+	QFontMetrics fm(f);
+	int i, sw;
+	d->od->maxLineWidth = 0;
+	for ( i = 0; i < d->od->numLines; i++ ) {
+	    sw = fm.width(d->od->lines[LOGOFFSET(i)]);
+	    if (d->od->maxLineWidth < sw)
+		d->od->maxLineWidth = sw;
+	}
+	resizeContents(d->od->maxLineWidth + 4, d->od->numLines * fm.lineSpacing() + 1);
+	return;
+    }
+#endif
+    QScrollView::setFont( f );
+    doc->setMinimumWidth( -1 );
+    doc->setDefaultFormat( f, doc->formatCollection()->defaultFormat()->color() );
+    lastFormatted = doc->firstParagraph();
+    formatMore();
+    repaintChanged();
+}
+
+/*!
+    \fn QTextEdit::zoomIn()
+
+    \overload
+
+    Zooms in on the text by making the base font size one point
+    larger and recalculating all font sizes to be the new size. This
+    does not change the size of any images.
+
+    \sa zoomOut()
+*/
+
+/*!
+    \fn QTextEdit::zoomOut()
+
+    \overload
+
+    Zooms out on the text by making the base font size one point
+    smaller and recalculating all font sizes to be the new size. This
+    does not change the size of any images.
+
+    \sa zoomIn()
+*/
+
+
+/*!
+    Zooms in on the text by making the base font size \a range
+    points larger and recalculating all font sizes to be the new size.
+    This does not change the size of any images.
+
+    \sa zoomOut()
+*/
+
+void QTextEdit::zoomIn( int range )
+{
+    QFont f( QScrollView::font() );
+    f.setPointSize( QFontInfo(f).pointSize() + range );
+    setFont( f );
+}
+
+/*!
+    Zooms out on the text by making the base font size \a range points
+    smaller and recalculating all font sizes to be the new size. This
+    does not change the size of any images.
+
+    \sa zoomIn()
+*/
+
+void QTextEdit::zoomOut( int range )
+{
+    QFont f( QScrollView::font() );
+    f.setPointSize( QMAX( 1, QFontInfo(f).pointSize() - range ) );
+    setFont( f );
+}
+
+/*!
+    Zooms the text by making the base font size \a size points and
+    recalculating all font sizes to be the new size. This does not
+    change the size of any images.
+*/
+
+void QTextEdit::zoomTo( int size )
+{
+    QFont f( QScrollView::font() );
+    f.setPointSize( size );
+    setFont( f );
+}
+
+/*!
+   QTextEdit is optimized for large amounts text. One of its
+   optimizations is to format only the visible text, formatting the rest
+   on demand, e.g. as the user scrolls, so you don't usually need to
+   call this function.
+
+    In some situations you may want to force the whole text
+    to be formatted. For example, if after calling setText(), you wanted
+    to know the height of the document (using contentsHeight()), you
+    would call this function first.
+*/
+
+void QTextEdit::sync()
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	QFontMetrics fm( QScrollView::font() );
+	resizeContents( d->od->maxLineWidth + 4, d->od->numLines * fm.lineSpacing() + 1 );
+    } else
+#endif
+    {
+	while ( lastFormatted ) {
+	    lastFormatted->format();
+	    lastFormatted = lastFormatted->next();
+	}
+	resizeContents( contentsWidth(), doc->height() );
+    }
+    updateScrollBars();
+}
+
+/*!
+    \reimp
+*/
+
+void QTextEdit::setEnabled( bool b )
+{
+    QScrollView::setEnabled( b );
+    if ( textFormat() == PlainText ) {
+	QTextFormat *f = doc->formatCollection()->defaultFormat();
+	f->setColor( colorGroup().text() );
+	updateContents();
+    }
+}
+
+/*!
+    Sets the background color of selection number \a selNum to \a back
+    and specifies whether the text of this selection should be
+    inverted with \a invertText.
+
+    This only works for \a selNum > 0. The default selection (\a
+    selNum == 0) gets its attributes from the text edit's
+    colorGroup().
+*/
+
+void QTextEdit::setSelectionAttributes( int selNum, const QColor &back, bool invertText )
+{
+    if ( selNum < 1 )
+	return;
+    if ( selNum > doc->numSelections() )
+	doc->addSelection( selNum );
+    doc->setSelectionColor( selNum, back );
+    doc->setInvertSelectionText( selNum, invertText );
+}
+
+/*!
+    \reimp
+*/
+void QTextEdit::windowActivationChange( bool oldActive )
+{
+    if ( oldActive && scrollTimer )
+	scrollTimer->stop();
+    if ( palette().active() != palette().inactive() )
+	updateContents();
+    QScrollView::windowActivationChange( oldActive );
+}
+
+void QTextEdit::setReadOnly( bool b )
+{
+    if ( (bool) readonly == b )
+	return;
+    readonly = b;
+#ifndef QT_NO_CURSOR
+    if ( readonly )
+	viewport()->setCursor( arrowCursor );
+    else
+	viewport()->setCursor( ibeamCursor );
+    setInputMethodEnabled( !readonly );
+#endif
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    checkOptimMode();
+#endif
+}
+
+/*!
+    Scrolls to the bottom of the document and does formatting if
+    required.
+*/
+
+void QTextEdit::scrollToBottom()
+{
+    sync();
+    setContentsPos( contentsX(), contentsHeight() - visibleHeight() );
+}
+
+/*!
+    Returns the rectangle of the paragraph \a para in contents
+    coordinates, or an invalid rectangle if \a para is out of range.
+*/
+
+QRect QTextEdit::paragraphRect( int para ) const
+{
+    QTextEdit *that = (QTextEdit *)this;
+    that->sync();
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return QRect( -1, -1, -1, -1 );
+    return p->rect();
+}
+
+/*!
+    Returns the paragraph which is at position \a pos (in contents
+    coordinates).
+*/
+
+int QTextEdit::paragraphAt( const QPoint &pos ) const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	QFontMetrics fm( QScrollView::font() );
+	int parag = pos.y() / fm.lineSpacing();
+	if ( parag <= d->od->numLines )
+	    return parag;
+	else
+	    return 0;
+    }
+#endif
+    QTextCursor c( doc );
+    c.place( pos, doc->firstParagraph() );
+    if ( c.paragraph() )
+	return c.paragraph()->paragId();
+    return -1; // should never happen..
+}
+
+/*!
+    Returns the index of the character (relative to its paragraph) at
+    position \a pos (in contents coordinates). If \a para is not 0,
+    \a *para is set to the character's paragraph.
+*/
+
+int QTextEdit::charAt( const QPoint &pos, int *para ) const
+{
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    if ( d->optimMode ) {
+	int par = paragraphAt( pos );
+	if ( para )
+	    *para = par;
+	return optimCharIndex( d->od->lines[ LOGOFFSET(par) ], pos.x() );
+    }
+#endif
+    QTextCursor c( doc );
+    c.place( pos, doc->firstParagraph() );
+    if ( c.paragraph() ) {
+	if ( para )
+	    *para = c.paragraph()->paragId();
+	return c.index();
+    }
+    return -1; // should never happen..
+}
+
+/*!
+    Sets the background color of the paragraph \a para to \a bg.
+*/
+
+void QTextEdit::setParagraphBackgroundColor( int para, const QColor &bg )
+{
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return;
+    p->setBackgroundColor( bg );
+    repaintChanged();
+}
+
+/*!
+    Clears the background color of the paragraph \a para, so that the
+    default color is used again.
+*/
+
+void QTextEdit::clearParagraphBackground( int para )
+{
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return;
+    p->clearBackgroundColor();
+    repaintChanged();
+}
+
+/*!
+    Returns the background color of the paragraph \a para or an
+    invalid color if \a para is out of range or the paragraph has no
+    background set
+*/
+
+QColor QTextEdit::paragraphBackgroundColor( int para ) const
+{
+    QTextParagraph *p = doc->paragAt( para );
+    if ( !p )
+	return QColor();
+    QColor *c = p->backgroundColor();
+    if ( c )
+	return *c;
+    return QColor();
+}
+
+/*!
+    \property QTextEdit::undoRedoEnabled
+    \brief whether undo/redo is enabled
+
+    When changing this property, the undo/redo history is cleared.
+
+    The default is TRUE.
+*/
+
+void QTextEdit::setUndoRedoEnabled( bool b )
+{
+    undoRedoInfo.clear();
+    doc->commands()->clear();
+
+    undoEnabled = b;
+}
+
+bool QTextEdit::isUndoRedoEnabled() const
+{
+    return undoEnabled;
+}
+
+/*!
+    Returns TRUE if undo is available; otherwise returns FALSE.
+*/
+
+bool QTextEdit::isUndoAvailable() const
+{
+    return undoEnabled && (doc->commands()->isUndoAvailable() || undoRedoInfo.valid());
+}
+
+/*!
+    Returns TRUE if redo is available; otherwise returns FALSE.
+*/
+
+bool QTextEdit::isRedoAvailable() const
+{
+    return undoEnabled && doc->commands()->isRedoAvailable();
+}
+
+void QTextEdit::ensureFormatted( QTextParagraph *p )
+{
+    while ( !p->isValid() ) {
+	if ( !lastFormatted )
+	    return;
+	formatMore();
+    }
+}
+
+/*! \internal */
+void QTextEdit::updateCursor( const QPoint & pos )
+{
+    if ( isReadOnly() && linksEnabled() ) {
+	QTextCursor c = *cursor;
+	placeCursor( pos, &c, TRUE );
+
+#ifndef QT_NO_NETWORKPROTOCOL
+	bool insideParagRect = TRUE;
+	if (c.paragraph() == doc->lastParagraph()
+	    && c.paragraph()->rect().y() + c.paragraph()->rect().height() < pos.y())
+	    insideParagRect = FALSE;
+	if (insideParagRect && c.paragraph() && c.paragraph()->at( c.index() ) &&
+	    c.paragraph()->at( c.index() )->isAnchor()) {
+	    if (!c.paragraph()->at( c.index() )->anchorHref().isEmpty()
+		    && c.index() < c.paragraph()->length() - 1 )
+		onLink = c.paragraph()->at( c.index() )->anchorHref();
+	    else
+		onLink = QString::null;
+
+	    if (!c.paragraph()->at( c.index() )->anchorName().isEmpty()
+		    && c.index() < c.paragraph()->length() - 1 )
+		d->onName = c.paragraph()->at( c.index() )->anchorName();
+	    else
+		d->onName = QString::null;
+
+	    if (!c.paragraph()->at( c.index() )->anchorHref().isEmpty() ) {
+#ifndef QT_NO_CURSOR
+		viewport()->setCursor( onLink.isEmpty() ? arrowCursor : pointingHandCursor );
+#endif
+		QUrl u( doc->context(), onLink, TRUE );
+		emitHighlighted( u.toString( FALSE, FALSE ) );
+	    }
+	} else {
+#ifndef QT_NO_CURSOR
+	    viewport()->setCursor( isReadOnly() ? arrowCursor : ibeamCursor );
+#endif
+	    onLink = QString::null;
+	    emitHighlighted( QString::null );
+	}
+#endif
+    }
+}
+
+/*!
+  Places the cursor \a c at the character which is closest to position
+  \a pos (in contents coordinates). If \a c is 0, the default text
+  cursor is used.
+
+  \sa setCursorPosition()
+*/
+void QTextEdit::placeCursor( const QPoint &pos, QTextCursor *c )
+{
+    placeCursor( pos, c, FALSE );
+}
+
+/*! \internal */
+void QTextEdit::clipboardChanged()
+{
+#ifndef QT_NO_CLIPBOARD
+    // don't listen to selection changes
+    disconnect( QApplication::clipboard(), SIGNAL(selectionChanged()), this, 0);
+#endif
+    selectAll(FALSE);
+}
+
+/*! \property QTextEdit::tabChangesFocus
+  \brief whether TAB changes focus or is accepted as input
+
+  In some occasions text edits should not allow the user to input
+  tabulators or change indentation using the TAB key, as this breaks
+  the focus chain. The default is FALSE.
+
+*/
+
+void QTextEdit::setTabChangesFocus( bool b )
+{
+    d->tabChangesFocus = b;
+}
+
+bool QTextEdit::tabChangesFocus() const
+{
+    return d->tabChangesFocus;
+}
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+/* Implementation of optimized LogText mode follows */
+
+static void qSwap( int * a, int * b )
+{
+    if ( !a || !b )
+	return;
+    int tmp = *a;
+    *a = *b;
+    *b = tmp;
+}
+
+/*! \internal */
+bool QTextEdit::checkOptimMode()
+{
+    bool oldMode = d->optimMode;
+    if ( textFormat() == LogText ) {
+	setReadOnly( TRUE );
+	d->optimMode = TRUE;
+    } else {
+	d->optimMode = FALSE;
+    }
+
+    // when changing mode - try to keep selections and text
+    if ( oldMode != d->optimMode ) {
+	if ( d->optimMode ) {
+	    d->od = new QTextEditOptimPrivate;
+	    connect( scrollTimer, SIGNAL( timeout() ), this, SLOT( optimDoAutoScroll() ) );
+	    disconnect( doc, SIGNAL( minimumWidthChanged(int) ), this, SLOT( documentWidthChanged(int) ) );
+	    disconnect( scrollTimer, SIGNAL( timeout() ), this, SLOT( autoScrollTimerDone() ) );
+	    disconnect( formatTimer, SIGNAL( timeout() ), this, SLOT( formatMore() ) );
+	    optimSetText( doc->originalText() );
+	    doc->clear(TRUE);
+	    delete cursor;
+	    cursor = new QTextCursor( doc );
+	} else {
+	    disconnect( scrollTimer, SIGNAL( timeout() ), this, SLOT( optimDoAutoScroll() ) );
+	    connect( doc, SIGNAL( minimumWidthChanged(int) ), this, SLOT( documentWidthChanged(int) ) );
+	    connect( scrollTimer, SIGNAL( timeout() ), this, SLOT( autoScrollTimerDone() ) );
+	    connect( formatTimer, SIGNAL( timeout() ), this, SLOT( formatMore() ) );
+	    setText( optimText() );
+	    delete d->od;
+	    d->od = 0;
+	}
+    }
+    return d->optimMode;
+}
+
+/*! \internal */
+QString QTextEdit::optimText() const
+{
+    QString str, tmp;
+
+    if ( d->od->len == 0 )
+	return str;
+
+    // concatenate all strings
+    int i;
+    int offset;
+    QMapConstIterator<int,QTextEditOptimPrivate::Tag *> it;
+    QTextEditOptimPrivate::Tag * ftag = 0;
+    for ( i = 0; i < d->od->numLines; i++ ) {
+	if ( d->od->lines[ LOGOFFSET(i) ].isEmpty() ) { // CR lines are empty
+	    str += "\n";
+	} else {
+	    tmp = d->od->lines[ LOGOFFSET(i) ] + "\n";
+	    // inject the tags for this line
+	    if ( (it = d->od->tagIndex.find( LOGOFFSET(i) )) != d->od->tagIndex.end() )
+		ftag = it.data();
+	    offset = 0;
+	    while ( ftag && ftag->line == i ) {
+		tmp.insert( ftag->index + offset, "<" + ftag->tag + ">" );
+		offset += ftag->tag.length() + 2; // 2 -> the '<' and '>' chars
+		ftag = ftag->next;
+	    }
+	    str += tmp;
+	}
+    }
+    return str;
+}
+
+/*! \internal */
+void QTextEdit::optimSetText( const QString &str )
+{
+    optimRemoveSelection();
+// this is just too slow - but may have to go in due to compatibility reasons
+//     if ( str == optimText() )
+//	return;
+    d->od->numLines = 0;
+    d->od->lines.clear();
+    d->od->maxLineWidth = 0;
+    d->od->len = 0;
+    d->od->clearTags();
+    QFontMetrics fm( QScrollView::font() );
+    if ( !(str.isEmpty() || str.isNull() || d->maxLogLines == 0) ) {
+	QStringList strl = QStringList::split( '\n', str, TRUE );
+	int lWidth = 0;
+	for ( QStringList::Iterator it = strl.begin(); it != strl.end(); ++it ) {
+	    optimParseTags( &*it );
+	    optimCheckLimit( *it );
+	    lWidth = fm.width( *it );
+	    if ( lWidth > d->od->maxLineWidth )
+		d->od->maxLineWidth = lWidth;
+	}
+    }
+    resizeContents( d->od->maxLineWidth + 4, d->od->numLines * fm.lineSpacing() + 1 );
+    repaintContents();
+    emit textChanged();
+}
+
+/*! \internal
+
+  Append \a tag to the tag list.
+*/
+QTextEditOptimPrivate::Tag * QTextEdit::optimAppendTag( int index, const QString & tag )
+{
+    QTextEditOptimPrivate::Tag * t = new QTextEditOptimPrivate::Tag, * tmp;
+
+    if ( d->od->tags == 0 )
+	d->od->tags = t;
+    t->bold = t->italic = t->underline = FALSE;
+    t->line  = d->od->numLines;
+    t->index = index;
+    t->tag   = tag;
+    t->leftTag = 0;
+    t->parent  = 0;
+    t->prev = d->od->lastTag;
+    if ( d->od->lastTag )
+	d->od->lastTag->next = t;
+    t->next = 0;
+    d->od->lastTag = t;
+    tmp = d->od->tagIndex[ LOGOFFSET(t->line) ];
+    if ( !tmp || (tmp && tmp->index > t->index) ) {
+	d->od->tagIndex.replace( LOGOFFSET(t->line), t );
+    }
+    return t;
+}
+
+ /*! \internal
+
+   Insert \a tag in the tag - according to line and index numbers
+*/
+
+QTextEditOptimPrivate::Tag *QTextEdit::optimInsertTag(int line, int index, const QString &tag)
+{
+    QTextEditOptimPrivate::Tag *t = new QTextEditOptimPrivate::Tag, *tmp;
+
+    if (d->od->tags == 0)
+	d->od->tags = t;
+    t->bold = t->italic = t->underline = FALSE;
+    t->line  = line;
+    t->index = index;
+    t->tag   = tag;
+    t->leftTag = 0;
+    t->parent  = 0;
+    t->next = 0;
+    t->prev = 0;
+
+    // find insertion pt. in tag struct.
+    QMap<int,QTextEditOptimPrivate::Tag *>::ConstIterator it;
+    if ((it = d->od->tagIndex.find(LOGOFFSET(line))) != d->od->tagIndex.end()) {
+	tmp = *it;
+	if (tmp->index >= index) { // the exisiting tag may be placed AFTER the one we want to insert
+	    tmp = tmp->prev;
+	} else {
+	    while (tmp && tmp->next && tmp->next->line == line && tmp->next->index <= index)
+		tmp = tmp->next;
+	}
+    } else {
+	tmp = d->od->tags;
+	while (tmp && tmp->next && tmp->next->line < line)
+	    tmp = tmp->next;
+	if (tmp == d->od->tags)
+	    tmp = 0;
+    }
+
+    t->prev = tmp;
+    t->next = tmp ? tmp->next : 0;
+    if (t->next)
+	t->next->prev = t;
+    if (tmp)
+	tmp->next = t;
+
+    tmp = d->od->tagIndex[LOGOFFSET(t->line)];
+    if (!tmp || (tmp && tmp->index >= t->index)) {
+	d->od->tagIndex.replace(LOGOFFSET(t->line), t);
+    }
+    return t;
+}
+
+
+/*! \internal
+
+  Find tags in \a line, remove them from \a line and put them in a
+  structure.
+
+  A tag is delimited by '<' and '>'. The characters '<', '>' and '&'
+  are escaped by using '&lt;', '&gt;' and '&amp;'. Left-tags marks
+  the starting point for formatting, while right-tags mark the ending
+  point. A right-tag is the same as a left-tag, but with a '/'
+  appearing before the tag keyword.  E.g a valid left-tag: <b>, and
+  a valid right-tag: </b>.  Tags can be nested, but they have to be
+  closed in the same order as they are opened. E.g:
+  <font color=red><font color=blue>blue</font>red</font> - is valid, while:
+  <font color=red><b>bold red</font> just bold</b> - is invalid since the font tag is
+  closed before the bold tag. Note that a tag does not have to be
+  closed: '<font color=blue>Lots of text - and then some..'  is perfectly valid for
+  setting all text appearing after the tag to blue.  A tag can be used
+  to change the color of a piece of text, or set one of the following
+  formatting attributes: bold, italic and underline.  These attributes
+  are set using the <b>, <i> and <u> tags.  Example of valid tags:
+  <font color=red>, </font>, <b>, <u>, <i>, </i>.
+  Example of valid text:
+  This is some <font color=red>red text</font>, while this is some <font color=green>green
+  text</font>. <font color=blue><font color=yellow>This is yellow</font>, while this is
+  blue.</font>
+
+  Note that only the color attribute of the HTML font tag is supported.
+
+  Limitations:
+  1. A tag cannot span several lines.
+  2. Very limited error checking - mismatching left/right-tags is the
+  only thing that is detected.
+
+*/
+void QTextEdit::optimParseTags( QString * line, int lineNo, int indexOffset )
+{
+    int len = line->length();
+    int i, startIndex = -1, endIndex = -1, escIndex = -1;
+    int state = 0; // 0 = outside tag, 1 = inside tag
+    bool tagOpen, tagClose;
+    int bold = 0, italic = 0, underline = 0;
+    QString tagStr;
+    QPtrStack<QTextEditOptimPrivate::Tag> tagStack;
+
+    for ( i = 0; i < len; i++ ) {
+	tagOpen = (*line)[i] == '<';
+	tagClose = (*line)[i] == '>';
+
+	// handle '&lt;' and '&gt;' and '&amp;'
+	if ( (*line)[i] == '&' ) {
+	    escIndex = i;
+	    continue;
+	} else if ( escIndex != -1 && (*line)[i] == ';' ) {
+	    QString esc = line->mid( escIndex, i - escIndex + 1 );
+	    QString c;
+	    if ( esc == "&lt;" )
+		c = '<';
+	    else if ( esc == "&gt;" )
+		c = '>';
+	    else if ( esc == "&amp;" )
+		c = '&';
+	    line->replace( escIndex, i - escIndex + 1, c );
+	    len = line->length();
+	    i -= i-escIndex;
+	    escIndex = -1;
+	    continue;
+	}
+
+	if ( state == 0 && tagOpen ) {
+	    state = 1;
+	    startIndex = i;
+	    continue;
+	}
+	if ( state == 1 && tagClose ) {
+	    state = 0;
+	    endIndex = i;
+	    if ( !tagStr.isEmpty() ) {
+		QTextEditOptimPrivate::Tag * tag, * cur, * tmp;
+		bool format = TRUE;
+
+		if ( tagStr == "b" )
+		    bold++;
+		else if ( tagStr == "/b" )
+		    bold--;
+		else if ( tagStr == "i" )
+		    italic++;
+		else if ( tagStr == "/i" )
+		    italic--;
+		else if ( tagStr == "u" )
+		    underline++;
+		else if ( tagStr == "/u" )
+		    underline--;
+		else
+		    format = FALSE;
+		if ( lineNo > -1 )
+		    tag = optimInsertTag( lineNo, startIndex + indexOffset, tagStr );
+		else
+		    tag = optimAppendTag( startIndex, tagStr );
+		// everything that is not a b, u or i tag is considered
+		// to be a color tag.
+		tag->type = format ? QTextEditOptimPrivate::Format
+			    : QTextEditOptimPrivate::Color;
+		if ( tagStr[0] == '/' ) {
+		    // this is a right-tag - search for the left-tag
+		    // and possible parent tag
+		    cur = tag->prev;
+		    if ( !cur ) {
+#ifdef QT_CHECK_RANGE
+			qWarning( "QTextEdit::optimParseTags: no left-tag for '<%s>' in line %d.", tag->tag.ascii(), tag->line + 1 );
+#endif
+			return; // something is wrong - give up
+		    }
+		    while ( cur ) {
+			if ( cur->leftTag ) { // push right-tags encountered
+			    tagStack.push( cur );
+			} else {
+			    tmp = tagStack.pop();
+			    if ( !tmp ) {
+				if ( (("/" + cur->tag) == tag->tag) ||
+				     (tag->tag == "/font" && cur->tag.left(4) == "font") ) {
+				    // set up the left and parent of this tag
+				    tag->leftTag = cur;
+				    tmp = cur->prev;
+				    if ( tmp && tmp->parent ) {
+					tag->parent = tmp->parent;
+				    } else if ( tmp && !tmp->leftTag ) {
+					tag->parent = tmp;
+				    }
+				    break;
+				} else if ( !cur->leftTag ) {
+#ifdef QT_CHECK_RANGE
+				    qWarning( "QTextEdit::optimParseTags: mismatching %s-tag for '<%s>' in line %d.", cur->tag[0] == '/' ? "left" : "right", cur->tag.ascii(), cur->line + 1 );
+#endif
+				    return; // something is amiss - give up
+				}
+			    }
+			}
+			cur = cur->prev;
+		    }
+		} else {
+		    tag->bold = bold > 0;
+		    tag->italic = italic > 0;
+		    tag->underline = underline > 0;
+		    tmp = tag->prev;
+		    while ( tmp && tmp->leftTag ) {
+			tmp = tmp->leftTag->parent;
+		    }
+		    if ( tmp ) {
+			tag->bold |= tmp->bold;
+			tag->italic |= tmp->italic;
+			tag->underline |= tmp->underline;
+		    }
+		}
+	    }
+	    if ( startIndex != -1 ) {
+		int l = (endIndex == -1) ?
+			line->length() - startIndex : endIndex - startIndex;
+		line->remove( startIndex, l+1 );
+		len = line->length();
+		i -= l+1;
+	    }
+	    tagStr = "";
+	    continue;
+	}
+
+	if ( state == 1 ) {
+	    tagStr += (*line)[i];
+	}
+    }
+}
+
+// calculate the width of a string in pixels inc. tabs
+static int qStrWidth(const QString& str, int tabWidth, const QFontMetrics& fm)
+{
+    int tabs = str.contains('\t');
+
+    if (!tabs)
+	return fm.width(str);
+
+    int newIdx = 0;
+    int lastIdx = 0;
+    int strWidth = 0;
+    int tn;
+    for (tn = 1; tn <= tabs; ++tn) {
+	newIdx = str.find('\t', newIdx);
+	strWidth += fm.width(str.mid(lastIdx, newIdx - lastIdx));
+	if (strWidth >= tn * tabWidth) {
+	    int u = tn;
+	    while (strWidth >= u * tabWidth)
+		++u;
+	    strWidth = u * tabWidth;
+	} else {
+	    strWidth = tn * tabWidth;
+	}
+	lastIdx = ++newIdx;
+    }
+    if ((int)str.length() > newIdx)
+	strWidth += fm.width(str.mid(newIdx));
+    return strWidth;
+}
+
+bool QTextEdit::optimHasBoldMetrics(int line)
+{
+    QTextEditOptimPrivate::Tag *t;
+    QMapConstIterator<int,QTextEditOptimPrivate::Tag *> it;
+    if ((it = d->od->tagIndex.find(line)) != d->od->tagIndex.end()) {
+	t = *it;
+	while (t && t->line == line) {
+	    if (t->bold)
+		return TRUE;
+	    t = t->next;
+	}
+    } else if ((t = optimPreviousLeftTag(line)) && t->bold) {
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*! \internal
+
+  Append \a str to the current text buffer. Parses each line to find
+  formatting tags.
+*/
+void QTextEdit::optimAppend( const QString &str )
+{
+    if ( str.isEmpty() || str.isNull() || d->maxLogLines == 0 )
+	return;
+
+    QStringList strl = QStringList::split( '\n', str, TRUE );
+    QStringList::Iterator it = strl.begin();
+
+    QFontMetrics fm(QScrollView::font());
+    int lWidth = 0;
+
+    for ( ; it != strl.end(); ++it ) {
+	optimParseTags( &*it );
+	optimCheckLimit( *it );
+	if (optimHasBoldMetrics(d->od->numLines-1)) {
+	    QFont fnt = QScrollView::font();
+	    fnt.setBold(TRUE);
+	    fm = QFontMetrics(fnt);
+	}
+	lWidth = qStrWidth(*it, tabStopWidth(), fm) + 4;
+	if ( lWidth > d->od->maxLineWidth )
+	    d->od->maxLineWidth = lWidth;
+    }
+    bool scrollToEnd = contentsY() >= contentsHeight() - visibleHeight();
+    resizeContents( d->od->maxLineWidth + 4, d->od->numLines * fm.lineSpacing() + 1 );
+    if ( scrollToEnd ) {
+	updateScrollBars();
+	ensureVisible( contentsX(), contentsHeight(), 0, 0 );
+    }
+    // when a max log size is set, the text may not be redrawn because
+    // the size of the viewport may not have changed
+    if ( d->maxLogLines > -1 )
+	viewport()->update();
+    emit textChanged();
+}
+
+
+static void qStripTags(QString *line)
+{
+    int len = line->length();
+    int i, startIndex = -1, endIndex = -1, escIndex = -1;
+    int state = 0; // 0 = outside tag, 1 = inside tag
+    bool tagOpen, tagClose;
+
+    for ( i = 0; i < len; i++ ) {
+	tagOpen = (*line)[i] == '<';
+	tagClose = (*line)[i] == '>';
+
+	// handle '&lt;' and '&gt;' and '&amp;'
+	if ( (*line)[i] == '&' ) {
+	    escIndex = i;
+	    continue;
+	} else if ( escIndex != -1 && (*line)[i] == ';' ) {
+	    QString esc = line->mid( escIndex, i - escIndex + 1 );
+	    QString c;
+	    if ( esc == "&lt;" )
+		c = '<';
+	    else if ( esc == "&gt;" )
+		c = '>';
+	    else if ( esc == "&amp;" )
+		c = '&';
+	    line->replace( escIndex, i - escIndex + 1, c );
+	    len = line->length();
+	    i -= i-escIndex;
+	    escIndex = -1;
+	    continue;
+	}
+
+	if ( state == 0 && tagOpen ) {
+	    state = 1;
+	    startIndex = i;
+	    continue;
+	}
+	if ( state == 1 && tagClose ) {
+	    state = 0;
+	    endIndex = i;
+	    if ( startIndex != -1 ) {
+		int l = (endIndex == -1) ?
+			line->length() - startIndex : endIndex - startIndex;
+		line->remove( startIndex, l+1 );
+		len = line->length();
+		i -= l+1;
+	    }
+	    continue;
+	}
+    }
+}
+
+/*! \internal
+
+    Inserts the text into \a line at index \a index.
+*/
+
+void QTextEdit::optimInsert(const QString& text, int line, int index)
+{
+    if (text.isEmpty() || d->maxLogLines == 0)
+	return;
+    if (line < 0)
+	line = 0;
+    if (line > d->od->numLines-1)
+	line = d->od->numLines-1;
+    if (index < 0)
+	index = 0;
+    if (index > (int) d->od->lines[line].length())
+	index = d->od->lines[line].length();
+
+    QStringList strl = QStringList::split('\n', text, TRUE);
+    int numNewLines = (int)strl.count() - 1;
+    QTextEditOptimPrivate::Tag *tag = 0;
+    QMap<int,QTextEditOptimPrivate::Tag *>::ConstIterator ii;
+    int x;
+
+    if (numNewLines == 0) {
+	// Case 1. Fast single line case - just inject it!
+	QString stripped = text;
+	qStripTags( &stripped );
+	d->od->lines[LOGOFFSET(line)].insert(index, stripped);
+	// move the tag indices following the insertion pt.
+	if ((ii = d->od->tagIndex.find(LOGOFFSET(line))) != d->od->tagIndex.end()) {
+	    tag = *ii;
+	    while (tag && (LOGOFFSET(tag->line) == line && tag->index < index))
+		tag = tag->next;
+	    while (tag && (LOGOFFSET(tag->line) == line)) {
+		tag->index += stripped.length();
+		tag = tag->next;
+	    }
+	}
+	stripped = text;
+	optimParseTags(&stripped, line, index);
+    } else if (numNewLines > 0) {
+        // Case 2. We have at least 1 newline char - split at
+        // insertion pt. and make room for new lines - complex and slow!
+	QString left = d->od->lines[LOGOFFSET(line)].left(index);
+	QString right = d->od->lines[LOGOFFSET(line)].mid(index);
+
+	// rearrange lines for insertion
+	for (x = d->od->numLines - 1; x > line; x--)
+	    d->od->lines[x + numNewLines] = d->od->lines[x];
+	d->od->numLines += numNewLines;
+
+	// fix the tag index and the tag line/index numbers - this
+	// might take a while..
+	for (x = line; x < d->od->numLines; x++) {
+	    if ((ii = d->od->tagIndex.find(LOGOFFSET(line))) != d->od->tagIndex.end()) {
+		tag = ii.data();
+		if (LOGOFFSET(tag->line) == line)
+		    while (tag && (LOGOFFSET(tag->line) == line && tag->index < index))
+			tag = tag->next;
+	    }
+	}
+
+	// relabel affected tags with new line numbers and new index
+	// positions
+	while (tag) {
+	    if (LOGOFFSET(tag->line) == line)
+		tag->index -= index;
+	    tag->line += numNewLines;
+	    tag = tag->next;
+	}
+
+	// generate a new tag index
+	d->od->tagIndex.clear();
+	tag = d->od->tags;
+	while (tag) {
+	    if (!((ii = d->od->tagIndex.find(LOGOFFSET(tag->line))) != d->od->tagIndex.end()))
+		d->od->tagIndex[LOGOFFSET(tag->line)] = tag;
+	    tag = tag->next;
+	}
+
+	// update the tag indices on the spliced line - needs to be done before new tags are added
+	QString stripped = strl[strl.count() - 1];
+	qStripTags(&stripped);
+	if ((ii = d->od->tagIndex.find(LOGOFFSET(line + numNewLines))) != d->od->tagIndex.end()) {
+	    tag = *ii;
+	    while (tag && (LOGOFFSET(tag->line) == line + numNewLines)) {
+		tag->index += stripped.length();
+		tag = tag->next;
+	    }
+	}
+
+	// inject the new lines
+	QStringList::Iterator it = strl.begin();
+	x = line;
+	int idx;
+	for (; it != strl.end(); ++it) {
+	    stripped = *it;
+	    qStripTags(&stripped);
+	    if (x == line) {
+		stripped = left + stripped;
+		idx = index;
+	    } else {
+		idx = 0;
+	    }
+	    d->od->lines[LOGOFFSET(x)] = stripped;
+	    optimParseTags(&*it, x++, idx);
+	}
+	d->od->lines[LOGOFFSET(x - 1)] += right;
+    }
+    // recalculate the pixel width of the longest injected line -
+    QFontMetrics fm(QScrollView::font());
+    int lWidth = 0;
+
+    for (x = line; x < line + numNewLines; x++) {
+	if (optimHasBoldMetrics(x)) {
+	    QFont fnt = QScrollView::font();
+	    fnt.setBold(TRUE);
+	    fm = QFontMetrics(fnt);
+	}
+	lWidth = fm.width(d->od->lines[x]) + 4;
+	if (lWidth > d->od->maxLineWidth)
+	    d->od->maxLineWidth = lWidth;
+    }
+    resizeContents(d->od->maxLineWidth + 4, d->od->numLines * fm.lineSpacing() + 1);
+    repaintContents();
+    emit textChanged();
+}
+
+
+
+/*! \internal
+
+  Returns the first open left-tag appearing before line \a line.
+ */
+QTextEditOptimPrivate::Tag * QTextEdit::optimPreviousLeftTag( int line )
+{
+    QTextEditOptimPrivate::Tag * ftag = 0;
+    QMapConstIterator<int,QTextEditOptimPrivate::Tag *> it;
+    if ( (it = d->od->tagIndex.find( LOGOFFSET(line) )) != d->od->tagIndex.end() )
+	ftag = it.data();
+    if ( !ftag ) {
+	// start searching for an open tag
+	ftag = d->od->tags;
+	while ( ftag ) {
+	    if ( ftag->line > line || ftag->next == 0 ) {
+		if ( ftag->line > line )
+		    ftag = ftag->prev;
+		break;
+	    }
+	    ftag = ftag->next;
+	}
+    } else {
+	ftag = ftag->prev;
+    }
+
+    if ( ftag ) {
+	if ( ftag && ftag->parent ) // use the open parent tag
+	    ftag = ftag->parent;
+	else if ( ftag && ftag->leftTag ) // this is a right-tag with no parent
+	    ftag = 0;
+    }
+    return ftag;
+}
+
+/*! \internal
+
+  Set the format for the string starting at index \a start and ending
+  at \a end according to \a tag. If \a tag is a Format tag, find the
+  first open color tag appearing before \a tag and use that tag to
+  color the string.
+*/
+void QTextEdit::optimSetTextFormat( QTextDocument * td, QTextCursor * cur,
+				    QTextFormat * f, int start, int end,
+				    QTextEditOptimPrivate::Tag * tag )
+{
+    int formatFlags = QTextFormat::Bold | QTextFormat::Italic |
+		      QTextFormat::Underline;
+    cur->setIndex( start );
+    td->setSelectionStart( 0, *cur );
+    cur->setIndex( end );
+    td->setSelectionEnd( 0, *cur );
+    QStyleSheetItem * ssItem = styleSheet()->item( tag->tag );
+    if ( !ssItem || tag->type == QTextEditOptimPrivate::Format ) {
+	f->setBold( tag->bold );
+	f->setItalic( tag->italic );
+	f->setUnderline( tag->underline );
+	if ( tag->type == QTextEditOptimPrivate::Format ) {
+	    // check to see if there are any open color tags prior to
+	    // this format tag
+	    tag = tag->prev;
+	    while ( tag && (tag->type == QTextEditOptimPrivate::Format ||
+			    tag->leftTag) ) {
+		tag = tag->leftTag ? tag->parent : tag->prev;
+	    }
+	}
+	if ( tag ) {
+	    QString col = tag->tag.simplifyWhiteSpace();
+	    if ( col.left( 10 ) == "font color" ) {
+		int i = col.find( '=', 10 );
+		col = col.mid( i + 1 ).simplifyWhiteSpace();
+		if ( col[0] == '\"' )
+		    col = col.mid( 1, col.length() - 2 );
+	    }
+	    QColor color = QColor( col );
+	    if ( color.isValid() ) {
+		formatFlags |= QTextFormat::Color;
+		f->setColor( color );
+	    }
+	}
+    } else { // use the stylesheet tag definition
+	if ( ssItem->color().isValid() ) {
+	    formatFlags |= QTextFormat::Color;
+	    f->setColor( ssItem->color() );
+	}
+	f->setBold( ssItem->fontWeight() == QFont::Bold );
+	f->setItalic( ssItem->fontItalic() );
+	f->setUnderline( ssItem->fontUnderline() );
+    }
+    td->setFormat( 0, f, formatFlags );
+    td->removeSelection( 0 );
+}
+
+/*! \internal */
+void QTextEdit::optimDrawContents( QPainter * p, int clipx, int clipy,
+				   int clipw, int cliph )
+{
+    QFontMetrics fm( QScrollView::font() );
+    int startLine = clipy / fm.lineSpacing();
+
+    // we always have to fetch at least two lines for drawing because the
+    // painter may be translated so that parts of two lines cover the area
+    // of a single line
+    int nLines = (cliph / fm.lineSpacing()) + 2;
+    int endLine = startLine + nLines;
+
+    if ( startLine >= d->od->numLines )
+	return;
+    if ( (startLine + nLines) > d->od->numLines )
+	nLines = d->od->numLines - startLine;
+
+    int i = 0;
+    QString str;
+    for ( i = startLine; i < (startLine + nLines); i++ )
+	str.append( d->od->lines[ LOGOFFSET(i) ] + "\n" );
+
+    QTextDocument * td = new QTextDocument( 0 );
+    td->setDefaultFormat( QScrollView::font(), QColor() );
+    td->setPlainText( str );
+    td->setFormatter( new QTextFormatterBreakWords ); // deleted by QTextDoc
+    td->formatter()->setWrapEnabled( FALSE );
+    td->setTabStops(doc->tabStopWidth());
+
+    // get the current text color from the current format
+    td->selectAll( QTextDocument::Standard );
+    QTextFormat f;
+    f.setColor( colorGroup().text() );
+    f.setFont( QScrollView::font() );
+    td->setFormat( QTextDocument::Standard, &f,
+		   QTextFormat::Color | QTextFormat::Font );
+    td->removeSelection( QTextDocument::Standard );
+
+    // add tag formatting
+    if ( d->od->tags ) {
+	int i = startLine;
+	QMapConstIterator<int,QTextEditOptimPrivate::Tag *> it;
+	QTextEditOptimPrivate::Tag * tag = 0, * tmp = 0;
+	QTextCursor cur( td );
+	// Step 1 - find previous left-tag
+	tmp = optimPreviousLeftTag( i );
+	for ( ; i < startLine + nLines; i++ ) {
+	    if ( (it = d->od->tagIndex.find( LOGOFFSET(i) )) != d->od->tagIndex.end() )
+		tag = it.data();
+	    // Step 2 - iterate over tags on the current line
+	    int lastIndex = 0;
+	    while ( tag && tag->line == i ) {
+		tmp = 0;
+		if ( tag->prev && !tag->prev->leftTag ) {
+		    tmp = tag->prev;
+		} else if ( tag->prev && tag->prev->parent ) {
+		    tmp = tag->prev->parent;
+		}
+		if ( (tag->index - lastIndex) > 0 && tmp ) {
+		    optimSetTextFormat( td, &cur, &f, lastIndex, tag->index, tmp );
+		}
+		lastIndex = tag->index;
+		tmp = tag;
+		tag = tag->next;
+	    }
+	    // Step 3 - color last part of the line - if necessary
+	    if ( tmp && tmp->parent )
+		tmp = tmp->parent;
+	    if ( (cur.paragraph()->length()-1 - lastIndex) > 0 && tmp && !tmp->leftTag ) {
+		optimSetTextFormat( td, &cur, &f, lastIndex,
+				    cur.paragraph()->length() - 1, tmp );
+	    }
+	    cur.setParagraph( cur.paragraph()->next() );
+	}
+        // useful debug info
+	//
+//	tag = d->od->tags;
+//	qWarning("###");
+//	while ( tag ) {
+//	    qWarning( "Tag: %p, parent: %09p, leftTag: %09p, Name: %-15s, ParentName: %s, %d%d%d", tag,
+//		       tag->parent, tag->leftTag, tag->tag.latin1(), tag->parent ? tag->parent->tag.latin1():"<none>",
+//		      tag->bold, tag->italic, tag->underline );
+//	    tag = tag->next;
+//	}
+    }
+
+    // if there is a selection, make sure that the selection in the
+    // part we need to redraw is set correctly
+    if ( optimHasSelection() ) {
+	QTextCursor c1( td );
+	QTextCursor c2( td );
+	int selStart = d->od->selStart.line;
+	int idxStart = d->od->selStart.index;
+	int selEnd = d->od->selEnd.line;
+	int idxEnd = d->od->selEnd.index;
+	if ( selEnd < selStart ) {
+	    qSwap( &selStart, &selEnd );
+	    qSwap( &idxStart, &idxEnd );
+	}
+	if ( selEnd > d->od->numLines-1 ) {
+	    selEnd = d->od->numLines-1;
+	}
+	if ( startLine <= selStart && endLine >= selEnd ) {
+	    // case 1: area to paint covers entire selection
+	    int paragS = selStart - startLine;
+	    int paragE = paragS + (selEnd - selStart);
+	    QTextParagraph * parag = td->paragAt( paragS );
+	    if ( parag ) {
+		c1.setParagraph( parag );
+		if ( td->text( paragS ).length() >= (uint) idxStart )
+		    c1.setIndex( idxStart );
+	    }
+	    parag = td->paragAt( paragE );
+	    if ( parag ) {
+		c2.setParagraph( parag );
+		if ( td->text( paragE ).length() >= (uint) idxEnd )
+		    c2.setIndex( idxEnd );
+	    }
+	} else if ( startLine > selStart && endLine < selEnd ) {
+	    // case 2: area to paint is all part of the selection
+	    td->selectAll( QTextDocument::Standard );
+	} else if ( startLine > selStart && endLine >= selEnd &&
+		    startLine <= selEnd ) {
+	    // case 3: area to paint starts inside a selection, ends past it
+	    c1.setParagraph( td->firstParagraph() );
+	    c1.setIndex( 0 );
+	    int paragE = selEnd - startLine;
+	    QTextParagraph * parag = td->paragAt( paragE );
+	    if ( parag ) {
+		c2.setParagraph( parag );
+		if ( td->text( paragE ).length() >= (uint) idxEnd )
+		    c2.setIndex( idxEnd );
+	    }
+	} else if ( startLine <= selStart && endLine < selEnd &&
+		    endLine > selStart ) {
+	    // case 4: area to paint starts before a selection, ends inside it
+	    int paragS = selStart - startLine;
+	    QTextParagraph * parag = td->paragAt( paragS );
+	    if ( parag ) {
+		c1.setParagraph( parag );
+		c1.setIndex( idxStart );
+	    }
+	    c2.setParagraph( td->lastParagraph() );
+	    c2.setIndex( td->lastParagraph()->string()->toString().length() - 1 );
+
+	}
+	// previously selected?
+	if ( !td->hasSelection( QTextDocument::Standard ) ) {
+	    td->setSelectionStart( QTextDocument::Standard, c1 );
+	    td->setSelectionEnd( QTextDocument::Standard, c2 );
+	}
+    }
+    td->doLayout( p, contentsWidth() );
+
+    // have to align the painter so that partly visible lines are
+    // drawn at the correct position within the area that needs to be
+    // painted
+    int offset = clipy % fm.lineSpacing() + 2;
+    QRect r( clipx, 0, clipw, cliph + offset );
+    p->translate( 0, clipy - offset );
+    td->draw( p, r.x(), r.y(), r.width(), r.height(), colorGroup() );
+    p->translate( 0, -(clipy - offset) );
+    delete td;
+}
+
+/*! \internal */
+void QTextEdit::optimMousePressEvent( QMouseEvent * e )
+{
+    if ( e->button() != LeftButton )
+	return;
+
+    QFontMetrics fm( QScrollView::font() );
+    mousePressed = TRUE;
+    mousePos = e->pos();
+    d->od->selStart.line = e->y() / fm.lineSpacing();
+    if ( d->od->selStart.line > d->od->numLines-1 ) {
+	d->od->selStart.line = d->od->numLines-1;
+	d->od->selStart.index = d->od->lines[ LOGOFFSET(d->od->numLines-1) ].length();
+    } else {
+	QString str = d->od->lines[ LOGOFFSET(d->od->selStart.line) ];
+	d->od->selStart.index = optimCharIndex( str, mousePos.x() );
+    }
+    d->od->selEnd.line = d->od->selStart.line;
+    d->od->selEnd.index = d->od->selStart.index;
+    oldMousePos = e->pos();
+    repaintContents( FALSE );
+}
+
+/*! \internal */
+void QTextEdit::optimMouseReleaseEvent( QMouseEvent * e )
+{
+    if ( e->button() != LeftButton )
+	return;
+
+    if ( scrollTimer->isActive() )
+	scrollTimer->stop();
+    if ( !inDoubleClick ) {
+	QFontMetrics fm( QScrollView::font() );
+	d->od->selEnd.line = e->y() / fm.lineSpacing();
+	if ( d->od->selEnd.line > d->od->numLines-1 ) {
+	    d->od->selEnd.line = d->od->numLines-1;
+	}
+	QString str = d->od->lines[ LOGOFFSET(d->od->selEnd.line) ];
+	mousePos = e->pos();
+	d->od->selEnd.index = optimCharIndex( str, mousePos.x() );
+	if ( d->od->selEnd.line < d->od->selStart.line ) {
+	    qSwap( &d->od->selStart.line, &d->od->selEnd.line );
+	    qSwap( &d->od->selStart.index, &d->od->selEnd.index );
+	} else if ( d->od->selStart.line == d->od->selEnd.line &&
+		    d->od->selStart.index > d->od->selEnd.index ) {
+	    qSwap( &d->od->selStart.index, &d->od->selEnd.index );
+	}
+	oldMousePos = e->pos();
+	repaintContents( FALSE );
+    }
+    if ( mousePressed ) {
+	mousePressed = FALSE;
+	copyToClipboard();
+    }
+
+    inDoubleClick = FALSE;
+    emit copyAvailable( optimHasSelection() );
+    emit selectionChanged();
+}
+
+/*! \internal */
+void QTextEdit::optimMouseMoveEvent( QMouseEvent * e )
+{
+    mousePos = e->pos();
+    optimDoAutoScroll();
+    oldMousePos = mousePos;
+}
+
+/*! \internal */
+void QTextEdit::optimDoAutoScroll()
+{
+    if ( !mousePressed )
+	return;
+
+    QFontMetrics fm( QScrollView::font() );
+    QPoint pos( mapFromGlobal( QCursor::pos() ) );
+    bool doScroll = FALSE;
+    int xx = contentsX() + pos.x();
+    int yy = contentsY() + pos.y();
+
+    // find out how much we have to scroll in either dir.
+    if ( pos.x() < 0 || pos.x() > viewport()->width() ||
+	 pos.y() < 0 || pos.y() > viewport()->height() ) {
+	int my = yy;
+	if ( pos.x() < 0 )
+	    xx = contentsX() - fm.width( 'w');
+	else if ( pos.x() > viewport()->width() )
+	    xx = contentsX() + viewport()->width() + fm.width('w');
+
+	if ( pos.y() < 0 ) {
+	    my = contentsY() - 1;
+	    yy = (my / fm.lineSpacing()) * fm.lineSpacing() + 1;
+	} else if ( pos.y() > viewport()->height() ) {
+	    my = contentsY() + viewport()->height() + 1;
+	    yy = (my / fm.lineSpacing() + 1) * fm.lineSpacing() - 1;
+	}
+	d->od->selEnd.line = my / fm.lineSpacing();
+	mousePos.setX( xx );
+	mousePos.setY( my );
+	doScroll = TRUE;
+    } else {
+	d->od->selEnd.line = mousePos.y() / fm.lineSpacing();
+    }
+
+    if ( d->od->selEnd.line < 0 ) {
+	d->od->selEnd.line = 0;
+    } else if ( d->od->selEnd.line > d->od->numLines-1 ) {
+	d->od->selEnd.line = d->od->numLines-1;
+    }
+
+    QString str = d->od->lines[ LOGOFFSET(d->od->selEnd.line) ];
+    d->od->selEnd.index = optimCharIndex( str, mousePos.x() );
+
+    // have to have a valid index before generating a paint event
+    if ( doScroll )
+	ensureVisible( xx, yy, 1, 1 );
+
+    // if the text document is smaller than the heigth of the viewport
+    // - redraw the whole thing otherwise calculate the rect that
+    // needs drawing.
+    if ( d->od->numLines * fm.lineSpacing() < viewport()->height() ) {
+	repaintContents( contentsX(), contentsY(), width(), height(), FALSE );
+    } else {
+	int h = QABS(mousePos.y() - oldMousePos.y()) + fm.lineSpacing() * 2;
+	int y;
+	if ( oldMousePos.y() < mousePos.y() ) {
+	    y = oldMousePos.y() - fm.lineSpacing();
+	} else {
+	    // expand paint area for a fully selected line
+	    h += fm.lineSpacing();
+	    y = mousePos.y() - fm.lineSpacing()*2;
+	}
+	if ( y < 0 )
+	    y = 0;
+	repaintContents( contentsX(), y, width(), h, FALSE );
+    }
+
+    if ( !scrollTimer->isActive() && pos.y() < 0 || pos.y() > height() )
+	scrollTimer->start( 100, FALSE );
+    else if ( scrollTimer->isActive() && pos.y() >= 0 && pos.y() <= height() )
+	scrollTimer->stop();
+}
+
+/*! \internal
+
+  Returns the index of the character in the string \a str that is
+  currently under the mouse pointer.
+*/
+int QTextEdit::optimCharIndex( const QString &str, int mx ) const
+{
+    QFontMetrics fm(QScrollView::font());
+    uint i = 0;
+    int dd, dist = 10000000;
+    int curpos = 0;
+    int strWidth;
+    mx = mx - 4; // ### get the real margin from somewhere
+
+    if (!str.contains('\t') && mx > fm.width(str))
+	return str.length();
+
+    while (i < str.length()) {
+	strWidth = qStrWidth(str.left(i), tabStopWidth(), fm);
+	dd = strWidth - mx;
+	if (QABS(dd) <= dist) {
+	    dist = QABS(dd);
+	    if (mx >= strWidth)
+		curpos = i;
+	}
+	++i;
+    }
+    return curpos;
+}
+
+/*! \internal */
+void QTextEdit::optimSelectAll()
+{
+    d->od->selStart.line = d->od->selStart.index = 0;
+    d->od->selEnd.line = d->od->numLines - 1;
+    d->od->selEnd.index = d->od->lines[ LOGOFFSET(d->od->selEnd.line) ].length();
+
+    repaintContents( FALSE );
+    emit copyAvailable( optimHasSelection() );
+    emit selectionChanged();
+}
+
+/*! \internal */
+void QTextEdit::optimRemoveSelection()
+{
+    d->od->selStart.line = d->od->selEnd.line = -1;
+    d->od->selStart.index = d->od->selEnd.index = -1;
+    repaintContents( FALSE );
+}
+
+/*! \internal */
+void QTextEdit::optimSetSelection( int startLine, int startIdx,
+				       int endLine, int endIdx )
+{
+    d->od->selStart.line = startLine;
+    d->od->selEnd.line = endLine;
+    d->od->selStart.index = startIdx;
+    d->od->selEnd.index = endIdx;
+}
+
+/*! \internal */
+bool QTextEdit::optimHasSelection() const
+{
+    if ( d->od->selStart.line != d->od->selEnd.line ||
+	 d->od->selStart.index != d->od->selEnd.index )
+	return TRUE;
+    return FALSE;
+}
+
+/*! \internal */
+QString QTextEdit::optimSelectedText() const
+{
+    QString str;
+
+    if ( !optimHasSelection() )
+	return str;
+
+    // concatenate all strings
+    if ( d->od->selStart.line == d->od->selEnd.line ) {
+	str = d->od->lines[ LOGOFFSET(d->od->selEnd.line) ].mid( d->od->selStart.index,
+			   d->od->selEnd.index - d->od->selStart.index );
+    } else {
+	int i = d->od->selStart.line;
+	str = d->od->lines[ LOGOFFSET(i) ].right( d->od->lines[ LOGOFFSET(i) ].length() -
+				  d->od->selStart.index ) + "\n";
+	i++;
+	for ( ; i < d->od->selEnd.line; i++ ) {
+	    if ( d->od->lines[ LOGOFFSET(i) ].isEmpty() ) // CR lines are empty
+		str += "\n";
+	    else
+		str += d->od->lines[ LOGOFFSET(i) ] + "\n";
+	}
+	str += d->od->lines[ LOGOFFSET(d->od->selEnd.line) ].left( d->od->selEnd.index );
+    }
+    return str;
+}
+
+/*! \internal */
+bool QTextEdit::optimFind( const QString & expr, bool cs, bool /*wo*/,
+			       bool fw, int * para, int * index )
+{
+    bool found = FALSE;
+    int parag = para ? *para : d->od->search.line,
+	  idx = index ? *index : d->od->search.index, i;
+
+    if ( d->od->len == 0 )
+	return FALSE;
+
+    for ( i = parag; fw ? i < d->od->numLines : i >= 0; fw ? i++ : i-- ) {
+	idx = fw ? d->od->lines[ LOGOFFSET(i) ].find( expr, idx, cs ) :
+	      d->od->lines[ LOGOFFSET(i) ].findRev( expr, idx, cs );
+	if ( idx != -1 ) {
+	    found = TRUE;
+	    break;
+	} else if ( fw )
+	    idx = 0;
+    }
+
+    if ( found ) {
+	if ( index )
+	    *index = idx;
+	if ( para )
+	    *para = i;
+	d->od->search.index = idx + 1;
+	d->od->search.line = i;
+	optimSetSelection( i, idx, i, idx + expr.length() );
+	QFontMetrics fm( QScrollView::font() );
+	int h = fm.lineSpacing();
+	int x = fm.width( d->od->lines[ LOGOFFSET(i) ].left( idx + expr.length()) ) + 4;
+	ensureVisible( x, i * h + h / 2, 1, h / 2 + 2 );
+	repaintContents(); // could possibly be optimized
+    }
+    return found;
+}
+
+/*! \reimp */
+void QTextEdit::polish()
+{
+    // this will ensure that the last line is visible if text have
+    // been added to the widget before it is shown
+    if ( d->optimMode )
+	scrollToBottom();
+    QWidget::polish();
+}
+
+/*!
+    Sets the maximum number of lines a QTextEdit can hold in \c
+    LogText mode to \a limit. If \a limit is -1 (the default), this
+    signifies an unlimited number of lines.
+
+    \warning Never use formatting tags that span more than one line
+    when the maximum log lines is set. When lines are removed from the
+    top of the buffer it could result in an unbalanced tag pair, i.e.
+    the left formatting tag is removed before the right one.
+ */
+void QTextEdit::setMaxLogLines( int limit )
+{
+    d->maxLogLines = limit;
+    if ( d->maxLogLines < -1 )
+	d->maxLogLines = -1;
+    if ( d->maxLogLines == -1 )
+	d->logOffset = 0;
+}
+
+/*!
+    Returns the maximum number of lines QTextEdit can hold in \c
+    LogText mode. By default the number of lines is unlimited, which
+    is signified by a value of -1.
+ */
+int QTextEdit::maxLogLines()
+{
+    return d->maxLogLines;
+}
+
+/*!
+    Check if the number of lines in the buffer is limited, and uphold
+    that limit when appending new lines.
+ */
+void QTextEdit::optimCheckLimit( const QString& str )
+{
+    if ( d->maxLogLines > -1 && d->maxLogLines <= d->od->numLines ) {
+	// NB! Removing the top line in the buffer will potentially
+	// destroy the structure holding the formatting tags - if line
+	// spanning tags are used.
+	QTextEditOptimPrivate::Tag *t = d->od->tags, *tmp, *itr;
+	QPtrList<QTextEditOptimPrivate::Tag> lst;
+	while ( t ) {
+	    t->line -= 1;
+	    // unhook the ptr from the tag structure
+	    if ( ((uint) LOGOFFSET(t->line) < (uint) d->logOffset &&
+		  (uint) LOGOFFSET(t->line) < (uint) LOGOFFSET(d->od->numLines) &&
+		  (uint) LOGOFFSET(d->od->numLines) > (uint) d->logOffset) )
+	    {
+		if ( t->prev )
+		    t->prev->next = t->next;
+		if ( t->next )
+		    t->next->prev = t->prev;
+		if ( d->od->tags == t )
+		    d->od->tags = t->next;
+		if ( d->od->lastTag == t ) {
+		    if ( t->prev )
+			d->od->lastTag = t->prev;
+		    else
+			d->od->lastTag = d->od->tags;
+		}
+		tmp = t;
+		t = t->next;
+		lst.append( tmp );
+		delete tmp;
+	    } else {
+		t = t->next;
+	    }
+	}
+	// Remove all references to the ptrs we just deleted
+	itr = d->od->tags;
+	while ( itr ){
+	    for ( tmp = lst.first(); tmp; tmp = lst.next() ) {
+		if ( itr->parent == tmp )
+		    itr->parent = 0;
+		if ( itr->leftTag == tmp )
+		    itr->leftTag = 0;
+	    }
+	    itr = itr->next;
+	}
+	// ...in the tag index as well
+	QMapIterator<int, QTextEditOptimPrivate::Tag *> idx;
+	if ( (idx = d->od->tagIndex.find( d->logOffset )) != d->od->tagIndex.end() )
+	    d->od->tagIndex.remove( idx );
+
+	QMapIterator<int,QString> it;
+	if ( (it = d->od->lines.find( d->logOffset )) != d->od->lines.end() ) {
+	    d->od->len -= (*it).length();
+	    d->od->lines.remove( it );
+	    d->od->numLines--;
+	    d->logOffset = LOGOFFSET(1);
+	}
+    }
+    d->od->len += str.length();
+    d->od->lines[ LOGOFFSET(d->od->numLines++) ] = str;
+}
+
+#endif // QT_TEXTEDIT_OPTIMIZATION
+
+/*!
+    \property QTextEdit::autoFormatting
+    \brief the enabled set of auto formatting features
+
+    The value can be any combination of the values in the \c
+    AutoFormatting enum.  The default is \c AutoAll. Choose \c AutoNone
+    to disable all automatic formatting.
+
+    Currently, the only automatic formatting feature provided is \c
+    AutoBulletList; future versions of Qt may offer more.
+*/
+
+void QTextEdit::setAutoFormatting( uint features )
+{
+    d->autoFormatting = features;
+}
+
+uint QTextEdit::autoFormatting() const
+{
+    return d->autoFormatting;
+}
+
+/*!
+    Returns the QSyntaxHighlighter set on this QTextEdit. 0 is
+    returned if no syntax highlighter is set.
+ */
+QSyntaxHighlighter * QTextEdit::syntaxHighlighter() const
+{
+    if (document()->preProcessor())
+	return ((QSyntaxHighlighterInternal *) document()->preProcessor())->highlighter;
+    else
+	return 0;
+}
+
+#endif //QT_NO_TEXTEDIT
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qtextedit.h qt-x11-free-3.3.8b/src/widgets/qtextedit.h
--- qt-x11-free-3.3.8b/src/widgets/qtextedit.h	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qtextedit.h	2009-10-18 14:38:39.375200628 -0700
@@ -215,5 +215,7 @@
 	RedoIndentation = 0x0001,
 	CheckNewLines = 0x0002,
-	RemoveSelected = 0x0004
+	RemoveSelected = 0x0004,
+	AsIMCompositionText = 0x0008,  // internal use
+	WithIMSelection = 0x0010       // internal use
     };
 
@@ -443,4 +445,5 @@
 #endif
     void contentsContextMenuEvent( QContextMenuEvent *e );
+    bool sendMouseEventToInputContext( QMouseEvent *e );
     bool focusNextPrevChild( bool next );
     QTextDocument *document() const;
diff -r -U2 -N qt-x11-free-3.3.8b/src/widgets/qtextedit.h.orig qt-x11-free-3.3.8b/src/widgets/qtextedit.h.orig
--- qt-x11-free-3.3.8b/src/widgets/qtextedit.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/src/widgets/qtextedit.h.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,613 @@
+/****************************************************************************
+**
+** Definition of the QTextEdit class
+**
+** Created : 990101
+**
+** Copyright (C) 1992-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** This file may be used under the terms of the Q Public License as
+** defined by Trolltech ASA and appearing in the file LICENSE.QPL
+** included in the packaging of this file.  Licensees holding valid Qt
+** Commercial licenses may use this file in accordance with the Qt
+** Commercial License Agreement provided with the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef QTEXTEDIT_H
+#define QTEXTEDIT_H
+
+#ifndef QT_H
+#include "qscrollview.h"
+#include "qstylesheet.h"
+#include "qptrvector.h"
+#include "qvaluelist.h"
+#include "qptrlist.h"
+#endif // QT_H
+
+#ifndef QT_NO_TEXTEDIT
+// uncomment below to enable optimization mode - also uncomment the
+// optimDoAutoScroll() private slot since moc ignores #ifdefs..
+#define QT_TEXTEDIT_OPTIMIZATION
+
+class QPainter;
+class QTextDocument;
+class QTextCursor;
+class QKeyEvent;
+class QResizeEvent;
+class QMouseEvent;
+class QTimer;
+class QTextString;
+class QTextCommand;
+class QTextParagraph;
+class QTextFormat;
+class QFont;
+class QColor;
+class QTextEdit;
+class QTextBrowser;
+class QTextString;
+struct QUndoRedoInfoPrivate;
+class QPopupMenu;
+class QTextEditPrivate;
+class QSyntaxHighlighter;
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+class QTextEditOptimPrivate
+{
+public:
+    // Note: no left-tag has any value for leftTag or parent, and
+    // no right-tag has any formatting flags set.
+    enum TagType { Color = 0, Format = 1 };
+    struct Tag {
+	TagType type:2;
+	bool bold:1;
+	bool italic:1;
+	bool underline:1;
+	int line;
+	int index;
+	Tag * leftTag; // ptr to left-tag in a left-right tag pair
+	Tag * parent;  // ptr to parent left-tag in a nested tag
+	Tag * prev;
+	Tag * next;
+	QString tag;
+    };
+    QTextEditOptimPrivate()
+    {
+	len = numLines = maxLineWidth = 0;
+	selStart.line = selStart.index = -1;
+	selEnd.line = selEnd.index = -1;
+	search.line = search.index = 0;
+	tags = lastTag = 0;
+    }
+    void clearTags()
+    {
+	Tag * itr = tags;
+	while ( tags ) {
+	    itr  = tags;
+	    tags = tags->next;
+	    delete itr;
+	}
+	tags = lastTag = 0;
+	tagIndex.clear();
+    }
+    ~QTextEditOptimPrivate()
+    {
+	clearTags();
+    }
+    int len;
+    int numLines;
+    int maxLineWidth;
+    struct Selection {
+	int line;
+	int index;
+    };
+    Selection selStart, selEnd, search;
+    Tag * tags, * lastTag;
+    QMap<int, QString> lines;
+    QMap<int, Tag *> tagIndex;
+};
+#endif
+
+class Q_EXPORT QTextEdit : public QScrollView
+{
+    friend class QTextBrowser;
+    friend class QSyntaxHighlighter;
+
+    Q_OBJECT
+    Q_ENUMS( WordWrap WrapPolicy )
+    Q_SETS( AutoFormatting )
+    Q_PROPERTY( TextFormat textFormat READ textFormat WRITE setTextFormat )
+    Q_PROPERTY( QString text READ text WRITE setText )
+    Q_PROPERTY( QBrush paper READ paper WRITE setPaper )
+    Q_PROPERTY( bool linkUnderline READ linkUnderline WRITE setLinkUnderline )
+    Q_PROPERTY( QString documentTitle READ documentTitle )
+    Q_PROPERTY( int length READ length )
+    Q_PROPERTY( WordWrap wordWrap READ wordWrap WRITE setWordWrap )
+    Q_PROPERTY( int wrapColumnOrWidth READ wrapColumnOrWidth WRITE setWrapColumnOrWidth )
+    Q_PROPERTY( WrapPolicy wrapPolicy READ wrapPolicy WRITE setWrapPolicy )
+    Q_PROPERTY( bool hasSelectedText READ hasSelectedText )
+    Q_PROPERTY( QString selectedText READ selectedText )
+    Q_PROPERTY( int undoDepth READ undoDepth WRITE setUndoDepth )
+    Q_PROPERTY( bool overwriteMode READ isOverwriteMode WRITE setOverwriteMode )
+    Q_PROPERTY( bool modified READ isModified WRITE setModified DESIGNABLE false )
+    Q_PROPERTY( bool readOnly READ isReadOnly WRITE setReadOnly )
+    Q_PROPERTY( bool undoRedoEnabled READ isUndoRedoEnabled WRITE setUndoRedoEnabled )
+    Q_PROPERTY( int tabStopWidth READ tabStopWidth WRITE setTabStopWidth )
+    Q_PROPERTY( bool tabChangesFocus READ tabChangesFocus WRITE setTabChangesFocus )
+    Q_PROPERTY( AutoFormatting autoFormatting READ autoFormatting WRITE setAutoFormatting )
+
+public:
+    enum WordWrap {
+	NoWrap,
+	WidgetWidth,
+	FixedPixelWidth,
+	FixedColumnWidth
+    };
+
+    enum WrapPolicy {
+	AtWordBoundary,
+	AtWhiteSpace = AtWordBoundary, // AtWhiteSpace is deprecated
+	Anywhere,
+	AtWordOrDocumentBoundary
+    };
+
+    enum AutoFormatting {
+	AutoNone = 0,
+	AutoBulletList = 0x00000001,
+	AutoAll = 0xffffffff
+    };
+
+    enum KeyboardAction {
+	ActionBackspace,
+	ActionDelete,
+	ActionReturn,
+	ActionKill,
+	ActionWordBackspace,
+	ActionWordDelete
+    };
+
+    enum CursorAction {
+	MoveBackward,
+	MoveForward,
+	MoveWordBackward,
+	MoveWordForward,
+	MoveUp,
+	MoveDown,
+	MoveLineStart,
+	MoveLineEnd,
+	MoveHome,
+	MoveEnd,
+	MovePgUp,
+	MovePgDown
+    };
+
+    enum VerticalAlignment {
+	AlignNormal,
+	AlignSuperScript,
+	AlignSubScript
+    };
+
+    enum TextInsertionFlags {
+	RedoIndentation = 0x0001,
+	CheckNewLines = 0x0002,
+	RemoveSelected = 0x0004
+    };
+
+    QTextEdit( const QString& text, const QString& context = QString::null,
+	       QWidget* parent=0, const char* name=0);
+    QTextEdit( QWidget* parent=0, const char* name=0 );
+    virtual ~QTextEdit();
+    void setPalette( const QPalette & );
+
+    QString text() const;
+    QString text( int para ) const;
+    TextFormat textFormat() const;
+    QString context() const;
+    QString documentTitle() const;
+
+    void getSelection( int *paraFrom, int *indexFrom,
+		    int *paraTo, int *indexTo, int selNum = 0 ) const;
+    virtual bool find( const QString &expr, bool cs, bool wo, bool forward = TRUE,
+		       int *para = 0, int *index = 0 );
+
+    int paragraphs() const;
+    int lines() const;
+    int linesOfParagraph( int para ) const;
+    int lineOfChar( int para, int chr );
+    int length() const;
+    QRect paragraphRect( int para ) const;
+    int paragraphAt( const QPoint &pos ) const;
+    int charAt( const QPoint &pos, int *para ) const;
+    int paragraphLength( int para ) const;
+
+    QStyleSheet* styleSheet() const;
+#ifndef QT_NO_MIME
+    QMimeSourceFactory* mimeSourceFactory() const;
+#endif
+    QBrush paper() const;
+    bool linkUnderline() const;
+
+    int heightForWidth( int w ) const;
+
+    bool hasSelectedText() const;
+    QString selectedText() const;
+    bool isUndoAvailable() const;
+    bool isRedoAvailable() const;
+
+    WordWrap wordWrap() const;
+    int wrapColumnOrWidth() const;
+    WrapPolicy wrapPolicy() const;
+
+    int tabStopWidth() const;
+
+    QString anchorAt( const QPoint& pos );
+    QString anchorAt( const QPoint& pos, AnchorAttribute a );
+
+    QSize sizeHint() const;
+
+    bool isReadOnly() const { return readonly; }
+
+    void getCursorPosition( int *parag, int *index ) const;
+
+    bool isModified() const;
+    bool italic() const;
+    bool bold() const;
+    bool underline() const;
+    QString family() const;
+    int pointSize() const;
+    QColor color() const;
+    QFont font() const;
+    QFont currentFont() const;
+    int alignment() const;
+    int undoDepth() const;
+
+    // do not use, will go away
+    virtual bool getFormat( int para, int index, QFont *font, QColor *color, VerticalAlignment *verticalAlignment );
+    // do not use, will go away
+    virtual bool getParagraphFormat( int para, QFont *font, QColor *color,
+				     VerticalAlignment *verticalAlignment, int *alignment,
+				     QStyleSheetItem::DisplayMode *displayMode,
+				     QStyleSheetItem::ListStyle *listStyle,
+				     int *listDepth );
+
+
+    bool isOverwriteMode() const { return overWrite; }
+    QColor paragraphBackgroundColor( int para ) const;
+
+    bool isUndoRedoEnabled() const;
+    bool eventFilter( QObject *o, QEvent *e );
+    bool tabChangesFocus() const;
+
+    void setAutoFormatting( uint features );
+    uint autoFormatting() const;
+    QSyntaxHighlighter *syntaxHighlighter() const;
+
+public slots:
+    void setEnabled( bool );
+#ifndef QT_NO_MIME
+    virtual void setMimeSourceFactory( QMimeSourceFactory* factory );
+#endif
+    virtual void setStyleSheet( QStyleSheet* styleSheet );
+    virtual void scrollToAnchor( const QString& name );
+    virtual void setPaper( const QBrush& pap );
+    virtual void setLinkUnderline( bool );
+
+    virtual void setWordWrap( WordWrap mode );
+    virtual void setWrapColumnOrWidth( int );
+    virtual void setWrapPolicy( WrapPolicy policy );
+
+    virtual void copy();
+    virtual void append( const QString& text );
+
+    void setText( const QString &txt ) { setText( txt, QString::null ); }
+    virtual void setText( const QString &txt, const QString &context );
+    virtual void setTextFormat( TextFormat f );
+
+    virtual void selectAll( bool select = TRUE );
+    virtual void setTabStopWidth( int ts );
+    virtual void zoomIn( int range );
+    virtual void zoomIn() { zoomIn( 1 ); }
+    virtual void zoomOut( int range );
+    virtual void zoomOut() { zoomOut( 1 ); }
+    virtual void zoomTo( int size );
+
+    virtual void sync();
+    virtual void setReadOnly( bool b );
+
+    virtual void undo();
+    virtual void redo();
+    virtual void cut();
+    virtual void paste();
+#ifndef QT_NO_CLIPBOARD
+    virtual void pasteSubType( const QCString &subtype );
+#endif
+    virtual void clear();
+    virtual void del();
+    virtual void indent();
+    virtual void setItalic( bool b );
+    virtual void setBold( bool b );
+    virtual void setUnderline( bool b );
+    virtual void setFamily( const QString &f );
+    virtual void setPointSize( int s );
+    virtual void setColor( const QColor &c );
+    virtual void setFont( const QFont &f );
+    virtual void setVerticalAlignment( VerticalAlignment a );
+    virtual void setAlignment( int a );
+
+    // do not use, will go away
+    virtual void setParagType( QStyleSheetItem::DisplayMode dm, QStyleSheetItem::ListStyle listStyle );
+
+    virtual void setCursorPosition( int parag, int index );
+    virtual void setSelection( int parag_from, int index_from, int parag_to, int index_to, int selNum = 0 );
+    virtual void setSelectionAttributes( int selNum, const QColor &back, bool invertText );
+    virtual void setModified( bool m );
+    virtual void resetFormat();
+    virtual void setUndoDepth( int d );
+    virtual void setFormat( QTextFormat *f, int flags );
+    virtual void ensureCursorVisible();
+    virtual void placeCursor( const QPoint &pos, QTextCursor *c = 0 );
+    virtual void moveCursor( CursorAction action, bool select );
+    virtual void doKeyboardAction( KeyboardAction action );
+    virtual void removeSelectedText( int selNum = 0 );
+    virtual void removeSelection( int selNum = 0 );
+    virtual void setCurrentFont( const QFont &f );
+    virtual void setOverwriteMode( bool b ) { overWrite = b; }
+
+    virtual void scrollToBottom();
+
+    void insert( const QString &text, uint insertionFlags = CheckNewLines | RemoveSelected ); // ## virtual in 4.0
+
+    // obsolete
+    virtual void insert( const QString &text, bool, bool = TRUE, bool = TRUE );
+
+    virtual void insertAt( const QString &text, int para, int index );
+    virtual void removeParagraph( int para );
+    virtual void insertParagraph( const QString &text, int para );
+
+    virtual void setParagraphBackgroundColor( int para, const QColor &bg );
+    virtual void clearParagraphBackground( int para );
+
+    virtual void setUndoRedoEnabled( bool b );
+    void setTabChangesFocus( bool b ); // ### make virtual in 4.0
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    void polish();
+    void setMaxLogLines( int numLines );
+    int maxLogLines();
+#endif
+
+signals:
+    void textChanged();
+    void selectionChanged();
+    void copyAvailable( bool );
+    void undoAvailable( bool yes );
+    void redoAvailable( bool yes );
+    void currentFontChanged( const QFont &f );
+    void currentColorChanged( const QColor &c );
+    void currentAlignmentChanged( int a );
+    void currentVerticalAlignmentChanged( VerticalAlignment a );
+    void cursorPositionChanged( QTextCursor *c );
+    void cursorPositionChanged( int para, int pos );
+    void returnPressed();
+    void modificationChanged( bool m );
+    void clicked( int parag, int index );
+    void doubleClicked( int parag, int index );
+
+protected:
+    void repaintChanged();
+    void updateStyles();
+    void drawContents( QPainter *p, int cx, int cy, int cw, int ch );
+    bool event( QEvent *e );
+    void keyPressEvent( QKeyEvent *e );
+    void resizeEvent( QResizeEvent *e );
+    void viewportResizeEvent( QResizeEvent* );
+    void contentsMousePressEvent( QMouseEvent *e );
+    void contentsMouseMoveEvent( QMouseEvent *e );
+    void contentsMouseReleaseEvent( QMouseEvent *e );
+    void contentsMouseDoubleClickEvent( QMouseEvent *e );
+#ifndef QT_NO_WHEELEVENT
+    void contentsWheelEvent( QWheelEvent *e );
+#endif
+    void imStartEvent( QIMEvent * );
+    void imComposeEvent( QIMEvent * );
+    void imEndEvent( QIMEvent * );
+#ifndef QT_NO_DRAGANDDROP
+    void contentsDragEnterEvent( QDragEnterEvent *e );
+    void contentsDragMoveEvent( QDragMoveEvent *e );
+    void contentsDragLeaveEvent( QDragLeaveEvent *e );
+    void contentsDropEvent( QDropEvent *e );
+#endif
+    void contentsContextMenuEvent( QContextMenuEvent *e );
+    bool focusNextPrevChild( bool next );
+    QTextDocument *document() const;
+    QTextCursor *textCursor() const;
+    void setDocument( QTextDocument *doc );
+    virtual QPopupMenu *createPopupMenu( const QPoint& pos );
+    virtual QPopupMenu *createPopupMenu();
+    void drawCursor( bool visible );
+
+    void windowActivationChange( bool );
+
+protected slots:
+    virtual void doChangeInterval();
+    void sliderReleased(); // ### make virtual in 4.0
+#if (QT_VERSION >= 0x040000)
+#error "Some functions need to be changed to virtual for Qt 4.0"
+#endif
+
+private slots:
+    void formatMore();
+    void doResize();
+    void autoScrollTimerDone();
+    void blinkCursor();
+    void setModified();
+    void startDrag();
+    void documentWidthChanged( int w );
+    void clipboardChanged();
+
+private:
+    struct Q_EXPORT UndoRedoInfo {
+	enum Type { Invalid, Insert, Delete, Backspace, Return, RemoveSelected, Format, Style, IME };
+
+	UndoRedoInfo( QTextDocument *dc );
+	~UndoRedoInfo();
+	void clear();
+	bool valid() const;
+
+	QUndoRedoInfoPrivate *d;
+	int id;
+	int index;
+	int eid;
+	int eindex;
+	QTextFormat *format;
+	int flags;
+	Type type;
+	QTextDocument *doc;
+	QByteArray styleInformation;
+    };
+
+private:
+    void updateCursor( const QPoint & pos );
+    void handleMouseMove( const QPoint& pos );
+    void drawContents( QPainter * );
+    virtual bool linksEnabled() const { return FALSE; }
+    void init();
+    void checkUndoRedoInfo( UndoRedoInfo::Type t );
+    void updateCurrentFormat();
+    bool handleReadOnlyKeyEvent( QKeyEvent *e );
+    void makeParagVisible( QTextParagraph *p );
+    void normalCopy();
+    void copyToClipboard();
+#ifndef QT_NO_MIME
+    QCString pickSpecial(QMimeSource* ms, bool always_ask, const QPoint&);
+    QTextDrag *dragObject( QWidget *parent = 0 ) const;
+#endif
+#ifndef QT_NO_MIMECLIPBOARD
+    void pasteSpecial(const QPoint&);
+#endif
+    void setFontInternal( const QFont &f );
+
+    virtual void emitHighlighted( const QString & ) {}
+    virtual void emitLinkClicked( const QString & ) {}
+
+    void readFormats( QTextCursor &c1, QTextCursor &c2, QTextString &text, bool fillStyles = FALSE );
+    void clearUndoRedo();
+    void paintDocument( bool drawAll, QPainter *p, int cx = -1, int cy = -1, int cw = -1, int ch = -1 );
+    void moveCursor( CursorAction action );
+    void ensureFormatted( QTextParagraph *p );
+    void placeCursor( const QPoint &pos, QTextCursor *c, bool link );
+    void updateMicroFocusHint();
+
+#ifdef QT_TEXTEDIT_OPTIMIZATION
+    bool checkOptimMode();
+    QString optimText() const;
+    void optimSetText( const QString &str );
+    void optimAppend( const QString &str );
+    void optimInsert( const QString &str, int line, int index );
+    void optimDrawContents( QPainter * p, int cx, int cy, int cw, int ch );
+    void optimMousePressEvent( QMouseEvent * e );
+    void optimMouseReleaseEvent( QMouseEvent * e );
+    void optimMouseMoveEvent( QMouseEvent * e );
+    int  optimCharIndex( const QString &str, int mx ) const;
+    void optimSelectAll();
+    void optimRemoveSelection();
+    void optimSetSelection( int startLine, int startIdx, int endLine,
+			    int endIdx );
+    bool optimHasSelection() const;
+    QString optimSelectedText() const;
+    bool optimFind( const QString & str, bool, bool, bool, int *, int * );
+    void optimParseTags( QString * str, int lineNo = -1, int indexOffset = 0 );
+    QTextEditOptimPrivate::Tag * optimPreviousLeftTag( int line );
+    void optimSetTextFormat( QTextDocument *, QTextCursor *, QTextFormat * f,
+			     int, int, QTextEditOptimPrivate::Tag * t );
+    QTextEditOptimPrivate::Tag * optimAppendTag( int index, const QString & tag );
+    QTextEditOptimPrivate::Tag * optimInsertTag( int line, int index, const QString & tag );
+    void optimCheckLimit( const QString& str );
+    bool optimHasBoldMetrics( int line );
+
+private slots:
+    void optimDoAutoScroll();
+#endif // QT_TEXTEDIT_OPTIMIZATION
+
+private:
+#ifndef QT_NO_CLIPBOARD
+    void pasteSubType( const QCString &subtype, QMimeSource *m );
+#endif
+
+private:
+    QTextDocument *doc;
+    QTextCursor *cursor;
+    QTimer *formatTimer, *scrollTimer, *changeIntervalTimer, *blinkTimer, *dragStartTimer;
+    QTextParagraph *lastFormatted;
+    int interval;
+    UndoRedoInfo undoRedoInfo;
+    QTextFormat *currentFormat;
+    int currentAlignment;
+    QPoint oldMousePos, mousePos;
+    QPoint dragStartPos;
+    QString onLink;
+    WordWrap wrapMode;
+    WrapPolicy wPolicy;
+    int wrapWidth;
+    QString pressedLink;
+    QTextEditPrivate *d;
+    bool inDoubleClick : 1;
+    bool mousePressed : 1;
+    bool cursorVisible : 1;
+    bool blinkCursorVisible : 1;
+    bool readOnly : 1;
+    bool modified : 1;
+    bool mightStartDrag : 1;
+    bool inDnD : 1;
+    bool readonly : 1;
+    bool undoEnabled : 1;
+    bool overWrite : 1;
+
+private:	// Disabled copy constructor and operator=
+#if defined(Q_DISABLE_COPY)
+    QTextEdit( const QTextEdit & );
+    QTextEdit &operator=( const QTextEdit & );
+#endif
+};
+
+inline QTextDocument *QTextEdit::document() const
+{
+    return doc;
+}
+
+inline QTextCursor *QTextEdit::textCursor() const
+{
+    return cursor;
+}
+
+inline void QTextEdit::setCurrentFont( const QFont &f )
+{
+    QTextEdit::setFontInternal( f );
+}
+
+#endif //QT_NO_TEXTEDIT
+#endif //QTEXTVIEW_H
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui	2009-10-18 14:38:39.388537727 -0700
@@ -1030,4 +1030,17 @@
                         </property>
                     </widget>
+                    <widget class="QLabel">
+                        <property name="name">
+                            <cstring>inputMethodLabel</cstring>
+                        </property>
+                        <property name="text">
+                            <string>Default Input Method:</string>
+                        </property>
+                    </widget>
+                    <widget class="QComboBox">
+                        <property name="name">
+                            <cstring>inputMethodCombo</cstring>
+                        </property>
+                    </widget>
                     <spacer>
                         <property name="name">
@@ -1043,5 +1056,5 @@
                             <size>
                                 <width>20</width>
-                                <height>40</height>
+                                <height>30</height>
                             </size>
                         </property>
@@ -1719,4 +1732,10 @@
     </connection>
     <connection>
+        <sender>inputMethodCombo</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
         <sender>gstylecombo</sender>
         <signal>activated(const QString&amp;)</signal>
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui.orig qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui.orig
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindowbase.ui.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,1827 @@
+<!DOCTYPE UI><UI version="3.2" stdsetdef="1">
+<class>MainWindowBase</class>
+<comment>********************************************************************* 
+** Copyright (C) 2000-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of Qt Configuration.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with
+** the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+*********************************************************************</comment>
+<widget class="QMainWindow">
+    <property name="name">
+        <cstring>MainWindowBase</cstring>
+    </property>
+    <property name="geometry">
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>700</width>
+            <height>600</height>
+        </rect>
+    </property>
+    <property name="caption">
+        <string>Qt Configuration</string>
+    </property>
+    <property name="icon">
+        <pixmap>appicon.png</pixmap>
+    </property>
+    <hbox>
+        <property name="name">
+            <cstring>unnamed</cstring>
+        </property>
+        <property name="margin">
+            <number>8</number>
+        </property>
+        <property name="spacing">
+            <number>4</number>
+        </property>
+        <widget class="QTextView">
+            <property name="name">
+                <cstring>helpview</cstring>
+            </property>
+            <property name="minimumSize">
+                <size>
+                    <width>200</width>
+                    <height>0</height>
+                </size>
+            </property>
+            <property name="text">
+                <string>&lt;p align=center&gt;&lt;b&gt;Documentation&lt;/b&gt;&lt;/p&gt;
+&lt;p&gt;This QTextView will display a brief explanation about the current page, so that the user isn't confused about the settings he/she is twiddling.&lt;/p&gt;</string>
+            </property>
+        </widget>
+        <widget class="QTabWidget">
+            <property name="name">
+                <cstring>TabWidget3</cstring>
+            </property>
+            <widget class="QWidget">
+                <property name="name">
+                    <cstring>tab</cstring>
+                </property>
+                <attribute name="title">
+                    <string>Appearance</string>
+                </attribute>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>4</number>
+                    </property>
+                    <property name="spacing">
+                        <number>4</number>
+                    </property>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox40</cstring>
+                        </property>
+                        <property name="title">
+                            <string>GUI Style</string>
+                        </property>
+                        <hbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>gstylebuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Select GUI &amp;Style:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>gstylecombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QComboBox">
+                                <property name="name">
+                                    <cstring>gstylecombo</cstring>
+                                </property>
+                            </widget>
+                        </hbox>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>groupAutoPalette</cstring>
+                        </property>
+                        <property name="sizePolicy">
+                            <sizepolicy>
+                                <hsizetype>5</hsizetype>
+                                <vsizetype>4</vsizetype>
+                                <horstretch>0</horstretch>
+                                <verstretch>0</verstretch>
+                            </sizepolicy>
+                        </property>
+                        <property name="title">
+                            <string>Build Palette</string>
+                        </property>
+                        <property name="alignment">
+                            <set>AlignAuto</set>
+                        </property>
+                        <hbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>labelMainColor</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;3-D Effects:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>buttonMainColor</cstring>
+                                </property>
+                            </widget>
+                            <widget class="ColorButton">
+                                <property name="name">
+                                    <cstring>buttonMainColor</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>labelMainColor2</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>1</hsizetype>
+                                        <vsizetype>1</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                                <property name="minimumSize">
+                                    <size>
+                                        <width>50</width>
+                                        <height>0</height>
+                                    </size>
+                                </property>
+                                <property name="lineWidth">
+                                    <number>1</number>
+                                </property>
+                                <property name="margin">
+                                    <number>0</number>
+                                </property>
+                                <property name="midLineWidth">
+                                    <number>0</number>
+                                </property>
+                                <property name="text">
+                                    <string>Back&amp;ground:</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>AlignVCenter</set>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>buttonMainColor2</cstring>
+                                </property>
+                            </widget>
+                            <widget class="ColorButton">
+                                <property name="name">
+                                    <cstring>buttonMainColor2</cstring>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>Spacer1</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Horizontal</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Expanding</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>70</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                            <widget class="QPushButton">
+                                <property name="name">
+                                    <cstring>btnAdvanced</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Tune Palette...</string>
+                                </property>
+                            </widget>
+                        </hbox>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox126</cstring>
+                        </property>
+                        <property name="sizePolicy">
+                            <sizepolicy>
+                                <hsizetype>5</hsizetype>
+                                <vsizetype>7</vsizetype>
+                                <horstretch>0</horstretch>
+                                <verstretch>0</verstretch>
+                            </sizepolicy>
+                        </property>
+                        <property name="title">
+                            <string>Preview</string>
+                        </property>
+                        <grid>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLabel" row="0" column="0">
+                                <property name="name">
+                                    <cstring>TextLabel1</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Select &amp;Palette:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>paletteCombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QComboBox" row="0" column="1">
+                                <item>
+                                    <property name="text">
+                                        <string>Active Palette</string>
+                                    </property>
+                                </item>
+                                <item>
+                                    <property name="text">
+                                        <string>Inactive Palette</string>
+                                    </property>
+                                </item>
+                                <item>
+                                    <property name="text">
+                                        <string>Disabled Palette</string>
+                                    </property>
+                                </item>
+                                <property name="name">
+                                    <cstring>paletteCombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="PreviewFrame" row="1" column="0" rowspan="1" colspan="2">
+                                <property name="name">
+                                    <cstring>previewFrame</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>7</hsizetype>
+                                        <vsizetype>7</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                                <property name="minimumSize">
+                                    <size>
+                                        <width>410</width>
+                                        <height>260</height>
+                                    </size>
+                                </property>
+                            </widget>
+                        </grid>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QWidget">
+                <property name="name">
+                    <cstring>tab</cstring>
+                </property>
+                <attribute name="title">
+                    <string>Fonts</string>
+                </attribute>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>8</number>
+                    </property>
+                    <property name="spacing">
+                        <number>4</number>
+                    </property>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox1</cstring>
+                        </property>
+                        <property name="title">
+                            <string>Default Font</string>
+                        </property>
+                        <grid>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QComboBox" row="1" column="1">
+                                <property name="name">
+                                    <cstring>stylecombo</cstring>
+                                </property>
+                                <property name="autoCompletion">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="duplicatesEnabled">
+                                    <bool>false</bool>
+                                </property>
+                            </widget>
+                            <widget class="QComboBox" row="0" column="1">
+                                <property name="name">
+                                    <cstring>familycombo</cstring>
+                                </property>
+                                <property name="autoCompletion">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="duplicatesEnabled">
+                                    <bool>false</bool>
+                                </property>
+                            </widget>
+                            <widget class="QComboBox" row="2" column="1">
+                                <property name="name">
+                                    <cstring>psizecombo</cstring>
+                                </property>
+                                <property name="editable">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="autoCompletion">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="duplicatesEnabled">
+                                    <bool>false</bool>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="1" column="0">
+                                <property name="name">
+                                    <cstring>stylebuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Style:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>stylecombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="2" column="0">
+                                <property name="name">
+                                    <cstring>psizebuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Point Size:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>psizecombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="0" column="0">
+                                <property name="name">
+                                    <cstring>familybuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>F&amp;amily:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>familycombo</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLineEdit" row="3" column="0" rowspan="1" colspan="2">
+                                <property name="name">
+                                    <cstring>samplelineedit</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Sample Text</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>AlignHCenter</set>
+                                </property>
+                            </widget>
+                        </grid>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox2</cstring>
+                        </property>
+                        <property name="frameShape">
+                            <enum>Box</enum>
+                        </property>
+                        <property name="frameShadow">
+                            <enum>Sunken</enum>
+                        </property>
+                        <property name="title">
+                            <string>Font Substitution</string>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout2</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>famsubbuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>S&amp;elect or Enter a Family:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>familysubcombo</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox">
+                                        <property name="name">
+                                            <cstring>familysubcombo</cstring>
+                                        </property>
+                                        <property name="editable">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="autoCompletion">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="duplicatesEnabled">
+                                            <bool>false</bool>
+                                        </property>
+                                    </widget>
+                                </hbox>
+                            </widget>
+                            <widget class="Line">
+                                <property name="name">
+                                    <cstring>Line1</cstring>
+                                </property>
+                                <property name="frameShape">
+                                    <enum>HLine</enum>
+                                </property>
+                                <property name="frameShadow">
+                                    <enum>Sunken</enum>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Horizontal</enum>
+                                </property>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>TextLabel5</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Current Substitutions:</string>
+                                </property>
+                            </widget>
+                            <widget class="QListBox">
+                                <property name="name">
+                                    <cstring>sublistbox</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout3</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QPushButton">
+                                        <property name="name">
+                                            <cstring>PushButton2</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Up</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton">
+                                        <property name="name">
+                                            <cstring>PushButton3</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Down</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton">
+                                        <property name="name">
+                                            <cstring>PushButton4</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Remove</string>
+                                        </property>
+                                    </widget>
+                                </hbox>
+                            </widget>
+                            <widget class="Line">
+                                <property name="name">
+                                    <cstring>Line2</cstring>
+                                </property>
+                                <property name="frameShape">
+                                    <enum>HLine</enum>
+                                </property>
+                                <property name="frameShadow">
+                                    <enum>Sunken</enum>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Horizontal</enum>
+                                </property>
+                            </widget>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout11</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>choosebuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Select s&amp;ubstitute Family:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>choosesubcombo</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox">
+                                        <property name="name">
+                                            <cstring>choosesubcombo</cstring>
+                                        </property>
+                                        <property name="autoCompletion">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="duplicatesEnabled">
+                                            <bool>false</bool>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton">
+                                        <property name="name">
+                                            <cstring>PushButton1</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Add</string>
+                                        </property>
+                                    </widget>
+                                </hbox>
+                            </widget>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QWidget">
+                <property name="name">
+                    <cstring>tab</cstring>
+                </property>
+                <attribute name="title">
+                    <string>Interface</string>
+                </attribute>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox4</cstring>
+                        </property>
+                        <property name="title">
+                            <string>Feel Settings</string>
+                        </property>
+                        <grid>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QSpinBox" row="0" column="1">
+                                <property name="name">
+                                    <cstring>dcispin</cstring>
+                                </property>
+                                <property name="suffix">
+                                    <string> ms</string>
+                                </property>
+                                <property name="maxValue">
+                                    <number>10000</number>
+                                </property>
+                                <property name="minValue">
+                                    <number>10</number>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="0" column="0">
+                                <property name="name">
+                                    <cstring>dcibuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Double Click Interval:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>dcispin</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QSpinBox" row="1" column="1">
+                                <property name="name">
+                                    <cstring>cfispin</cstring>
+                                </property>
+                                <property name="suffix">
+                                    <string> ms</string>
+                                </property>
+                                <property name="maxValue">
+                                    <number>10000</number>
+                                </property>
+                                <property name="minValue">
+                                    <number>9</number>
+                                </property>
+                                <property name="specialValueText">
+                                    <string>No blinking</string>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="1" column="0">
+                                <property name="name">
+                                    <cstring>cfibuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Cursor Flash Time:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>cfispin</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QSpinBox" row="2" column="1">
+                                <property name="name">
+                                    <cstring>wslspin</cstring>
+                                </property>
+                                <property name="suffix">
+                                    <string> lines</string>
+                                </property>
+                                <property name="maxValue">
+                                    <number>20</number>
+                                </property>
+                                <property name="minValue">
+                                    <number>1</number>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="2" column="0">
+                                <property name="name">
+                                    <cstring>wslbuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Wheel &amp;Scroll Lines:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>wslspin</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QCheckBox" row="3" column="0" rowspan="1" colspan="2">
+                                <property name="name">
+                                    <cstring>resolvelinks</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Resolve symlinks in URLs</string>
+                                </property>
+                            </widget>
+                        </grid>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox3</cstring>
+                        </property>
+                        <property name="title">
+                            <string>GUI Effects</string>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QCheckBox">
+                                <property name="name">
+                                    <cstring>effectcheckbox</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>&amp;Enable</string>
+                                </property>
+                                <property name="accel">
+                                    <string>Alt+E</string>
+                                </property>
+                            </widget>
+                            <widget class="QFrame">
+                                <property name="name">
+                                    <cstring>effectbase</cstring>
+                                </property>
+                                <property name="frameShape">
+                                    <enum>NoFrame</enum>
+                                </property>
+                                <property name="frameShadow">
+                                    <enum>Plain</enum>
+                                </property>
+                                <grid>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QLabel" row="0" column="0">
+                                        <property name="name">
+                                            <cstring>meffectbuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>&amp;Menu Effect:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>menueffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QLabel" row="1" column="0">
+                                        <property name="name">
+                                            <cstring>ceffectbuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>C&amp;omboBox Effect:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>comboeffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QLabel" row="2" column="0">
+                                        <property name="name">
+                                            <cstring>teffectbuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>&amp;ToolTip Effect:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>tooltipeffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QLabel" row="3" column="0">
+                                        <property name="name">
+                                            <cstring>beffectbuddy</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Tool&amp;Box Effect:</string>
+                                        </property>
+                                        <property name="buddy" stdset="0">
+                                            <cstring>toolboxeffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox" row="0" column="1">
+                                        <item>
+                                            <property name="text">
+                                                <string>Disable</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Animate</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Fade</string>
+                                            </property>
+                                        </item>
+                                        <property name="name">
+                                            <cstring>menueffect</cstring>
+                                        </property>
+                                        <property name="currentItem">
+                                            <number>0</number>
+                                        </property>
+                                        <property name="autoCompletion">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox" row="1" column="1">
+                                        <item>
+                                            <property name="text">
+                                                <string>Disable</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Animate</string>
+                                            </property>
+                                        </item>
+                                        <property name="name">
+                                            <cstring>comboeffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox" row="2" column="1">
+                                        <item>
+                                            <property name="text">
+                                                <string>Disable</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Animate</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Fade</string>
+                                            </property>
+                                        </item>
+                                        <property name="name">
+                                            <cstring>tooltipeffect</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QComboBox" row="3" column="1">
+                                        <item>
+                                            <property name="text">
+                                                <string>Disable</string>
+                                            </property>
+                                        </item>
+                                        <item>
+                                            <property name="text">
+                                                <string>Animate</string>
+                                            </property>
+                                        </item>
+                                        <property name="name">
+                                            <cstring>toolboxeffect</cstring>
+                                        </property>
+                                    </widget>
+                                </grid>
+                            </widget>
+                        </vbox>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox5</cstring>
+                        </property>
+                        <property name="title">
+                            <string>Global Strut</string>
+                        </property>
+                        <grid>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLabel" row="0" column="0">
+                                <property name="name">
+                                    <cstring>swbuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Minimum &amp;Width:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>strutwidth</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QLabel" row="1" column="0">
+                                <property name="name">
+                                    <cstring>shbuddy</cstring>
+                                </property>
+                                <property name="text">
+                                    <string>Minimum Hei&amp;ght:</string>
+                                </property>
+                                <property name="buddy" stdset="0">
+                                    <cstring>strutheight</cstring>
+                                </property>
+                            </widget>
+                            <widget class="QSpinBox" row="0" column="1">
+                                <property name="name">
+                                    <cstring>strutwidth</cstring>
+                                </property>
+                                <property name="suffix">
+                                    <string> pixels</string>
+                                </property>
+                                <property name="maxValue">
+                                    <number>1000</number>
+                                </property>
+                            </widget>
+                            <widget class="QSpinBox" row="1" column="1">
+                                <property name="name">
+                                    <cstring>strutheight</cstring>
+                                </property>
+                                <property name="suffix">
+                                    <string> pixels</string>
+                                </property>
+                                <property name="maxValue">
+                                    <number>1000</number>
+                                </property>
+                            </widget>
+                        </grid>
+                    </widget>
+                    <widget class="QCheckBox">
+                        <property name="name">
+                            <cstring>rtlExtensions</cstring>
+                        </property>
+                        <property name="text">
+                            <string>Enhanced support for languages written right-to-left</string>
+                        </property>
+                    </widget>
+                    <widget class="QLabel">
+                        <property name="name">
+                            <cstring>inputStyleLabel</cstring>
+                        </property>
+                        <property name="text">
+                            <string>XIM Input Style:</string>
+                        </property>
+                    </widget>
+                    <widget class="QComboBox">
+                        <item>
+                            <property name="text">
+                                <string>On The Spot</string>
+                            </property>
+                        </item>
+                        <item>
+                            <property name="text">
+                                <string>Over The Spot</string>
+                            </property>
+                        </item>
+                        <item>
+                            <property name="text">
+                                <string>Off The Spot</string>
+                            </property>
+                        </item>
+                        <item>
+                            <property name="text">
+                                <string>Root</string>
+                            </property>
+                        </item>
+                        <property name="name">
+                            <cstring>inputStyle</cstring>
+                        </property>
+                        <property name="currentItem">
+                            <number>0</number>
+                        </property>
+                    </widget>
+                    <spacer>
+                        <property name="name">
+                            <cstring>spacer5</cstring>
+                        </property>
+                        <property name="orientation">
+                            <enum>Vertical</enum>
+                        </property>
+                        <property name="sizeType">
+                            <enum>Expanding</enum>
+                        </property>
+                        <property name="sizeHint">
+                            <size>
+                                <width>20</width>
+                                <height>40</height>
+                            </size>
+                        </property>
+                    </spacer>
+                </vbox>
+            </widget>
+            <widget class="QWidget">
+                <property name="name">
+                    <cstring>tab</cstring>
+                </property>
+                <attribute name="title">
+                    <string>Library Paths</string>
+                </attribute>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>4</number>
+                    </property>
+                    <property name="spacing">
+                        <number>4</number>
+                    </property>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox39</cstring>
+                        </property>
+                        <property name="title">
+                            <string>Library Paths</string>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout68</cstring>
+                                </property>
+                                <grid>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QListBox" row="0" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>libpathlistbox</cstring>
+                                        </property>
+                                        <property name="frameShape">
+                                            <enum>StyledPanel</enum>
+                                        </property>
+                                        <property name="frameShadow">
+                                            <enum>Sunken</enum>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="1" column="1">
+                                        <property name="name">
+                                            <cstring>PushButton8</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Down</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="1" column="2">
+                                        <property name="name">
+                                            <cstring>PushButton9</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Remove</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="1" column="0">
+                                        <property name="name">
+                                            <cstring>PushButton7</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Up</string>
+                                        </property>
+                                    </widget>
+                                </grid>
+                            </widget>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout71</cstring>
+                                </property>
+                                <grid>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <spacer row="2" column="0">
+                                        <property name="name">
+                                            <cstring>Spacer1_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Minimum</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>20</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel" row="0" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>TextLabel15</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Press the &lt;b&gt;Browse&lt;/b&gt; button or enter a directory and press Enter to add them to the list.</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QLineEdit" row="1" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>libpathlineedit</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="2" column="1">
+                                        <property name="name">
+                                            <cstring>PushButton5</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Browse...</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="2" column="2">
+                                        <property name="name">
+                                            <cstring>PushButton6</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Add</string>
+                                        </property>
+                                    </widget>
+                                </grid>
+                            </widget>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QWidget">
+                <property name="name">
+                    <cstring>tab</cstring>
+                </property>
+                <attribute name="title">
+                    <string>Printer</string>
+                </attribute>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>8</number>
+                    </property>
+                    <property name="spacing">
+                        <number>4</number>
+                    </property>
+                    <widget class="QCheckBox">
+                        <property name="name">
+                            <cstring>fontembeddingcheckbox</cstring>
+                        </property>
+                        <property name="text">
+                            <string>Enable Font embedding</string>
+                        </property>
+                        <property name="checked">
+                            <bool>true</bool>
+                        </property>
+                    </widget>
+                    <widget class="QGroupBox">
+                        <property name="name">
+                            <cstring>GroupBox10</cstring>
+                        </property>
+                        <property name="sizePolicy">
+                            <sizepolicy>
+                                <hsizetype>5</hsizetype>
+                                <vsizetype>7</vsizetype>
+                                <horstretch>0</horstretch>
+                                <verstretch>0</verstretch>
+                            </sizepolicy>
+                        </property>
+                        <property name="title">
+                            <string>Font Paths</string>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>8</number>
+                            </property>
+                            <property name="spacing">
+                                <number>4</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout9</cstring>
+                                </property>
+                                <grid>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <widget class="QPushButton" row="1" column="0">
+                                        <property name="name">
+                                            <cstring>PushButton11</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Up</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="1" column="2">
+                                        <property name="name">
+                                            <cstring>PushButton13</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Remove</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QListBox" row="0" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>fontpathlistbox</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="1" column="1">
+                                        <property name="name">
+                                            <cstring>PushButton12</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Down</string>
+                                        </property>
+                                    </widget>
+                                </grid>
+                            </widget>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>Layout10</cstring>
+                                </property>
+                                <grid>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <property name="margin">
+                                        <number>0</number>
+                                    </property>
+                                    <property name="spacing">
+                                        <number>4</number>
+                                    </property>
+                                    <spacer row="2" column="0">
+                                        <property name="name">
+                                            <cstring>Spacer4</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Minimum</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>20</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel" row="0" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>TextLabel15_2</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Press the &lt;b&gt;Browse&lt;/b&gt; button or enter a directory and press Enter to add them to the list.</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="2" column="2">
+                                        <property name="name">
+                                            <cstring>PushButton15</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Add</string>
+                                        </property>
+                                    </widget>
+                                    <widget class="QLineEdit" row="1" column="0" rowspan="1" colspan="3">
+                                        <property name="name">
+                                            <cstring>fontpathlineedit</cstring>
+                                        </property>
+                                    </widget>
+                                    <widget class="QPushButton" row="2" column="1">
+                                        <property name="name">
+                                            <cstring>PushButton14</cstring>
+                                        </property>
+                                        <property name="text">
+                                            <string>Browse...</string>
+                                        </property>
+                                    </widget>
+                                </grid>
+                            </widget>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+        </widget>
+    </hbox>
+</widget>
+<menubar>
+    <property name="name">
+        <cstring>menubar</cstring>
+    </property>
+    <item text="&amp;File" name="PopupMenu">
+        <action name="fileSaveAction"/>
+        <separator/>
+        <action name="fileExitAction"/>
+    </item>
+    <item text="&amp;Help" name="PopupMenu_2">
+        <action name="helpAboutAction"/>
+        <action name="helpAboutQtAction"/>
+    </item>
+</menubar>
+<toolbars>
+</toolbars>
+<customwidgets>
+    <customwidget>
+        <class>ColorButton</class>
+        <header location="local">colorbutton.h</header>
+        <sizehint>
+            <width>40</width>
+            <height>25</height>
+        </sizehint>
+        <container>0</container>
+        <sizepolicy>
+            <hordata>5</hordata>
+            <verdata>5</verdata>
+            <horstretch>0</horstretch>
+            <verstretch>0</verstretch>
+        </sizepolicy>
+        <pixmap>image0</pixmap>
+        <signal>clicked()</signal>
+        <signal>colorChanged(const QColor &amp;)</signal>
+        <signal>changed()</signal>
+        <property type="Color">color</property>
+        <property type="Pixmap">pixmap</property>
+        <property type="Bool">scale</property>
+    </customwidget>
+    <customwidget>
+        <class>PreviewFrame</class>
+        <header location="local">previewframe.h</header>
+        <sizehint>
+            <width>200</width>
+            <height>200</height>
+        </sizehint>
+        <container>0</container>
+        <sizepolicy>
+            <hordata>5</hordata>
+            <verdata>5</verdata>
+            <horstretch>0</horstretch>
+            <verstretch>0</verstretch>
+        </sizepolicy>
+        <pixmap>image1</pixmap>
+    </customwidget>
+</customwidgets>
+<actions>
+    <action>
+        <property name="name">
+            <cstring>fileSaveAction</cstring>
+        </property>
+        <property name="iconSet">
+            <iconset></iconset>
+        </property>
+        <property name="text">
+            <string>Save</string>
+        </property>
+        <property name="menuText">
+            <string>&amp;Save</string>
+        </property>
+        <property name="accel">
+            <string>Ctrl+S</string>
+        </property>
+    </action>
+    <action>
+        <property name="name">
+            <cstring>fileExitAction</cstring>
+        </property>
+        <property name="text">
+            <string>Exit</string>
+        </property>
+        <property name="menuText">
+            <string>E&amp;xit</string>
+        </property>
+        <property name="accel">
+            <string></string>
+        </property>
+    </action>
+    <action>
+        <property name="name">
+            <cstring>helpAboutAction</cstring>
+        </property>
+        <property name="text">
+            <string>About</string>
+        </property>
+        <property name="menuText">
+            <string>&amp;About</string>
+        </property>
+        <property name="accel">
+            <string></string>
+        </property>
+    </action>
+    <action>
+        <property name="name">
+            <cstring>helpAboutQtAction</cstring>
+        </property>
+        <property name="text">
+            <string>About Qt</string>
+        </property>
+        <property name="menuText">
+            <string>About &amp;Qt</string>
+        </property>
+    </action>
+</actions>
+<images>
+    <image name="image0">
+        <data format="XPM.GZ" length="4350">789c6dd7594f23471007f0f7fd14d6d6db2aaaf58c3db647511eb831b7317794879ac30760cc61c010e5bba7dcf5af5688167664fdb66bbaababbb67cccf1f8dab93c3c68f9fdf5e16b298968d7222cf8d1fd5eb6cf6f1e75f7ffcfded7b9a3656ff9aad46fafdb76fdf078b46d9389a3fd42bf04841699e964933b830b79a7019dd0b96955b895b5a703bcd572e08eea576ff6570ae0eedd477b792103f854b8b2fc6d1163f77237e646e37113f89b6f8307e3bf1785a8b0eedbc696eb7ad9db7e01ee6476ee4ffe0c6fd158c7c69182cde4eec6e87fea50dfbf8176e6ba7d07f96669999cfa325ccaf862bcc97a36dbccf60f178cee11cde706761f16917ae30fe6b7488a7851bf14d7327417f676eb4f756eea41e2f57e6d83e83919f6cba117f04235fd9765b3b0fa36dfc398cf973edc67a6fb951ffe768ab6765ee26b8dff213ef5f4630e2b9e7463ea7ee8ee5ff60ee2618af8eb6fe3238437eb91bf1299cdbfacad3cadd5617f5a11738c7fe4adcb8ffd68d7aeec15e8fc3683b9f62ee2518ef33dafa3f75e3bc957086f86eb4d56f3db8e8e6dd56f01a5cc1bbe65e629673d8ebd18d0efdc9058cf9f2c08df9e630ce037db8719ec37c7a9a7fb708f10267b65e7cef46fb3e9ca3fd23dad6ef0cf67abe99f304f95ec3a8871cbb71be52d8d777e8b6fee412f6f958be3adf5ea817b561afe7d86ded7c67ce13c46fc37ede2766c17a17059cd9f38e466e8c3f8eb6fd700f0b9ef7095c37cd3d37de178f2be76dcf876fa343bd790267f012f67a77cc319f69b4ed872e2ca8e732daeabfe3c6fa9cc235f21f9b8bd4f2a5cd687bfedbfd659ee7ede017b842becf6eb44fa3cbd0df8559b0ffe808ceb0ff37e01afba3652e52cc87a26dbe276ecca7097790ff73b4cdef0616ac4fdf6df1c2d1d67ee8c6f80318eb4bd1180ff529513f0ecf7b694b62f5a002ceccb2662e523c2fb7605f9f0fd8fbbf75e3bc2dcd3e9ebcb9f17ce8c05e8f83685bcf701e44eb2db65e4fd1b65eebe62245be53b8c6f3ffdd8dfd3933fbf884761f5f0edcd88f951bf118bf44bde926dae24fe01ae7af76e3f9169e2f45bb143c0f5fdcf6fea23b18f773eac6f3e63ddac6db75e37df5e8c6fbae65aebcde6d37beaf84f528aa52f03c9dc3359ea79939c627d136deab1befaf75b883ef23e76e3ccfaea36d7dc2f795322b05ebfb0ad738af7db7ad371f99fd7e59b8b13f276e9cdf1318f5e54337e6d78cb67cf761ec170efba1acaa1afd9db92d3f3a36d729ea77efc6f33cbccf2beddfe6478fe6d85e45dbfd851bf1577007f5d877e3bc86f5a9ea3a2d6cffdfc1debe116df5db73a39e37b0e777191dda257c7fa83b6e8a2eaae00eeceb13d6b7d69f325b79b058fd32b170c1a55ebffaac2ccae2b9e6118f79c253bd6ef9ee3fd7587fef79c60f7acf3cc617fcc84ffcac6d8ffcc20b7ee5377ee7257ff027aff1bac66ff0269716cf5b1ab7cd3bbcabb17ddee37d3ee0433ee2633ee1019ff290cff89c2ff89229c48b66f1ac3d5df135df7093134eb9c56dcef4b3c35dee71ce393111dbfa8c784a4205955451cd1d1ad1982634a55bbad3f80eddd38c1ef882e66cf52ab5ff2b8d7ea4277aa6175ad06bb866f446efb4d4df0ffad4fed762ffb7b44e1b9cd2266dd142c75e5ddb3cd0bb3e347a477bd9d5f83ee245e3f7689f0ee830f67d44c77412ee186946033aa5e197fecfe85c7bf7be2fe892aee89a6ea84989f6bfa434f4eff9df52c509b5d0779b32ea684d13ea528f728d1e882ebfce37f6cf077422b4ea5b440ad14af1a15452ab473aee52c65ff39789b64fe955f44eb9937b5d858c5b32d377c0c32a7fee7ecd5fe61aff284ff22c2fb290577993775db1443fb53ef2219f5ff2bf93356d5b970dd9d41eb77820dbb223bbab155ed55ffab2f725ffb1eccb81aed6931cca116ab490633909d10339fd5ffdef795d869ae7923bc27226e772415d5986b51d683663b9d4fcfbb1ff190fe54aaec35aeaa577ee20f24673e94b531249a585fc2b69ebfe3ed7dae91f75ba964b5c03e9d344ba1add93bce0826c3f87f3b2a9fb6f18aeba10ba2f563f25eb1b563771a5d17531e2513c5fba538b3111cd690dd73c7ef6a95f4c8aa99de12fe77da4951de9ffffea730be7fd9fdfbffd0b690edc6c</data>
+    </image>
+    <image name="image1">
+        <data format="XPM.GZ" length="857">789c6d92cd4ec3300c80ef7d8a68b94da8dbba51a9423c02882312e210c7f95d3a241807847877eca4e93a84d54af9fcd5899374b316cf4f0f62bd693eceea1cb4d05ebd8b357e8ee3d7cbebfd77b3ea3a41cfae17bbd54db36a85168f6f27c3634563b9dfedb7db2da3acd8778cb1607f5bd0331ed4411f142330f65db5a1e0301444c64157d41507cd980a6a53d67515cbc723a3c66a6dc5624dc532d5a9a0b5058f8cd6566cdb56aaeba05436a0f43210a4826294369c31c63a4404002f55362c02e50d2f8001207a2f6531d4d131e729128227a32643152ed14ce86c4a09168605440ac031a57031b404091f3d861872d16c6ca9a01d87885cb430b9c29cac8b90122e0c7205094b4dd374b3a16d70056f15fc1f6323d8bc550757b3510680d3fc5e75e0f2b72e00f2212cbb464701d45d449796060199318490079775e8dc4b660e980c9dad9f1dd2f10428b7d02a991d9f58001ec0747374dbf24fa8c9fcff87fcdc35bf3990fd9c</data>
+    </image>
+</images>
+<connections>
+    <connection>
+        <sender>fontpathlineedit</sender>
+        <signal>returnPressed()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>addFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton15</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>addFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton6</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>addLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>libpathlineedit</sender>
+        <signal>returnPressed()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>addLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton1</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>addSubstitute()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton14</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>browseFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton5</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>browseLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>stylecombo</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>buildFont()</slot>
+    </connection>
+    <connection>
+        <sender>psizecombo</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>buildFont()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton12</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>downFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton8</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>downLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton3</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>downSubstitute()</slot>
+    </connection>
+    <connection>
+        <sender>familycombo</sender>
+        <signal>activated(const QString&amp;)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>familySelected(const QString&amp;)</slot>
+    </connection>
+    <connection>
+        <sender>fileExitAction</sender>
+        <signal>activated()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>fileExit()</slot>
+    </connection>
+    <connection>
+        <sender>fileSaveAction</sender>
+        <signal>activated()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>fileSave()</slot>
+    </connection>
+    <connection>
+        <sender>helpAboutAction</sender>
+        <signal>activated()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>helpAbout()</slot>
+    </connection>
+    <connection>
+        <sender>helpAboutQtAction</sender>
+        <signal>activated()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>helpAboutQt()</slot>
+    </connection>
+    <connection>
+        <sender>TabWidget3</sender>
+        <signal>currentChanged(QWidget*)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>pageChanged(QWidget*)</slot>
+    </connection>
+    <connection>
+        <sender>paletteCombo</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>paletteSelected(int)</slot>
+    </connection>
+    <connection>
+        <sender>PushButton13</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>removeFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton9</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>removeLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton4</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>removeSubstitute()</slot>
+    </connection>
+    <connection>
+        <sender>effectcheckbox</sender>
+        <signal>toggled(bool)</signal>
+        <receiver>effectbase</receiver>
+        <slot>setEnabled(bool)</slot>
+    </connection>
+    <connection>
+        <sender>fontembeddingcheckbox</sender>
+        <signal>toggled(bool)</signal>
+        <receiver>GroupBox10</receiver>
+        <slot>setEnabled(bool)</slot>
+    </connection>
+    <connection>
+        <sender>toolboxeffect</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>dcispin</sender>
+        <signal>valueChanged(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>cfispin</sender>
+        <signal>valueChanged(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>wslspin</sender>
+        <signal>valueChanged(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>menueffect</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>comboeffect</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>tooltipeffect</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>strutwidth</sender>
+        <signal>valueChanged(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>strutheight</sender>
+        <signal>valueChanged(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>effectcheckbox</sender>
+        <signal>toggled(bool)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>resolvelinks</sender>
+        <signal>toggled(bool)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>fontembeddingcheckbox</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>rtlExtensions</sender>
+        <signal>toggled(bool)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>inputStyle</sender>
+        <signal>activated(int)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>somethingModified()</slot>
+    </connection>
+    <connection>
+        <sender>gstylecombo</sender>
+        <signal>activated(const QString&amp;)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>styleSelected(const QString&amp;)</slot>
+    </connection>
+    <connection>
+        <sender>familysubcombo</sender>
+        <signal>activated(const QString&amp;)</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>substituteSelected(const QString&amp;)</slot>
+    </connection>
+    <connection>
+        <sender>btnAdvanced</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>tunePalette()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton11</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>upFontpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton7</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>upLibpath()</slot>
+    </connection>
+    <connection>
+        <sender>PushButton2</sender>
+        <signal>clicked()</signal>
+        <receiver>MainWindowBase</receiver>
+        <slot>upSubstitute()</slot>
+    </connection>
+</connections>
+<tabstops>
+    <tabstop>helpview</tabstop>
+    <tabstop>TabWidget3</tabstop>
+    <tabstop>familycombo</tabstop>
+    <tabstop>stylecombo</tabstop>
+    <tabstop>psizecombo</tabstop>
+    <tabstop>samplelineedit</tabstop>
+    <tabstop>familysubcombo</tabstop>
+    <tabstop>PushButton2</tabstop>
+    <tabstop>PushButton3</tabstop>
+    <tabstop>PushButton4</tabstop>
+    <tabstop>choosesubcombo</tabstop>
+    <tabstop>PushButton1</tabstop>
+    <tabstop>dcispin</tabstop>
+    <tabstop>cfispin</tabstop>
+    <tabstop>wslspin</tabstop>
+    <tabstop>effectcheckbox</tabstop>
+    <tabstop>menueffect</tabstop>
+    <tabstop>comboeffect</tabstop>
+    <tabstop>tooltipeffect</tabstop>
+    <tabstop>strutwidth</tabstop>
+    <tabstop>strutheight</tabstop>
+    <tabstop>libpathlineedit</tabstop>
+    <tabstop>PushButton5</tabstop>
+    <tabstop>PushButton6</tabstop>
+    <tabstop>PushButton7</tabstop>
+    <tabstop>PushButton8</tabstop>
+    <tabstop>PushButton9</tabstop>
+    <tabstop>sublistbox</tabstop>
+    <tabstop>libpathlistbox</tabstop>
+</tabstops>
+<slots>
+    <slot access="protected">init()</slot>
+    <slot access="protected">destroy()</slot>
+    <slot>addFontpath()</slot>
+    <slot>addLibpath()</slot>
+    <slot>addSubstitute()</slot>
+    <slot>browseFontpath()</slot>
+    <slot>browseLibpath()</slot>
+    <slot>buildFont()</slot>
+    <slot>buildPalette()</slot>
+    <slot>downFontpath()</slot>
+    <slot>downLibpath()</slot>
+    <slot>downSubstitute()</slot>
+    <slot>familySelected( const QString &amp; )</slot>
+    <slot>fileExit()</slot>
+    <slot>fileSave()</slot>
+    <slot>helpAbout()</slot>
+    <slot>helpAboutQt()</slot>
+    <slot>new_slot()</slot>
+    <slot>pageChanged( QWidget * )</slot>
+    <slot>paletteSelected( int )</slot>
+    <slot>removeFontpath()</slot>
+    <slot>removeLibpath()</slot>
+    <slot>removeSubstitute()</slot>
+    <slot>somethingModified()</slot>
+    <slot>styleSelected( const QString &amp; )</slot>
+    <slot>substituteSelected( const QString &amp; )</slot>
+    <slot>tunePalette()</slot>
+    <slot>upFontpath()</slot>
+    <slot>upLibpath()</slot>
+    <slot>upSubstitute()</slot>
+</slots>
+<pixmapinproject/>
+<layoutdefaults spacing="4" margin="8"/>
+<includehints>
+    <includehint>colorbutton.h</includehint>
+    <includehint>colorbutton.h</includehint>
+    <includehint>previewframe.h</includehint>
+</includehints>
+</UI>
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp	2009-10-18 14:38:39.378535121 -0700
@@ -41,4 +41,5 @@
 #include <qcombobox.h>
 #include <qstylefactory.h>
+#include <qinputcontextfactory.h>
 #include <qobjectlist.h>
 #include <qfontdatabase.h>
@@ -375,5 +376,5 @@
     rtlExtensions->setChecked( settings.readBoolEntry( "/qt/useRtlExtensions", FALSE ) );
 
-#ifdef Q_WS_X11
+#if defined(Q_WS_X11)
     inputStyle->setCurrentText( settings.readEntry( "/qt/XIMInputStyle", trUtf8( "On The Spot" ) ) );
 #else
@@ -382,4 +383,64 @@
 #endif
 
+#if defined(Q_WS_X11) && !defined(QT_NO_IM_EXTENSIONS)
+    /*
+        This code makes it possible to set up default input method.
+
+	The list of identifier names of input method which can be used
+	is acquired using QInputContextFactory::keys(). And it is
+	translated to display name and set to inputMethodCombo which
+	displays the list of input method.
+     */
+    inputMethodIdentifiers = QInputContextFactory::keys();
+    QStringList imDispNames;
+    {
+	// input method switcher should named with "imsw-" prefix to
+	// prevent to be listed in ordinary input method list.
+	QStringList::Iterator imIt = inputMethodIdentifiers.begin();
+	while (imIt != inputMethodIdentifiers.end()) {
+	    if ((*imIt).find("imsw-") == 0)
+		imIt = inputMethodIdentifiers.remove(imIt);
+	    else
+		imIt++;
+	}
+	// we should not sort the list
+	//inputMethodIdentifiers.sort();
+	for (imIt = inputMethodIdentifiers.begin();
+	     imIt != inputMethodIdentifiers.end();
+	     imIt++) {
+	    QString dispName = QInputContextFactory::displayName(*imIt);
+	    if (dispName.isNull() || dispName.isEmpty())
+		dispName = *imIt;
+	    imDispNames << dispName;
+	}
+    }
+    //inputMethodCombo->insertStringList(inputMethodIdentifiers);
+    inputMethodCombo->insertStringList(imDispNames);
+
+    /*
+        input method set up as a default in the past is chosen.
+	If nothing is set up, default input method in the platform is chosen. 
+     */
+    // default input method is XIM in X11.
+    QString currentIM = settings.readEntry("/qt/DefaultInputMethod", "xim");
+    {
+	int index = inputMethodIdentifiers.findIndex(currentIM);
+	// set up Selected input method.
+	if (0 <= index && index < inputMethodIdentifiers.count()) {
+	    inputMethodCombo->setCurrentItem(index);
+	} else {
+	    // Give up. this part is executed when specified IM is not
+	    // installed.
+	    QString dispName = tr("Unknown Input Method") + " (" + currentIM + ")";
+	    inputMethodCombo->insertItem(dispName);
+	    inputMethodCombo->setCurrentItem(inputMethodCombo->count() - 1);
+	    inputMethodIdentifiers << currentIM;
+	}
+    }
+#else
+    inputMethodCombo->hide();
+    inputMethodLabel->hide();
+#endif
+
     fontembeddingcheckbox->setChecked( settings.readBoolEntry("/qt/embedFonts", TRUE) );
     fontpaths = settings.readListEntry("/qt/fontPath", ':');
@@ -458,4 +519,11 @@
 	    str = "Root";
         settings.writeEntry( "/qt/XIMInputStyle", inputStyle->currentText() );
+
+#if !defined(QT_NO_IM_EXTENSIONS)
+	QString imSwitcher = settings.readEntry("/qt/DefaultInputMethodSwitcher", "imsw-multi");
+	settings.writeEntry("/qt/DefaultInputMethodSwitcher", imSwitcher);
+	int imIndex = inputMethodCombo->currentItem();
+	settings.writeEntry("/qt/DefaultInputMethod", inputMethodIdentifiers[imIndex]);
+#endif
 #endif
 
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp.orig qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp.orig
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.cpp.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,1074 @@
+/**********************************************************************
+** Copyright (C) 2000-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of Qt Configuration.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with
+** the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#include "mainwindow.h"
+#include "colorbutton.h"
+#include "previewframe.h"
+#include "paletteeditoradvanced.h"
+
+#include <qlabel.h>
+#include <qapplication.h>
+#include <qcombobox.h>
+#include <qstylefactory.h>
+#include <qobjectlist.h>
+#include <qfontdatabase.h>
+#include <qlineedit.h>
+#include <qlistbox.h>
+#include <qspinbox.h>
+#include <qcheckbox.h>
+#include <qfiledialog.h>
+#include <qaction.h>
+#include <qstatusbar.h>
+#include <qsettings.h>
+#include <qmessagebox.h>
+#include <qtextview.h>
+#include <qstyle.h>
+
+#include <stdlib.h>
+
+
+// from qapplication.cpp and qapplication_x11.cpp - These are NOT for
+// external use ignore them
+extern bool Q_EXPORT qt_resolve_symlinks;
+
+
+static const char *appearance_text =
+"<p><b><font size+=2>Appearance</font></b></p>"
+"<hr>"
+"<p>Use this tab to customize the appearance of your Qt applications.</p>"
+"<p>You can select the default GUI Style from the drop down list and "
+"customize the colors.</p>"
+"<p>Any GUI Style plugins in your plugin path will automatically be added "
+"to the list of built-in Qt styles. (See the Library Paths tab for "
+"information on adding new plugin paths.)</p>"
+"<p>When you choose 3-D Effects and Background colors, the Qt Configuration "
+"program will automatically generate a palette for you.  To customize "
+"colors further, press the Tune Palette button to open the advanced "
+"palette editor."
+"<p>The Preview Window shows what the selected Style and colors look "
+"like.";
+
+static const char *font_text =
+"<p><b><font size+=2>Fonts</font></b></p>"
+"<hr>"
+"<p>Use this tab to select the default font for your Qt applications. "
+"The selected font is shown (initially as 'Sample Text') in the line "
+"edit below the Family, "
+"Style and Point Size drop down lists.</p>"
+"<p>Qt has a powerful font substitution feature that allows you to "
+"specify a list of substitute fonts.  Substitute fonts are used "
+"when a font cannot be loaded, or if the specified font doesn't have "
+"a particular character."
+"<p>For example, if you select the font Lucida, which doesn't have Korean "
+"characters, but need to show some Korean text using the Mincho font family "
+"you can do so by adding Mincho to the list. Once Mincho is added, any "
+"Korean characters that are not found in the Lucida font will be taken "
+"from the Mincho font.  Because the font substitutions are "
+"lists, you can also select multiple families, such as Song Ti (for "
+"use with Chinese text).";
+
+static const char *interface_text =
+"<p><b><font size+=2>Interface</font></b></p>"
+"<hr>"
+"<p>Use this tab to customize the feel of your Qt applications.</p>"
+"<p>If the Resolve Symlinks checkbox is checked Qt will follow symlinks "
+"when handling URLs. For example, in the file dialog, if this setting is turned "
+"on and /usr/tmp is a symlink to /var/tmp, entering the /usr/tmp directory "
+"will cause the file dialog to change to /var/tmp.  With this setting turned "
+"off, symlinks are not resolved or followed.</p>"
+"<p>The Global Strut setting is useful for people who require a "
+"minimum size for all widgets (e.g. when using a touch panel or for users "
+"who are visually impaired).  Leaving the Global Strut width and height "
+"at 0 will disable the Global Strut feature</p>"
+"<p>XIM (Extended Input Methods) are used for entering characters in "
+"languages that have large character sets, for example, Chinese and "
+"Japanese.";
+// ### What does the 'Enhanced support for languages written R2L do?
+
+static const char *libpath_text =
+"<p><b><font size+=2>Library Paths</font></b></p>"
+"<hr>"
+"<p>Use this tab to select additional directories where Qt should search "
+"for component plugins."
+"<p>These directories should be the base directory of where your plugins "
+"are stored.  For example, if you wish to store GUI Style plugins in "
+"$HOME/plugins/styles and Qt Designer plugins in $HOME/plugins/designer, "
+"you would add $HOME/plugins to your Library Path. <p>Notes:"
+"<ul><li>The Qt Configuration program does <i>not</i> support environment "
+"variables, so you must give full path names, for example "
+"<tt>/home/brad/myplugins</tt> not <tt>$HOME/myplugins</tt>"
+"<li> Qt automatically "
+"searches in the directory where you installed Qt for component plugins. "
+"Removing that path is not possible.</ul>";
+
+static const char *printer_text =
+"<p><b><font size+=2>Printer</font></b></p>"
+"<hr>"
+"<p>Use this tab to configure the way Qt generates output for the printer."
+"You can specify if Qt should try to embed fonts into its generated output."
+"If you enable font embedding, the resulting postscript will be more "
+"portable and will more accurately reflect the "
+"visual output on the screen; however the resulting postscript file "
+"size will be bigger."
+"<p>When using font embedding you can select additional directories where "
+"Qt should search for embeddable font files.  By default, the X "
+"server font path is used.";
+
+static const char *about_text =
+"<p><b><font size=+2>Qt Configuration</font></b></p>"
+"<p>A graphical configuration tool for programs using Qt</p>"
+"<p>Version 1.0</p>"
+"<p>Copyright (C) 2001-2008 Trolltech ASA. All rights reserved.</p>"
+"<p></p>"
+"<p>This program is licensed to you under the terms of the GNU General "
+"Public License Version 2 as published by the Free Software Foundation. This "
+"gives you legal permission to copy, distribute and/or modify this software "
+"under certain conditions. For details, see the file 'LICENSE.GPL' that came with "
+"this software distribution. If you did not get the file, send email to "
+"info@trolltech.com.</p>\n\n<p>The program is provided AS IS with NO WARRANTY "
+"OF ANY KIND, INCLUDING THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS "
+"FOR A PARTICULAR PURPOSE.</p>";
+
+
+static QColorGroup::ColorRole centralFromItem( int item )
+{
+    switch( item ) {
+    case 0:  return QColorGroup::Background;
+    case 1:  return QColorGroup::Foreground;
+    case 2:  return QColorGroup::Button;
+    case 3:  return QColorGroup::Base;
+    case 4:  return QColorGroup::Text;
+    case 5:  return QColorGroup::BrightText;
+    case 6:  return QColorGroup::ButtonText;
+    case 7:  return QColorGroup::Highlight;
+    case 8:  return QColorGroup::HighlightedText;
+    default: return QColorGroup::NColorRoles;
+    }
+}
+
+
+static QColorGroup::ColorRole effectFromItem( int item )
+{
+    switch( item ) {
+    case 0:  return QColorGroup::Light;
+    case 1:  return QColorGroup::Midlight;
+    case 2:  return QColorGroup::Mid;
+    case 3:  return QColorGroup::Dark;
+    case 4:  return QColorGroup::Shadow;
+    default: return QColorGroup::NColorRoles;
+    }
+}
+
+
+static void setStyleHelper(QWidget *w, QStyle *s)
+{
+    w->unsetPalette();
+    w->setStyle(s);
+
+    const QObjectList *children = w->children();
+    if (! children)
+	return;
+
+    QPtrListIterator<QObject> childit(*children);
+    QObject *child;
+    while ((child = childit.current()) != 0) {
+	++childit;
+
+	if (child->isWidgetType())
+	    setStyleHelper((QWidget *) child, s);
+    }
+}
+
+
+MainWindow::MainWindow()
+    : MainWindowBase(0, "main window"),
+      editPalette(palette()), previewPalette(palette()), previewstyle(0)
+{
+    modified = TRUE;
+
+    QStringList gstyles = QStyleFactory::keys();
+    gstyles.sort();
+    gstylecombo->insertStringList(gstyles);
+
+    QSettings settings;
+    QString currentstyle = settings.readEntry("/qt/style");
+    if (currentstyle.isNull())
+	currentstyle = QApplication::style().className();
+    {
+	int s = 0;
+	QStringList::Iterator git = gstyles.begin();
+	while (git != gstyles.end()) {
+	    if (*git == currentstyle)
+		break;
+	    s++;
+	    git++;
+	}
+
+	if (s < gstylecombo->count()) {
+	    gstylecombo->setCurrentItem(s);
+	} else {
+	    // no predefined style, try to find the closest match
+	    // class names usually contain the name of the style, so we
+	    // iterate over the items in the combobox, and use the one whose
+	    // name is contained in the classname of the style
+	    s = 0;
+	    git = gstyles.begin();
+	    while (git != gstyles.end()) {
+		if (currentstyle.contains(*git))
+		    break;
+		s++;
+		git++;
+	    }
+
+	    if (s < gstylecombo->count()) {
+		gstylecombo->setCurrentItem(s);
+	    } else {
+		// we give up
+		gstylecombo->insertItem("Unknown");
+		gstylecombo->setCurrentItem(gstylecombo->count() - 1);
+	    }
+	}
+    }
+
+    buttonMainColor->setColor(palette().color(QPalette::Active,
+					      QColorGroup::Button));
+    buttonMainColor2->setColor(palette().color(QPalette::Active,
+					       QColorGroup::Background));
+
+    QFontDatabase db;
+    QStringList families = db.families();
+    familycombo->insertStringList(families);
+
+    QStringList fs = families;
+    QStringList fs2 = QFont::substitutions();
+    QStringList::Iterator fsit = fs2.begin();
+    while (fsit != fs2.end()) {
+	if (! fs.contains(*fsit))
+	    fs += *fsit;
+	fsit++;
+    }
+    fs.sort();
+    familysubcombo->insertStringList(fs);
+
+    choosesubcombo->insertStringList(families);
+    QValueList<int> sizes = db.standardSizes();
+    QValueList<int>::Iterator it = sizes.begin();
+    while (it != sizes.end())
+	psizecombo->insertItem(QString::number(*it++));
+
+    dcispin->setValue(QApplication::doubleClickInterval());
+    cfispin->setValue(QApplication::cursorFlashTime());
+    wslspin->setValue(QApplication::wheelScrollLines());
+    resolvelinks->setChecked(qt_resolve_symlinks);
+
+    effectcheckbox->setChecked(QApplication::isEffectEnabled(UI_General));
+    effectbase->setEnabled(effectcheckbox->isChecked());
+
+    if (QApplication::isEffectEnabled(UI_FadeMenu))
+	menueffect->setCurrentItem(2);
+    else if (QApplication::isEffectEnabled(UI_AnimateMenu))
+	menueffect->setCurrentItem(1);
+
+    if (QApplication::isEffectEnabled(UI_AnimateCombo))
+	comboeffect->setCurrentItem(1);
+
+    if (QApplication::isEffectEnabled(UI_FadeTooltip))
+	tooltipeffect->setCurrentItem(2);
+    else if (QApplication::isEffectEnabled(UI_AnimateTooltip))
+	tooltipeffect->setCurrentItem(1);
+
+    if ( QApplication::isEffectEnabled( UI_AnimateToolBox ) )
+	toolboxeffect->setCurrentItem( 1 );
+
+    QSize globalStrut = QApplication::globalStrut();
+    strutwidth->setValue(globalStrut.width());
+    strutheight->setValue(globalStrut.height());
+
+    libpathlistbox->clear();
+    libpathlistbox->insertStringList(QApplication::libraryPaths());
+
+    // find the default family
+    QStringList::Iterator sit = families.begin();
+    int i = 0, possible = -1;
+    while (sit != families.end()) {
+	if (*sit == QApplication::font().family())
+	    break;
+	if ((*sit).contains(QApplication::font().family()))
+	    possible = i;
+
+	i++;
+	sit++;
+    }
+    if (sit == families.end())
+	i = possible;
+    if (i == -1) // no clue about the current font
+	i = 0;
+
+    familycombo->setCurrentItem(i);
+
+    QStringList styles = db.styles(familycombo->currentText());
+    stylecombo->insertStringList(styles);
+
+    QString stylestring = db.styleString(QApplication::font());
+    sit = styles.begin();
+    i = 0;
+    possible = -1;
+    while (sit != styles.end()) {
+	if (*sit == stylestring)
+	    break;
+	if ((*sit).contains(stylestring))
+	    possible = i;
+
+	i++;
+	sit++;
+    }
+    if (sit == styles.end())
+	i = possible;
+    if (i == -1) // no clue about the current font
+	i = 0;
+    stylecombo->setCurrentItem(i);
+
+    i = 0;
+    while (i < psizecombo->count()) {
+	if (psizecombo->text(i) == QString::number(QApplication::font().pointSize())) {
+	    psizecombo->setCurrentItem(i);
+	    break;
+	}
+
+	i++;
+    }
+
+    QStringList subs = QFont::substitutes(familysubcombo->currentText());
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+
+    rtlExtensions->setChecked( settings.readBoolEntry( "/qt/useRtlExtensions", FALSE ) );
+
+#ifdef Q_WS_X11
+    inputStyle->setCurrentText( settings.readEntry( "/qt/XIMInputStyle", trUtf8( "On The Spot" ) ) );
+#else
+    inputStyle->hide();
+    inputStyleLabel->hide();
+#endif
+
+    fontembeddingcheckbox->setChecked( settings.readBoolEntry("/qt/embedFonts", TRUE) );
+    fontpaths = settings.readListEntry("/qt/fontPath", ':');
+    fontpathlistbox->insertStringList(fontpaths);
+
+    setModified(FALSE);
+}
+
+
+MainWindow::~MainWindow()
+{
+}
+
+
+void MainWindow::fileSave()
+{
+    if (! modified) {
+	statusBar()->message("No changes to be saved.", 2000);
+	return;
+    }
+
+    statusBar()->message("Saving changes...");
+
+    {
+	QSettings settings;
+	QFontDatabase db;
+	QFont font = db.font(familycombo->currentText(),
+			     stylecombo->currentText(),
+			     psizecombo->currentText().toInt());
+	QStringList actcg, inactcg, discg;
+
+	int i;
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    actcg << editPalette.color(QPalette::Active,
+				       (QColorGroup::ColorRole) i).name();
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    inactcg << editPalette.color(QPalette::Inactive,
+					 (QColorGroup::ColorRole) i).name();
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    discg << editPalette.color(QPalette::Disabled,
+				       (QColorGroup::ColorRole) i).name();
+
+	settings.writeEntry("/qt/font", font.toString());
+	settings.writeEntry("/qt/Palette/active", actcg);
+	settings.writeEntry("/qt/Palette/inactive", inactcg);
+	settings.writeEntry("/qt/Palette/disabled", discg);
+
+	QStringList libpath = QApplication::libraryPaths();
+	QString libpathkey =
+	    QString("/qt/%1.%2/libraryPath").arg( QT_VERSION >> 16 ).arg( (QT_VERSION & 0xff00 ) >> 8 );
+	settings.writeEntry(libpathkey, libpath, ':');
+	settings.writeEntry("/qt/fontPath", fontpaths, ':');
+	settings.writeEntry("/qt/embedFonts", fontembeddingcheckbox->isChecked() );
+	settings.writeEntry("/qt/style", gstylecombo->currentText());
+	settings.writeEntry("/qt/doubleClickInterval",
+					     dcispin->value());
+	settings.writeEntry("/qt/cursorFlashTime", cfispin->value() == 9 ? 0 : cfispin->value() );
+	settings.writeEntry("/qt/wheelScrollLines", wslspin->value());
+	settings.writeEntry("/qt/resolveSymlinks", resolvelinks->isChecked());
+
+	QStringList strut;
+	strut << QString::number(strutwidth->value());
+	strut << QString::number(strutheight->value());
+	settings.writeEntry("/qt/globalStrut", strut);
+
+	settings.writeEntry("/qt/useRtlExtensions", rtlExtensions->isChecked() );
+
+#ifdef Q_WS_X11
+	QString style = inputStyle->currentText();
+	QString str = "On The Spot";
+	if ( style == trUtf8( "Over The Spot" ) )
+	    str = "Over The Spot";
+	else if ( style == trUtf8( "Off The Spot" ) )
+	    str = "Off The Spot";
+	else if ( style == trUtf8( "Root" ) )
+	    str = "Root";
+        settings.writeEntry( "/qt/XIMInputStyle", inputStyle->currentText() );
+#endif
+
+	QStringList effects;
+	if (effectcheckbox->isChecked()) {
+	    effects << "general";
+
+	    switch (menueffect->currentItem()) {
+	    case 1: effects << "animatemenu"; break;
+	    case 2: effects << "fademenu"; break;
+	    }
+
+	    switch (comboeffect->currentItem()) {
+	    case 1: effects << "animatecombo"; break;
+	    }
+
+	    switch (tooltipeffect->currentItem()) {
+	    case 1: effects << "animatetooltip"; break;
+	    case 2: effects << "fadetooltip"; break;
+	    }
+
+	    switch ( toolboxeffect->currentItem() ) {
+	    case 1: effects << "animatetoolbox"; break;
+	    }
+	} else
+	    effects << "none";
+	settings.writeEntry("/qt/GUIEffects", effects);
+
+	QStringList familysubs = QFont::substitutions();
+	QStringList::Iterator fit = familysubs.begin();
+	while (fit != familysubs.end()) {
+	    QStringList subs = QFont::substitutes(*fit);
+	    settings.writeEntry("/qt/Font Substitutions/" + *fit, subs);
+	    fit++;
+	}
+    }
+
+#if defined(Q_WS_X11)
+    QApplication::x11_apply_settings();
+#endif // Q_WS_X11
+
+    setModified(FALSE);
+    statusBar()->message("Saved changes.");
+}
+
+
+void MainWindow::fileExit()
+{
+    qApp->closeAllWindows();
+}
+
+
+void MainWindow::setModified(bool m)
+{
+    if (modified == m)
+	return;
+
+    modified = m;
+    fileSaveAction->setEnabled(m);
+}
+
+
+void MainWindow::buildPalette()
+{
+    int i;
+    QColorGroup cg;
+    QColor btn = buttonMainColor->color();
+    QColor back = buttonMainColor2->color();
+    QPalette automake( btn, back );
+
+    for (i = 0; i<9; i++)
+	cg.setColor( centralFromItem(i), automake.active().color( centralFromItem(i) ) );
+
+    editPalette.setActive( cg );
+    buildActiveEffect();
+
+    cg = editPalette.inactive();
+
+    QPalette temp( editPalette.active().color( QColorGroup::Button ),
+		   editPalette.active().color( QColorGroup::Background ) );
+
+    for (i = 0; i<9; i++)
+	cg.setColor( centralFromItem(i), temp.inactive().color( centralFromItem(i) ) );
+
+    editPalette.setInactive( cg );
+    buildInactiveEffect();
+
+    cg = editPalette.disabled();
+
+    for (i = 0; i<9; i++)
+	cg.setColor( centralFromItem(i), temp.disabled().color( centralFromItem(i) ) );
+
+    editPalette.setDisabled( cg );
+    buildDisabledEffect();
+
+    updateColorButtons();
+
+    setModified(TRUE);
+}
+
+
+void MainWindow::buildActiveEffect()
+{
+    QColorGroup cg = editPalette.active();
+    QColor btn = cg.color( QColorGroup::Button );
+
+    QPalette temp( btn, btn );
+
+    for (int i = 0; i<5; i++)
+	cg.setColor( effectFromItem(i), temp.active().color( effectFromItem(i) ) );
+
+    editPalette.setActive( cg );
+    setPreviewPalette( editPalette );
+
+    updateColorButtons();
+}
+
+
+void MainWindow::buildInactive()
+{
+    editPalette.setInactive( editPalette.active() );
+    buildInactiveEffect();
+}
+
+
+void MainWindow::buildInactiveEffect()
+{
+    QColorGroup cg = editPalette.inactive();
+
+    QColor light, midlight, mid, dark, shadow;
+    QColor btn = cg.color( QColorGroup::Button );
+
+    light = btn.light(150);
+    midlight = btn.light(115);
+    mid = btn.dark(150);
+    dark = btn.dark();
+    shadow = black;
+
+    cg.setColor( QColorGroup::Light, light );
+    cg.setColor( QColorGroup::Midlight, midlight );
+    cg.setColor( QColorGroup::Mid, mid );
+    cg.setColor( QColorGroup::Dark, dark );
+    cg.setColor( QColorGroup::Shadow, shadow );
+
+    editPalette.setInactive( cg );
+    setPreviewPalette( editPalette );
+    updateColorButtons();
+}
+
+
+void MainWindow::buildDisabled()
+{
+    QColorGroup cg = editPalette.active();
+    cg.setColor( QColorGroup::ButtonText, darkGray );
+    cg.setColor( QColorGroup::Foreground, darkGray );
+    cg.setColor( QColorGroup::Text, darkGray );
+    cg.setColor( QColorGroup::HighlightedText, darkGray );
+    editPalette.setDisabled( cg );
+
+    buildDisabledEffect();
+}
+
+
+void MainWindow::buildDisabledEffect()
+{
+    QColorGroup cg = editPalette.disabled();
+
+    QColor light, midlight, mid, dark, shadow;
+    QColor btn = cg.color( QColorGroup::Button );
+
+    light = btn.light(150);
+    midlight = btn.light(115);
+    mid = btn.dark(150);
+    dark = btn.dark();
+    shadow = black;
+
+    cg.setColor( QColorGroup::Light, light );
+    cg.setColor( QColorGroup::Midlight, midlight );
+    cg.setColor( QColorGroup::Mid, mid );
+    cg.setColor( QColorGroup::Dark, dark );
+    cg.setColor( QColorGroup::Shadow, shadow );
+
+    editPalette.setDisabled( cg );
+    setPreviewPalette( editPalette );
+    updateColorButtons();
+}
+
+
+void MainWindow::setPreviewPalette( const QPalette& pal )
+{
+    QColorGroup cg;
+
+    switch (paletteCombo->currentItem()) {
+    case 0:
+    default:
+	cg = pal.active();
+	break;
+    case 1:
+	cg = pal.inactive();
+	break;
+    case 2:
+	cg = pal.disabled();
+	break;
+    }
+    previewPalette.setActive( cg );
+    previewPalette.setInactive( cg );
+    previewPalette.setDisabled( cg );
+
+    previewFrame->setPreviewPalette(previewPalette);
+}
+
+
+void MainWindow::updateColorButtons()
+{
+    buttonMainColor->setColor( editPalette.active().color( QColorGroup::Button ));
+    buttonMainColor2->setColor( editPalette.active().color( QColorGroup::Background ));
+}
+
+
+void MainWindow::tunePalette()
+{
+    bool ok;
+    QPalette pal = PaletteEditorAdvanced::getPalette(&ok, editPalette,
+						     backgroundMode(), this);
+    if (! ok)
+	return;
+
+    editPalette = pal;
+    setPreviewPalette(editPalette);
+    setModified(TRUE);
+}
+
+
+void MainWindow::paletteSelected(int)
+{
+    setPreviewPalette(editPalette);
+}
+
+
+void MainWindow::styleSelected(const QString &stylename)
+{
+    QStyle *style = QStyleFactory::create(stylename);
+    if (! style)
+	return;
+
+    setStyleHelper(previewFrame, style);
+    delete previewstyle;
+    previewstyle = style;
+
+    setModified(TRUE);
+}
+
+
+void MainWindow::familySelected(const QString &family)
+{
+    QFontDatabase db;
+    QStringList styles = db.styles(family);
+    stylecombo->clear();
+    stylecombo->insertStringList(styles);
+    familysubcombo->insertItem(family);
+    buildFont();
+}
+
+
+void MainWindow::buildFont()
+{
+    QFontDatabase db;
+    QFont font = db.font(familycombo->currentText(),
+			 stylecombo->currentText(),
+			 psizecombo->currentText().toInt());
+    samplelineedit->setFont(font);
+    setModified(TRUE);
+}
+
+
+void MainWindow::substituteSelected(const QString &family)
+{
+    QStringList subs = QFont::substitutes(family);
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+}
+
+
+void MainWindow::removeSubstitute()
+{
+    if (sublistbox->currentItem() < 0 ||
+	uint(sublistbox->currentItem()) > sublistbox->count())
+	return;
+
+    int item = sublistbox->currentItem();
+    QStringList subs = QFont::substitutes(familysubcombo->currentText());
+    subs.remove(subs.at(sublistbox->currentItem()));
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+    if (uint(item) > sublistbox->count())
+	item = int(sublistbox->count()) - 1;
+    sublistbox->setCurrentItem(item);
+    QFont::removeSubstitution(familysubcombo->currentText());
+    QFont::insertSubstitutions(familysubcombo->currentText(), subs);
+    setModified(TRUE);
+}
+
+
+void MainWindow::addSubstitute()
+{
+    if (sublistbox->currentItem() < 0 ||
+	uint(sublistbox->currentItem()) > sublistbox->count()) {
+	QFont::insertSubstitution(familysubcombo->currentText(), choosesubcombo->currentText());
+        QStringList subs = QFont::substitutes(familysubcombo->currentText());
+	sublistbox->clear();
+	sublistbox->insertStringList(subs);
+	setModified(TRUE);
+	return;
+    }
+
+    int item = sublistbox->currentItem();
+    QFont::insertSubstitution(familysubcombo->currentText(), choosesubcombo->currentText());
+    QStringList subs = QFont::substitutes(familysubcombo->currentText());
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+    sublistbox->setCurrentItem(item);
+    setModified(TRUE);
+}
+
+
+void MainWindow::downSubstitute()
+{
+    if (sublistbox->currentItem() < 0 ||
+	uint(sublistbox->currentItem()) >= sublistbox->count())
+	return;
+
+    int item = sublistbox->currentItem();
+    QStringList subs = QFont::substitutes(familysubcombo->currentText());
+    QStringList::Iterator it = subs.at(item);
+    QString fam = *it;
+    subs.remove(it);
+    it = subs.at(item);
+    subs.insert(++it, fam);
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+    sublistbox->setCurrentItem(item + 1);
+    QFont::removeSubstitution(familysubcombo->currentText());
+    QFont::insertSubstitutions(familysubcombo->currentText(), subs);
+    setModified(TRUE);
+}
+
+
+void MainWindow::upSubstitute()
+{
+    if (sublistbox->currentItem() < 1)
+	return;
+
+    int item = sublistbox->currentItem();
+    QStringList subs = QFont::substitutes(familysubcombo->currentText());
+    QStringList::Iterator it = subs.at(item);
+    QString fam = *it;
+    subs.remove(it);
+    it = subs.at(item - 1);
+    subs.insert(it, fam);
+    sublistbox->clear();
+    sublistbox->insertStringList(subs);
+    sublistbox->setCurrentItem(item - 1);
+    QFont::removeSubstitution(familysubcombo->currentText());
+    QFont::insertSubstitutions(familysubcombo->currentText(), subs);
+    setModified(TRUE);
+}
+
+
+void MainWindow::removeLibpath()
+{
+    if (libpathlistbox->currentItem() < 0 ||
+	uint(libpathlistbox->currentItem()) > libpathlistbox->count())
+	return;
+
+    int item = libpathlistbox->currentItem();
+    QStringList paths = QApplication::libraryPaths();
+    paths.remove(paths.at(libpathlistbox->currentItem()));
+    libpathlistbox->clear();
+    libpathlistbox->insertStringList(paths);
+    if (uint(item) > libpathlistbox->count())
+	item = int(libpathlistbox->count()) - 1;
+    libpathlistbox->setCurrentItem(item);
+    QApplication::setLibraryPaths(paths);
+    setModified(TRUE);
+}
+
+
+void MainWindow::addLibpath()
+{
+    if (libpathlineedit->text().isEmpty())
+	return;
+
+    if (libpathlistbox->currentItem() < 0 ||
+	uint(libpathlistbox->currentItem()) > libpathlistbox->count()) {
+	QStringList paths = QApplication::libraryPaths();
+	paths.append(libpathlineedit->text());
+	libpathlistbox->clear();
+	libpathlistbox->insertStringList(paths);
+	QApplication::setLibraryPaths(paths);
+	setModified(TRUE);
+
+	return;
+    }
+
+    int item = libpathlistbox->currentItem();
+    QStringList paths =QApplication::libraryPaths();
+    paths.insert(++paths.at(libpathlistbox->currentItem()),
+		 libpathlineedit->text());
+    libpathlistbox->clear();
+    libpathlistbox->insertStringList(paths);
+    libpathlistbox->setCurrentItem(item);
+    QApplication::setLibraryPaths(paths);
+    setModified(TRUE);
+}
+
+
+void MainWindow::downLibpath()
+{
+    if (libpathlistbox->currentItem() < 0 ||
+	uint(libpathlistbox->currentItem()) >= libpathlistbox->count() - 1)
+	return;
+
+    int item = libpathlistbox->currentItem();
+    QStringList paths = QApplication::libraryPaths();
+    QStringList::Iterator it = paths.at(item);
+    QString fam = *it;
+    paths.remove(it);
+    it = paths.at(item);
+    paths.insert(++it, fam);
+    libpathlistbox->clear();
+    libpathlistbox->insertStringList(paths);
+    libpathlistbox->setCurrentItem(item + 1);
+    QApplication::setLibraryPaths(paths);
+    setModified(TRUE);
+}
+
+
+void MainWindow::upLibpath()
+{
+    if (libpathlistbox->currentItem() < 1)
+	return;
+
+    int item = libpathlistbox->currentItem();
+    QStringList paths = QApplication::libraryPaths();
+    QStringList::Iterator it = paths.at(item);
+    QString fam = *it;
+    paths.remove(it);
+    it = paths.at(item - 1);
+    paths.insert(it, fam);
+    libpathlistbox->clear();
+    libpathlistbox->insertStringList(paths);
+    libpathlistbox->setCurrentItem(item - 1);
+    QApplication::setLibraryPaths(paths);
+    setModified(TRUE);
+}
+
+
+void MainWindow::browseLibpath()
+{
+    QString dirname = QFileDialog::getExistingDirectory(QString::null, this, 0,
+							tr("Select a Directory"));
+    if (dirname.isNull())
+	return;
+
+    libpathlineedit->setText(dirname);
+}
+
+
+void MainWindow::removeFontpath()
+{
+    if (fontpathlistbox->currentItem() < 0 ||
+	uint(fontpathlistbox->currentItem()) > fontpathlistbox->count())
+	return;
+
+    int item = fontpathlistbox->currentItem();
+    fontpaths.remove(fontpaths.at(fontpathlistbox->currentItem()));
+    fontpathlistbox->clear();
+    fontpathlistbox->insertStringList(fontpaths);
+    if (uint(item) > fontpathlistbox->count())
+	item = int(fontpathlistbox->count()) - 1;
+    fontpathlistbox->setCurrentItem(item);
+    setModified(TRUE);
+}
+
+
+void MainWindow::addFontpath()
+{
+    if (fontpathlineedit->text().isEmpty())
+	return;
+
+    if (fontpathlistbox->currentItem() < 0 ||
+	uint(fontpathlistbox->currentItem()) > fontpathlistbox->count()) {
+	fontpaths.append(fontpathlineedit->text());
+	fontpathlistbox->clear();
+	fontpathlistbox->insertStringList(fontpaths);
+	setModified(TRUE);
+
+	return;
+    }
+
+    int item = fontpathlistbox->currentItem();
+    fontpaths.insert(++fontpaths.at(fontpathlistbox->currentItem()),
+		     fontpathlineedit->text());
+    fontpathlistbox->clear();
+    fontpathlistbox->insertStringList(fontpaths);
+    fontpathlistbox->setCurrentItem(item);
+    setModified(TRUE);
+}
+
+
+void MainWindow::downFontpath()
+{
+    if (fontpathlistbox->currentItem() < 0 ||
+	uint(fontpathlistbox->currentItem()) >= fontpathlistbox->count() - 1)
+	return;
+
+    int item = fontpathlistbox->currentItem();
+    QStringList::Iterator it = fontpaths.at(item);
+    QString fam = *it;
+    fontpaths.remove(it);
+    it = fontpaths.at(item);
+    fontpaths.insert(++it, fam);
+    fontpathlistbox->clear();
+    fontpathlistbox->insertStringList(fontpaths);
+    fontpathlistbox->setCurrentItem(item + 1);
+    setModified(TRUE);
+}
+
+
+void MainWindow::upFontpath()
+{
+    if (fontpathlistbox->currentItem() < 1)
+	return;
+
+    int item = fontpathlistbox->currentItem();
+    QStringList::Iterator it = fontpaths.at(item);
+    QString fam = *it;
+    fontpaths.remove(it);
+    it = fontpaths.at(item - 1);
+    fontpaths.insert(it, fam);
+    fontpathlistbox->clear();
+    fontpathlistbox->insertStringList(fontpaths);
+    fontpathlistbox->setCurrentItem(item - 1);
+    setModified(TRUE);
+}
+
+
+void MainWindow::browseFontpath()
+{
+    QString dirname = QFileDialog::getExistingDirectory(QString::null, this, 0,
+							tr("Select a Directory"));
+    if (dirname.isNull())
+	return;
+
+   fontpathlineedit->setText(dirname);
+}
+
+
+void MainWindow::somethingModified()
+{
+    setModified(TRUE);
+}
+
+
+void MainWindow::helpAbout()
+{
+    QMessageBox::about(this, tr("Qt Configuration"),
+		       tr(about_text));
+}
+
+
+void MainWindow::helpAboutQt()
+{
+    QMessageBox::aboutQt(this, tr("Qt Configuration"));
+}
+
+
+void MainWindow::pageChanged(QWidget *page)
+{
+    if (page == tab)
+	helpview->setText(tr(appearance_text));
+    else if (page == tab_2)
+	helpview->setText(tr(font_text));
+    else if (page == tab_3)
+	helpview->setText(tr(interface_text));
+    else if (page == tab_4)
+	helpview->setText(tr(libpath_text));
+    else if (page == tab_5)
+	helpview->setText(tr(printer_text));
+}
+
+
+void MainWindow::closeEvent(QCloseEvent *e)
+{
+    if (modified) {
+	switch(QMessageBox::warning(this, tr("Save Changes"),
+				    tr("Save changes to settings?"),
+				    tr("&Yes"), tr("&No"), tr("&Cancel"), 0, 2)) {
+	case 0: // save
+	    qApp->processEvents();
+	    fileSave();
+
+	    // fall through intended
+	case 1: // don't save
+	    e->accept();
+	    break;
+
+	case 2: // cancel
+	    e->ignore();
+	    break;
+
+	default: break;
+	}
+    } else
+	e->accept();
+}
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h	2008-01-15 12:09:14.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h	2009-10-18 14:38:39.378535121 -0700
@@ -97,4 +97,5 @@
     QStyle *previewstyle;
     QStringList fontpaths;
+    QStringList inputMethodIdentifiers;
     bool modified;
 };
diff -r -U2 -N qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h.orig qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h.orig
--- qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ qt-x11-free-3.3.8b/tools/qtconfig/mainwindow.h.orig	2008-01-15 12:09:14.000000000 -0700
@@ -0,0 +1,103 @@
+/**********************************************************************
+** Copyright (C) 2000-2008 Trolltech ASA.  All rights reserved.
+**
+** This file is part of Qt Configuration.
+**
+** This file may be used under the terms of the GNU General
+** Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the files LICENSE.GPL2
+** and LICENSE.GPL3 included in the packaging of this file.
+** Alternatively you may (at your option) use any later version
+** of the GNU General Public License if such license has been
+** publicly approved by Trolltech ASA (or its successors, if any)
+** and the KDE Free Qt Foundation.
+**
+** Please review the following information to ensure GNU General
+** Public Licensing requirements will be met:
+** http://trolltech.com/products/qt/licenses/licensing/opensource/.
+** If you are unsure which license is appropriate for your use, please
+** review the following information:
+** http://trolltech.com/products/qt/licenses/licensing/licensingoverview
+** or contact the sales department at sales@trolltech.com.
+**
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with
+** the Software.
+**
+** This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
+** INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE. Trolltech reserves all rights not granted
+** herein.
+**
+**********************************************************************/
+
+#ifndef MAINWINDOW_H
+#define MAINWINDOW_H
+
+#include "mainwindowbase.h"
+
+
+class MainWindow : public MainWindowBase
+{
+    Q_OBJECT
+
+public:
+    MainWindow();
+    ~MainWindow();
+
+    void closeEvent(QCloseEvent *);
+
+
+public slots:
+    virtual void buildPalette();
+    virtual void buildFont();
+    virtual void tunePalette();
+    virtual void paletteSelected(int);
+    virtual void styleSelected(const QString &);
+    virtual void familySelected(const QString &);
+    virtual void substituteSelected(const QString &);
+    virtual void removeSubstitute();
+    virtual void addSubstitute();
+    virtual void downSubstitute();
+    virtual void upSubstitute();
+    virtual void removeLibpath();
+    virtual void addLibpath();
+    virtual void downLibpath();
+    virtual void upLibpath();
+    virtual void browseLibpath();
+    virtual void removeFontpath();
+    virtual void addFontpath();
+    virtual void downFontpath();
+    virtual void upFontpath();
+    virtual void browseFontpath();
+    virtual void fileSave();
+    virtual void fileExit();
+    virtual void somethingModified();
+    virtual void helpAbout();
+    virtual void helpAboutQt();
+    virtual void pageChanged(QWidget *);
+
+
+private:
+    void buildActive();
+    void buildActiveEffect();
+    void buildInactive();
+    void buildInactiveEffect();
+    void buildDisabled();
+    void buildDisabledEffect();
+
+    void updateColorButtons();
+    void updateFontSample();
+
+    void setPreviewPalette(const QPalette &);
+
+    void setModified(bool);
+
+    QPalette editPalette, previewPalette;
+    QStyle *previewstyle;
+    QStringList fontpaths;
+    bool modified;
+};
+
+
+#endif // MAINWINDOW_H

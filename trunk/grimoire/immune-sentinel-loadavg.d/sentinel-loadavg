#!/bin/bash
# Copyright 2012 by Kyle Sallee,
# All rights reserved.
# For use with the Sorcerer distribution only.

# sentinel-loadavg freezes the cast
# of the most recently started spell when loadavg becomes unreasonable.
# sentinel-loadavg unfreezes the cast
# of a spell that it froze when loadavg again becomes reasonable.

if   [ -n  "$1" ]
then LIMIT="$1"
else LIMIT=$( sed "/^processor/p;d" /proc/cpuinfo | wc -l )
 ((  LIMIT = LIMIT * 2 + 1 ))
fi

CG=
ICE=

LC_ALL=C
TERM="dumb"
IFS=" 	
"
export IFS LC_ALL TERM

SSC=slow/sorcery/cast

cgroup_load(){
 if   [ -f /lib/cgroup/functions ]
 then .    /lib/cgroup/functions
 fi
}

loadavg(){
 read LOADAVG < /proc/loadavg
 LOADAVG=${LOADAVG%% *}
 LOADAVG=${LOADAVG%%.*}
}

casting(){
 if ! [ -d /root/.sorcery/queue/cast ]; then return 1; fi
 
 for S in /root/.sorcery/cast/*; do
  if   [ -f $S ] &&
       [ -s $S ]
  then return
  else return 1
  fi
 done
}

newb(){
 ICE=$(
  find /root/.sorcery/queue/cast/ -type f -not -empty \
       -printf "%T@	%f\n" |
  sort -gr | head -n 1 | cut -f2
 )
 [ -n "$ICE" ]
}

ice(){ newb && echo FROZEN > $CG/$SSC/$ICE/freezer.state; }
thaw(){        echo THAWED > $CG/$SSC/$ICE/freezer.state; ICE=; }

try_thaw(){ loadavg; if (( LIMIT > LOADAVG )); then thaw; fi; }
try_ice(){  loadavg; if (( LIMIT < LOADAVG )); then ice; else return 1; fi; }

scan(){
 if   [ -n "$ICE" ]
 then            try_thaw;  sleep 60
 else casting && try_ice && sleep 60 || sleep 300
 fi
}

main(){
 trap : SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGSTOP SIGPIPE
 if   [[     -x /usr/libexec/bash/sleep ]]
 then enable -f /usr/libexec/bash/sleep sleep
 fi
 while :; do scan; done
}

if [ -f /etc/init.d/find_ir ]; then return 0; fi
cgroup_load
cgroup_find
main &>/dev/null &
exit 0

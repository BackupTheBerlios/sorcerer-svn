#!/bin/bash
# Copyright 2011 by Kyle Sallee,
# All rights reserved.
# For use with the Sorcerer distribution only.

# sentinel-space attempts to maintain free space

LOW=268435456
MIN=134217728

VC=/var/cache
AC=$VC/archive
CC=$VC/ccache
SC=$VC/sources

TAR='/\.tar$/p'
TGZ='/\.tar\.gz$/p;/\.tgz$/p'
BZ2='/\.tar\.bz2$/p'
FILES="$TAR;$TGZ;$BZ2"
LIM="${1:-10%}"

LC_ALL=C
TERM="dumb"
IFS=" 	
"
export IFS LC_ALL TERM

compressor(){
 case "$( file -bk "$1" )" in
      gzip*) echo gzip  ;;
     bzip2*) echo bzip2 ;;
  compress*) echo gzip  ;;
      *tar*) echo tar   ;;
 esac
}

decomp(){
 case $( compressor "$IN" ) in
  bzip2) bzip2 -cd  "$IN" > "$TMP" ;;
   gzip) gzip  -cd  "$IN" > "$TMP" ;;
    tar) ln         "$IN"   "$TMP" ;;
      *) false ;;
 esac
}

found(){ while read; do return ; done; return 1; }

rootname(){
 REPLY="${1%.bz2}"
 REPLY="${REPLY%.gz}"
 REPLY="${REPLY%.tar}"
 REPLY="${REPLY%.tgz}"
}

size(){ [ -f "$TMP" ] && stat -c "%s" $TMP ; }
doxz(){ xz -f -M $LIM --lzma2=dict=$( size ),mf=bt4,nice=273 "$TMP" ; }
rtmp(){ rm -f "$TMP" "$NEW"; false; }

recompress(){
 local IN OUT NEW TMP REPLY

 IN="$1"

 rootname "$1"
 TMP="$REPLY.tar.tmp"
 NEW="$REPLY.tar.tmp.xz"
 OUT="$REPLY.tar.xz"

 rm -f "$NEW" "$OUT" "$TMP"
 umask 0077
 decomp  &&
 doxz    ||
 rtmp
 umask 0022

 if [ -f "$NEW" ]; then
  mv "$NEW" "$OUT"
  chmod $( stat -c "%a" "$IN" ) "$OUT"
  touch -r "$IN" "$OUT"
  rm    -f "$IN" "$TMP" "$NEW"
 else false
 fi
}

pending(){ find $AC/ $CC/ $SC/ -maxdepth 4 -type f | sed -n "$FILES"; }
reduction(){ pending | while read; do recompress "$REPLY"; done; }

free_bytes(){ stat -f -c '%a*%s' $1 | bc; }

full(){
 if   [ -d $1 ] && (( $( free_bytes $1 ) < $2 ))
 then logger -p syslog.crit -s -t sentinel-space -- $"Low space on $1"
 else return 1
 fi
}

waste_locales(){
 ( locale -a |
   cut -d . -f1 |
   sort -u |
   sed 's:^:/usr/share/locale/:p' |
   sed -r 's:(.*)(_.*):\1\2\n\1:'
   find /usr/share/locale -maxdepth 1 -mindepth 1 -type d
 ) | sort | uniq -u | xargs -r --max-lines=256 rm -r
}

remove_file(){
 while read
 do if (( $( free_bytes $1 ) < $2 )); then rm -f $REPLY; fi
 done
}

compress_dir(){
 local TMP NEW
 while read; do
  if (( $( free_bytes $1 ) < $2 )); then
   TMP=$REPLY.tar
   NEW=$REPLY.tar.xz
   if   tar -c "$REPLY" > "$TMP" && doxz
   then rm -fr "$REPLY"   "$TMP"
   else rm -f  "$NEW"     "$TMP"
   fi
  fi
 done
}

inside(){
 find $1 -maxdepth 1 -mindepth 1 -type $2 -printf '%T@\t%p\n' |
 sort -gr |
 cut -f2
}

shrink_dir(){ [ -d $1 ] && inside $1 d | oldest | compress_dir "$@"; }
waste_file(){ [ -d $1 ] && inside $1 f | oldest | remove_file  "$@"; }

acad(){
 if [ -f /proc/acpi/ac_adapter/*/state ]; then local REPLY
  read < /proc/acpi/ac_adapter/*/state
  [[ $REPLY =~ on-line ]]
 fi
}

busy(){
 pgrep -u root "^xz$" ||
 pgrep -u root "^cast$"
}

scan(){
 if   [ -f /etc/init.d/find_ir ] || busy || ! acad
 then return 0
 fi

 # Compression tactics
 if full /usr/doc          $LOW; then shrink_dir /usr/doc          $LOW; fi
 if full /usr/share/doc    $LOW; then shrink_dir /usr/share/doc    $LOW; fi

 # Removal tactics
 if full /usr/share/locale $LOW; then waste_locales; fi
 if full /var/cache/ccache $LOW; then waste_file /var/cache/ccache $LOW; fi
 if full /usr/share/doc    $MIN; then waste_file /usr/share/doc    $MIN; fi
 if full /usr/doc          $MIN; then waste_file /usr/doc          $MIN; fi

 reduction
}

main(){
 trap : SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGSTOP SIGPIPE
 if   [[     -x /usr/libexec/bash/sleep ]]
 then enable -f /usr/libexec/bash/sleep sleep
 fi
 while sleep 900; do scan; done
}

main &>/dev/null &
exit 0

# EVMS Configuration file

# This file is a useable sample.
# Its location should be /etc/evms.conf
# It contains the default values which will be used in the absence of a
# configuration file or the absence of a configuration option being set.

# Global engine section
engine {
	mode		= readwrite

	# Possible values for debug_level in order are: critical, serious,
	# error, warning, default, details, entry_exit, debug, extra, everything
	#
	# The default value is "default".  Only log entries designated at the
	# debug_level or at a more severe level than the debug_level will be
	# printed to the log.  Thus, a debug_level of "default" will also log
	# critical, serious, error, and warning messages.  "critical" will
	# produce the smallest log, and "everything" will produce the largest
	# log.

	debug_level	= default

	log_file	= /var/log/evms-engine.log

	# Include microseconds in the log timestamps.  Default is "no".

#	log_usec	= yes

	# Include process IDs in the timestamps for log entries.  Default is
	# "no", unless the Engine is running in a clustered environment, in
	# which case PIDs are always included, since the Engine will have
	# several threads running.

#	log_pid		= yes

	# Open the log file with O_SYNC so that all writes to the log file
	# are guaranteed to be on the disk rather than just in cache.
	# Default is "no".

#	sync_log	= no

	# The directory where EVMS puts its metadata backup files.

	metadata_backup_dir	= /var/evms/metadata_backups

	# Save a backup of the metadata after each successful save of a
	# configuration change

#	auto_metadata_backup	= yes
}

# Settings if the Engine is opened in daemon mode
daemon {
	debug_level	= default	# Same settings as available for
					# engine.debug_level

	log_file	= /var/log/evms-daemon.log

	# Include microseconds in the log timestamps.  Default is "no".

#	log_usec	= yes

	# Include process IDs in the timestamps for log entries.  Default is
	# "no", unless the Engine is running in a clustered environment, in
	# which case PIDs are always included, since the Engine will have
	# several threads running.

#	log_pid		= yes

	# Open the log file with O_SYNC so that all writes to the log file
	# are guaranteed to be on the disk rather than just in cache.
	# Default is "no".

#	sync_log	= no
}


# Clustering section

clustering {

	# The number of seconds the engine/daemon should wait for a valid
	# cluster membership to show up.

	membership_timeout = 10
}


# Activation section
#
# Use this section to tell EVMS which volumes and objects should be activated.

activate {

	# Names of volumes and objects that should be activated.
	#
	# Names can be specified using "*", "?", and "[...]" notations.

	include = [   ]

	# Names of volumes and objects that should not be activated.
	#
	# Names can be specified using "*", "?", and "[...]" notations.

	exclude = [   ]
}


# Local disk manager sections

# Use this section to tell EVMS where to look for devices and which devices to
# include or exclude on a system without sysfs (i.e., 2.4 kernels). If you are
# using a 2.6 kernel, you'll likely want to see the "sysfs_devices" section
# instead of this one.

legacy_devices {

	# "scan" is the location of the dev node tree.

	scan = /dev

	# "directories" is any directories under the "scan" directory you want
	# searched recursively. On systems running devfs without devfsd, the
	# default settings will find all IDE and SCSI disks.

	directories = [ ide scsi dasd ]

	# "include" are the block devices found in the dev tree that you want
	# EVMS to use as disks.  By default, this will search for traditional
	# style device names (e.g., hda, sdb).  If you know the exact disks that
	# your system uses, you can specify them here to cut down on unnecessary
	# searching.
	#
	# If you are running devfs with devfsd, the default settings will find
	# the old-style names (eg. hda). If you wish to use the new-style names
	# (eg. ide/host0/bus0/target0/lun0/disc), simply remove "sd?" and "hd?"
	# from the list below. If you are running devfs without devfsd, the
	# new-style names will be used.
	#
	# Block device names can be specified using "*", "?", and "[...]"
	# notations.

	# include = [ hd? sd? dasd? disc ]
        include = [   ]

	# "exclude" are the block devices found in the dev tree that you don't
	# want EVMS to use as disks.  Entries here will override any possible
	# matches from the "include" setting.  Thus, if you specify "hd?" in
	# "include", and "hdc" in "exclude", EVMS will examine all IDE disks
	# except hdc.
	#
	# Block device names can be specified using "*", "?", and "[...]"
	# notations.

	exclude = [   ]

	# "max_open_disks" is the maximum number of disks that EVMS will have
	# open file-descriptors for while the engine is running. The allowable
	# range is 1 to 1024, and the default value is 64.

#	max_open_disks = 64
}

# Use this section to tell EVMS where to look for devices and which devices to
# include or exclude on a system with sysfs (i.e., 2.5 and later kernels).

sysfs_devices {

	# "include" are the block devices found in the /sys/block/
	# directory that you want EVMS to use as disks.
	#
	# Block device names can be specified using "*", "?", and "[...]"
	# notations.

	include = [   ]

	# "exclude" are the block devices found in the /sys/block/
	# directory that you don't want EVMS to use as disks.  Entries here
	# will override any possible matches from the "include" setting.
	#
	# Block device names can be specified using "*", "?", and "[...]"
	# notations.

	exclude = [   ]

	# "max_open_disks" is the maximum number of disks that EVMS will have
	# open file-descriptors for while the engine is running. The allowable
	# range is 1 to 1024, and the default value is 64.

#	max_open_disks = 64

	# "ignore_sysfs" will tell the disk plugin to ignore the sysfs_devices
	# section, and fall back to the legacy_devices section, even if sysfs
	# is available. The default is "no", which should be fine for almost
	# all users.

#	ignore_sysfs = no
}


# Cluster Segment Manager (CSM) section

csm {

	# Set admin_mode to yes when you wish to force the CSM to discover
	# objects from all cluster containers, allowing you to perform
	# configuration and maintenance.  Setting admin_mode to yes will cause
	# the CSM to ignore container ownership which will allow you to
	# configure storage in a maintenance mode.
	#
	# The default is no.

#	admin_mode = yes
}


# Multipath section
#
# Use this section to tell EVMS which paths in a multipath device should be
# treated only as "backup" paths. These paths will be activated in the kernel
# in a separate priority-group, and will only be used when all of the "normal"
# paths have failed.
#
# Each entry in this section should be the name of a multipath device on your
# system. The value for each entry should be the names of the child objects
# which should be treated as "backup" paths. Child objects which should be
# treated as "active" paths should not be listed here.
#
# Do not use any wildcard characters in this section.

multipath {
#	md/md0 = [ hdc ]
#	mp/lvm/vg1-pv1 = [ hdd ]
}


# LVM2 plugin section.

lvm2 {
	# Should the LVM2 plugin prompt you for confirmation when it finds
	# LVM2 metadata on an object, but the object does not pass the
	# necessary size checks? If yes, it will ask you if the object is
	# really an LVM2 PV. If no, it will assume the object is not a PV.
	#
	# If you have used EVMS to create an LVM2 container on top of an
	# MD Software-RAID region, you'll most likely want to set this
	# parameter to no.
	#
	# The default is yes.

	device_size_prompt = yes
}

# MD plugin section

md {
	# MD version 1 superblock feature exists in kernel 2.6.10 or later.
	# Before making the "Version 1 superblock create" option available,
	# the MD plugin checks the version of the running kernel to ensure
	# that MD version 1 superblock will be supported.  However, some
	# Linux distros may choose to port latest MD features into their
	# kernel whose base level is before 2.6.10 (e.g. 2.6.5-xxx).

	# If you know for sure that the MD driver can support MD version 1
	# superblock, set can_create_sb_1 to yes.  The default is no.

#	can_create_sb_1 = yes
}


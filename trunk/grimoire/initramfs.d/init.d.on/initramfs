#!/bin/bash
### BEGIN INIT INFO
# Provides: initramfs
# Required-Start: 
# Required-Stop:  $local_fs udev
# Default-Start: 
# Default-Stop: 0 6
# Short-Description: initramfs creates initramfs boot filesystems
### END INIT INFO

# Copyright 2007 by Kyle Sallee, all rights reserved.
# intiramfs script is for the Sorcerer distribution only

. /lib/lsb/init-functions

NAME=initramfs
T='	'

update_lilo(){
 lm(){
  grep -q    large-memory  $1 ||
  sed  -i '1ilarge-memory' $1
 }

 lm /etc/lilo.conf.head
 lm /etc/lilo.conf

 find /boot -maxdepth 2 -mindepth 2 -type f -name linux -printf '%h/initrf.gz\t%h/linux\n' |
 while read IRF IMG; do
  grep -q "$IRF" /etc/lilo.conf ||
  sed  -i   "s:$IMG$:$IMG\n${T}initrd$T$T=$T$IRF:" /etc/lilo.conf
 done
}


run_lilo(){ sync; /sbin/lilo -P ignore; }
mkinitrf(){

 gcpio(){
  INC="\,/lib/modules/$1$,p
       \,/lib/modules/$1/,p"
  OUT='\,^/lib/modules/,d'
  OLD="/boot/$1/initrf.gz"
  NEW="/tmp/initrf.gz.$$$RANDOM.new"
  OPS='-o -H newc --quiet'

  fail(){ rm -f $NEW; return 1; }

  echo -n  > $NEW
  chmod 0600 $NEW

  sed "$INC;$OUT" |
  if  ! cpio $OPS;        then fail; fi |
  if  ! gzip -1 > $NEW;   then fail; fi
  if  ! [    -s   $NEW ]; then fail; fi

  rm -f   $OLD
  mv $NEW $OLD
 }

 echo "$EVERY" | gcpio "$1"
}

every(){
 local KBD KEYMAPS LIB64

 exists(){ while read; do [[ -e $REPLY ]] && echo "$REPLY"; done; }

 if   [  -d   /usr/share/kbd/keymaps ]
 then KEYMAPS=/usr/share/kbd/keymaps
       KBD='1i/usr/share/kbd
            1i/usr/share/kbd/keymaps'
 fi

 if   [ -d  /lib64 ]
 then LIB64=/lib64
 fi

 find /bin /dev /etc /lib $LIB64 /sbin $KEYMAPS |
 sed "\
\,^/dev/pts/,d
\,^/dev/.udev,d
\,^/dev/shm/,d
\,^/etc/[^/]*.old,d
\,^/etc/sorcery/,d
\,^/etc/asciidoc/,d
\,^/etc/avahi/,d
\,^/etc/chipcard,d
\,^/etc/courier/,d
\,^/etc/cups/,d
\,^/etc/elvis.default/stubs/,d
\,^/etc/fonts/,d
\,^/etc/gconf/,d
\,^/etc/gdm/,d
\,^/etc/gtk/,d
\,^/etc/httpd/,d
\,^/etc/kde,d
\,^/etc/mono/,d
\,^/etc/mplayer/,d
\,^/etc/mtab/,d
\,^/etc/openldap/,d
\,^/etc/ppp/,d
\,^/etc/sane.d/,d
\,^/etc/sound/,d
\,^/etc/squid/,d
\,^/etc/ssh/,d
\,^/etc/ssl/,d
\,^/etc/xdg/,d
\,^/etc/bootblaze,d
\,^/etc/xml,d
\,^/lib.*\.la$,d
\,^/lib.*lib.*\.a$,d
\,^/sbin/sln$,d
1i/init
1i/media
1i/media/root
1i/proc
1i/sys
1i/usr
1i/usr/share
$KBD
1i/usr/share/terminfo
1i/usr/share/terminfo/l
1i/usr/share/terminfo/l/linux" | exists
}

initrf_update(){
 if   [  -f /boot/initrf.gz ]
 then rm -f /boot/initrf.gz
 fi

 [     -d       /media/root ] ||
 mkdir -pm 0755 /media/root

 EVERY="$( every )"

 update_lilo

 find /boot -maxdepth 2 -mindepth 2 -type f -name linux -printf '%h\n' |
 cut -d / -f3 |
 while read      VERSION
 do    mkinitrf $VERSION
 done

 run_lilo
}

initrf_present(){
 find /boot -maxdepth 2 -mindepth 2 -type f -name linux -printf '%h\n' |
 while read; do [ -f "$REPLY/initrf.gz" ] || return 1; done
}

initrf_current(){
 DIRS='/bin /etc/bash.d /etc/init.d /etc/lvm /etc/modules.d'
 DIRS+=' /etc/udev /lib /sbin'
 
 [ -d    /lib64 ] &&
 DIRS+=' /lib64'

 FILES='/etc/fstab /etc/hostname /etc/inittab'
 FILES+=' /etc/lilo.conf /etc/lilo.conf.head'
 FILES+=' /etc/modprobe.conf /etc/passwd /etc/shadow'

 OMIT='\,/etc/init.d/log,d'

 find /boot -mindepth 2 -mindepth 2 -type f -name initrf.gz -printf '%T@\t%p\n' |
 LC_ALL=C sort -g |
 while read JUNK REPLY; do
  find $DIRS $FILES -type f -newer $REPLY |
  sed "$OMIT" | grep -q . &&
  return 1 ||
  return
 done
}

on_cd(){
   if ! [ -d /boot/isolinux ] ; then return 1
 elif ! touch  /tmp/writeable ; then return
 else rm    -f /tmp/writeable ;      return 1
   fi 2>/dev/null
}

begin(){
 if   on_cd
 then return
 elif initrf_present &&
      initrf_current
 then return
 elif log_warning_msg "$NAME updating"; initrf_update
 then log_success_msg "$NAME updated"
 else log_failure_msg "$NAME failed"
  if   [ "$1" == stop ]
  then sulogin -t 300 &>/dev/console 0</dev/console
  fi
 fi
}

main(){
 log_warning_msg "$NAME checking"; begin "$1"
 log_success_msg "$NAME checked"
}

case $1 in
 stop) main stop ;;
    *) main ;;
esac

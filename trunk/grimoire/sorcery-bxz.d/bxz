#!/bin/bash
# Copyright 2008-2011 by Kyle Sallee,
# All rights reserved.
# For use with the Sorcerer distribution only.
# bxz recompresses tarballs using xz in the background,
# during periods of low loadavg, to conserve disk space

VC=/var/cache
AC=$VC/archive
CC=$VC/ccache
SC=$VC/sources

TAR='/\.tar$/p'
TGZ='/\.tar\.gz$/p;/\.tgz$/p'
BZ2='/\.tar\.bz2$/p'
FILES="$TAR;$TGZ;$BZ2"
PIDF=/var/run/bxz.pid
XZO="$1"

declare -i NEXT=900
declare -i LOW=2
LC_ALL=C
TERM="dumb"
IFS=" 	
"
export IFS LC_ALL TERM

ll(){
 read < /proc/loadavg
 REPLY=${REPLY%% *}
 REPLY=${REPLY%%.*}
 (( LOW > REPLY ))
}

decomp(){
 local REPLY
 compressor "$1"
 case "$REPLY" in
  bzip2) bzip2 -cd $1 ;;
   gzip) gzip  -cd $1 ;;
      *) cat       $1 ;;
 esac
}

found(){ while read; do return ; done; return 1; }

compressor(){
        REPLY="$( file -bk $1 )"
 case "$REPLY" in
      gzip*) REPLY=gzip  ;;
     bzip2*) REPLY=bzip2 ;;
  compress*) REPLY=gzip  ;;
      *tar*) REPLY=tar   ;;
 esac
}

rootname(){
 REPLY="${1%.bz2}"
 REPLY="${REPLY%.gz}"
 REPLY="${REPLY%.tar}"
 REPLY="${REPLY%.tgz}"
}

recompress(){
 local IN OUT TMP REPLY

 rtmp(){ rm -f "$TMP"; }
 uncompr(){         if ! decomp "$IN"; then rtmp; fi; }
 xz_it(){ uncompr | if ! xz $XZO > "$TMP"; then rtmp; fi; }

 IN="$1"

 rootname "$1"
 OUT="$REPLY.tar.xz"
 TMP="$OUT.new"

 rm -f "$OUT" "$TMP"
 umask 0077
 xz_it
 umask 0022

 if [[ -f $TMP ]]; then
  mv "$TMP" "$OUT"
  chmod $( stat -c "%a" "$IN" ) "$OUT"
  touch -r "$IN" "$OUT"
  rm    -f "$IN"
 else false
 fi
}

ima(){ local REPLY; acad && ll; }
pending(){ find $AC/ $CC/ $SC/ -maxdepth 4 -type f | sed -n "$FILES"; }
owari(){ [[ -z $( pending ) ]]; }
reduction(){ pending | while read && ima; do recompress "$REPLY"; done; }

locked(){
 local LEN STATUS LINE LPID

 [[ -n $1 ]] && [[ -f $1 ]] &&
 [[ -n $2 ]] && LEN=${#2} &&
 read LPID < $1 &&
 STATUS="/proc/$LPID/status" &&
 [[  -f      $STATUS ]] &&
 read LINE < $STATUS &&
 [ "${LINE:6:$LEN}" == "$2" ]
}

lock_bxz(){
 locked       $PIDF bxz &&
 kill -15 $(< $PIDF ); sleep 0.1
 echo  $!   > $PIDF
 disown
}

acad(){
 if [ -f /proc/acpi/ac_adapter/*/state ]; then
  read < /proc/acpi/ac_adapter/*/state
  [[ ${REPLY// /} == state:on-line ]]
 fi
}

idle_cgroup_join(){
 local DC=/dev/cgroup
 local CI=$DC/idle
 if ! [ -d  $CI ]; then
  mkdir -p  $CI
  cat       $DC/cpuset.cpus > $CI/cpuset.cpus
  cat       $DC/cpuset.mems > $CI/cpuset.mems
  echo 1  > $CI/cpu.shares
  echo 1  > $CI/blkio.weight
  echo 99 > $CI/memory.swappiness
 fi

 echo $BASHPID > $CI/tasks
}

main(){
 trap : SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGSTOP SIGPIPE
 while sleep 600; do if owari; then rm -f $PIDF; exit 0; elif ima; then reduction; fi; done
}

if   [ -f /etc/init.d/find_ir ] || grep -q "boot=IR" /proc/cmdline
then exit 1
fi

idle_cgroup_join

[[ -f     /usr/libexec/bash/sleep ]] &&
enable -f /usr/libexec/bash/sleep sleep

main 1>>/var/log/bxz 2>&1 &
lock_bxz

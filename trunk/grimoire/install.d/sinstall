#!/bin/bash
############################################################
# Copyright 2001 through 2008 by Kyle Sallee,              #
# all rights reserved                                      #
# and may not be reditribute in modified form without      # 
# prior writen permission of Kyle Sallee                   #
# It may only be used for installing Sorcerer              #
############################################################
# sorcerer.install menu driven process of for installing   #
# installing the Sorcerer Install/Rescue ISO               #
############################################################


inputbox(){ $DIALOG --nocancel --inputbox "$1" 0 0 "$2"; }


chroot_run(){
 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon  -a
 chroot $TARGET "$@"
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
}


chroot_build(){
 scry_finish(){
  while ls     $TARGET/root/.sorcery/queue/cast | grep -q "."
  do    chroot $TARGET augur scry
  done
 }

 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon -a
 chroot $TARGET dispel install
 chroot $TARGET cast "$@"
 scry_finish
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
}


confirm(){ $DIALOG $2 --yesno "$1" 8 50; }


goodbye(){
 if   [ "$PMOUNTED" == true ]
 then filesystem_unmount
 fi

 if   confirm "Reboot now?" --defaultno
 then shutdown -r now
 fi
 exit  0
}

list_disk(){ find /dev -group disk -printf "%p	disk\n" | sed "/[0-9]/d"; }
list_bb()  { find /dev -type b -printf "%p	%y\n"   | sed '\,^/dev/loop,d;\,^/dev/mapper/,d'; }
get_disk() { $DIALOG --title $"Please select disk"       --menu "" 0 0 0 $( list_disk ); }

get_bb(){
 for ((CX=0;CX<MP;CX++)); do if [[ ${PMOUNT[$CX]} == /boot ]]; then BB=$CX; return; fi; done
 for ((CX=0;CX<MP;CX++)); do if [[ ${PMOUNT[$CX]} == /     ]]; then BB=$CX; return; fi; done
}


boot_dev_check(){
 if   [     "${PDEVICE[$1]:0:12}" == /dev/mapper/ ] &&
      [      "${PMOUNT[$1]}"      == /boot        ] &&
    ! [ "${PFILESYSTEM[$1]}"      == ext2         ]
 then
  $DIALOG --msgbox "/boot must be ext2 and can not be a mapped device" 8 50
       PMOUNT[$1]=
  PFILESYSTEM[$1]=
 fi
}


get_filesystem(){

 local EXT2 EXT3 JFS XFS REISER SWAP DEFAULT

   EXT2="Second Extended             file system"
   EXT3="Second Extended  journaling file system"
    JFS="JFS              journaling file system"
    XFS="XFS              journaling file system"
 REISER="Reiserfs         journaling file system"
   SWAP="Swap"

 case "${PMOUNT[$1]}" in
  /boot) DEFAULT=ext2 ; echo ext2; return ;;
   none) DEFAULT=swap ;;
      *) DEFAULT=ext3 ;;
 esac

 $DIALOG \
 --title $"Filesystem Selection Menu" \
 --default-item "$DEFAULT" \
 --menu $"Please select a filesystem" 0 0 0 \
 ext2 "$EXT2" ext3 "$EXT3" jfs "$JFS" \
 reiserfs "$REISER" xfs "$XFS" swap "$SWAP"
}


fdisc(){
 $DIALOG \
 --title $"Partitioning Menu" --no-cancel \
 --menu  $"Select a partitioning program" 0 0 0 \
 cfdisk "" fdisk "" parted ""
}


run_partition(){
 if   launch $( fdisc ) $( get_disk )
 then PARTITION=true
 fi
 filesystem_table_load
}


run_mbr(){ ms-sys -s $( get_disk ); MBR=true; }


get_mount(){
 local      PLEASE="Please enter a mount point"
 inputbox "$PLEASE" "${PMOUNT[$1]}"
 boot_dev_check "$1"
}

get_device(){
 get_part       "$1"
 boot_dev_check "$1"
}

list_swaps(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ "${PFILESYSTEM[$CX]}" == swap ]
  then echo  "${PDEVICE[$CX]} none swap defaults 0 0"
  fi
 done
}

fstab_line(){
 if   [[   ${PFILESYSTEM[$1]} == swap ]] || [[ -n $2 ]]
 then echo -n "${PDEVICE[$1]}${TAB}"
 else
  if ! [[ -n   ${PUUID[$1]} ]];then
   pvcreate "${PDEVICE[$1]}" &>/dev/null
   PUUID[$1]=$( blkid ${PDEVICE[$1]} 2>/dev/null | cut -d '"' -f2 )
  fi
  echo -n "UUID=${PUUID[$1]}${TAB}"
 fi
 echo -n "${PMOUNT[$1]:-none} "
 echo -n "${PFILESYSTEM[$1]:-unknown} "
 echo -n "${POPTIONS[$1]} "
 echo -n "${PDUMP[$1]} "
 echo    "${PORDER[$1]}"
}


make_fstab(){
 echo "# Real file systems"
 list_mounts | LC_ALL=C sort | cut -f2 |
 while read          CX
 do    fstab_line  "$CX"
 done | tr ' ' '\t'
 echo; echo
 echo "# Swap"
 list_swaps
 echo; echo
 cat /etc/fstab.empty
}


make_bootloader_conf(){

 cp $BL_CONF.new $BL_CONF

 get_bb

# PUUID might not be assigned, although device does have UUID
#echo "boot${TAB}${TAB}${TAB}=${TAB}/dev/disk/by-uuid/${PUUID[$BB]}" >> $BL_CONF

 # To update /dev/disk/by-uuid/
 /etc/init.d/udevtrigger start

 UUID=$( blkid ${PDEVICE[$BB]} 2>/dev/null | cut -d '"' -f2 )
 echo "boot${TAB}${TAB}${TAB}=${TAB}/dev/disk/by-uuid/$UUID" >> $BL_CONF

 BBDEV=${PDEVICE[$BB]}

 MESSAGE="${BOOTLOADER} will be installed to boot block: $BBDEV"
 $DIALOG --msgbox "$MESSAGE" 8 50

 sfdisk ${BBDEV:0:8} -A ${BBDEV:8:2}
 mbr_check
}


transfer_arch(){
 BUFFER=$( inputbox "Please enter buffer size or press enter" "64m" )

 if   [[ -d $TARGET/var/cache ]]
 then mv    $TARGET/var/cache $TARGET/var/cache.old
 fi

 cd /
 rm    -vfr                    $TARGET/{bin,dev,etc,lib,lib64,sbin,tmp,usr,var}
 mkdir -vpm 755                $TARGET/{dev,etc,home,media/{cdrom,floppy,root},proc,sys,tmp,var/cache/archive}
 mkdir -vpm 700                $TARGET/etc/sorcery/log/{config,opt.{on,off},provide}
 chmod -v  1777                $TARGET/tmp
 cp    -va dev etc init root   $TARGET
 rm    -f                      $TARGET/etc/init.d/log.d/*
 cp    -va     etc/skel        $TARGET/root
 chmod -v   700                $TARGET/root
 if   [  -d  /media/IR/$HOSTTYPE/boot ]
 then cp -va /media/IR/$HOSTTYPE/boot \
                               $TARGET
 else cp -va /media/IR/boot    $TARGET
 fi
 cp    -av /media/IR/var/cache/sources \
                               $TARGET/var/cache/
 rm    -fr                     $TARGET/boot/isolinux
 cp    -va /media/IR/var/cache/archive/*-$HOSTTYPE-*.tar.7z \
             $TARGET/var/cache/archive/
 mkdir -vpm 755                $TARGET/lib/udev
 cp    -va /lib/udev/dev       $TARGET/lib/udev/

 find $TARGET/var/cache/archive -type f |
 while read
 do 7za x -bd -so "$REPLY"
 done 2>/dev/null |
 bfr -b $BUFFER |
 tar -C $TARGET -ixvpf - 2>&1 |
 sed '/tar: /d'

 make_fstab > $TARGET/etc/fstab
 read -n 1 -t 900 -p "Press space to continue."
 $DIALOG --msgbox $"Files transferred." 8 50
 ARCH_DONE=true
}


select_extra_spells(){
 HELP="
The sources CD contains sources for software
that may be useful or required for networking.
Please select software that will also be compiled and installed.
Any of this software can also be installed after the first boot
should you decide later that they will be required."

 show_extra(){
  ( find $TARGET/var/cache/sources -maxdepth 1 -type d -printf "%P\n"
    echo "$REQUIRED_SPELLS"
    echo "$REQUIRED_SPELLS"
  ) | LC_ALL=C sort | uniq -u | grep -vx "" |
  while read; do
   echo "$REPLY"
   echo "Optional"
   echo "off"
  done
 }


 $DIALOG \
  --title "Additional Software Selection" \
  --nocancel --ok-label "Commit" --separate-output \
  --checklist "$HELP" 0 0 0 $( show_extra )
}


editor_menu(){
 local      TITLE="Text Editor Selection Menu"
 local  NANO_HELP="nano is a very easy to use text editor."
 local ELVIS_HELP="elvis is a clone vi/en editor."
 local  ZILE_HELP="zile is a small, fast and powerful emacs clone."

 EDITOR=$(
  $DIALOG \
  --title $"Text Editor Selection Menu" --item-help --default-item nano \
  --menu  $"Please select a text editor" 0 0 0 \
  nano "" "$NANO_HELP" elvis "" "$ELVIS_HELP" zile "" "$ZILE_HELP" )
 export EDTIOR
}


edit(){
 [ -n "$EDITOR" ] || editor_menu
 $EDITOR "$1"
}


edit_fstab(){
 if   [ -f $TARGET/etc/fstab ]
 then edit $TARGET/etc/fstab
 else $DIALOG --msgbox $"Transfer first." 8 50
 fi
}


get_options(){
 local DEFAULT_OPTIONS

 case ${PFILESYSTEM[$1]} in
      swap) DEFAULT_OPTIONS="defaults"                     ;;
  reiserfs) DEFAULT_OPTIONS="defaults,notail,noatime"      ;;
       jfs) DEFAULT_OPTIONS="defaults,noatime"             ;;
      ext3) DEFAULT_OPTIONS="defaults,noatime,commit=3600" ;;
       xfs) DEFAULT_OPTIONS="defaults,noatime"             ;;
      ext2) DEFAULT_OPTIONS="defaults,noatime"             ;;
 esac

 case ${PMOUNT[$1]} in
  /tmp) [ "${PFILESYSTEM[$1]}" == ext3 ] &&
        DEFAULT_OPTIONS="defaults,noatime,commit=864000" ;;
 esac

 if   [ -n "$DEFAULT_OPTIONS" ]
 then inputbox "Please enter mount options" "$DEFAULT_OPTIONS"
 fi
}


get_size(){
 inputbox "Please enter size in megabytes" "${PSIZE[$1]:-256}"
}

get_password(){
 local KEY

 if   [ -z      "${PDEVICE[$1]}" ]; then $DIALOG --msgbox "Please set device first." 8 50; return 1; fi
 if   [ -z  "${PFILESYSTEM[$1]}" ]; then $DIALOG --msgbox "Please set filesystem type first." 8 50; return 1; fi
 if   [ /boot == "${PMOUNT[$1]}" ]; then $DIALOG --msgbox "/boot can not be encrypted." 8 50; return 1; fi
 if   [     "${PFILESYSTEM[$1]}" == swap ]
 then confirm $"Encrypted swap?" --defaultno && KEY=$RANDOM
 else KEY="$( inputbox "Please enter a password for key 0" )"
 fi

 if   [ -z "$KEY" ]; then
  if  [ /dev/mapper/luks- == "${PDEVICE[$1]:0:17}" ]; then
   cryptsetup luksClose       ${PDEVICE[$1]##*/}
  fi
 else echo "$KEY"
  if  [ /dev/mapper/luks- ==   "${PDEVICE[$1]:0:17}" ]; then
      [ -b          /dev/mapper/${PDEVICE[$1]#*-} ] &&
       PDEVICE[$1]="/dev/mapper/${PDEVICE[$1]#*-}"  ||
              PDEVICE[$1]="/dev/${PDEVICE[$1]#*-}"
  fi

  echo          cryptsetup -c aes-xts-plain -s 512 luksFormat ${PDEVICE[$1]} 1>&2
  echo "$KEY" | cryptsetup -c aes-xts-plain -s 512 luksFormat ${PDEVICE[$1]}
  echo          cryptsetup luksOpen ${PDEVICE[$1]} luks-${PDEVICE[$1]##*/} 1>&2
  echo "$KEY" | cryptsetup luksOpen ${PDEVICE[$1]} luks-${PDEVICE[$1]##*/}
  pause
 fi
}


get_feature(){
 local FEATURE

 if [ -z "${PFEATURE[$1]}" ]; then
  case "${PFILESYSTEM[$1]}" in
   ext*) FEATURE="dir_index,filetype,sparse_super" ;;
  esac
 fi
 FEATURE="$( inputbox "Please enter optional features" "$FEATURE" )"
 if   [ -n "$FEATURE" ]
 then echo "-O	$FEATURE"
 fi
}


get_check(){

 check_type(){
  echo "Skip"
  echo "Do not check device for bad blocks"

  case  "${PFILESYSTEM[$1]}"  in
   jfs)  echo RO
         echo "Check for bad blocks before creating the file system" ;;
   swap) if [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
          echo RO
          echo "Check for bad blocks before creating the swap space"
         fi ;;
   ext*) echo RO
         echo "Adequate read only checking for new drives"
         echo RW
         echo "Appropritate read write checking for older drives." ;;
  esac
 }


 if   [ -z "${PFILESYSTEM[$1]}" ]; then $DIALOG --msgbox "Please set filesystem type first." 8 50; return 1
 elif [ -z "${PDEVICE[$1]}"     ]; then $DIALOG --msgbox "Please set device first." 8 50; return 1
 fi

 CHECK=$(
  $DIALOG \
   --title $"Filesystem Check Menu" --default-item Skip \
   --menu "Please select desired checking" 0 0 0 $( check_type "$1" ) )

 case $CHECK in
  RO) echo "-c"		;;
  RW) echo "-c	-c"	;;
 esac
}


get_dump(){
 if   confirm "Should it be dumped?" "--defaultno"
 then echo 1
 else echo 0
 fi
}


get_check_order(){

 local HELP TITLE CO=0

 TITLE=$"fsck check order menu"
 HELP=$"Journaling file systems do not require fsck checking
when booting if the they were not properly unmounted 
on the previous boot.  However non journaling file 
systems do require checking.  The root partition 
should be checked first, and all other partitions second."

 case ${PFILESYSTEM[$1]} in
  ext2) if [ "$1" == 0 ]; then CO=1; else CO=2; fi ;;
 esac

 $DIALOG \
 --title $"fsck check order menu" --default-item "$CO" --menu "" 0 0 0 \
 0 "No check required" 1 "Check on first pass" 2 "Check on second pass"
}


show_pinfo(){
 echo "device"
 echo "mount filesys options d o"
 for (( CX=0; CX<MP; CX++ )); do
  if    [ -n "${PDEVICE[$CX]}" ]; then
   echo   -n  "${PMOUNT[$CX]:-none}	"
   fstab_line          "$CX" $1
  fi
 done | LC_ALL=C sort | cut -f2- | tr '\t' '\n'
}


get_pcx(){
 if   [ -z "$1"           ]; then false
 elif [    "$1" == device ]; then
  for (( CX=0; CX<MP; CX++ )); do
   if   [ -z "${PDEVICE[$CX]}" ]
   then echo           "$CX"; break
   fi
  done
 else
  for (( CX=0; CX<MP; CX++ )); do
   if   [ "${PDEVICE[$CX]}" == "$1" ]
   then echo        "$CX"; break
   fi
  done
 fi
}


show_pinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if  [ -n      "${PMOUNT[$CX]}"              ] ||
      [    "${PFILESYSTEM[$CX]}"     == swap  ]; then
   if [        "${PDEVICE[$CX]:0:5}" == /dev/ ]; then
      fstab_line         "$CX" "dev"
      echo off
   fi
  fi
 done | tr '\t' '\n'
}


show_sinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ -n    "${PSIZE[$CX]}"              ] &&
       [ "${PFILESYSTEM[$CX]}"     == swap  ] &&
     ! [     "${PDEVICE[$CX]:0:5}" == /dev/ ]; then
   fstab_line          "$CX"
   echo off
  fi
 done | tr '\t' '\n'
# | column -t
}


root_device(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ / == "${PMOUNT[$CX]}" ]
  then echo  "${PDEVICE[$CX]}"; break
  fi
 done
}

empty_entry(){
#    PDEVICE[$1]=
#      PUUID[$1]=
      PMOUNT[$1]=
     PRMOUNT[$1]=
#PFILESYSTEM[$1]=
    POPTIONS[$1]=
       PDUMP[$1]=
      PORDER[$1]=
    PFEATURE[$1]=
      PCHECK[$1]=
   PPASSWORD[$1]=
}


filesystem_table(){

 pselect(){
  $DIALOG --ok-label Select --cancel-label Done \
   --title $"Filesystem Table Menu" \
   --menu  $"Filesystems with mount point of none are ignored unless swap." 0 70 12 $( show_pinfo dev )
 }

 pempty(){
  if   confirm $"Please confirm removal of this entry?" --defaultno;
  then empty_entry "$1"
  fi
 }


 check_pentry(){
  if [ -z "${PDEVICE[$1]}"     ] ||
     [ -z "${PFILESYSTEM[$1]}" ] ||
     [ -z "${PMOUNT[$1]}"      ] ||
     [ -z "${POPTIONS[$1]}"    ] ||
     [ -z "${PDUMP[$1]}"       ] ||
     [ -z "${PORDER[$1]}"      ]; then
   $DIALOG --msgbox $"Essential fields are missing. Emptying entry." 8 50
   empty_entry "$1"
   false
  fi
 }


 modify_pentry(){

  if   [ -z "$1" ]
  then false
  else
   local COMMAND TITLE EHELP HELP

   TITLE=$"Filesystem entry menu"
    HELP=$"Please visit every menu item except the Empty All Fields"

   while
    if  [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
     COMMAND=$(
      $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
       --title "$TITLE" \
       --menu  "$HELP" 20 60 15 \
       Device         "${PDEVICE[$1]}" \
       Filesystem "${PFILESYSTEM[$1]}" \
       Mount           "${PMOUNT[$1]}" \
       Options       "${POPTIONS[$1]}" \
       Dump             "${PDUMP[$1]}" \
       Order           "${PORDER[$1]}" \
       Feature       "${PFEATURE[$1]}" \
       Check           "${PCHECK[$1]}" \
       Encryption   "${PPASSWORD[$1]:+yes}" \
       Empty      "All fields removing entry" )
    else
     COMMAND=$(
      $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
       --title "$TITLE" \
       --menu  "$HELP" 20 60 15 \
       Device         "${PDEVICE[$1]}" \
       Filesystem "${PFILESYSTEM[$1]}" \
       Mount           "${PMOUNT[$1]}" \
       Options       "${POPTIONS[$1]}" \
       Dump             "${PDUMP[$1]}" \
       Order           "${PORDER[$1]}" \
       Size             "${PSIZE[$1]}" \
       Check           "${PCHECK[$1]}" \
       Empty      "All fields removing entry" )
    fi
   do
    case $COMMAND in
     Empty)      pempty "$1"					;;
     Device)         PDEVICE[$1]=$( get_device      "$1" )	;;
     Filesystem) PFILESYSTEM[$1]=$( get_filesystem  "$1" )	;;
     Mount)           PMOUNT[$1]=$( get_mount       "$1" )	;;
     Options)       POPTIONS[$1]=$( get_options     "$1" )	;;
     Dump)             PDUMP[$1]=$( get_dump        "$1" )	;;
     Order)           PORDER[$1]=$( get_check_order "$1" )	;;
     Size)             PSIZE[$1]=$( get_size        "$1" )	;;
     Feature)       PFEATURE[$1]=$( get_feature     "$1" )	;;
     Check)           PCHECK[$1]=$( get_check       "$1" )	;;
     Encryption)   PPASSWORD[$1]=$( get_password    "$1" )	;;
    esac

    DV=/dev
    DM=/dev/mapper
    DML=/dev/mapper/luks-

    if   [ -n       "${PPASSWORD[$1]}" ]; then
         [ $DML ==   "${PDEVICE[$1]:0:17}" ] ||
     PDEVICE[$1]="$DML${PDEVICE[$1]##*/}"
    elif [ $DML ==   "${PDEVICE[$1]:0:17}" ]; then
     [ -b         $DM/${PDEVICE[$1]#*-} ] &&
     PDEVICE[$1]="$DM/${PDEVICE[$1]#*-}"  ||
     PDEVICE[$1]="$DV/${PDEVICE[$1]#*-}"
    fi

    case "${PFILESYSTEM[$1]}" in
     swap)    PDUMP[$1]=0
             PMOUNT[$1]=none
           POPTIONS[$1]=default
             PORDER[$1]=0 ;;
     ext*) PFEATURE[$1]="${PFEATURE[$1]:--O	dir_index,filetype,sparse_super}" ;;
    esac

  done
  check_pentry "$1" &&
  PRMOUNT[$1]="$TARGET${PMOUNT[$1]}"
 fi
}


 check_root_defined(){
  root_device | grep -q . ||
  $DIALOG --msgbox $"/ Root filesystem required!" 18 65
 }


 local HELP="The following menu is for specifying filesystems
to mount prior to transfering sorcerer.
The information prompted for corresponds
to the fields on a line in /etc/fstab
man fstab in separate virtual console if needed."

 $DIALOG --msgbox "$HELP" 18 65
 while modify_pentry $( get_pcx $( pselect ) ); do : ; done
 check_root_defined
 true
}


select_partitions_to_initialize(){

  local HELP=$"Select Partitions to initialize.
All data on selected partitions will be lost.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title $"Partition Initialization Selection Menu" \
  --checklist "$HELP" 18 74 8 $( show_pinfo_init )
}


select_swapfile_to_initialize(){

  local  TITLE  HELP

   HELP=$"If swapfiles have not been created and initialized
then now is the time to do so.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title $"Swapfile Initialization Selection Menu" \
  --checklist "$HELP" 18 74 8 $( show_sinfo_init )
}


installed_fs(){

 check_jfs(){ dd if=$1 bs=64k count=1 2>/dev/null | grep -q JFS1 && echo jfs; }

 case $( file -k - < $1 ) in
  *swap\ file*)		echo  swap	;;
  *ext3\ filesystem*)	echo  ext3	;;
  *ext2\ filesystem*)	echo  ext2	;;
  *SGI\ XFS*)		echo  xfs	;;
  *ReiserFS*)		echo  reiserfs	;;    
  *FAT*)		echo  fat	;;
  *stdin:\ data*)  	check_jfs "$1"	;;
 esac
}

pipe(){ cat -; "$@"; }
uniqs(){  LC_ALL=C sort | uniq -u; }
dups(){   LC_ALL=C sort | uniq -d; }

lv(){       lvs --noheadings -o lv_name       $1 | tr -d ' '; }
pv_in_vg(){ vgs --noheadings -o pv_name       $1 | tr -d ' '; }
pv(){       pvs --noheadings -o pv_name          | tr -d ' '; }
vg(){       vgs --noheadings -o vg_name          | tr -d ' '; }
vg_free(){  vgs --noheadings -o vg_free_count $1 | tr -d ' '; }
vg_lv(){    vgs --noheadings -o vg_name,lv_name  |
            sed 's:^ *::;s: :/:'                 | tr -d ' '; }
            

apvs(){     pv_in_vg | sed p | pipe pv | uniqs; }

ppv(){
 pv | sed p | pipe \
 find /dev -type b |
 sed '\,^/dev/loop,d;\,^/dev/mapper/,d;\,[0-9],p;d' | uniqs
}

ppv_to_pv(){ ppv | xargs -r --max-lines=16 pvcreate; }


filesystem_table_load(){
 local CX PART

     PDEVICE[0]=/swap
 PFILESYSTEM[0]=swap
    POPTIONS[0]=defaults
       PDUMP[0]=0
      PORDER[0]=0
      PMOUNT[0]=none
       PSIZE[0]=256

 (( CX = 1 ))

 for PART in $( list_part ); do

      PDEVICE[$CX]="$PART"
        PUUID[$CX]=$( blkid $PART 2>/dev/null | cut -d '"' -f2 )
  PFILESYSTEM[$CX]="$( installed_fs $PART )"
     POPTIONS[$CX]="defaults,noatime"
        PDUMP[$CX]=0
       PORDER[$CX]=0

  case "${PFILESYSTEM[$CX]}" in
   ext2)   PORDER[$CX]=1	;;
   ext3)   PORDER[$CX]=1	;;
   ext4)   PORDER[$CX]=1	;;
   swap) POPTIONS[$CX]=defaults	;;
  esac

  (( CX++ ))
 done

 for (( ; CX<MP; CX++ )); do empty_entry "$CX"; done
}


get_mk_command(){
 file_or_part(){
  case ${PDEVICE[$1]:0:5} in
   /dev/) echo "mkswap	${PCHECK[$1]}	${PDEVICE[$1]}" ;;
       *) echo "dd	of=$TARGET${PDEVICE[$1]}	if=/dev/zero	bs=1M	count=${PSIZE[$1]}	&&${LF}mkswap	$TARGET${PDEVICE[$1]}	&&${LF}chmod	0	$TARGET${PDEVICE[$1]}" ;;
  esac
 }

 case ${PFILESYSTEM[$1]} in
      ext2) echo "mkfs.ext2	${PCHECK[$1]}	${PFEATURE[$1]}	${PDEVICE[$1]}" ;;
      ext*) echo "mkfs.ext3	${PCHECK[$1]}	${PFEATURE[$1]}	${PDEVICE[$1]}" ;;
  reiserfs) echo "mkreiserfs	-f	${PDEVICE[$1]}" ;;
       xfs) echo "mkfs.xfs	-f	${PDEVICE[$1]}" ;;
       jfs) echo "jfs_mkfs	-q	${PCHECK[$1]}	${PDEVICE[$1]}" ;;
      swap) file_or_part "$1" ;;
 esac
}


initialize(){

 local SURE SUCCESS FAILURE COMMAND

 SURE="Please confirm it is okay that all data on  ${PDEVICE[$1]} is lost?"
 SUCCESS="${PFILESYSTEM[$1]} successfully created on ${PDEVICE[$1]}"
 FAILURE="No success at creating ${PFILESYSTEM[$1]} on ${PDEVICE[$1]}"

 if confirm "$SURE" --defaultno; then
                 COMMAND="$( get_mk_command "$1" )"
  if   confirm "$COMMAND" --defaultno &&
       eval    "$COMMAND"
  then sleep  3; $DIALOG --msgbox "$SUCCESS" 8 50
  else sleep 10; $DIALOG --msgbox "$FAILURE" 8 50; return 1
  fi
 fi
}


filesystem_initialize(){
 local PART

 [ -n "${PDEVICE[1]}"  ]  &&
 for PART in $( select_partitions_to_initialize )
 do  initialize $( get_pcx "$PART" )
 done
}


swapfile_initialize(){
 local SWAP

 [ -n "${PDEVICE[1]}" ] &&
 for SWAP in $( select_swapfile_to_initialize )
 do  initialize $( get_pcx "$SWAP" )
 done
}


list_mounts(){
 for (( CX=0; CX<MP; CX++ )); do
  if     [ -n       "${PMOUNT[$CX]}" ] &&
       ! [ none ==  "${PMOUNT[$CX]}" ]
  then echo         "${PMOUNT[$CX]}	$CX"
  fi
 done
}


filesystem_mount(){

 local ALREADY NOT_NOW SUCCESS FAILED

 ALREADY=$"Partitions are already mounted."
 NOT_NOW=$"No partitions to mount, yet."
 SUCCESS=$"successfully mounted"
  FAILED=$"failed mounting"

 if   [[ $PMOUNTED == true ]]; then $DIALOG --msgbox "$ALREADY" 8 50; false
 elif [ -z "${PMOUNT[*]}"   ]; then $DIALOG --msgbox "$NOT_NOW" 8 50; false
 else
  list_mounts | LC_ALL=C sort | cut -f2 |
  while read CX; do
   if mkdir -p     ${PRMOUNT[$CX]} &&
      mount -t ${PFILESYSTEM[$CX]} \
            -o  ${POPTIONS[$CX]} \
                ${PDEVICE[$CX]} \
                ${PRMOUNT[$CX]}
   then          $DIALOG --msgbox "${PRMOUNT[$CX]} $SUCCESS" 8 50
   else sleep 5; $DIALOG --msgbox "${RPMOUNT[$CX]} $FAILED"  8 50
   fi
   if   [ -d      $TARGET/tmp ]
   then chmod 1777 $TARGET/tmp
   fi
  done
  swapfile_initialize
  PMOUNTED=true
 fi
}

trans(){ [[ -f $TARGET/etc/fstab ]]; }

mbr_check(){
 if [[ -n $MBR ]]; then return; fi
 if [[ -n $BB  ]] && echo "$BB" | grep -q '[a-z]$'; then return; fi
 if confirm "Install a bootable MBR?"; then run_mbr; fi
}


filesystem_unmount(){

 local ALREADY NOT_NOW SURE SUCCESS FAILED

 SUCCESS=$"successfully unmounted"
  FAILED=$"failed unmounting"
 ALREADY=$"Partitions are not mounted."

  SURE=$"Partitions must be mounted to transfer 
Sorcerer and continue installation.
Really unmount the currently mounted partitions?"

 if   ! [[ $PMOUNTED == true ]]
 then $DIALOG --msgbox "$ALREADY" 8 50; false
 else
  if trans || confirm "$SURE" --defaultno; then
   list_mounts | LC_ALL=C sort -r | cut -f2 |
   while read CX; do
    if   umount ${PRMOUNT[$CX]}
    then          $DIALOG --msgbox "${PRMOUNT[$CX]} $SUCCESS" 8 50
    else sleep 5; $DIALOG --msgbox "${PRMOUNT[$CX]} $FAILED"  8 50
    fi
   done
   PMOUNTED=false
  fi
 fi
}


confirm_unmount(){
 local NOT_YET="
Until the install image is transfered
and compilation of initramfs is completed
the filesystems should remain mounted.

However to modify the filesystem table, create,
initialize and/or mount more file systems
then the currently mounted filesystems must be unmounted first."

 $DIALOG --msgbox "$NOT_YET" 20 70
 if   confirm "Really Unmount filesystems?" --defaultno
 then filesystem_unmount
 fi
}


mapped(){
 find /dev/mapper -type b |
 sed 's:/dev/mapper/luks-:/dev/:
      s:/dev/mapper/:/dev/:'
}


list_part(){
 ( mapped | pipe pv_in_vg | sed p
   find /dev -type b |
   sed '\,^/dev/loop,d
        \,^/dev/mapper/,p
        \,^/dev/mapper/,d
        \,^/dev/sr[0-9]$,d
        \,[0-9],p;d'
 ) | uniqs
}

get_part(){
 $DIALOG \
  --title $"Block Device Selection Menu" \
  --menu  $"Please select a block device" \
  0 0 0   $( list_part | sed ' s:$:\tblock' )
}

get_pass(){
 local PASS1 PASS2
 PASS1="$( $DIALOG --passwordbox $"Please    enter password" --no-cancel 0 0 )"
 PASS2="$( $DIALOG --passwordbox $"Please re-enter password" --no-cancel 0 0 )"
 if   [    "$PASS1" == "$PASS2" ]
 then echo "$PASS1";
 else $DIALOG --msgbox "passwords did not match" 0 0; false
 fi
}

# Creating LUKS devices from filesystem table instead
luks(){
 luks_format_open(){
  [ -n "$1" ] && [ -n "$2" ] || return
  echo "$1" | cryptsetup -c aes-xts-plain -s 512 luksFormat $2
  echo "$1" | cryptsetup luksOpen $2
 }

 MESSAGE="\
An encrypted / requires a 1G unencrypted /boot
because lilo can not load files from encrypted partitions.
Passwords for encrypted swaps are not asked at boot.
After each shutdown content of encrypted swaps become unencryptable."

 $DIALOG --msgbox "$MESSAGE" 20 70
 luks_format_open "$( get_pass )" "$( get_part )"
}

boot_partition_warning(){

 $DIALOG --msgbox \
'A dedicated ext2 /boot partition of 1G is required only:

1. On old i586 Hardware with broken BIOS
2. When / is a LVM2 logical volume
3. When / is a LUKS encrypted volume
4. When / is a LVM2 logical volume that is also LUKS encrypted.
5. When / is a software RAID.' 20 75
}


launch(){ if confirm "Execute $*" --defaultno; then eval "$@"; else return 1; fi; }
name_vg(){ $DIALOG --nocancel --inputbox "Name for VG? No / in name" 0 0; }
name_lv(){ $DIALOG --nocancel --inputbox "Name for LV? No / in name" 0 0; }

get_pv(){
 $DIALOG --separate-output --nocancel \
         --title "Select PVs for VG" --checklist "" 20 70 10 \
         $( apvs | sed 's:$:	Physical Volume	off:' ) | tr '\n' '\t'
 echo
}


get_vg(){
 $DIALOG --no-cancel --ok-label Select --menu "Select VG" 0 60 8 \
         $( vg | sed 's:$:	Volume Group:' )
}


get_lv(){
 $DIALOG --no-cancel --ok-label Select --menu "Select LV" 0 60 8 \
         $( lv | sed 's:$:	Logical Volume:' )
}

get_vg_lv(){
 $DIALOG --no-cancel --ok-label Select --menu "Select LV" 0 60 8 \
         $( vg_lv | sed 's:$:	Volume Group/Logical Volume:' )
}

get_lv_size(){
 local SIZE
 local HELP=\
'Enter Size where suffix can be:
 %VG   Percentage of total space in Volume Group
 %FREE Percentage of free  space in Volume Group
 M for megabytes,
 G for Gigabytes
 T for Terabytes
 P for Petabytes
 E for Exabytes'


 SIZE=$( $DIALOG --no-cancel --inputbox "$HELP" 0 0 )

 case $SIZE in
  *VG) echo "-l	$SIZE" ;;
  *EE) echo "-l	$SIZE" ;;
    *) echo "-L	$SIZE" ;;
 esac
}


clv(){ launch lvcreate -n $( name_lv ) $( get_vg ) $( get_lv_size ); }
cvg(){ launch vgcreate    $( name_vg ) $( get_pv ); }
rvg(){ launch vgremove -f $( get_vg ); }
rlv(){ launch lvremove -f $( get_vg_lv ); }

run_vgcreate(){ ppv_to_pv; cvg; vgchange -ay; filesystem_table_load; }
run_lvcreate(){ ppv_to_pv; clv; vgchange -ay; filesystem_table_load; }
run_vgremove(){            rvg; vgchange -ay; filesystem_table_load; }
run_lvremove(){            rlv; vgchange -ay; filesystem_table_load; }


pause(){ read -n 1 -t 900 -p "Press space to continue."; }

name_raid(){
 local CX
 for ((CX=0;CX<MP;CX++)); do
  if ! [ -b /dev/md$CX ]
  then echo /dev/md$CX; break
  fi
 done
}

raid_level(){
 $DIALOG --title $"RAID Level?" --no-cancel --menu "" 20 20 15 \
 linear "" raid0 "" 0 "" stripe "" raid1 "" 1 "" mirror "" \
 raid4 "" 4 "" raid5 "" 5 "" raid6 "" 6 "" \
 raid10 "" 10 "" multipath "" mp "" faulty ""
}

raid_part(){
 local CX=0

 DEVS=$( $DIALOG --separate-output --nocancel \
         --title "Select Devices for RAID" --checklist "" 20 70 10 \
         $( list_part | sed '\,^/dev/mapper,d
                             s:$:	Partition Volume	off:' ) )
 [ -n "$DEVS" ] || return

 for DEV in $DEVS; do
  (( CX++ ))
  sfdisk -c ${DEV:0:8} ${DEV:8:2} fd
 done

 echo "-n $CX $DEVS"
}

compile_menu(){
 if   ! [ -f $TARGET/etc/fstab ]
 then $DIALOG --msgbox $"Transfer first." 8 50; return 1
 fi

 local EXTRA_SPELLS REQUIRED_SPELLS="\
glibc-locales
glibc-localtime
initramfs
init-scripts
kbd"

 if   [ -f $TARGET/etc/lilo.conf.head.new ]
 then BOOTLOADER=lilo
 else BOOTLOADER=yaboot
 fi

 BL_CONF="$TARGET/etc/$BOOTLOADER.conf.head"

 make_bootloader_conf

 EXTRA_SPELLS=$( select_extra_spells )

 chroot_build	$REQUIRED_SPELLS	$EXTRA_SPELLS

 for ITEM in $EXTRA_SPELLS; do
  case $ITEM in
   dial2net)	chroot_run /bin/dial2net -s	;;
   rp-ppoe)	chroot_run /usr/sbin/adsl-setup	;;
   wvdial)	chroot_run /usr/bin/wvdialconf;	edit $TARGET/etc/wvdial.conf ;;
  esac
 done

 CVIS="Visited"
}

run_mdadm(){ if launch mdadm -C $( name_raid ) -l $( raid_level ) $( raid_part ); then MDADM=true; fi; filesystem_table_load; }
run_mdadm_stop(){ mdadm --stop --scan; filesystem_table_load; }

run_lsmod(){ ( lsmod; echo "Press q to return" ) | less; }

loaded(){
 echo "Module"; echo "Used by"
 lsmod | tr -s ' ' | cut -d ' ' -f1,3- | sed "1d;s: :\n:"
}

run_rmmod(){
 local MOD=$( $DIALOG \
  --title $"Module Unload Menu" \
  --menu  $"Select a module to unload please" 0 0 0  $( loaded ) )

 [ -n "$MOD" ] && rmmod "$MOD"
}


run_modprobe(){
 para(){ $DIALOG --nocancel --inputbox "Parameters for $1?" 0 0; }
 mods(){ find /lib/modules -type f | cut -d / -f6- | LC_ALL=C sort | sed -nr "s:(.*)/(.*):\2\t\1: ; s:\.ko\t:\t:p"; }
 msel(){ $DIALOG --title $"Module Load Menu" --menu  $"Select a module to load please" 0 0 0 $( mods ); }

 local PARAM MODULE
 if          MODULE="$( msel )" &&
      [ -n "$MODULE" ] &&
      PARAM="$( para "$MODULE" )"
 then
  modprobe $MODULE $PARAMETERS
  read -n 1 -t 900 -p "Press space to continue."
 fi
}

run_reload_fstab(){ if [ -z "$MOUNT" ]; then filesystem_table_load; fi; }
run_modify_fstab(){ filesystem_table; FSTAB=true; }
run_init_filesys(){ if [ "$FSTAB"    ]; then filesystem_initialize; FINIT=true; fi; }
     run_install(){ if [ "$MOUNT"    ]; then transfer_arch 2>&1 | tee /tmp/transfer.txt; INSTALL=true; fi; }
  run_edit_fstab(){ if [ "$INSTALL"  ]; then edit_fstab; fi; }
     run_compile(){ if [ "$INSTALL"  ]; then compile_menu; COMPILE=true; fi; }
      run_umount(){ if [ "$MOUNT"    ]; then filesystem_unmount; MOUNT=; fi; }
        run_done(){ goodbye; }

       rdy_lsmod(){ echo optional; }
    rdy_modprobe(){ echo optional; }
       rdy_rmmod(){ echo optional; }
         rdy_mbr(){ if [ "$MBR"        ]; then echo complete; else echo optional; fi; }
   rdy_partition(){ if [ "$PARTITION"  ]; then echo complete; else echo optional; fi; }
    rdy_vgcreate(){ echo optional; }
    rdy_lvcreate(){ echo optional; }
    rdy_vgremove(){ echo optional; }
    rdy_lvremove(){ echo optional; }
       rdy_mdadm(){ echo optional; }
  rdy_mdadm_stop(){ echo optional; }
rdy_reload_fstab(){ if [ -n "$MOUNT"   ]; then echo -n 'too late, '; fi; echo optional; }
rdy_modify_fstab(){ if [    "$FSTAB"   ]; then echo complete; else echo required; fi; }
rdy_init_filesys(){ if [ -z "$FSTAB"   ]; then echo -n 'later, '; fi; echo optional; }
       rdy_mount(){ if [    "$MOUNT"   ]; then echo complete; else if [ -z "$FSTAB"   ]; then echo -n 'later, '; fi; echo required; fi; }
     rdy_install(){ if [    "$INSTALL" ]; then echo complete; else if [ -z "$MOUNT"   ]; then echo -n 'later, '; fi; echo required; fi; }
  rdy_edit_fstab(){ if [ -z "$INSTALL" ]; then echo -n 'later, '; fi; echo optional; }
     rdy_compile(){ if [    "$COMPILE" ]; then echo complete; else if [ -z "$INSTALL" ]; then echo -n 'later, '; fi; echo required; fi; }
      rdy_umount(){ echo optional; }
        rdy_done(){ if [ -z "$COMPILE" ]; then echo -n 'later, '; fi; echo required; }

main_menu(){
 local MAIN

 filesystem_table_load

 while
   HELP="Sorcerer comes with no warranty.
Navigate this menu with the up an down arrow keys.
Press the Enter key to make a selection."

  MAIN=$( $DIALOG --item-help --nocancel --default-item "$MAIN" --menu "$HELP" 0 60 10 \
   lsmod        "$( rdy_lsmod        )" "list loaded modules" \
   modprobe     "$( rdy_modprobe     )" "load module" \
   rmmod        "$( rdy_rmmod        )" "remove loaded module" \
   mbr          "$( rdy_mbr          )" "write bootable master boot record" \
   partition    "$( rdy_partition    )" "create partition on a block device" \
   vgcreate     "$( rdy_vgcreate     )" "create volume group" \
   lvcreate     "$( rdy_lvcreate     )" "create logical volume" \
   vgremove     "$( rdy_vgremove     )" "remove volume group" \
   lvremove     "$( rdy_lvremove     )" "remove logical volume" \
   mdadm        "$( rdy_mdadm        )" "create and activate software RAID" \
   mdadm_stop   "$( rdy_mdadm_stop   )" "stop software RAID" \
   reload_fstab "$( rdy_reload_fstab )" "reload incomplete filesystem table" \
   modify_fstab "$( rdy_modify_fstab )" "modify filesystem table" \
   init_filesys "$( rdy_init_filesys )" "initialize filesystems" \
   mount        "$( rdy_mount        )" "mount filesystems" \
   install      "$( rdy_install      )" "install software to new filesystem" \
   edit_fstab   "$( rdy_edit_fstab   )" "edit /etc/fstab on new root filesystem" \
   compile      "$( rdy_compile      )" "configure, compile and install some software" \
   umount       "$( rdy_umount       )" "unmount filesystems" \
   exit         "$( rdy_done         )" "exit installer" )
 do
  case $MAIN in
   lsmod)		run_lsmod ;;
   modprobe)		run_modprobe ;;
   rmmod)		run_rmmod ;;
   mbr)			run_mbr ;;
   partition)		run_partition ;;
   vgcreate)		run_vgcreate ;;
   lvcreate)		run_lvcreate ;;
   vgremove)		run_vgremove ;;
   lvremove)		run_lvremove ;;
   mdadm)		run_mdadm ;;
   mdadm_stop)		run_mdadm_stop ;;
   reload_fstab)	run_reload_fstab ;;
   modify_fstab)	run_modify_fstab ;;
   init_filesys)	run_init_filesys ;;
   mount)		run_mount ;;
   install)		run_install ;;
   edit_fstab)		run_edit_fstab ;;
   compile)		run_compile ;;
   umount)		run_umount ;;
   exit)		goodbye	;;
  esac
 done
}


# Max Partitions
MP=64
TARGET="/media/root"

TAB="	"
LF="
"

export IFS="	$LF"
export DIALOG="dialog	--backtitle	Sorcerer Installer	--stdout"

trap : INT QUIT

main_menu

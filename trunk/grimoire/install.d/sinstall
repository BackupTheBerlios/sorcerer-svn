#!/bin/bash
############################################################
# Copyright 2001 through 2008 by Kyle Sallee,              #
# all rights reserved                                      #
# and may not be reditribute in modified form without      # 
# prior writen permission of Kyle Sallee                   #
# It may only be used for installing Sorcerer              #
############################################################
# sorcerer.install menu driven process of for installing   #
# installing the Sorcerer Install/Rescue ISO               #
############################################################


inputbox(){ $DIALOG --nocancel --inputbox "$1" 0 0 "$2"; }


chroot_run(){
 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon  -a
 chroot $TARGET "$@"
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
}


chroot_build(){
 scry_finish(){
  while ls     $TARGET/root/.sorcery/queue/cast | grep -q "."
  do    chroot $TARGET augur scry
  done
 }

 echo    $"Chrooting to $TARGET"

 mkdir  -p                       $TARGET/{usr/src/sorcery,var/lock}
 mkdir  -p                       $TARGET/$TARGET/dev # avoids bug in linux?
 mount  --bind  /dev             $TARGET/$TARGET/dev # avoids bug in linux?
 mkdir  -p                       $TARGET/tmp/.sorcery
 mount  --bind  /dev             $TARGET/dev
 mount  --bind  /dev/pts         $TARGET/dev/pts
 mount  --bind  /proc            $TARGET/proc
 mount  --bind  /root/.sorcery   $TARGET/root/.sorcery
 mount  --bind  /usr/src/sorcery $TARGET/usr/src/sorcery
 mount  --bind  /var/lock        $TARGET/var/lock
 chroot $TARGET swapon -a
 chroot $TARGET dispel install
 chroot $TARGET cast -r "$@"
 scry_finish
 chroot $TARGET swapoff -a
 umount                          $TARGET/var/lock
 umount                          $TARGET/usr/src/sorcery
 umount                          $TARGET/root/.sorcery
 umount                          $TARGET/proc
 umount                          $TARGET/dev/pts
 umount                          $TARGET/dev
 umount                          $TARGET/$TARGET/dev # avoids bug in linux?
}


confirm(){ $DIALOG $2 --yesno "$1" 8 50; }


goodbye(){
 if   [ "$PMOUNTED" == true ]
 then filesystem_unmount
 fi

 if   confirm "Reboot now?" --defaultno
 then shutdown -r now
 fi
 exit  0
}

list_disk(){ find /dev -group disk -printf "%p	disk\n" | sed "/[0-9]/d"; }
list_bb()  { find /dev -type b -printf "%p	%y\n"   | sed '\,^/dev/loop,d;\,^/dev/mapper/,d'; }
get_bb()   { $DIALOG --title $"Please select boot block" --menu "" 0 0 0 $( list_bb   ); }
get_disk() { $DIALOG --title $"Please select disk"       --menu "" 0 0 0 $( list_disk ); }


boot_dev_check(){
 if   [     "${PDEVICE[$1]:0:12}" == /dev/mapper/ ] &&
      [      "${PMOUNT[$1]}"      == /boot        ] &&
    ! [ "${PFILESYSTEM[$1]}"      == ext2         ]
 then
  $DIALOG --msgbox "/boot must be ext2 and can not be a mapped device" 8 50
       PMOUNT[$1]=
  PFILESYSTEM[$1]=
 fi
}


get_filesystem(){

 local EXT2 EXT3 JFS XFS REISER SWAP DEFAULT

   EXT2="Second Extended             file system"
   EXT3="Second Extended  journaling file system"
    JFS="JFS              journaling file system"
    XFS="XFS              journaling file system"
 REISER="Reiserfs         journaling file system"
   SWAP="Swap"

 case "${PMOUNT[$1]}" in
  /boot) DEFAULT=ext2 ; echo ext2; return ;;
   none) DEFAULT=swap ;;
      *) DEFAULT=ext3 ;;
 esac

 $DIALOG \
 --title $"Filesystem Selection Menu" \
 --default-item "$DEFAULT" \
 --menu $"Please select a filesystem" 0 0 0 \
 ext2 "$EXT2" ext3 "$EXT3" jfs "$JFS" \
 reiserfs "$REISER" xfs "$XFS" swap "$SWAP"
}


fdisc(){
 $DIALOG \
 --title $"Partitioning Menu" --no-cancel \
 --menu  $"Select a partitioning program" 0 0 0 \
 cfdisk "" fdisk "" parted ""
}


partition_disks(){
 launch $( fdisc ) $( get_disk );
 filesystem_table_load
}


write_mbr(){ ms-sys -s $( get_disk ); MBR=true; }


get_mount(){
 local      PLEASE="Please enter a mount point"
 inputbox "$PLEASE" "${PMOUNT[$1]}"
 boot_dev_check "$1"
}

get_device(){
 get_part       "$1"
 boot_dev_check "$1"
}

list_swaps(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ "${PFILESYSTEM[$CX]}" == swap ]
  then echo  "${PDEVICE[$CX]} none swap defaults 0 0"
  fi
 done
}

fstab_line(){
 echo -n "${PDEVICE[$1]}${TAB}"
 echo -n "${PMOUNT[$1]:-none} "
 echo -n "${PFILESYSTEM[$1]:-unknown} "
 echo -n "${POPTIONS[$1]} "
 echo -n "${PDUMP[$1]} "
 echo    "${PORDER[$1]}"
}


make_fstab(){
 echo "# Real file systems"
 list_mounts | LC_ALL=C sort | cut -f2 |
 while read          CX
 do    fstab_line  "$CX"
 done | tr ' ' '\t'
 echo; echo
 echo "# Swap"
 list_swaps
 echo; echo
 cat /etc/fstab.empty
}


option_menu(){ chroot_run sorcery options; }


make_bootloader_conf(){

 cp $BL_CONF.new $BL_CONF

 MESSAGE="Select the location to install ${BOOTLOADER}"
 $DIALOG --msgbox "$MESSAGE" 8 50

 local BB=$( get_boot_block )
 local RD=$( root_device    )

 echo "boot${TAB}${TAB}${TAB}=${TAB}$BB" >> $BL_CONF
 echo "root${TAB}${TAB}${TAB}=${TAB}$RD" >> $BL_CONF

 MESSAGE="${BOOTLOADER} will be installed to boot block: ${BB}"
 $DIALOG --msgbox "$MESSAGE" 8 50

 sfdisk ${BB:0:8} -A ${BB:8:2}
 mbr_check
}


transfer_arch_old(){

 local CAT=/tmp/catalog.txt

 if     ! [ -f $CAT ]; then
  echo 'Waiting for catalog to complete'
  pgrep             catalog &>/dev/null ||
        /etc/init.d/catalog
  while ! [ -f $CAT ]
  do    read -p . -n 1 -t 1
  done
  echo
 fi

 local TOT START=$SECONDS

 TOT=$( wc -l $CAT | cut -d ' ' -f1 )

 tar --no-recursion -cT $CAT |
 tar -C $TARGET     -xvpf -  |
 cat -n |
 while read NUM REPLY; do
  (( NOW = SECONDS - START ))
  (( REM = TOT * NOW / NUM - NOW ))
  (( PER = 100 * NUM / TOT ))
  echo "$PER%	${REM}s	$REPLY"
 done

 chmod 1777   $TARGET/tmp
 make_fstab > $TARGET/etc/fstab

 if   [ -s /tmp/catalog.log ]
 then cat  /tmp/catalog.log
 fi

 read -n 1 -t 900 -p "Press space to continue."
 $DIALOG --msgbox $"Files transferred." 8 50
 ARCH_DONE=true
}


transfer_arch(){
 give(){
  find $TARGET/var/cache/archive -type f -printf "%T@\t%p\n" |
  LC_ALL=C sort -g |
  cut -f2 |
  sed "\,\.$1$,p;d"
 }

 utar(){ tar -C                $TARGET -xvpf -; }

 cd /
 mkdir -p                      $TARGET/{dev,home,media/{cdrom,floppy,root},proc,sys,tmp,var}
 mkdir -p                      $TARGET/etc/sorcery/log/{boot.{on,off},config,opt.{on,off},xinetd.{on,off}}
 chmod 1777                    $TARGET/tmp
 cp    -av dev etc init root   $TARGET
 cp    -av     etc/skel        $TARGET/root
 cp    -av /media/IR/boot      $TARGET
 rm    -rf                     $TARGET/boot/isolinux
 cp    -av /media/IR/var/cache $TARGET/var/
 give tar.7z  | while read; do 7za x -bd -so "$REPLY" | utar; done
#give tar.bz2 | while read; do bzip2 -cd     "$REPLY" | utar; done
#give tar.gz  | while read; do gzip  -cd     "$REPLY" | utar; done
#give tar     | while read; do cat           "$REPLY" | utar; done
}


select_extra_spells(){
 HELP="
The sources CD contains sources for software
that may be useful or required for networking.
Please select software that will also be compiled and installed.
Any of this software can also be installed after the first boot
should you decide later that they will be required."

 show_extra(){
  ( find $TARGET/var/cache/sources -maxdepth 1 -type d -printf "%P\n"
    echo "$REQUIRED_SPELLS"
    echo "$REQUIRED_SPELLS"
  ) | LC_ALL=C sort | uniq -u | grep -vx "" |
  while read; do
   echo "$REPLY"
   echo "Optional"
   echo "off"
  done
 }


 $DIALOG \
  --title "Additional Software Selection" \
  --nocancel --ok-label "Commit" --separate-output \
  --checklist "$HELP" 0 0 0 $( show_extra )
}


editor_menu(){
 local      TITLE="Text Editor Selection Menu"
 local  NANO_HELP="nano is a very easy to use text editor."
 local ELVIS_HELP="elvis is a clone vi/en editor."
 local  ZILE_HELP="zile is a small, fast and powerful emacs clone."

 EDITOR=$(
  $DIALOG \
  --title $"Text Editor Selection Menu" --item-help --default-item nano \
  --menu  $"Please select a text editor" 0 0 0 \
  nano "" "$NANO_HELP" elvis "" "$ELVIS_HELP" zile "" "$ZILE_HELP" )
 export EDTIOR
}


edit(){
 [ -n "$EDITOR" ] || editor_menu
 $EDITOR "$1"
}


get_boot_block(){
 local BB
 while [ -z "$BB" ]; do BB="$( get_bb )"; done
 echo "$BB"
}


edit_fstab(){
 if   [ -f $TARGET/etc/fstab ]
 then edit $TARGET/etc/fstab
 else $DIALOG --msgbox $"Transfer first." 8 50
 fi
}


get_options(){
 local DEFAULT_OPTIONS

 case ${PFILESYSTEM[$1]} in
      swap) DEFAULT_OPTIONS="defaults"                     ;;
  reiserfs) DEFAULT_OPTIONS="defaults,notail,noatime"      ;;
       jfs) DEFAULT_OPTIONS="defaults,noatime"             ;;
      ext3) DEFAULT_OPTIONS="defaults,noatime,commit=3600" ;;
       xfs) DEFAULT_OPTIONS="defaults,noatime"             ;;
      ext2) DEFAULT_OPTIONS="defaults,noatime"             ;;
 esac

 case ${PMOUNT[$1]} in
  /tmp) [ "${PFILESYSTEM[$1]}" == ext3 ] &&
        DEFAULT_OPTIONS="defaults,noatime,commit=864000" ;;
 esac

 if   [ -n "$DEFAULT_OPTIONS" ]
 then inputbox "Please enter mount options" "$DEFAULT_OPTIONS"
 fi
}


get_size(){
 inputbox "Please enter size in megabytes" "${PSIZE[$1]:-256}"
}

get_password(){
 local KEY

 if   [ -z      "${PDEVICE[$1]}" ]; then $DIALOG --msgbox "Please set device first." 8 50; return 1; fi
 if   [ -z  "${PFILESYSTEM[$1]}" ]; then $DIALOG --msgbox "Please set filesystem type first." 8 50; return 1; fi
 if   [ /boot == "${PMOUNT[$1]}" ]; then $DIALOG --msgbox "/boot can not be encrypted." 8 50; return 1; fi
 if   [     "${PFILESYSTEM[$1]}" == swap ]
 then confirm $"Encrypted swap?" --defaultno && KEY=$RANDOM
 else KEY="$( inputbox "Please enter a password for key 0" )"
 fi

 if   [ -z "$KEY" ]; then
  if  [ /dev/mapper/luks- == "${PDEVICE[$1]:0:17}" ]; then
   cryptsetup luksClose       ${PDEVICE[$1]##*/}
  fi
 else echo "$KEY"
  if  [ /dev/mapper/luks- ==   "${PDEVICE[$1]:0:17}" ]; then
      [ -b          /dev/mapper/${PDEVICE[$1]#*-} ] &&
       PDEVICE[$1]="/dev/mapper/${PDEVICE[$1]#*-}"  ||
              PDEVICE[$1]="/dev/${PDEVICE[$1]#*-}"
  fi

  echo          cryptsetup luksFormat ${PDEVICE[$1]} 1>&2
  echo "$KEY" | cryptsetup luksFormat ${PDEVICE[$1]}
  echo          cryptsetup luksOpen   ${PDEVICE[$1]} luks-${PDEVICE[$1]##*/} 1>&2
  echo "$KEY" | cryptsetup luksOpen   ${PDEVICE[$1]} luks-${PDEVICE[$1]##*/}
  pause
 fi
}


get_feature(){
 local FEATURE

 if [ -z "${PFEATURE[$1]}" ]; then
  case "${PFILESYSTEM[$1]}" in
   ext*) FEATURE="dir_index,filetype,sparse_super" ;;
  esac
 fi
 FEATURE="$( inputbox "Please enter optional features" "$FEATURE" )"
 if   [ -n "$FEATURE" ]
 then echo "-O	$FEATURE"
 fi
}


get_check(){

 check_type(){
  echo "Skip"
  echo "Do not check device for bad blocks"

  case  "${PFILESYSTEM[$1]}"  in
   jfs)  echo RO
         echo "Check for bad blocks before creating the file system" ;;
   swap) if [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
          echo RO
          echo "Check for bad blocks before creating the swap space"
         fi ;;
   ext*) echo RO
         echo "Adequate read only checking for new drives"
         echo RW
         echo "Appropritate read write checking for older drives." ;;
  esac
 }


 if   [ -z "${PFILESYSTEM[$1]}" ]; then $DIALOG --msgbox "Please set filesystem type first." 8 50; return 1
 elif [ -z "${PDEVICE[$1]}"     ]; then $DIALOG --msgbox "Please set device first." 8 50; return 1
 fi

 CHECK=$(
  $DIALOG \
   --title $"Filesystem Check Menu" --default-item Skip \
   --menu "Please select desired checking" 0 0 0 $( check_type "$1" ) )

 case $CHECK in
  RO) echo "-c"		;;
  RW) echo "-c	-c"	;;
 esac
}


get_dump(){
 if   confirm "Should it be dumped?" "--defaultno"
 then echo 1
 else echo 0
 fi
}


get_check_order(){

 local HELP TITLE CO=0

 TITLE=$"fsck check order menu"
 HELP=$"Journaling file systems do not require fsck checking
when booting if the they were not properly unmounted 
on the previous boot.  However non journaling file 
systems do require checking.  The root partition 
should be checked first, and all other partitions second."

 case ${PFILESYSTEM[$1]} in
  ext2) if [ "$1" == 0 ]; then CO=1; else CO=2; fi ;;
 esac

 $DIALOG \
 --title $"fsck check order menu" --default-item "$CO" --menu "" 0 0 0 \
 0 "No check required" 1 "Check on first pass" 2 "Check on second pass"
}


show_pinfo(){
 echo "device"
 echo "mount filesys options d o"
 for (( CX=0; CX<MP; CX++ )); do
  if    [ -n "${PDEVICE[$CX]}" ]; then
   echo   -n  "${PMOUNT[$CX]:-none}	"
   fstab_line          "$CX"
  fi
 done | LC_ALL=C sort | cut -f2- | tr '\t' '\n'
}


get_pcx(){
 if   [ -z "$1"           ]; then false
 elif [    "$1" == device ]; then
  for (( CX=0; CX<MP; CX++ )); do
   if   [ -z "${PDEVICE[$CX]}" ]
   then echo           "$CX"; break
   fi
  done
 else
  for (( CX=0; CX<MP; CX++ )); do
   if   [ "${PDEVICE[$CX]}" == "$1" ]
   then echo        "$CX"; break
   fi
  done
 fi
}


show_pinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if  [ -n      "${PMOUNT[$CX]}"              ] ||
      [    "${PFILESYSTEM[$CX]}"     == swap  ]; then
   if [        "${PDEVICE[$CX]:0:5}" == /dev/ ]; then
      fstab_line         "$CX"
      echo off
   fi
  fi
 done | tr '\t' '\n'
}


show_sinfo_init(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ -n    "${PSIZE[$CX]}"              ] &&
       [ "${PFILESYSTEM[$CX]}"     == swap  ] &&
     ! [     "${PDEVICE[$CX]:0:5}" == /dev/ ]; then
   fstab_line          "$CX"
   echo off
  fi
 done | tr '\t' '\n'
# | column -t
}


root_device(){
 for (( CX=0; CX<MP; CX++ )); do
  if   [ / == "${PMOUNT[$CX]}" ]
  then echo  "${PDEVICE[$CX]}"; break
  fi
 done
}

empty_entry(){
#    PDEVICE[$1]=
      PMOUNT[$1]=
     PRMOUNT[$1]=
#PFILESYSTEM[$1]=
    POPTIONS[$1]=
       PDUMP[$1]=
      PORDER[$1]=
    PFEATURE[$1]=
      PCHECK[$1]=
   PPASSWORD[$1]=
}


filesystem_table(){

 pselect(){
  $DIALOG --ok-label Select --cancel-label Done \
   --title $"Filesystem Table Menu" \
   --menu  $"Filesystems with mount point of none are ignored unless swap." 0 70 12 $( show_pinfo )
 }

 pempty(){
  if   confirm $"Please confirm removal of this entry?" --defaultno;
  then empty_entry "$1"
  fi
 }


 check_pentry(){
  if [ -z "${PDEVICE[$1]}"     ] ||
     [ -z "${PFILESYSTEM[$1]}" ] ||
     [ -z "${PMOUNT[$1]}"      ] ||
     [ -z "${POPTIONS[$1]}"    ] ||
     [ -z "${PDUMP[$1]}"       ] ||
     [ -z "${PORDER[$1]}"      ]; then
   $DIALOG --msgbox $"Essential fields are missing. Emptying entry." 8 50
   empty_entry "$1"
   false
  fi
 }


 modify_pentry(){

  if   [ -z "$1" ]
  then false
  else
   local COMMAND TITLE EHELP HELP

   TITLE=$"Filesystem entry menu"
    HELP=$"Please visit every menu item except the Empty All Fields"

   while
    if  [ "${PDEVICE[$1]:0:5}" == /dev/ ]; then
     COMMAND=$(
      $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
       --title "$TITLE" \
       --menu  "$HELP" 20 60 15 \
       Device         "${PDEVICE[$1]}" \
       Filesystem "${PFILESYSTEM[$1]}" \
       Mount           "${PMOUNT[$1]}" \
       Options       "${POPTIONS[$1]}" \
       Dump             "${PDUMP[$1]}" \
       Order           "${PORDER[$1]}" \
       Feature       "${PFEATURE[$1]}" \
       Check           "${PCHECK[$1]}" \
       Encryption   "${PPASSWORD[$1]:+yes}" \
       Empty      "All fields removing entry" )
    else
     COMMAND=$(
      $DIALOG --ok-label Select --cancel-label Done --default-item "$WHAT" \
       --title "$TITLE" \
       --menu  "$HELP" 20 60 15 \
       Device         "${PDEVICE[$1]}" \
       Filesystem "${PFILESYSTEM[$1]}" \
       Mount           "${PMOUNT[$1]}" \
       Options       "${POPTIONS[$1]}" \
       Dump             "${PDUMP[$1]}" \
       Order           "${PORDER[$1]}" \
       Size             "${PSIZE[$1]}" \
       Check           "${PCHECK[$1]}" \
       Empty      "All fields removing entry" )
    fi
   do
    case $COMMAND in
     Empty)      pempty "$1"					;;
     Device)         PDEVICE[$1]=$( get_device      "$1" )	;;
     Filesystem) PFILESYSTEM[$1]=$( get_filesystem  "$1" )	;;
     Mount)           PMOUNT[$1]=$( get_mount       "$1" )	;;
     Options)       POPTIONS[$1]=$( get_options     "$1" )	;;
     Dump)             PDUMP[$1]=$( get_dump        "$1" )	;;
     Order)           PORDER[$1]=$( get_check_order "$1" )	;;
     Size)             PSIZE[$1]=$( get_size        "$1" )	;;
     Feature)       PFEATURE[$1]=$( get_feature     "$1" )	;;
     Check)           PCHECK[$1]=$( get_check       "$1" )	;;
     Encryption)   PPASSWORD[$1]=$( get_password    "$1" )	;;
    esac

    DV=/dev
    DM=/dev/mapper
    DML=/dev/mapper/luks-

    if   [ -n       "${PPASSWORD[$1]}" ]; then
         [ $DML ==   "${PDEVICE[$1]:0:17}" ] ||
     PDEVICE[$1]="$DML${PDEVICE[$1]##*/}"
    elif [ $DML ==   "${PDEVICE[$1]:0:17}" ]; then
     [ -b         $DM/${PDEVICE[$1]#*-} ] &&
     PDEVICE[$1]="$DM/${PDEVICE[$1]#*-}"  ||
     PDEVICE[$1]="$DV/${PDEVICE[$1]#*-}"
    fi

    case "${PFILESYSTEM[$1]}" in
     swap)    PDUMP[$1]=0
             PMOUNT[$1]=none
           POPTIONS[$1]=default
             PORDER[$1]=0 ;;
     ext*) PFEATURE[$1]="${PFEATURE[$1]:--O	dir_index,filetype,sparse_super}" ;;
    esac

  done
  check_pentry "$1" &&
  PRMOUNT[$1]="$TARGET${PMOUNT[$1]}"
 fi
}


 check_root_defined(){
  root_device | grep -q . ||
  $DIALOG --msgbox $"/ Root filesystem required!" 18 65
 }


 local HELP="The following menu is for specifying filesystems
to mount prior to transfering sorcerer.
The information prompted for corresponds
to the fields on a line in /etc/fstab
man fstab in separate virtual console if needed."

 $DIALOG --msgbox "$HELP" 18 65
 while modify_pentry $( get_pcx $( pselect ) ); do : ; done
 check_root_defined
 true
}


select_partitions_to_initialize(){

  local HELP=$"Select Partitions to initialize.
All data on selected partitions will be lost.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title $"Partition Initialization Selection Menu" \
  --checklist "$HELP" 18 74 8 $( show_pinfo_init )
}


select_swapfile_to_initialize(){

  local  TITLE  HELP

   HELP=$"If swapfiles have not been created and initialized
then now is the time to do so.
[x] = initialize  [ ] = leave alone 
Up and Down arrows navigate.  Space toggles.  Enter proceeds."

 $DIALOG --ok-label Done --no-cancel --separate-output \
  --title $"Swapfile Initialization Selection Menu" \
  --checklist "$HELP" 18 74 8 $( show_sinfo_init )
}


installed_fs(){

 check_jfs(){ dd if=$1 bs=64k count=1 2>/dev/null | grep -q JFS1 && echo jfs; }

 case $( file -k - < $1 ) in
  *swap\ file*)		echo  swap	;;
  *ext3\ filesystem*)	echo  ext3	;;
  *ext2\ filesystem*)	echo  ext2	;;
  *SGI\ XFS*)		echo  xfs	;;
  *ReiserFS*)		echo  reiserfs	;;    
  *FAT*)		echo  fat	;;
  *stdin:\ data*)  	check_jfs "$1"	;;
 esac
}

pipe(){ cat -; "$@"; }
uniqs(){  LC_ALL=C sort | uniq -u; }
dups(){   LC_ALL=C sort | uniq -d; }

lv(){       lvs --noheadings -o lv_name       $1 | tr -d ' '; }
pv_in_vg(){ vgs --noheadings -o pv_name       $1 | tr -d ' '; }
pv(){       pvs --noheadings -o pv_name          | tr -d ' '; }
vg(){       vgs --noheadings -o vg_name          | tr -d ' '; }
vg_free(){  vgs --noheadings -o vg_free_count $1 | tr -d ' '; }
vg_lv(){    vgs --noheadings -o vg_name,lv_name  |
            sed 's:^ *::;s: :/:'                 | tr -d ' '; }
            

apvs(){     pv_in_vg | sed p | pipe pv | uniqs; }

ppv(){
 pv | sed p | pipe \
 find /dev -type b |
 sed '\,^/dev/loop,d;\,^/dev/mapper/,d;\,[0-9],p;d' | uniqs
}

ppv_to_pv(){ ppv | xargs -r --max-lines=16 pvcreate; }


filesystem_table_load(){
 local CX PART

     PDEVICE[0]=/swap
 PFILESYSTEM[0]=swap
    POPTIONS[0]=defaults
       PDUMP[0]=0
      PORDER[0]=0
      PMOUNT[0]=none
       PSIZE[0]=256

 (( CX = 1 ))

 for PART in $( list_part ); do

      PDEVICE[$CX]="$PART"
  PFILESYSTEM[$CX]="$( installed_fs $PART )"
     POPTIONS[$CX]="defaults,noatime"
        PDUMP[$CX]=0
       PORDER[$CX]=0

  case "${PFILESYSTEM[$CX]}" in
   ext2)   PORDER[$CX]=1	;;
   ext3)   PORDER[$CX]=1	;;
   ext4)   PORDER[$CX]=1	;;
   swap) POPTIONS[$CX]=defaults	;;
  esac

  (( CX++ ))
 done

 for (( ; CX<MP; CX++ )); do empty_entry "$CX"; done
}


get_mk_command(){
 file_or_part(){
  case ${PDEVICE[$1]:0:5} in
   /dev/) echo "mkswap	${PCHECK[$1]}	${PDEVICE[$1]}" ;;
       *) echo "dd	of=$TARGET${PDEVICE[$1]}	if=/dev/zero	bs=1M	count=${PSIZE[$1]}	&&${LF}mkswap	$TARGET${PDEVICE[$1]}	&&${LF}chmod	0	$TARGET${PDEVICE[$1]}" ;;
  esac
 }

 case ${PFILESYSTEM[$1]} in
      ext2) echo "mkfs.ext2	${PCHECK[$1]}	${PFEATURE[$1]}	${PDEVICE[$1]}" ;;
      ext*) echo "mkfs.ext3	${PCHECK[$1]}	${PFEATURE[$1]}	${PDEVICE[$1]}" ;;
  reiserfs) echo "mkreiserfs	-f	${PDEVICE[$1]}" ;;
       xfs) echo "mkfs.xfs	-f	${PDEVICE[$1]}" ;;
       jfs) echo "jfs_mkfs	-q	${PCHECK[$1]}	${PDEVICE[$1]}" ;;
      swap) file_or_part "$1" ;;
 esac
}


initialize(){

 local SURE SUCCESS FAILURE COMMAND

 SURE="Please confirm it is okay that all data on  ${PDEVICE[$1]} is lost?"
 SUCCESS="${PFILESYSTEM[$1]} successfully created on ${PDEVICE[$1]}"
 FAILURE="No success at creating ${PFILESYSTEM[$1]} on ${PDEVICE[$1]}"

 if confirm "$SURE" --defaultno; then
                 COMMAND="$( get_mk_command "$1" )"
  if   confirm "$COMMAND" --defaultno &&
       eval    "$COMMAND"
  then sleep  3; $DIALOG --msgbox "$SUCCESS" 8 50
  else sleep 10; $DIALOG --msgbox "$FAILURE" 8 50; return 1
  fi
 fi

}


filesystem_initialize(){
 local PART

 [ -n "${PDEVICE[1]}"  ]  &&
 for PART in $( select_partitions_to_initialize )
 do  initialize $( get_pcx "$PART" )
 done
}


swapfile_initialize(){
 local SWAP

 [ -n "${PDEVICE[1]}" ] &&
 for SWAP in $( select_swapfile_to_initialize )
 do  initialize $( get_pcx "$SWAP" )
 done
}


list_mounts(){
 for (( CX=0; CX<MP; CX++ )); do
  if     [ -n       "${PMOUNT[$CX]}" ] &&
       ! [ none ==  "${PMOUNT[$CX]}" ]
  then echo         "${PMOUNT[$CX]}	$CX"
  fi
 done
}


filesystem_mount(){

 local ALREADY NOT_NOW SUCCESS FAILED

 ALREADY=$"Partitions are already mounted."
 NOT_NOW=$"No partitions to mount, yet."
 SUCCESS=$"successfully mounted"
  FAILED=$"failed mounting"

 if   [ "$PMOUNTED" == true ]; then $DIALOG --msgbox "$ALREADY" 8 50; false
 elif [ -z "${PMOUNT[*]}"   ]; then $DIALOG --msgbox "$NOT_NOW" 8 50; false
 else
  list_mounts | LC_ALL=C sort | cut -f2 |
  while read CX; do
   if mkdir -p     ${PRMOUNT[$CX]} &&
      mount -t ${PFILESYSTEM[$CX]} \
            -o  ${POPTIONS[$CX]} \
                ${PDEVICE[$CX]} \
                ${PRMOUNT[$CX]}
   then          $DIALOG --msgbox "${PRMOUNT[$CX]} $SUCCESS" 8 50
   else sleep 5; $DIALOG --msgbox "${RPMOUNT[$CX]} $FAILED"  8 50
   fi
   if   [ -d      $TARGET/tmp ]
   then chmod 1777 $TARGET/tmp
   fi
  done
  swapfile_initialize
  PMOUNTED=true
 fi
}

trans(){ [ -f $TARGET/etc/fstab ]; }

mbr_check(){
 if [ -n "$MBR" ]; then return; fi
 if [ -n "$BB"  ] && echo "$BB" | grep -q '[a-z]$'; then return; fi
 if confirm "Install a bootable MBR?"; then write_mbr; fi
}


filesystem_unmount(){

 local ALREADY NOT_NOW SURE SUCCESS FAILED

 SUCCESS=$"successfully unmounted"
  FAILED=$"failed unmounting"
 ALREADY=$"Partitions are not mounted."

  SURE=$"Partitions must be mounted to transfer 
Sorcerer and continue installation.
Really unmount the currently mounted partitions?"

 if   ! [ "$PMOUNTED" == true ]
 then $DIALOG --msgbox "$ALREADY" 8 50; false
 else
  if trans || confirm "$SURE" --defaultno; then
   list_mounts | LC_ALL=C sort -r | cut -f2 |
   while read CX; do
    if   umount ${PRMOUNT[$CX]}
    then          $DIALOG --msgbox "${PRMOUNT[$CX]} $SUCCESS" 8 50
    else sleep 5; $DIALOG --msgbox "${PRMOUNT[$CX]} $FAILED"  8 50
    fi
   done
   PMOUNTED=false
  fi
 fi
}


confirm_unmount(){
 local NOT_YET="
Until the install image is transfered
and compilation of initramfs is completed
the filesystems should remain mounted.

However to modify the filesystem table, create,
initialize and/or mount more file systems
then the currently mounted filesystems must be unmounted first."

 $DIALOG --msgbox "$NOT_YET" 20 70
 if   confirm "Really Unmount filesystems?" --defaultno
 then filesystem_unmount
 fi
}


mapped(){
 find /dev/mapper -type b |
 sed 's:/dev/mapper/luks-:/dev/:
      s:/dev/mapper/:/dev/:'
}


list_part(){
 ( mapped | pipe pv_in_vg | sed p
   find /dev -type b |
   sed '\,^/dev/loop,d
        \,^/dev/mapper/,p
        \,^/dev/mapper/,d
        \,^/dev/sr[0-9]$,d
        \,[0-9],p;d'
 ) | uniqs
}

get_part(){
 $DIALOG \
  --title $"Block Device Selection Menu" \
  --menu  $"Please select a block device" \
  0 0 0   $( list_part | sed ' s:$:\tblock' )
}

get_pass(){
 local PASS1 PASS2
 PASS1="$( $DIALOG --passwordbox $"Please    enter password" --no-cancel 0 0 )"
 PASS2="$( $DIALOG --passwordbox $"Please re-enter password" --no-cancel 0 0 )"
 if   [    "$PASS1" == "$PASS2" ]
 then echo "$PASS1";
 else $DIALOG --msgbox "passwords did not match" 0 0; false
 fi
}

# Creating LUKS devices from filesystem table instead
luks(){
 luks_format_open(){
  [ -n "$1" ] && [ -n "$2" ] || return
  echo "$1" | cryptsetup luksFormat $2
  echo "$1" | cryptsetup luksOpen   $2
 }

 MESSAGE="\
An encrypted / requires a 1G unencrypted /boot
because lilo can not load files from encrypted partitions.
Passwords for encrypted swaps are not asked at boot.
After each shutdown content of encrypted swaps become unencryptable."

 $DIALOG --msgbox "$MESSAGE" 20 70
 luks_format_open "$( get_pass )" "$( get_part )"
}

boot_partition_warning(){

 $DIALOG --msgbox \
'A dedicated ext2 /boot partition of 256M to 1G is required only on:

1. Old i586 Hardware with broken BIOS
2. When / is a LVM2 logical volume
3. When / is a LUKS encrypted volume
4. When / is a LVM2 logical volume that is also LUKS encrypted.
5. When / is a software RAID.' 20 75
}


lvm2_explain(){
 $DIALOG --msgbox \
'Disks are physical hardware for storing data.
Partitions are divisions of disks.
Filesystems can be created on partitions.
Partitions are also Physical Volumes.

A Volume Group is a collection of Physical Volumes.
Any number of Physical Volumes can be added to a Volume Group.

Logical Volumes are divisions of Volume Groups.
The relationship between a Logical Volume and Volume Group
is very similar to the 
the relationship between a Partition and a Disk.

In order to more more easily remember these terms:
A Volume Group is a virtual Disk.
A Logical Volume is a virtual Partition.

By using LVM2 a single filesystem can be created
that spans several partitions and disks.
Or a LVM2 can be used to partition a software RAID' 24 75
}


launch(){ if confirm "Execute $*" --defaultno; then eval "$@"; fi; }

name_vg(){ $DIALOG --nocancel --inputbox "Name for VG? No / in name" 0 0; }
name_lv(){ $DIALOG --nocancel --inputbox "Name for LV? No / in name" 0 0; }

get_pv(){
 $DIALOG --separate-output --nocancel \
         --title "Select PVs for VG" --checklist "" 20 70 10 \
         $( apvs | sed 's:$:	Physical Volume	off:' ) | tr '\n' '\t'
 echo
}


get_vg(){
 $DIALOG --no-cancel --ok-label Select --menu "Select VG" 0 60 8 \
         $( vg | sed 's:$:	Volume Group:' )
}


get_lv(){
 $DIALOG --no-cancel --ok-label Select --menu "Select LV" 0 60 8 \
         $( lv | sed 's:$:	Logical Volume:' )
}

get_vg_lv(){
 $DIALOG --no-cancel --ok-label Select --menu "Select LV" 0 60 8 \
         $( vg_lv | sed 's:$:	Volume Group/Logical Volume:' )
}

get_lv_size(){
 local SIZE
 local HELP=\
'Enter Size where suffix can be:
 %VG   Percentage of total space in Volume Group
 %FREE Percentage of free  space in Volume Group
 M for megabytes,
 G for Gigabytes
 T for Terabytes
 P for Petabytes
 E for Exabytes'


 SIZE=$( $DIALOG --no-cancel --inputbox "$HELP" 0 0 )

 case $SIZE in
  *VG) echo "-l	$SIZE" ;;
  *EE) echo "-l	$SIZE" ;;
    *) echo "-L	$SIZE" ;;
 esac
}


clv(){ launch lvcreate -n $( name_lv ) $( get_vg ) $( get_lv_size ); }
cvg(){ launch vgcreate    $( name_vg ) $( get_pv ); }
rvg(){ launch vgremove -f $( get_vg ); }
rlv(){ launch lvremove -f $( get_vg_lv ); }

pause(){ read -n 1 -t 900 -p "Press space to continue."; }

lvm2_menu(){

 ppv_to_pv
 lvm2_explain

 while
  CVG_HELP=$"Create a Volume Group and add Physical Volumes to it"
  RVG_HELP=$"Remove Volume Group and freeing Physical Volumes"
  CLV_HELP=$"Create Logical Volume within Volume Group"
  RLV_HELP=$"Remove Logical Volume within Volume Group"

  WHAT=$(
   $DIALOG --title $"LVM2 Menu" --no-cancel --item-help --menu "" 0 60 8 \
   CVG "Create Volume Group"   "$CVG_HELP" \
   CLV "Create Logical Volume" "$CLV_HELP" \
   RVG "Remove Volume Group"   "$RVG_HELP" \
   RLV "Remove Logical Volume" "$RLV_HELP" \
   Done "" "" )
 do
  case $WHAT in
    CVG) cvg	;;
    RVG) rvg	;;
    CLV) clv	;;
    RLV) rlv	;;
   Done) break	;;
  esac
  pause
 done
 vgchange -ay
 filesystem_table_load
}

name_raid(){
 local CX
 for ((CX=0;CX<64;CX++)); do
  if ! [ -b /dev/md$CX ]
  then echo /dev/md$CX; break
  fi
 done
}

raid_level(){
 $DIALOG --title $"RAID Level?" --no-cancel --menu "" 20 20 15 \
 linear "" raid0 "" 0 "" stripe "" raid1 "" 1 "" mirror "" \
 raid4 "" 4 "" raid5 "" 5 "" raid6 "" 6 "" \
 raid10 "" 10 "" multipath "" mp "" faulty ""
}

raid_part(){
 local CX=0

 DEVS=$( $DIALOG --separate-output --nocancel \
         --title "Select Devices for RAID" --checklist "" 20 70 10 \
         $( list_part | sed '\,^/dev/mapper,d
                             s:$:	Partition Volume	off:' ) )
 [ -n "$DEVS" ] || return

 for DEV in $DEVS; do
  (( CX++ ))
  sfdisk -c ${DEV:0:8} ${DEV:8:2} fd
 done

 echo "-n $CX $DEVS"
}


mdadm_menu(){

 while
  C_HELP=$"Create a Volume Group and add Physical Volumes to it"
  S_HELP=$"Stop all RAIDs, only if you want to redefine the RAIDs"

  WHAT=$(
   $DIALOG --title $"mdadm Software RAID Menu" --no-cancel --item-help --menu "" 0 60 8 \
   Create "Create a software RAID"  "$C_HELP" \
   Stop   "Stop all software RAIDs" "$S_HELP" \
   Done "" "" )
 do
  case $WHAT in
   Create)	launch mdadm -C $( name_raid ) -l $( raid_level ) $( raid_part )	;;
   Stop)	mdadm --stop --scan	;;
   Done)	break	;;
  esac
  pause
 done
 filesystem_table_load
}

disk_menu(){

 boot_partition_warning

 if   [ -z "${PDEVICE[*]}" ]
 then filesystem_table_load
 fi

 WHAT="Partition"

 while
  TITLE=$"Disk Menu"
  A_HELP=$"Transfer files to mounted filesystems"
  B_HELP=$"Write a LBA addressing enabled bootable public domain MBR"
  C_HELP=$"Define filesystem table"
  E_HELP=$"Edit $TARGET/etc/fstab after transfering"
  I_HELP=$"Selectively create filesystems defined in filesystem table"
  K_HELP=$"Configure and compile a few programs to complete installation"
  L_HELP=$"Load unmodified filesystem table by defined disk partitions"
  M_HELP=$"Mount defined filesystems"
  O_HELP=$"Install initramfs image, lilo, and networking programs to finish install"
  P_HELP=$"Create partitions on physical disks"
  R_HELP=$"Create a software RAID"
  U_HELP=$"Unmount defined filesystems, do this only to correct mistakes"
  V_HELP=$"LVM2 Logical Volume Managment 2 Menu"

  if [ "$PMOUNTED" == true ]; then

   WHAT=$(
    $DIALOG \
    --title "$TITLE" --ok-label Select --no-cancel \
    --default-item "$WHAT" --item-help --menu "" 0 40 15 \
    MBR     "Master Boot Record" "$B_HELP" \
    Install "Transfer Files"     "$A_HELP" \
    Compile "Menu $CVIS"         "$K_HELP" \
    Edit    "$TARGET/etc/fstab"  "$E_HELP" \
    Unmount "Filesystems"        "$U_HELP" \
    Done    ""                   ""        )
  else
   WHAT=$(
    $DIALOG \
    --title "$TITLE" --ok-label Select --no-cancel \
    --default-item "$WHAT" --item-help --menu "" 0 40 15 \
    MBR        "Master Boot Record" "$B_HELP" \
    Partition  "Disks"              "$P_HELP" \
    mdadm      "Software Raid"      "$R_HELP" \
    LVM2       "LVM2 Menu"          "$V_HELP" \
    Reload     "Filesystem Table"   "$L_HELP" \
    Modify     "Filesystem Table"   "$C_HELP" \
    Initialize "Filesystems"        "$I_HELP" \
    Mount      "Filesystems"        "$M_HELP" \
    Done       ""                   ""        )
    fi
 do
  case $WHAT in
          MBR)	write_mbr		;;
         LVM2)  lvm2_menu		;;
        mdadm)  mdadm_menu              ;;
      Install)	transfer_arch 2>&1 | tee /tmp/transfer.txt ;;
      Compile)	compile_menu		;;
    Partition)	partition_disks		;;
       Reload)	filesystem_table_load	;;
       Modify)	filesystem_table	;;
   Initialize)	filesystem_initialize	;;
        Mount)	filesystem_mount	;;
      Unmount)	confirm_unmount		;;
         Edit)	edit_fstab		;;
         Done)	break			;;
    esac
 done
}


compile_menu(){
 if   ! [ -f $TARGET/etc/fstab ]
 then $DIALOG --msgbox $"Transfer first." 8 50; return 1
 fi

 local EXTRA_SPELLS REQUIRED_SPELLS="\
glibc-locales
glibc-localtime
initramfs
init-scripts
kbd"

 if   [ -f $TARGET/etc/lilo.conf.head.new ]
 then BOOTLOADER=lilo
 else BOOTLOADER=yaboot
 fi

 BL_CONF="$TARGET/etc/$BOOTLOADER.conf.head"

 make_bootloader_conf

 EXTRA_SPELLS=$( select_extra_spells )

 chroot_build	$REQUIRED_SPELLS	$EXTRA_SPELLS

 for ITEM in $EXTRA_SPELLS; do
  case $ITEM in
   dial2net)	chroot_run /bin/dial2net -s	;;
   rp-ppoe)	chroot_run /usr/sbin/adsl-setup	;;
   wvdial)	chroot_run /usr/bin/wvdialconf;	edit $TARGET/etc/wvdial.conf ;;
  esac
 done

 CVIS="Visited"
}


module_menu(){

 list(){ ( lsmod; echo "Press q to return" ) | less; }
 para(){ $DIALOG --nocancel --inputbox "Parameters for $1?" 0 0; }

 mods(){
  find /lib/modules -type f | cut -d / -f6- | LC_ALL=C sort |
  sed -nr  "s:(.*)/(.*):\2	\1:
            s:\.ko	:	:p"
 }

 mselect(){
  $DIALOG --title $"Module Load Menu" \
          --menu  $"Select a module to load please"  0 0 0 $( mods )
 }

 load(){
  local PARAM MODULE
  if          MODULE="$( mselect )" &&
       [ -n "$MODULE" ] &&
       PARAM="$( para "$MODULE" )"
  then
   modprobe $MODULE $PARAMETERS
   read -n 1 -t 900 -p "Press space to continue."
  fi
 }


 loaded(){
  echo "Module"; echo "Used by"
  lsmod | tr -s ' ' | cut -d ' ' -f1,3- | sed "1d;s: :\n:"
 }

 lose(){
  local MOD=$( $DIALOG \
   --title $"Module Unload Menu" \
   --menu  $"Select a module to unload please" 0 0 0  $( loaded ) )

  [ -n "$MOD" ] && rmmod "$MOD"
 }


 while
  WHAT=$( $DIALOG \
   --title $"Module Menu" --ok-label "Select" --no-cancel \
   --menu  $"Add missing /dev nodes by loading modules." 0 0 0 \
   List Loaded Load "" Unload "" Done "" )
 do
  case $WHAT in
     List) list ;;
     Load) load ;;
   Unload) lose ;;
     Done) break ;;
  esac
 done
}


main_menu(){

 WHAT="Disk"
 MVIS="Optional"
 DVIS="Required"
 OVIS="Optional"
 CVIS="Required"

 while
  TITLE="Main Menu"
   HELP="Sorcerer comes with no warranty."
  D_HELP="Prepare partitions and transfer operating system"
  F_HELP="Exit to a manual installation or reboot"
  M_HELP="List load and unload modules"

  WHAT=$( $DIALOG \
   --title "$TITLE" --nocancel --default-item "$WHAT" \
   --item-help --menu "$HELP" 0 50 10 \
   Module  "Menu $MVIS" "$M_HELP" \
   Disk    "Menu $DVIS" "$D_HELP" \
   Done    ""           "$F_HELP" )

 do
  case $WHAT in
   Module)	module_menu;	MVIS="Visited"	;;
     Disk)	disk_menu;	DVIS="Visited"	;;
     Done)	goodbye	;;
  esac
 done
}



# Max Partitions
MP=64
TARGET="/media/root"

TAB="	"
LF="
"

export IFS="	$LF"
export DIALOG="dialog	--backtitle	Sorcerer Installer	--stdout"

trap : INT QUIT

main_menu

# Functions for LSB-compliant init-scripts
# For use with the distribution Sorcerer only!
# Copyright Kyle Sallee 2005 through 2008.
# All rights reserved.

NORM="\e[0m"; RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[34m"; WHITE="\e[37m"

S65="                                                                 "

log_line(){
 REPLY="$GREEN * $NORM$1${S65:${#1}}$BLUE[$2 $BLUE]$NORM\r"
 echo -e "$REPLY" 1>&2
}

log_success_msg(){ log_line "$1" "$GREEN success";}
log_failure_msg(){ log_line "$1" "$RED failed ";}
log_warning_msg(){ log_line "$1" "$WHITE warning";}

locked(){
 local L S P REPLY

 [[ -n $2 ]] && L=${#2} &&
 [[ -n $1 ]] && [[ -f $1 ]] &&
 read P < $1 &&
 S="/proc/$P/status" &&
 [[ -f  $S ]] &&
 read < $S &&
 [ "${REPLY:6:$L}" == "$2" ]
}

pidofproc(){
 local PIDS

 while
  case $1 in
   -p) PIDF=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}

 if    [[ -z $PIDF ]]; then
  if   [[ -f /var/run/$BASE.pid ]]; then PIDF=/var/run/$BASE.pid
  elif [[ -f /var/run/$BASE     ]]; then PIDF=/var/run/$BASE
  else PIDS=$( /bin/pidof -o %PPID $BASE )
  fi
 fi

 if    [[  -s  $PIDF ]]; then
  if   locked "$PIDF" "$BASE"
  then read <  $PIDF; echo $REPLY
  else false
  fi
 elif [[  -n $PIDS ]]
 then echo  "$PIDS"
 else return 1
 fi
}

killproc(){
 local PIDF PID BASE PIDS SIGL

 while
  case $1 in
   -p) PIDF=$2 ;;
   -s) SIGL=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}; [[ -n $2 ]] &&
 SIGL=$2
 PIDS="$( pidofproc -p "$PIDF" "$1" )"

 if    [[ -n    $PIDS ]]; then
  if   [[ -n    $SIGL ]]
  then kill -s "$SIGL" $PIDS
  else kill -s 15      $PIDS; sleep 3
       kill -s 9       $PIDS
  fi
  if   [[  -n $PIDF ]] &&
       [[  -f $PIDF ]]
  then rm -f "$PIDF"
  fi
 else return 1
 fi
}

start_daemon(){
 run(){
  if   [[ -n $BACK ]]
  then "$@" & sleep .1; echo $! > $PIDF
  else "$@"
  fi
 }

 local BACK BASE FORC LOGF PIDF

 while
  case $1 in
   -p) PIDF=$2; shift ;;
   -l) LOGF=$2; shift ;;
   -n) renice $2 $$; shift ;;
   -b) BACK=1 ;;
   -f) FORC=1 ;;
    *) break ;;
  esac
 do shift
 done

 BASE=${1##*/}

 if [[ -n $BACK ]]; then
  LOGF="${LOGF:-/var/log/$BASE}"
  PIDF="${PIDF:-/var/run/$BASE.pid}"
 fi

 if   pidofproc -p "$PIDF" "$1" &>/dev/null
 then [[ -n $FORC ]] || return 1
 fi

 if [[ -n $LOGF ]]; then run "$@" &> "$LOGF"; else run "$@";  fi
}


# Functions below are not specified in LSB 3.1
# $SERV must be set
# $LOCK $NAME $PIDF are optional.
# $OPTS is optional except when mounting


status(){
 stats(){
  PIDS="$( pidofproc -p "$PIDF" "$SERV" )"
  if   [[ -n $PIDS ]]; then log_warning_msg "$NAME is running"; return 0
  elif [[ -f $PIDF ]]; then log_warning_msg "$NAME is dead and $PIDF exists"; return 1
  elif [[ -n $LOCK ]] &&
       [[ -f $LOCK ]]; then log_warning_msg "$NAME is dead and $LOCK exists"; return 2
                       else log_warning_msg "$NAME is not running"; return 3
  fi
 }

 statm(){
  if   mnt
  then log_warning_msg "$NAME is mounted"; return 0
  else log_warning_msg "$NAME is not mounted"; return 3
  fi
 }

 statk(){
  if   lsmod | grep -qws "^${NAME//-/_}"
  then log_warning_msg "$NAME module is loaded"; return 0
  else log_warning_msg "$NAME module is not loaded"; return 3
  fi
 }

 [[ -n $NAME ]] || NAME=${0##*/}
 if   [ / = "${NAME:0:1}" ]
 then statm
 elif [[ -n $SERV ]]
 then stats
 else statk
 fi
}

stop(){
 stops(){
  if   log_warning_msg "$NAME stopping"; killproc -p "$PIDF" -s 15 "$SERV"
  then log_success_msg "$NAME stopped"
  else log_failure_msg "$NAME not stopped"; status
  fi
 }

 stopm(){
  if   log_warning_msg "$NAME umount"; umount $NAME
  then log_success_msg "$NAME unmounted"
  else log_failure_msg "$NAME not unmounted"; status
  fi
 }
  
 stopk(){
  if   log_warning_msg "$NAME module unloading"; /sbin/modprobe -r $NAME
  then log_success_msg "$NAME unloaded"
  else log_failure_msg "$NAME not unloaded"
  fi
 }

 [[ -n $NAME ]] || NAME=${0##*/}
 if   [ / = "${NAME:0:1}" ]
 then stopm
 elif [[ -n $SERV ]]
 then stops
 else stopk
 fi
}

mnt(){
 if [[ -f /proc/mounts ]]; then
  while read DEV MNT JNK
  do [[ $NAME == $MNT ]] && return
  done < /proc/mounts
 fi
 return 1
}

start(){
 conf(){ [[ -n $CONF ]] && ! [[ -e $CONF ]]; }
 miss(){ [ ${SERV:0:1} == / ] && ! [[ -f $SERV ]]; }

 starts(){
  if   conf
  then log_warning_msg "$NAME not started"
       log_warning_msg "$NAME missing $CONF"
  elif miss
  then log_warning_msg "$NAME not started"
       log_warning_msg "$NAME missing $SERV"
  elif log_warning_msg "$NAME starting"; start_daemon -l "$LOGF" -p "$PIDF" "$SERV" $OPTS
  then log_success_msg "$NAME started"
  else log_failure_msg "$NAME not started"; status
  fi
 }

 startm(){
  run(){
   if   !  [[ -d  $NAME ]]
   then mkdir -p "$NAME"; fi &&
   mount $OPTS   "$NAME"
  }

  stb(){ sed 's/#.*//' /etc/fstab | grep -qw $NAME;}
  chk(){ case $NAME in /dev|/proc|/sys) return 1;; esac; stb;}

  if mnt || chk; then return; fi
  if   conf
  then log_warning_msg "$NAME not mounted; $CONF does not exist"
  elif log_warning_msg "$NAME mounting"; run
  then log_success_msg "$NAME mounted"
  else log_failure_msg "$NAME not mounted"
  fi
 }

 startk(){
  if   conf
  then log_warning_msg "$NAME module not loaded; $CONF does not exist"
  elif log_warning_msg "$NAME module loading"; /sbin/modprobe $NAME $OPTS
  then log_success_msg "$NAME loaded"
  else log_failure_msg "$NAME not loaded"
  fi
 }

 [[ -n $NAME ]] || NAME=${0##*/}
 if   [ / = "${NAME:0:1}" ]
 then startm
 elif [[ -n $SERV ]]
 then starts
 else startk
 fi
}

    restart(){ stop && sleep 1; start;}
try_restart(){ [[ -n $SERV ]] && status &>/dev/null && restart; return 0;}

help(){ echo "Usage: $0 {start|stop|status|reload|restart}";}

reload(){ try_restart; }

parse(){
 case $1 in
  start) start ;;
  restart) restart ;;
  try-restart) try_restart ;;
  reload) reload ;;
    stop) stop   ;;
  status) status ;;
  *) help ;;
 esac
}

# Functions for LSB-compliant init-scripts
# Compatible with /bin/dash and /bin/bash
# For use with the distribution Sorcerer only!
# Copyright Kyle Sallee 2005 through 2010.
# All rights reserved.

RED="[31m"
GREEN="[32m"
BLUE="[34m"
WHITE="[37m"
OVER="[65G"
NORM="[0m"

if   [ "$BASH_VERSION" ]
then SO='+B -f'; BE=-e;
else SO=-f
fi

log_line(){ echo $BE "$GREEN * $NORM$1$OVER$BLUE[$2 $BLUE]$NORM\r" 1>&2; }

log_success_msg(){ log_line "$1" "$GREEN success";}
log_failure_msg(){ log_line "$1" "$RED failed ";}
log_warning_msg(){ log_line "$1" "$WHITE warning";}

locked(){
 local S P REPLY

 [ "$2" ] && L=${#2} &&
 [ "$1" ] && [ -f "$1" ] &&
 read P < $1 &&
 S=/proc/$P/status &&
 [ -f  "$S" ] &&
 read REPLY < $S &&
 [ ${REPLY##*	} = "$2" ]
}

session(){
 read REPLY < $1 &&
 ps --no-heading -o comm -s $REPLY | grep -qx "$2" 
}

pidofproc(){

 local PIDS

 while
  case $1 in
   -p) PIDF=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}

 if    [ -z "$PIDF" ]; then
  if   [ -f "/var/run/$BASE.pid"  ]; then PIDF=/var/run/$BASE.pid
  elif [ -f "/var/run/$BASE"      ]; then PIDF=/var/run/$BASE
  elif find_cgroup && [ -f $CGDNT ]; then PIDF=$CGDNT
  else PIDS=$( /bin/pidof -o %PPID $BASE )
  fi
 fi

 if    [ -s    "$PIDF" ]; then
  if   locked  "$PIDF" "$BASE" ||
       session "$PIDF" "$BASE"
  then read REPLY < $PIDF; echo $REPLY
  else false
  fi
 elif [ -n "$PIDS" ]
 then echo "$PIDS"
 else return 1
 fi
}

find_cgroup(){
 local JUNK DIR TYPE
 while read JUNK DIR TYPE JUNK; do
  if [ "$TYPE" == cgroup ] && [ -f $DIR/tasks ]; then
   CG=$DIR
   CGD=$CG/daemon
   CGDN=$CGD/$NAME; 
   CGDNT=$CGDN/tasks
   return 0
  fi
 done < /proc/mounts
 return 1
}

killproc(){
 local PIDF PID BASE PIDS SIGL

 while
  case $1 in
   -p) PIDF=$2 ;;
   -s) SIGL=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}; [ "$2" ] &&
 SIGL=$2
 PIDS="$( pidofproc -p "$PIDF" "$1" )"

 if    [      "$PIDS" ]; then
  if   [      "$SIGL" ]
  then pkill "-$SIGL" -s $PIDS; kill "-$SIGL" $PIDS
  else pkill -15      -s $PIDS; kill -15      $PIDS; sleep 3
       pkill -9       -s $PIDS; kill -9       $PIDS
  fi
  if   [  -f "$PIDF" ]
  then rm -f "$PIDF"
  fi
  if    find_cgroup && [ -f $CGDNT ]; then
   if   read < $CGDNT; [ -z "$REPLY" ]
   then rmdir  $CGDN; true
   fi
  fi
 else return 1
 fi
}

start_daemon(){
 run(){
  if   find_cgroup
  then mkdir -p $CGDN; echo $BASHPID > $CGDNT
  fi

  if   [ "$BACK" ]
  then setsid /lib/lsb/pidf "$PIDF" "$@" &
  else "$@"
  fi
 }

 local BASE LOGF PIDF

 while
  case $1 in
   -p) PIDF=$2; shift ;;
   -l) LOGF=$2; shift ;;
   -n) renice $2 $$; shift ;;
   -b) BACK=1 ;;
   -f) FORC=1 ;;
    *) break ;;
  esac
 do shift
 done

 BASE=${1##*/}

 if [ "$BACK" ]; then
  LOGF="${LOGF:-/var/log/$BASE}"
  PIDF="${PIDF:-/var/run/$BASE.pid}"
 fi

 if   pidofproc -p "$PIDF" "$1" 1>/dev/null
 then [ "$FORC" ] || return 1
 fi

 if [ "$LOGF" ]; then run "$@" 1>> "$LOGF" 2>&1; else run "$@";  fi
}


# Functions below are not specified in LSB 3.1
# $SERV must be set
# $LOCK $NAME $PIDF are optional.
# $OPTS is optional except when mounting


status(){
 stats(){
  PIDS="$( pidofproc -p "$PIDF" "$SERV" )"
  if   [    "$PIDS" ]; then log_warning_msg "$NAME is running"; return 0
  elif [ -f "$PIDF" ]; then log_warning_msg "$NAME is dead and $PIDF exists"; return 1
  elif [    "$LOCK" ] &&
       [ -f "$LOCK" ]; then log_warning_msg "$NAME is dead and $LOCK exists"; return 2
                       else log_warning_msg "$NAME is not running"; return 3
  fi
 }

 statm(){
  if   mnt
  then log_warning_msg "$NAME is mounted"; return 0
  else log_warning_msg "$NAME is not mounted"; return 3
  fi
 }

 statk(){
  if   lsmod | LC_ALL=C grep -qws "${NAME//-/.}"
  then log_warning_msg "$NAME module is loaded"; return 0
  else log_warning_msg "$NAME module is not loaded"; return 3
  fi
 }

 if   [ "$NAME" ] && [ -z "${NAME%%/*}" ]
 then statm
 elif [ "$SERV" ]
 then stats
 else statk
 fi
}

stop(){
 stops(){
  if   log_warning_msg "$NAME stopping"; killproc -p "$PIDF" -s 15 "$SERV"
  then log_success_msg "$NAME stopped"
  else log_failure_msg "$NAME not stopped"; status
  fi
 }

 stopm(){
  if   log_warning_msg "$NAME umount"; umount $NAME
  then log_success_msg "$NAME unmounted"
  else log_failure_msg "$NAME not unmounted"; status
  fi
 }
  
 stopk(){
  if   log_warning_msg "$NAME module unloading"; /sbin/modprobe -r $NAME
  then log_success_msg "$NAME unloaded"
  else log_failure_msg "$NAME not unloaded"
  fi
 }

 set $SO

 if   [ "$NAME" ] && [ -z "${NAME%%/*}" ]
 then stopm
 elif [ "$SERV" ]
 then stops
 else stopk
 fi
}

mnt(){
 if [ -f /proc/mounts ]; then
  while read DEV MNT JNK
  do [ "$NAME" = "$MNT" ] && return
  done < /proc/mounts
 fi
 return 1
}

start(){
 conf(){ [ "$CONF" ] && ! [ -e "$CONF" ]; }
 miss(){ ! [ -f "$SERV" ]; }

 starts(){
  if   conf
  then log_warning_msg "$NAME not started"
       log_warning_msg "$NAME missing $CONF"
  elif miss
  then log_warning_msg "$NAME not started"
       log_warning_msg "$NAME missing $SERV"
  elif log_warning_msg "$NAME starting"; start_daemon -l "$LOGF" -p "$PIDF" "$SERV" $OPTS
  then log_success_msg "$NAME started"
  else log_failure_msg "$NAME not started"; status
  fi
 }

 startm(){
  run(){
   if   !  [  -d "$NAME" ]
   then mkdir -p "$NAME"; fi &&
   mount $OPTS   "$NAME"
  }

  if mnt; then return; fi
  if   conf
  then log_warning_msg "$NAME not mounted; $CONF does not exist"
  elif log_warning_msg "$NAME mounting"; run
  then log_success_msg "$NAME mounted"
  else log_failure_msg "$NAME not mounted"
  fi
 }

 startk(){
  if   conf
  then log_warning_msg "$NAME module not loaded; $CONF does not exist"
  elif log_warning_msg "$NAME module loading"; /sbin/modprobe $NAME $OPTS
  then log_success_msg "$NAME loaded"
  else log_failure_msg "$NAME not loaded"
  fi
 }

 set $SO

 if   [ "$NAME" ] && [ -z "${NAME%%/*}" ]
 then startm
 elif [ "$SERV" ]
 then starts
 else startk
 fi
}

    restart(){ stop && sleep 1; start;}
try_restart(){ [ "$SERV" ] && status 2>/dev/null && restart; return 0;}

help(){ echo "Usage: $0 {start|stop|status|reload|restart}";}

reload(){ try_restart; }

parse(){
 case $1 in
  start) start ;;
  stop) stop ;;
  try-restart) try_restart ;;
  status) status ;;
  restart) restart ;;
  reload) reload ;;
  *) help ;;
 esac
}

pid_file(){ PIDF=$1; }
server()  { SERV=$1; }
config()  { CONF=$1; }
name()    { NAME=$1; }
options() { OPTS=$1; }

if [ -z "$NAME" ]
then NAME=${0##*/}; NAME=${NAME#[SK][0-9][0-9]}
fi

if   [ -f /etc/init.d/conf.d/$NAME ]
then .    /etc/init.d/conf.d/$NAME
fi

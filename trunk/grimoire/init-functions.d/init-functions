# Functions for LSB-compliant init-scripts
# For use with the distribution Sorcerer only!
# Copyright Kyle Sallee 2005 through 2008.
# All rights reserved.

NORM="\e[0m"; RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[34m"; WHITE="\e[37m"

S60="                                                            "

log_start() { echo -en "$GREEN * $NORM$1${S60:${#1}}" 1>&2;}
log_finish(){ echo -e  "$BLUE[$1 $BLUE]$NORM" 1>&2;}

log_success_msg(){ log_start "$1"; log_finish "$GREEN success";}
log_failure_msg(){ log_start "$1"; log_finish "$RED failed ";}
log_warning_msg(){ log_start "$1"; log_finish "$WHITE warning";}

locked(){
 local L S P REPLY

 [ -n "$2" ] && L=${#2} &&
 [ -n "$1" ] && [ -f  $1 ] &&
 read P < $1 &&
 S="/proc/$P/status" &&
 [ -f   $S ] &&
 read < $S &&
 [ "${REPLY:6:$L}" == "$2" ]
}

pidofproc(){

 while
  case $1 in
   -p) PIDF=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}

 if    [ -z "$PIDF" ]; then
  if   [ -f /var/run/$BASE.pid ]; then PIDF=/var/run/$BASE.pid
  elif [ -f /var/run/$BASE     ]; then PIDF=/var/run/$BASE
  else PIDS=$( /bin/pidof -o %PPID $BASE )
  fi
 fi

 if    [  -n  "$PIDF" ]; then
  if   locked "$PIDF" "$BASE"
  then read <  $PIDF; echo $REPLY
  else false
  fi
 elif [  -n "$PIDS" ]
 then echo  "$PIDS" 
 else return 1
 fi
}

killproc(){
 local PIDF PID BASE PIDS SIGL

 while
  case $1 in
   -p) PIDF=$2 ;;
   -s) SIGL=$2 ;;
    *) break ;;
  esac
 do shift 2
 done

 BASE=${1##*/}; [ -n "$2" ] &&
 SIGL=$2
 PIDS="$( pidofproc -p "$PIDF" "$1" )"

 if    [ -n    "$PIDS" ]; then
  if   [ -n    "$SIGL" ]
  then kill -s "$SIGL" $PIDS
  else kill -s 15      $PIDS; sleep 3
       kill -s 9       $PIDS
  fi
  if   [  -n "$PIDF" ] &&
       [  -f "$PIDF" ]
  then rm -f "$PIDF"
  fi
 else return 1
 fi
}

start_daemon(){
 local FORC NICE PIDF BASE PIDS BACK

 while
  case $1 in
   -f) FORC=on ;;
   -n) NICE=$2; shift 1 ;;
   -p) PIDF=$2; shift 1 ;;
   -b) BACK=on ;;
    *) break ;;
  esac
 do shift 1
 done

 BASE=${1##*/}
 PIDS="$( pidofproc -p "$PIDF" "$1" )"

 if   [ -z "$PIDS" ] ||
      [ -n "$FORC" ]
 then
   if     [    -z "$PIDF" ] ||
          [    -z "$BACK" ]; then
     if   [    -n "$NICE" ]
     then nice -n "$NICE" "$@"
     else "$@"
     fi
   else (
     if   [    -n "$NICE" ]
     then nice -n "$NICE" "$@" &
     else "$@" &
     fi
     sleep 1; echo $! > $PIDF
     ) &
   fi
 else false
 fi
}


# Functions below are not specified in LSB 3.1
# $SERV $NAME must be set
# $PIDF $LOCK are optional.
# $OPTS is optional except when mounting

status(){
 stats(){
  PIDS="$( pidofproc -p "$PIDF" "$SERV" )"
  if   [ -n "$PIDS" ]; then log_warning_msg "$NAME is running"; return 0
  elif [ -f "$PIDF" ]; then log_warning_msg "$NAME is dead and $PIDF exists"; return 1
  elif [ -n "$LOCK" ] &&
       [ -f "$LOCK" ]; then log_warning_msg "$NAME is dead and $LOCK exists"; return 2
                       else log_warning_msg "$NAME is not running"; return 3
  fi
 }

 statm(){
  if   mnt
  then log_warning_msg "$NAME is mounted"; return 0
  else log_warning_msg "$NAME is not mounted"; return 3
  fi
 }

 statk(){
  if   lsmod | grep -qws "^${NAME//-/_}"
  then log_warning_msg "$NAME module is loaded"; return 0
  else log_warning_msg "$NAME module is not loaded"; return 3
  fi
 }

 if   [ -n "$SERV" ]
 then stats
 elif [ / = "${NAME:0:1}" ]
 then statm
 else statk
 fi
}

stop(){
 stops(){
  if   log_warning_msg "$NAME stopping"; killproc -p "$PIDF" -s 15 "$SERV"
  then log_success_msg "$NAME stopped"
  else log_failure_msg "$NAME not stopped"; status
  fi
 }

 stopm(){
  if   log_warning_msg "$NAME umount"; umount $NAME
  then log_success_msg "$NAME unmounted"
  else log_failure_msg "$NAME not unmounted"; status
  fi
 }
  
 stopk(){
  if   log_warning_msg "$NAME module unloading"; modprobe -r $NAME
  then log_success_msg "$NAME unloaded"
  else log_failure_msg "$NAME not unloaded"
  fi
 }

 if   [ -n "$SERV" ]
 then stops
 elif [ / = "${NAME:0:1}" ]
 then stopm
 else stopk
 fi
}

mnt(){ grep -qws "$NAME" /proc/mounts;}

start(){
 starts(){
  if   log_warning_msg "$NAME starting"; start_daemon -p "$PIDF" "$SERV" $OPTS
  then log_success_msg "$NAME started"
  else log_failure_msg "$NAME not started"; status
  fi
 }

 startm(){
  run(){
   if   !   [ -d "$NAME" ]
   then mkdir -p "$NAME"; fi &&
   mount $OPTS   "$NAME"
  }

  stb(){ sed 's/#.*//' /etc/fstab | grep -qw $NAME;}
  chk(){ case $NAME in /dev|/proc|/sys) return 1;; esac; stb;}

  if mnt || chk; then return; fi
  if   log_warning_msg "$NAME mounting"; run
  then log_success_msg "$NAME mounted"
  else log_failure_msg "$NAME not mounted"
  fi
 }

 startk(){
  if   log_warning_msg "$NAME module loading"; modprobe $NAME $OPTS
  then log_success_msg "$NAME loaded"
  else log_failure_msg "$NAME not loaded"
  fi
 }

 if   [ -n "$SERV" ]
 then starts
 elif [ / = "${NAME:0:1}" ]
 then startm
 else startk
 fi
}

    restart(){ stop && sleep 1; start;}
try_restart(){ [ -n "$SERV" ] && status &>/dev/null && restart; return 0;}

help(){ echo "Usage: $0 {start|stop|status|restart}";}

parse(){
 case $1 in
  start) start ;;
  restart) restart ;;
  try-restart) try_restart ;;
    stop) stop   ;;
  status) status ;;
  *) help ;;
 esac
}

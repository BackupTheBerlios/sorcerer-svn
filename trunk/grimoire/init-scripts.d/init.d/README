#!/bin/bash
less << EOF

Sorcerer System V Initialization and Shutdown Script Documentation

Sections:

1.0 Overview
2.0 Customization
3.0 Logs

Section 1.0 Overview

Section 1.1 POST

Following power on the Power On Self Test, or POST begins.
Following a successful POST the BIOS, basic input output,
attempts to load an operating system.
Depending on the capability and configuration
the BIOS will attempt to load an operating system from CDROM,
fixed disks, floppy disks, network, or removeable drives.
When loading an operating system from fixed disk BIOS
first loads and runs the content of the MBR, master boot record,
of the primary fixed disk.

Section 1.2 MBR / ms-sys

The MBR must contain bootable code.
The code is typically from the ms-sys project.
However, other bootloaders are can be used.
The code in the MBR does not typically load the linux kernel
but instead loads and begins execution of the code in the boot block
of the first partition that has the bootable flag enabled.

Section 1.3 boot block / extlinux

If a box has a dedicated ext2 /boot partition
then extlinux installed in the the boot block
of that partition is run.
Otherwise extlinux installed in the
boot block of the / partition is run.
extlinux is the default boot loader.
It's task is to load the initrams and kernel
from disk into RAM and to pass control to the kernel.

Section 1.4 linux kernel

The linux kernel begins.
It initializes hardware devices
such as the screen and keyboard.
Then the kernel decompresses, if necessary, and
extracts the cpio initramfs images to the rootfs.
The rootfs is automatically mounted on /
Finally, the kernel begins execution of the file /init as process 1.

However, using the kernel paramter rdinit=/bin/bash
the kernel can be instructed to execute a shell instead of /init.
Executing a shell instead of the normal /init is useful
for debugging problems that occur during sysinit.

Section 1.5 sysinit

Sysinit runs from entirely from the initramfs.
Sysinit is the third stage of the boot process.
During sysinit udev automatically loads
kernel drivers, modules, firmware for installed hardware.
Udev also creates device nodes in /dev with permission
and ownership as specified by udev rule files.
As sysinit progress
kernel modules are loaded for filesystems
and other commonly used protocols and methods such as FUSE,
file system in user space, and networking protocols.
The purpose of the sysinit is to complete required preparations
for being able to successfully mount filesystems provided
on disk, by network, or by memory storage devices.

Section 1.6 the end of sysinit

The end portion of sysinit
creates unshared namespace containers
for each root file system.
/etc/fstab.rootfs is parsed
during the creation of namespace containers.

3 types of mounts are specified in /etc/fstab.rootfs.
File systems mounted on an immediate subdirectory of
/media/root/ become root file systems.
File systems mounted anywhere except within /media/root/
are becomes accessible on the rootfs.
If those file systems on the rootfs are to be accessed by
or shared by multiple root file systems
then /etc/fstab.rootfs will specify binds.

Here is an example:

/dev/sda2 /media/root/main         ext4 defaults 0 0
/dev/sda1 /media/root/main/boot    ext4 defaults 0 0
/dev/sda3 /media/root/work         ext4 defaults 0 0
/dev/sda4 /media/root/play         ext4 defaults 0 0
/dev/sdb1 /aux/can/                ext4 defaults 0 0
/aux/can  /media/root/main/aux/can none bind     0 0
/aux/can  /media/root/work/aux/can none bind     0 0
/aux/can  /media/root/play/aux/can none bind     0 0

In the above example /dev/sdb1 provides a file system
that stores the content of /aux/can/ that is shared
among all 3 root file by binding /aux/can
to the /aux/can/ of /media/root/{main,home,work}/aux/can/

Each root runs in an unshared mnt namespace.
Therefore, a file system shared among multiple root file systems
must first be mounted on the rootfs
and then mount --bind into each unshared namespace.

Here is the above example with a shared /home/

/dev/sda2 /media/root/main         ext4 defaults 0 0
/dev/sda1 /media/root/main/boot    ext4 defaults 0 0
/dev/sda3 /media/root/work         ext4 defaults 0 0
/dev/sda4 /media/root/play         ext4 defaults 0 0
/dev/sdb1 /aux/can/                ext4 defaults 0 0
/aux/can  /media/root/main/aux/can none bind     0 0
/aux/can  /media/root/work/aux/can none bind     0 0
/aux/can  /media/root/play/aux/can none bind     0 0
/dev/sdb2 /home                    ext4 defaults 0 0
/home     /media/root/main/home    none bind     0 0
/home     /media/root/work/home    none bind     0 0
/home     /media/root/play/home    none bind     0 0

The columns in /etc/fstab and /etc/fstab.rootfs
are explained in the fstab manual page.
The manual page is displayed by executing the command:
man fstab

In the following example /home from /media/root/main/home
is bind to /media/root/main/{work,play}/home
This works because file systems specified in /etc/fstab.rootfs
are mounted in rootfs' mnt namespace rather than
the unshared mnt name spaces of each root file system.

/dev/sda2             /media/root/main      ext4 defaults 0 0
/dev/sda3             /media/root/work      ext4 defaults 0 0
/dev/sda4             /media/root/play      ext4 defaults 0 0
/media/root/main/home /media/root/work/home none bind     0 0
/media/root/main/home /media/root/play/home none bind     0 0

File /etc/fstab is still valid and used.
File /etc/fstab is parsed by the mount that is run during the runlevel.
Therefore, each root file system can have it's own private mounts.

Section 1.7 gettys

/etc/inittab is the traditional location
for specifying how gettys run.
The concept works good on a single root file system.
However, editing /etc/inittab
to provide gettys for multiple root file systems is tedious.
Consequently, the only getty specified in /etc/inittab
is the getty which runs on the rootfs.

Each root file system has an init-script /etc/init.d/ttyd
ttyd dynamically allocates a virtual console
for providing a prompt for running a login program.
If the login program is activated
then gettyd allocates another virtual console
for providing an additional prompt
for starting a login program.
Therefore, multiple virtual console logins
to a root file system remain possible.

Linux provides a total of 64 virtual consoles.
As many as 63 root file systems
could run ttyd to provide login prompts.
However, the limit for root file systems is 256.
If running a massive amount of root file systems
then alternate login methods
for each root file system
must be provided/
sshd is a useful method for login into both
locally hosted and remotely hosted root file systems.

To prevent a root from offering a login on a virtual console
enter it's root file system and execute the following 2 commands:
bash      /etc/init.d/gettyd stop
chmod 400 /etc/init.d/gettyd

root file systems can be entered from the rootfs,
or by ttyd, or by ssh, or by a method that the SA creates.

Section 1.8 runlevel

/etc/inittab contains a description of runlevels.
And the default runlevel can be changed by editing /etc/inittab
Run levels 1 through 5 are valid for init default.
However, runlevels 3 through 5 are most popular.
The purpose of a runlevel is to start services
such as webservers, secure socket shell server,
system logger, cron, X server and other services
that make computers friendly and useful.



Section 2.0 Customization

Section 2.1 init-script

A POSIX, portable operating system for unix,
is a collection of software from various vendors
which is installed and run in a meaningful fashion.
Individual init-scripts ensure properly ordered
execution and shutdown of services and filesystems.
It is a modular, dynamic, and efficient system
where init-scripts are added, removed,
and sometimes customized as necessary
in order to adjust to installed software.

Section 2.2 init-scripts in detail

Sorcerer provides a system for running LSB compliant
system V init-scripts with capabilities defined at the following URL:
http://www.linux-foundation.org/spec/refspecs/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptfunc.html
However, Sorcerer init-scripts are not themselves LSB compliant.
Sorcerer init-scripts have nearly all common code factorized out
and made available in /lib/lsb/init-functions.
This makes small, fast, uniform, easy to edit init-script.

init-scripts that run during sysinit
are frequently specialized and sometimes complex.
However, the more simple init-scripts
that are executed during runlevel are
often short and simple.
Each init-script tends to perform a single specific task such as:
mounting a virtual file system;
loading a kernel module;
unloading a kernel module;
or starting a server.

The best way to understand a Sorcerer init-script
is to first learn about LSB compliant init-scripts
and then view some of the already installed init-scripts.
Since the format of most init-scripts is similar
new init-scripts are usually created
by copying and modifying old init-scripts.

Section 2.3 init-script customization

/etc/init.d/ contains init-scripts.

init-scripts will be mode 510 500 or 400.
To change the mode of an init-script run
the init-script with the parameter "control"

Some init-scripts should not be change
to a different mode than their default mode
otherwise a box might not properly run, boot, or shutdown.

Modes         of init-scripts are     retained across updates.
Modifications to init-scripts are not retained across updates.

To modify an init-script please do the following:
Where $ORIGINAL is written please substitute the original file name.
# cp $ORIGNAL custom-$ORIGINAL
# chmod 700   custom-$ORIGINAL
# chmod 600          $ORIGINAL
# nano        custom-$ORIGINAL
Add the comment # Provides: $ORIGINAL
Make other desired modifications.
CTRL-X y to save.

Customization of init-scripts installed by spells such
as the init-scripts spell is strongly discouraged.
Customizing init-scripts can cause failure of services to start
or even failure of a box being able to mount root file systems.

Section 2.4 Configuration

Some init-scripts support dialog menu driven configuration.
If running the init-script with parameter "help" reports
that an init-script supports accepts the parameter configure
then configure can be run to accept input for configuration variables.

Section 2.5 Init-script Menu

# /etc/init.d/Menu configure
can be run instead of selecting individual init-scripts.
The dialog menu driven interface is used to select
an init-script to execute and a parameter parameters to pass.

Section 3.0 Logs

Section 3.1 log names

Output from runlevel 0 and 6   is written to /var/log/runlevel.$RL

Section 3.2 /var/log/init/

Because the rootfs is mounted as the root filesystem during sysinit
a disk based file system for /var/log/ is yet unavailable.
Consequently, a tmpfs, temporary filesystem, is mounted on /var/log/init/
Placing the files on tmpfs allows /var/log/init/
to later be moved if desired.

Section 3.3 Boot scroll

Currently, there is no SA, system administrator, consensus
about whether reading boot scroll is useful or desirable.
Some SAs prefer that the sysinit and runlevel scroll is redirected
to virtual consoles rather than scrolling on the main console.
If this is selected then the default virtual console for sysinit scroll
is /dev/tty9 which can be accessed by pressing the keys ALT F9 or CTRL ALT F9.
The defautl virtual console for runlevel scroll is /dev/tty10
As expected it can be viwed with the key sequence ALT F10 or CTRL ALT F10.
The primary virtual console,
which is typically used for logging in,
can be returned to with the key sequence ALT F1 or CTRL ALT F1
Holding ALT and pressing right or left arrow keys
switches sequentially among available virtual consoles.

The default for most Sorcerer boxes is to simply send both scrolls to /dev/console .
/dev/console causes scroll to appear on any actively selected virtual console.
However, this can be changed by executing the following command at a root prompt:
augur forget sysvinit; cast sysinit
Then in the sysinit spell configuration menu
nearly any available character device can be selected.

Execution of some programs cause uncategorized messags to be printed.
However, messages printed by init-scripts fall into 3 categories:
white [ warning ]; green [ success ]; and red [ failure ].
If the logs in /var/log/init/ are cat
then holding SHIFT while pressing PAGE UP
can be used to scroll up while looking for red [ failure ] messages.
A failure message is not necessarily bad,
but it can indicate something that the SA should be
aware of and might want to do something about.

EOF
